<!DOCTYPE html><html lang="zh-CN"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"><meta name="description" content="AFL代码详读（上）"><meta name="keywords" content="fuzz"><meta name="author" content="Kr0emer"><meta name="copyright" content="Kr0emer"><title>AFL代码详读（上） | Kr0emerのBlog</title><link rel="shortcut icon" href="/melody-favicon.ico"><link rel="stylesheet" href="/css/index.css?version=1.9.0"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/font-awesome@latest/css/font-awesome.min.css?version=1.9.0"><meta name="format-detection" content="telephone=no"><meta http-equiv="x-dns-prefetch-control" content="on"><link rel="dns-prefetch" href="https://cdn.jsdelivr.net"><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/npm/gitalk/dist/gitalk.min.css"><script src="https://cdn.jsdelivr.net/npm/gitalk@latest/dist/gitalk.min.js"></script><script src="https://cdn.jsdelivr.net/npm/blueimp-md5@2.10.0/js/md5.min.js"></script><meta http-equiv="Cache-Control" content="no-transform"><meta http-equiv="Cache-Control" content="no-siteapp"><script src="https://v1.hitokoto.cn/?encode=js&amp;charset=utf-8&amp;select=.footer_custom_text" defer></script><script>var GLOBAL_CONFIG = { 
  root: '/',
  algolia: undefined,
  localSearch: {"path":"search.xml","languages":{"hits_empty":"We didn't find any results for the search: ${query}"}},
  copy: {
    success: 'Copy successfully',
    error: 'Copy error',
    noSupport: 'The browser does not support'
  },
  hexoVersion: '5.4.0'
} </script><meta name="generator" content="Hexo 5.4.0"></head><body><i class="fa fa-arrow-right" id="toggle-sidebar" aria-hidden="true"></i><div id="sidebar" data-display="true"><div class="toggle-sidebar-info text-center"><span data-toggle="Toggle article">Toggle site</span><hr></div><div class="sidebar-toc"><div class="sidebar-toc__title">Catalog</div><div class="sidebar-toc__progress"><span class="progress-notice">You've read</span><span class="progress-num">0</span><span class="progress-percentage">%</span><div class="sidebar-toc__progress-bar"></div></div><div class="sidebar-toc__content"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#AFL%E4%BB%A3%E7%A0%81%E8%AF%A6%E8%AF%BB%EF%BC%88%E4%B8%8A%EF%BC%89"><span class="toc-number">1.</span> <span class="toc-text">AFL代码详读（上）</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#afl-gcc"><span class="toc-number">1.1.</span> <span class="toc-text">afl-gcc</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#afl-as"><span class="toc-number">1.2.</span> <span class="toc-text">afl-as</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#trampoline-fmt-32%E4%B8%8Etrampoline-fmt-64"><span class="toc-number">1.2.1.</span> <span class="toc-text">trampoline_fmt_32与trampoline_fmt_64</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#OpenBSD"><span class="toc-number">1.2.2.</span> <span class="toc-text">OpenBSD</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#add-instrumentation%E7%9A%84%E9%80%BB%E8%BE%91"><span class="toc-number">1.2.3.</span> <span class="toc-text">add_instrumentation的逻辑</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%B8%80%E3%80%81%E6%95%B4%E4%BD%93%E5%A4%84%E7%90%86%E6%B5%81%E7%A8%8B"><span class="toc-number">1.2.3.1.</span> <span class="toc-text">一、整体处理流程</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BA%8C%E3%80%81%E5%85%B3%E9%94%AE%E6%8F%92%E6%A1%A9%E4%BD%8D%E7%BD%AE"><span class="toc-number">1.2.3.2.</span> <span class="toc-text">二、关键插桩位置</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%B8%89%E3%80%81%E8%B7%B3%E8%BF%87%E6%9C%BA%E5%88%B6"><span class="toc-number">1.2.3.3.</span> <span class="toc-text">三、跳过机制</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#afl-fast-clang"><span class="toc-number">1.3.</span> <span class="toc-text">afl-fast-clang</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#afl-llvm-pass"><span class="toc-number">1.4.</span> <span class="toc-text">afl-llvm-pass</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#GlobalVariable"><span class="toc-number">1.4.1.</span> <span class="toc-text">GlobalVariable</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#AFLMapPtr-%E5%85%B1%E4%BA%AB%E5%86%85%E5%AD%98%E5%8C%BA%E5%9F%9F%E6%8C%87%E9%92%88"><span class="toc-number">1.4.1.1.</span> <span class="toc-text">AFLMapPtr - 共享内存区域指针</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#afl-llvm-rt"><span class="toc-number">1.5.</span> <span class="toc-text">afl-llvm-rt</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#afl-manual-init"><span class="toc-number">1.5.1.</span> <span class="toc-text">__afl_manual_init</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#afl-map-shm"><span class="toc-number">1.5.1.1.</span> <span class="toc-text">__afl_map_shm</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#afl-start-forkserver"><span class="toc-number">1.5.1.2.</span> <span class="toc-text">__afl_start_forkserver</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E9%80%9A%E4%BF%A1%E7%AE%A1%E9%81%93%E8%AF%B4%E6%98%8E"><span class="toc-number">1.5.1.2.1.</span> <span class="toc-text">通信管道说明</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%8C%81%E4%B9%85%E5%8C%96-vs-%E9%9D%9E%E6%8C%81%E4%B9%85%E5%8C%96%E6%A8%A1%E5%BC%8F"><span class="toc-number">1.5.1.2.2.</span> <span class="toc-text">持久化 vs 非持久化模式</span></a><ol class="toc-child"><li class="toc-item toc-level-6"><a class="toc-link" href="#%E9%9D%9E%E6%8C%81%E4%B9%85%E5%8C%96%E6%A8%A1%E5%BC%8F%EF%BC%88%E9%BB%98%E8%AE%A4%EF%BC%89"><span class="toc-number">1.5.1.2.2.1.</span> <span class="toc-text">非持久化模式（默认）</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#%E6%8C%81%E4%B9%85%E5%8C%96%E6%A8%A1%E5%BC%8F"><span class="toc-number">1.5.1.2.2.2.</span> <span class="toc-text">持久化模式</span></a></li></ol></li></ol></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#afl-persistent-loop"><span class="toc-number">1.5.2.</span> <span class="toc-text">__afl_persistent_loop</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%9B%AE%E6%A0%87%E7%A8%8B%E5%BA%8F%E4%B8%AD%E7%9A%84%E9%9B%86%E6%88%90"><span class="toc-number">1.5.2.1.</span> <span class="toc-text">目标程序中的集成</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#SanitizerCoverage-%E5%9B%9E%E8%B0%83%E5%87%BD%E6%95%B0"><span class="toc-number">1.5.3.</span> <span class="toc-text">SanitizerCoverage 回调函数</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#sanitizer-cov-trace-pc-guard%EF%BC%9A%E8%A6%86%E7%9B%96%E7%8E%87%E8%BF%BD%E8%B8%AA%E5%9B%9E%E8%B0%83"><span class="toc-number">1.5.3.1.</span> <span class="toc-text">__sanitizer_cov_trace_pc_guard：覆盖率追踪回调</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#sanitizer-cov-trace-pc-guard-init%EF%BC%9A%E6%8F%92%E6%A1%A9%E7%82%B9%E5%88%9D%E5%A7%8B%E5%8C%96"><span class="toc-number">1.5.3.2.</span> <span class="toc-text">__sanitizer_cov_trace_pc_guard_init：插桩点初始化</span></a></li></ol></li></ol></li></ol></li></ol></div></div><div class="author-info hide"><div class="author-info__avatar text-center"><img src="https://kr0emer-blog-1306550410.cos.ap-nanjing.myqcloud.com/img/psc.jpg"></div><div class="author-info__name text-center">Kr0emer</div><div class="author-info__description text-center"></div><div class="follow-button"><a target="_blank" rel="noopener" href="https://github.com/Kr0emer">Follow Me</a></div><hr><div class="author-info-articles"><a class="author-info-articles__archives article-meta" href="/archives"><span class="pull-left">Articles</span><span class="pull-right">14</span></a><a class="author-info-articles__tags article-meta" href="/tags"><span class="pull-left">Tags</span><span class="pull-right">7</span></a><a class="author-info-articles__categories article-meta" href="/categories"><span class="pull-left">Categories</span><span class="pull-right">9</span></a></div><hr><div class="author-info-links"><div class="author-info-links__title text-center">Links</div><a class="author-info-links__name text-center" target="_blank" rel="noopener" href="https://lonmar.cn/">L0nm4r</a><a class="author-info-links__name text-center" target="_blank" rel="noopener" href="http://www.aerol1te.xyz">Aerol1te</a><a class="author-info-links__name text-center" target="_blank" rel="noopener" href="https://blog.csdn.net/wuyvle?spm=1000.2115.3001.5343">Wondermaker</a><a class="author-info-links__name text-center" target="_blank" rel="noopener" href="https://eeeeeeeeeeeeeeeea.cn">Eeee</a><a class="author-info-links__name text-center" target="_blank" rel="noopener" href="http://pyozo.top">Pyozo</a></div></div></div><div id="content-outer"><div id="top-container" style="background-image: url(https://kr0emer-blog-1306550410.cos.ap-nanjing.myqcloud.com/img/72177032_p0.png)"><div id="page-header"><span class="pull-left"> <a id="site-name" href="/">Kr0emerのBlog</a></span><i class="fa fa-bars toggle-menu pull-right" aria-hidden="true"></i><span class="pull-right menus">   <a class="site-page" href="/">Home</a><a class="site-page" href="/archives">Archives</a><a class="site-page" href="/tags">Tags</a><a class="site-page" href="/categories">Categories</a></span><span class="pull-right"><a class="site-page social-icon search"><i class="fa fa-search"></i><span> Search</span></a></span></div><div id="post-info"><div id="post-title">AFL代码详读（上）</div><div id="post-meta"><time class="post-meta__date"><i class="fa fa-calendar" aria-hidden="true"></i> 2025-07-14</time><span class="post-meta__separator">|</span><i class="fa fa-inbox post-meta__icon" aria-hidden="true"></i><a class="post-meta__categories" href="/categories/fuzz/">fuzz</a><div class="post-meta-wordcount"><span>Word count: </span><span class="word-count">12.6k</span><span class="post-meta__separator">|</span><span>Reading time: 56 min</span></div></div></div></div><div class="layout" id="content-inner"><article id="post"><div class="article-container" id="post-content"><h1 id="AFL代码详读（上）"><a href="#AFL代码详读（上）" class="headerlink" title="AFL代码详读（上）"></a>AFL代码详读（上）</h1><h2 id="afl-gcc"><a href="#afl-gcc" class="headerlink" title="afl-gcc"></a>afl-gcc</h2><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* 声明使用AFL的主程序宏，用于某些平台的特殊处理 */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> AFL_MAIN</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* 包含头文件部分开始 */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;config.h&quot;</span>       <span class="comment">// AFL的编译配置信息（自动生成）</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;types.h&quot;</span>        <span class="comment">// AFL自定义数据类型（如u8、u32等）</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;debug.h&quot;</span>        <span class="comment">// 调试输出相关函数（SAYF, FATAL等）</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;alloc-inl.h&quot;</span>    <span class="comment">// AFL自定义内存分配函数（带错误检查）</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* 标准库头文件 */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span>        <span class="comment">// 标准输入输出函数</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span>       <span class="comment">// POSIX系统调用（access, execvp等）</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span>       <span class="comment">// 标准库函数（getenv, exit等）</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span>       <span class="comment">// 字符串处理函数（strrchr, strncmp等）</span></span></span><br><span class="line"><span class="comment">/* 包含头文件部分结束 */</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* 全局变量声明开始 */</span></span><br><span class="line"><span class="keyword">static</span> u8*  as_path;        <span class="comment">// 存储afl-as汇编器路径的指针</span></span><br><span class="line"><span class="keyword">static</span> u8** cc_params;      <span class="comment">// 最终要传递给真实编译器的参数数组</span></span><br><span class="line"><span class="keyword">static</span> u32  cc_par_cnt = <span class="number">1</span>; <span class="comment">// 参数计数器（从1开始，包含argv[0]）</span></span><br><span class="line"><span class="keyword">static</span> u8   be_quiet,       <span class="comment">// 静默模式标志（不显示横幅等信息）</span></span><br><span class="line">            clang_mode;    <span class="comment">// 是否以clang模式运行的标志</span></span><br><span class="line"><span class="comment">/* 全局变量声明结束 */</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*-----------------------------------------------------------*/</span></span><br><span class="line"><span class="comment">/* 查找AFL汇编器路径的函数 */</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">find_as</span><span class="params">(u8* argv0)</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line"><span class="comment">/*-----------------------*/</span>    </span><br><span class="line"><span class="comment">/* 先从环境变量中寻找AFL_PATH，如果找到了则设置as_path为AFL_PATH*/</span></span><br><span class="line">  u8 *afl_path = getenv(<span class="string">&quot;AFL_PATH&quot;</span>); <span class="comment">// 尝试从环境变量获取路径</span></span><br><span class="line">  u8 *slash, *tmp; <span class="comment">// 临时变量：slash用于路径分割，tmp用于构建路径字符串</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">/* 环境变量检查分支 */</span></span><br><span class="line">  <span class="keyword">if</span> (afl_path) &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 构建完整路径字符串：AFL_PATH/as</span></span><br><span class="line">    tmp = alloc_printf(<span class="string">&quot;%s/as&quot;</span>, afl_path);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 检查文件是否存在且可执行</span></span><br><span class="line">    <span class="keyword">if</span> (!access(tmp, X_OK)) &#123;</span><br><span class="line">      as_path = afl_path;  <span class="comment">// 验证成功，保存路径</span></span><br><span class="line">      ck_free(tmp);        <span class="comment">// 释放临时内存</span></span><br><span class="line">      <span class="keyword">return</span>;              <span class="comment">// 直接返回</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    ck_free(tmp); <span class="comment">// 释放构建失败的路径字符串</span></span><br><span class="line"></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*-----------------------*/</span>    </span><br><span class="line"><span class="comment">/* 如果没有找到则从argv0寻找*/</span></span><br><span class="line">  slash = <span class="built_in">strrchr</span>(argv0, <span class="string">&#x27;/&#x27;</span>); <span class="comment">// 查找最后一个&#x27;/&#x27;字符位置</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (slash) &#123; <span class="comment">// 如果argv0包含路径信息</span></span><br><span class="line"></span><br><span class="line">    u8 *dir; <span class="comment">// 目录路径临时变量</span></span><br><span class="line"></span><br><span class="line">    *slash = <span class="number">0</span>; <span class="comment">// 暂时截断字符串，获取目录路径</span></span><br><span class="line">    dir = ck_strdup(argv0); <span class="comment">// 复制目录路径（分配堆内存）</span></span><br><span class="line">    *slash = <span class="string">&#x27;/&#x27;</span>; <span class="comment">// 恢复原始argv0字符串</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 构建路径：目录路径/afl-as</span></span><br><span class="line">    tmp = alloc_printf(<span class="string">&quot;%s/afl-as&quot;</span>, dir);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 检查文件可执行性</span></span><br><span class="line">    <span class="keyword">if</span> (!access(tmp, X_OK)) &#123;</span><br><span class="line">      as_path = dir;   <span class="comment">// 验证成功，保存路径</span></span><br><span class="line">      ck_free(tmp);    <span class="comment">// 释放临时路径字符串</span></span><br><span class="line">      <span class="keyword">return</span>;          <span class="comment">// 直接返回</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 清理分支内分配的内存</span></span><br><span class="line">    ck_free(tmp);</span><br><span class="line">    ck_free(dir);</span><br><span class="line"></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* 硬编码路径检查分支 */</span></span><br><span class="line">  <span class="keyword">if</span> (!access(AFL_PATH <span class="string">&quot;/as&quot;</span>, X_OK)) &#123; <span class="comment">// 检查默认安装路径</span></span><br><span class="line">    as_path = AFL_PATH;  <span class="comment">// 使用编译时定义的AFL_PATH</span></span><br><span class="line">    <span class="keyword">return</span>; </span><br><span class="line">  &#125;</span><br><span class="line"><span class="comment">/*-----------------------*/</span>    </span><br><span class="line"><span class="comment">/* 所有路径查找失败后的致命错误 */</span></span><br><span class="line">  FATAL(<span class="string">&quot;Unable to find AFL wrapper binary for &#x27;as&#x27;. Please set AFL_PATH&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*-----------------------------------------------------------*/</span></span><br><span class="line"><span class="comment">/* 编辑编译器参数的函数 */</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">edit_params</span><span class="params">(u32 argc, <span class="keyword">char</span>** argv)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  u8 fortify_set = <span class="number">0</span>, <span class="comment">// FORTIFY_SOURCE是否已设置的标志</span></span><br><span class="line">     asan_set = <span class="number">0</span>;    <span class="comment">// 地址消毒剂是否已设置的标志</span></span><br><span class="line">  u8 *name;           <span class="comment">// 存储程序名称的指针</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">if</span> defined(__FreeBSD__) &amp;&amp; defined(__x86_64__) <span class="comment">// FreeBSD特定处理</span></span></span><br><span class="line">  u8 m32_set = <span class="number">0</span>;      <span class="comment">// -m32参数是否存在的标志</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"></span><br><span class="line">  <span class="comment">/* 分配参数数组内存（原始参数+128个额外参数） */</span></span><br><span class="line">  cc_params = ck_alloc((argc + <span class="number">128</span>) * <span class="keyword">sizeof</span>(u8*));</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* 解析程序名称 */</span></span><br><span class="line">  name = <span class="built_in">strrchr</span>(argv[<span class="number">0</span>], <span class="string">&#x27;/&#x27;</span>); <span class="comment">// 查找最后一个&#x27;/&#x27;位置</span></span><br><span class="line">  <span class="keyword">if</span> (!name) name = argv[<span class="number">0</span>]; <span class="keyword">else</span> name++; <span class="comment">// 获取纯程序名（不含路径）</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">/* 判断是否clang模式 */</span></span><br><span class="line">  <span class="keyword">if</span> (!<span class="built_in">strncmp</span>(name, <span class="string">&quot;afl-clang&quot;</span>, <span class="number">9</span>)) &#123; <span class="comment">// 检测程序名前缀</span></span><br><span class="line"></span><br><span class="line">    clang_mode = <span class="number">1</span>; <span class="comment">// 设置clang模式标志</span></span><br><span class="line">    setenv(CLANG_ENV_VAR, <span class="string">&quot;1&quot;</span>, <span class="number">1</span>); <span class="comment">// 向后续编译流程（如汇编器、链接器）传递「当前使用 Clang」的信息，以启用 Clang 特有的插桩逻辑。</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 处理C++特殊情况 */</span></span><br><span class="line">    <span class="keyword">if</span> (!<span class="built_in">strcmp</span>(name, <span class="string">&quot;afl-clang++&quot;</span>)) &#123; <span class="comment">// 精确匹配C++版本</span></span><br><span class="line">      u8* alt_cxx = getenv(<span class="string">&quot;AFL_CXX&quot;</span>);  <span class="comment">// 检查自定义C++编译器</span></span><br><span class="line">      cc_params[<span class="number">0</span>] = alt_cxx ? alt_cxx : (u8*)<span class="string">&quot;clang++&quot;</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      u8* alt_cc = getenv(<span class="string">&quot;AFL_CC&quot;</span>);    <span class="comment">// 检查自定义C编译器</span></span><br><span class="line">      cc_params[<span class="number">0</span>] = alt_cc ? alt_cc : (u8*)<span class="string">&quot;clang&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 处理其他编译器（GCC系列） */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> __APPLE__ <span class="comment">// MacOS特殊处理</span></span></span><br><span class="line">    <span class="comment">// 因为Mac的gcc实际上是clang别名，需要特别处理</span></span><br><span class="line">    <span class="keyword">if</span> (!<span class="built_in">strcmp</span>(name, <span class="string">&quot;afl-g++&quot;</span>)) cc_params[<span class="number">0</span>] = getenv(<span class="string">&quot;AFL_CXX&quot;</span>);</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (!<span class="built_in">strcmp</span>(name, <span class="string">&quot;afl-gcj&quot;</span>)) cc_params[<span class="number">0</span>] = getenv(<span class="string">&quot;AFL_GCJ&quot;</span>);</span><br><span class="line">    <span class="keyword">else</span> cc_params[<span class="number">0</span>] = getenv(<span class="string">&quot;AFL_CC&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 错误处理分支</span></span><br><span class="line">    <span class="keyword">if</span> (!cc_params[<span class="number">0</span>]) &#123;</span><br><span class="line">      SAYF(<span class="string">&quot;\n&quot;</span> cLRD <span class="string">&quot;[-] &quot;</span> cRST</span><br><span class="line">           <span class="string">&quot;On Apple systems, &#x27;gcc&#x27; is usually just a wrapper for clang...&quot;</span>);</span><br><span class="line">      FATAL(<span class="string">&quot;AFL_CC or AFL_CXX required on MacOS X&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">else</span> <span class="comment">// 非Mac系统处理</span></span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 标准GCC处理流程 */</span></span><br><span class="line">    <span class="keyword">if</span> (!<span class="built_in">strcmp</span>(name, <span class="string">&quot;afl-g++&quot;</span>)) &#123;</span><br><span class="line">      u8* alt_cxx = getenv(<span class="string">&quot;AFL_CXX&quot;</span>);</span><br><span class="line">      cc_params[<span class="number">0</span>] = alt_cxx ? alt_cxx : (u8*)<span class="string">&quot;g++&quot;</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (!<span class="built_in">strcmp</span>(name, <span class="string">&quot;afl-gcj&quot;</span>)) &#123; <span class="comment">// GCJ特殊处理</span></span><br><span class="line">      u8* alt_cc = getenv(<span class="string">&quot;AFL_GCJ&quot;</span>);</span><br><span class="line">      cc_params[<span class="number">0</span>] = alt_cc ? alt_cc : (u8*)<span class="string">&quot;gcj&quot;</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123; <span class="comment">// 默认GCC情况</span></span><br><span class="line">      u8* alt_cc = getenv(<span class="string">&quot;AFL_CC&quot;</span>);</span><br><span class="line">      cc_params[<span class="number">0</span>] = alt_cc ? alt_cc : (u8*)<span class="string">&quot;gcc&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span> <span class="comment">/* __APPLE__ */</span></span></span><br><span class="line"></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* 参数处理循环（跳过argv[0]） */</span></span><br><span class="line">  <span class="keyword">while</span> (--argc) &#123; <span class="comment">// 递减参数计数器</span></span><br><span class="line">    u8* cur = *(++argv); <span class="comment">// 获取当前参数指针</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 处理用户指定的-B参数（必须覆盖） */</span></span><br><span class="line">    <span class="keyword">if</span> (!<span class="built_in">strncmp</span>(cur, <span class="string">&quot;-B&quot;</span>, <span class="number">2</span>)) &#123; <span class="comment">// 匹配-B开头的参数</span></span><br><span class="line">      <span class="keyword">if</span> (!be_quiet) WARNF(<span class="string">&quot;-B is already set, overriding&quot;</span>); <span class="comment">// 显示警告</span></span><br><span class="line">      <span class="comment">// 处理-B后带空格的情况（如&quot;-B /path&quot;）</span></span><br><span class="line">      <span class="keyword">if</span> (!cur[<span class="number">2</span>] &amp;&amp; argc &gt; <span class="number">1</span>) &#123; argc--; argv++; &#125;</span><br><span class="line">      <span class="keyword">continue</span>; <span class="comment">// 跳过这个参数</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 过滤冲突参数 */</span></span><br><span class="line">    <span class="keyword">if</span> (!<span class="built_in">strcmp</span>(cur, <span class="string">&quot;-integrated-as&quot;</span>)) <span class="keyword">continue</span>; <span class="comment">// 禁用clang集成汇编器</span></span><br><span class="line">    <span class="keyword">if</span> (!<span class="built_in">strcmp</span>(cur, <span class="string">&quot;-pipe&quot;</span>)) <span class="keyword">continue</span>;         <span class="comment">// 过滤管道参数</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">if</span> defined(__FreeBSD__) &amp;&amp; defined(__x86_64__)</span></span><br><span class="line">    <span class="comment">/* FreeBSD下32位模式检测 */</span></span><br><span class="line">    <span class="keyword">if</span> (!<span class="built_in">strcmp</span>(cur, <span class="string">&quot;-m32&quot;</span>)) m32_set = <span class="number">1</span>; <span class="comment">// 记录-m32参数存在</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 检测安全相关参数 */</span></span><br><span class="line">    <span class="keyword">if</span> (!<span class="built_in">strcmp</span>(cur, <span class="string">&quot;-fsanitize=address&quot;</span>) || </span><br><span class="line">        !<span class="built_in">strcmp</span>(cur, <span class="string">&quot;-fsanitize=memory&quot;</span>)) asan_set = <span class="number">1</span>; <span class="comment">// 地址/内存消毒剂</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">strstr</span>(cur, <span class="string">&quot;FORTIFY_SOURCE&quot;</span>)) fortify_set = <span class="number">1</span>; <span class="comment">// 强化检测</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 添加有效参数到列表 */</span></span><br><span class="line">    cc_params[cc_par_cnt++] = cur; <span class="comment">// 复制当前参数</span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* 添加AFL强制参数 */</span></span><br><span class="line">  cc_params[cc_par_cnt++] = <span class="string">&quot;-B&quot;</span>;      <span class="comment">// 指定汇编器路径参数</span></span><br><span class="line">  cc_params[cc_par_cnt++] = as_path;   <span class="comment">// 之前找到的as路径</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">/* Clang模式特殊处理 */</span></span><br><span class="line">  <span class="keyword">if</span> (clang_mode)</span><br><span class="line">    cc_params[cc_par_cnt++] = <span class="string">&quot;-no-integrated-as&quot;</span>; <span class="comment">// 强制使用外部汇编器</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">/* 加固选项处理 */</span></span><br><span class="line">  <span class="keyword">if</span> (getenv(<span class="string">&quot;AFL_HARDEN&quot;</span>)) &#123; <span class="comment">// 如果启用加固模式</span></span><br><span class="line">    cc_params[cc_par_cnt++] = <span class="string">&quot;-fstack-protector-all&quot;</span>; <span class="comment">// 全栈保护</span></span><br><span class="line">    <span class="keyword">if</span> (!fortify_set) <span class="comment">// 如果用户未设置FORTIFY</span></span><br><span class="line">      cc_params[cc_par_cnt++] = <span class="string">&quot;-D_FORTIFY_SOURCE=2&quot;</span>; <span class="comment">// 添加强化宏定义</span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* 消毒剂处理逻辑 */</span></span><br><span class="line">  <span class="keyword">if</span> (asan_set) &#123; <span class="comment">// 如果用户已启用消毒剂</span></span><br><span class="line">    setenv(<span class="string">&quot;AFL_USE_ASAN&quot;</span>, <span class="string">&quot;1&quot;</span>, <span class="number">1</span>); <span class="comment">// 通知后续流程使用ASAN</span></span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (getenv(<span class="string">&quot;AFL_USE_ASAN&quot;</span>)) &#123; <span class="comment">// 如果通过环境变量启用</span></span><br><span class="line">    <span class="keyword">if</span> (getenv(<span class="string">&quot;AFL_USE_MSAN&quot;</span>)) <span class="comment">// 消毒剂互斥检查</span></span><br><span class="line">      FATAL(<span class="string">&quot;ASAN and MSAN are mutually exclusive&quot;</span>);</span><br><span class="line">    <span class="keyword">if</span> (getenv(<span class="string">&quot;AFL_HARDEN&quot;</span>)) </span><br><span class="line">      FATAL(<span class="string">&quot;ASAN and AFL_HARDEN are mutually exclusive&quot;</span>);</span><br><span class="line">    </span><br><span class="line">    cc_params[cc_par_cnt++] = <span class="string">&quot;-U_FORTIFY_SOURCE&quot;</span>; <span class="comment">// 取消强化宏</span></span><br><span class="line">    cc_params[cc_par_cnt++] = <span class="string">&quot;-fsanitize=address&quot;</span>; <span class="comment">// 添加消毒剂参数</span></span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (getenv(<span class="string">&quot;AFL_USE_MSAN&quot;</span>)) &#123; <span class="comment">// 内存消毒剂处理</span></span><br><span class="line">    <span class="comment">// ...类似ASAN的处理（为节省篇幅省略重复注释）...</span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* 优化参数处理 */</span></span><br><span class="line">  <span class="keyword">if</span> (!getenv(<span class="string">&quot;AFL_DONT_OPTIMIZE&quot;</span>)) &#123; <span class="comment">// 默认添加优化参数</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">if</span> defined(__FreeBSD__) &amp;&amp; defined(__x86_64__)</span></span><br><span class="line">    <span class="comment">/* FreeBSD下clang的-m32调试问题规避 */</span></span><br><span class="line">    <span class="keyword">if</span> (!clang_mode || !m32_set) <span class="comment">// 非clang模式或未使用-m32时</span></span><br><span class="line">      cc_params[cc_par_cnt++] = <span class="string">&quot;-g&quot;</span>; <span class="comment">// 调试符号</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">else</span></span></span><br><span class="line">    cc_params[cc_par_cnt++] = <span class="string">&quot;-g&quot;</span>;    <span class="comment">// 添加调试符号</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"></span><br><span class="line">    cc_params[cc_par_cnt++] = <span class="string">&quot;-O3&quot;</span>;           <span class="comment">// 最高优化级别</span></span><br><span class="line">    cc_params[cc_par_cnt++] = <span class="string">&quot;-funroll-loops&quot;</span>; <span class="comment">// 循环展开优化</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 添加fuzzing相关宏定义 */</span></span><br><span class="line">    cc_params[cc_par_cnt++] = <span class="string">&quot;-D__AFL_COMPILER=1&quot;</span>; <span class="comment">// 标识AFL编译</span></span><br><span class="line">    cc_params[cc_par_cnt++] = <span class="string">&quot;-DFUZZING_BUILD_MODE_UNSAFE_FOR_PRODUCTION=1&quot;</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* 禁用内建函数处理 */</span></span><br><span class="line">  <span class="keyword">if</span> (getenv(<span class="string">&quot;AFL_NO_BUILTIN&quot;</span>)) &#123; <span class="comment">// 如果要求禁用内建函数</span></span><br><span class="line">    cc_params[cc_par_cnt++] = <span class="string">&quot;-fno-builtin-strcmp&quot;</span>;  <span class="comment">// 字符串比较</span></span><br><span class="line">    cc_params[cc_par_cnt++] = <span class="string">&quot;-fno-builtin-strncmp&quot;</span>;</span><br><span class="line">    cc_params[cc_par_cnt++] = <span class="string">&quot;-fno-builtin-strcasecmp&quot;</span>; <span class="comment">// 大小写不敏感比较</span></span><br><span class="line">    cc_params[cc_par_cnt++] = <span class="string">&quot;-fno-builtin-strncasecmp&quot;</span>;</span><br><span class="line">    cc_params[cc_par_cnt++] = <span class="string">&quot;-fno-builtin-memcmp&quot;</span>;   <span class="comment">// 内存比较</span></span><br><span class="line">    cc_params[cc_par_cnt++] = <span class="string">&quot;-fno-builtin-strstr&quot;</span>;   <span class="comment">// 子字符串查找</span></span><br><span class="line">    cc_params[cc_par_cnt++] = <span class="string">&quot;-fno-builtin-strcasestr&quot;</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* 终止参数数组 */</span></span><br><span class="line">  cc_params[cc_par_cnt] = <span class="literal">NULL</span>; <span class="comment">// execvp要求NULL结尾</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*-----------------------------------------------------------*/</span></span><br><span class="line"><span class="comment">/* 主函数 */</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span>** argv)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* 静默模式检测 */</span></span><br><span class="line">  <span class="keyword">if</span> (isatty(<span class="number">2</span>) &amp;&amp; !getenv(<span class="string">&quot;AFL_QUIET&quot;</span>)) &#123; <span class="comment">// 检查标准错误是否是终端</span></span><br><span class="line">    SAYF(cCYA <span class="string">&quot;afl-cc &quot;</span> cBRI VERSION cRST <span class="string">&quot; by &lt;lcamtuf@google.com&gt;\n&quot;</span>);</span><br><span class="line">  &#125; <span class="keyword">else</span> be_quiet = <span class="number">1</span>; <span class="comment">// 设置静默标志</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">/* 参数数量检查 */</span></span><br><span class="line">  <span class="keyword">if</span> (argc &lt; <span class="number">2</span>) &#123; <span class="comment">// 没有实际参数时显示帮助</span></span><br><span class="line">    SAYF(<span class="string">&quot;\n&quot;</span></span><br><span class="line">         <span class="string">&quot;This is a helper application for afl-fuzz. It serves as a drop-in replacement\n&quot;</span></span><br><span class="line">         <span class="string">&quot;for gcc or clang, letting you recompile third-party code with the required\n&quot;</span></span><br><span class="line">         <span class="string">&quot;runtime instrumentation. A common use pattern would be one of the following:\n\n&quot;</span></span><br><span class="line"></span><br><span class="line">         <span class="string">&quot;  CC=%s/afl-gcc ./configure\n&quot;</span></span><br><span class="line">         <span class="string">&quot;  CXX=%s/afl-g++ ./configure\n\n&quot;</span></span><br><span class="line"></span><br><span class="line">         <span class="string">&quot;You can specify custom next-stage toolchain via AFL_CC, AFL_CXX, and AFL_AS.\n&quot;</span></span><br><span class="line">         <span class="string">&quot;Setting AFL_HARDEN enables hardening optimizations in the compiled code.\n\n&quot;</span>,</span><br><span class="line">         BIN_PATH, BIN_PATH);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* 核心处理流程 */</span></span><br><span class="line">  find_as(argv[<span class="number">0</span>]);     <span class="comment">// 查找as路径</span></span><br><span class="line">  edit_params(argc, argv); <span class="comment">// 构建参数列表</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">/* 执行真实编译器 */</span></span><br><span class="line">  execvp(cc_params[<span class="number">0</span>], (<span class="keyword">char</span>**)cc_params); <span class="comment">// 替换当前进程</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">/* 执行失败处理 */</span></span><br><span class="line">  FATAL(<span class="string">&quot;Oops, failed to execute &#x27;%s&#x27; - check your PATH&quot;</span>, cc_params[<span class="number">0</span>]);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>; <span class="comment">// 理论不会执行到这里</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>afl-gcc的核心功能就是找到AFL中as所在文件夹的路径并调用gcc并将该路径加入，设置必要参数，一些宏，以及环境变量。</p>
<p>我们测试一下，在main函数中添加下面的代码，打印一下参数</p>
<p><img src="C:/Users/Kr0emer/AppData/Roaming/Typora/typora-user-images/image-20250529104509081.png" alt="添加代码"></p>
<p><img src="C:/Users/Kr0emer/AppData/Roaming/Typora/typora-user-images/image-20250529105657479.png" alt="结果"></p>
<h2 id="afl-as"><a href="#afl-as" class="headerlink" title="afl-as"></a>afl-as</h2><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// AFL 汇编器包装器核心代码</span></span><br><span class="line"><span class="comment">// 主要功能：在 GCC/Clang 生成的汇编代码中插入覆盖率追踪桩代码</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> AFL_MAIN  <span class="comment">// 主程序标识</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;config.h&quot;</span>     <span class="comment">// AFL 配置头文件</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;types.h&quot;</span>      <span class="comment">// 自定义类型定义</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;debug.h&quot;</span>      <span class="comment">// 调试输出宏</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;alloc-inl.h&quot;</span>  <span class="comment">// 安全内存分配函数</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;afl-as.h&quot;</span>     <span class="comment">// 桩代码定义</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;time.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;ctype.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/wait.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/time.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> u8** as_params;          <span class="comment">// 传递给真实汇编器的参数数组</span></span><br><span class="line"><span class="keyword">static</span> u8*  input_file;         <span class="comment">// 原始输入文件名</span></span><br><span class="line"><span class="keyword">static</span> u8*  modified_file;      <span class="comment">// 插桩后的临时文件名</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> u8   be_quiet,           <span class="comment">// 静默模式标志</span></span><br><span class="line">            clang_mode,         <span class="comment">// Clang 模式标志</span></span><br><span class="line">            pass_thru,          <span class="comment">// 直接透传模式（不插桩）</span></span><br><span class="line">            just_version,       <span class="comment">// 仅显示版本标志</span></span><br><span class="line">            sanitizer;          <span class="comment">// ASAN/MSAN 模式标志</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> u32  inst_ratio = <span class="number">100</span>,   <span class="comment">// 插桩概率百分比（默认100%）</span></span><br><span class="line">            as_par_cnt = <span class="number">1</span>;     <span class="comment">// 当前参数计数器</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 根据编译环境设置默认位宽（32/64位）</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> WORD_SIZE_64</span></span><br><span class="line"><span class="keyword">static</span> u8   use_64bit = <span class="number">1</span>;      <span class="comment">// 64位模式</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">else</span></span></span><br><span class="line"><span class="keyword">static</span> u8   use_64bit = <span class="number">0</span>;      <span class="comment">// 32位模式</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> __APPLE__</span></span><br><span class="line"><span class="meta">#  <span class="meta-keyword">error</span> <span class="meta-string">&quot;Apple 32位平台不支持&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* 参数处理函数：修改传递给真实汇编器的参数 */</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">edit_params</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span>** argv)</span> </span>&#123;</span><br><span class="line">  u8 *tmp_dir = getenv(<span class="string">&quot;TMPDIR&quot;</span>), *afl_as = getenv(<span class="string">&quot;AFL_AS&quot;</span>);<span class="comment">//先检查环境变量，看是否可以直接获取路径</span></span><br><span class="line">  u32 i;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> __APPLE__</span></span><br><span class="line">  <span class="comment">// MacOS 特殊处理：优先使用 Clang 作为汇编器[3,8](@ref)</span></span><br><span class="line">  u8 use_clang_as = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">if</span> (clang_mode &amp;&amp; !afl_as) &#123;</span><br><span class="line"></span><br><span class="line">    use_clang_as = <span class="number">1</span>;<span class="comment">//如果使用clang_mode,且环境变量中没有AFL_AS，则设置use_clang_as为1</span></span><br><span class="line"></span><br><span class="line">    afl_as = getenv(<span class="string">&quot;AFL_CC&quot;</span>);</span><br><span class="line">    <span class="keyword">if</span> (!afl_as) afl_as = getenv(<span class="string">&quot;AFL_CXX&quot;</span>);</span><br><span class="line">    <span class="keyword">if</span> (!afl_as) afl_as = <span class="string">&quot;clang&quot;</span>;</span><br><span class="line"></span><br><span class="line">  &#125;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// 确定临时目录</span></span><br><span class="line">  <span class="keyword">if</span> (!tmp_dir) tmp_dir = getenv(<span class="string">&quot;TEMP&quot;</span>);<span class="comment">//如果之前通过TMPDIR没有找到，则查找TEMP环境变量</span></span><br><span class="line">  <span class="keyword">if</span> (!tmp_dir) tmp_dir = getenv(<span class="string">&quot;TMP&quot;</span>);<span class="comment">//如果之前通过TEMP没有找到，则查找TMP环境变量</span></span><br><span class="line">  <span class="keyword">if</span> (!tmp_dir) tmp_dir = <span class="string">&quot;/tmp&quot;</span>;<span class="comment">//如果之前通过TEP没有找到，则设置为&quot;/tmp&quot;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">  as_params = ck_alloc((argc + <span class="number">32</span>) * <span class="keyword">sizeof</span>(u8*)); <span class="comment">// 分配参数数组内存</span></span><br><span class="line">  as_params[<span class="number">0</span>] = afl_as ? afl_as : (u8*)<span class="string">&quot;as&quot;</span>;       <span class="comment">// 如果之前通过环境变量找到了afl_as，则令as_params[0]为afl_as，否则设置为as</span></span><br><span class="line">  as_params[argc] = <span class="number">0</span>;</span><br><span class="line">  <span class="comment">// 处理传入参数</span></span><br><span class="line">  <span class="keyword">for</span> (i = <span class="number">1</span>; i &lt; argc - <span class="number">1</span>; i++) &#123;</span><br><span class="line">    <span class="keyword">if</span> (!<span class="built_in">strcmp</span>(argv[i], <span class="string">&quot;--64&quot;</span>)) use_64bit = <span class="number">1</span>;   <span class="comment">// 如果有参数 --64，6use_64bit设置为1</span></span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (!<span class="built_in">strcmp</span>(argv[i], <span class="string">&quot;--32&quot;</span>)) use_64bit = <span class="number">0</span>; <span class="comment">//  如果有参数 --32，use_64bit设置为0</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> __APPLE__</span></span><br><span class="line">    <span class="comment">// 处理 MacOS 架构参数</span></span><br><span class="line"><span class="keyword">if</span> (!<span class="built_in">strcmp</span>(argv[i], <span class="string">&quot;-arch&quot;</span>) &amp;&amp; i + <span class="number">1</span> &lt; argc) &#123;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">if</span> (!<span class="built_in">strcmp</span>(argv[i + <span class="number">1</span>], <span class="string">&quot;x86_64&quot;</span>)) use_64bit = <span class="number">1</span>;<span class="comment">//如果存在-arch x86_64，设置use_64bit为1</span></span><br><span class="line">      <span class="keyword">else</span> <span class="keyword">if</span> (!<span class="built_in">strcmp</span>(argv[i + <span class="number">1</span>], <span class="string">&quot;i386&quot;</span>))</span><br><span class="line">        FATAL(<span class="string">&quot;Sorry, 32-bit Apple platforms are not supported.&quot;</span>);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 过滤 Clang 特殊参数</span></span><br><span class="line">    <span class="keyword">if</span> (clang_mode &amp;&amp; (argv[i][<span class="number">0</span>] == <span class="string">&#x27;-&#x27;</span> &amp;&amp; (argv[i][<span class="number">1</span>] == <span class="string">&#x27;q&#x27;</span> || argv[i][<span class="number">1</span>] == <span class="string">&#x27;Q&#x27;</span>))) <span class="comment">//当apple环境下设置了clang模式，则跳过-q/-Q</span></span><br><span class="line">      <span class="keyword">continue</span>;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">	</span><br><span class="line">    as_params[as_par_cnt++] = argv[i]; <span class="comment">// 添加有效参数</span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> __APPLE__</span></span><br><span class="line">  <span class="comment">// MacOS Clang 模式，且没设置afl_as环境变量，设置必要参数</span></span><br><span class="line">  <span class="keyword">if</span> (use_clang_as) &#123;</span><br><span class="line">    as_params[as_par_cnt++] = <span class="string">&quot;-c&quot;</span>;</span><br><span class="line">    as_params[as_par_cnt++] = <span class="string">&quot;-x&quot;</span>;</span><br><span class="line">    as_params[as_par_cnt++] = <span class="string">&quot;assembler&quot;</span>;</span><br><span class="line">  &#125;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// 处理输入文件</span></span><br><span class="line">  input_file = argv[argc - <span class="number">1</span>];<span class="comment">//将最后一个参数作为input_argv</span></span><br><span class="line">  <span class="keyword">if</span> (input_file[<span class="number">0</span>] == <span class="string">&#x27;-&#x27;</span>) &#123;  <span class="comment">// 处理特殊输入（如--version）</span></span><br><span class="line">    <span class="keyword">if</span> (!<span class="built_in">strcmp</span>(input_file + <span class="number">1</span>, <span class="string">&quot;-version&quot;</span>)) &#123;</span><br><span class="line">      just_version = <span class="number">1</span>;</span><br><span class="line">      modified_file = input_file;</span><br><span class="line">      <span class="keyword">goto</span> wrap_things_up;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (input_file[<span class="number">1</span>]) FATAL(<span class="string">&quot;Incorrect use (not called through afl-gcc?)&quot;</span>);</span><br><span class="line">      <span class="keyword">else</span> input_file = <span class="literal">NULL</span>;</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="comment">// 判断是否需要透传模式（非临时目录文件）</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">strncmp</span>(input_file, tmp_dir, <span class="built_in">strlen</span>(tmp_dir)) &amp;&amp;</span><br><span class="line">        <span class="built_in">strncmp</span>(input_file, <span class="string">&quot;/var/tmp/&quot;</span>, <span class="number">9</span>) &amp;&amp;</span><br><span class="line">        <span class="built_in">strncmp</span>(input_file, <span class="string">&quot;/tmp/&quot;</span>, <span class="number">5</span>)) pass_thru = <span class="number">1</span>;<span class="comment">//比较input_file最前面几个字节和tmp_dir之前设置的路径或者/var/tmp/或者/tmp/相同，如果不相同，就设置pass_thru为1</span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 生成临时输出文件名（格式：/tmp/.afl-pid-timestamp.s）</span></span><br><span class="line">  modified_file = alloc_printf(<span class="string">&quot;%s/.afl-%u-%u.s&quot;</span>, tmp_dir, getpid(), (u32)time(<span class="literal">NULL</span>));</span><br><span class="line"></span><br><span class="line">wrap_things_up:</span><br><span class="line">  as_params[as_par_cnt++] = modified_file;  <span class="comment">// 添加最终输出文件参数</span></span><br><span class="line">  as_params[as_par_cnt] = <span class="literal">NULL</span>;             <span class="comment">// 参数数组终止符</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 插桩核心函数：在汇编代码中插入覆盖率追踪代码 */</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">add_instrumentation</span><span class="params">(<span class="keyword">void</span>)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">static</span> u8 line[MAX_LINE];  <span class="comment">// 行缓冲区</span></span><br><span class="line">  <span class="comment">/* 输入/输出文件指针 */</span></span><br><span class="line">  FILE* inf;   <span class="comment">// 输入文件</span></span><br><span class="line">  FILE* outf;  <span class="comment">// 输出文件</span></span><br><span class="line">  s32 outfd;   <span class="comment">// 输出文件描述符</span></span><br><span class="line">  u32 ins_lines = <span class="number">0</span>;  <span class="comment">// 记录已插桩位置数量</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// 状态标志</span></span><br><span class="line">  u8  instr_ok = <span class="number">0</span>,      <span class="comment">// 当前是否在.text段（可插桩区域）</span></span><br><span class="line">      skip_csect = <span class="number">0</span>,    <span class="comment">// 是否跳过当前代码段</span></span><br><span class="line">      skip_next_label = <span class="number">0</span>, <span class="comment">// 是否跳过下一个标签</span></span><br><span class="line">      skip_intel = <span class="number">0</span>,     <span class="comment">// 是否跳过Intel语法块</span></span><br><span class="line">      skip_app = <span class="number">0</span>,       <span class="comment">// 是否跳过#APP/#NO_APP块</span></span><br><span class="line">      instrument_next = <span class="number">0</span>; <span class="comment">// 是否对下一个标签插桩</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> __APPLE__</span></span><br><span class="line"></span><br><span class="line">  u8* colon_pos;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span> <span class="comment">/* __APPLE__ */</span></span></span><br><span class="line">  <span class="comment">// 打开输入输出文件</span></span><br><span class="line">  <span class="keyword">if</span> (input_file) &#123;<span class="comment">//如果input_file存在</span></span><br><span class="line"></span><br><span class="line">    inf = fopen(input_file, <span class="string">&quot;r&quot;</span>);<span class="comment">//尝试打开input_file</span></span><br><span class="line">    <span class="keyword">if</span> (!inf) PFATAL(<span class="string">&quot;Unable to read &#x27;%s&#x27;&quot;</span>, input_file);<span class="comment">//如果打开失败，异常</span></span><br><span class="line"></span><br><span class="line">  &#125; <span class="keyword">else</span> inf = <span class="built_in">stdin</span>;<span class="comment">//如果input_file不存在，则令inf为标准输入</span></span><br><span class="line"></span><br><span class="line">  outfd = open(modified_file, O_WRONLY | O_EXCL | O_CREAT, <span class="number">0600</span>);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (outfd &lt; <span class="number">0</span>) PFATAL(<span class="string">&quot;Unable to write to &#x27;%s&#x27;&quot;</span>, modified_file);</span><br><span class="line"></span><br><span class="line">  outf = fdopen(outfd, <span class="string">&quot;w&quot;</span>);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (!outf) PFATAL(<span class="string">&quot;fdopen() failed&quot;</span>);<span class="comment">//文件描述符转换失败报错</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">while</span> (fgets(line, MAX_LINE, inf)) &#123;<span class="comment">// 逐行处理汇编代码</span></span><br><span class="line"></span><br><span class="line">     <span class="comment">/* ====== 延迟插桩检查点 ====== */</span></span><br><span class="line">    <span class="comment">/* 处理函数/标签后的第一条实际指令时插入桩代码 */</span></span><br><span class="line">    <span class="keyword">if</span> (!pass_thru &amp;&amp;                 <span class="comment">// 非透传模式</span></span><br><span class="line">        !skip_intel &amp;&amp;                <span class="comment">// 不在Intel语法块</span></span><br><span class="line">        !skip_app &amp;&amp;                  <span class="comment">// 不在APP/NO_APP块</span></span><br><span class="line">        !skip_csect &amp;&amp;                <span class="comment">// 在有效代码段</span></span><br><span class="line">        instr_ok &amp;&amp;                   <span class="comment">// 在.text段，后面代码会置位</span></span><br><span class="line">        instrument_next &amp;&amp;            <span class="comment">// 已标记需要插桩，后面代码会置位</span></span><br><span class="line">        line[<span class="number">0</span>] == <span class="string">&#x27;\t&#x27;</span> &amp;&amp;           <span class="comment">// 行首是制表符</span></span><br><span class="line">        <span class="built_in">isalpha</span>(line[<span class="number">1</span>])) &#123;           <span class="comment">// 第二个字符是字母（指令）</span></span><br><span class="line">      </span><br><span class="line">      <span class="comment">// 根据架构选择32位或64位桩代码模板</span></span><br><span class="line">      <span class="built_in">fprintf</span>(outf, use_64bit ? trampoline_fmt_64 : trampoline_fmt_32,</span><br><span class="line">              R(MAP_SIZE));  <span class="comment">// 生成随机位置标识符</span></span><br><span class="line">      </span><br><span class="line">      instrument_next = <span class="number">0</span>;  <span class="comment">// 重置标记</span></span><br><span class="line">      ins_lines++;         <span class="comment">// 增加插桩计数</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">fputs</span>(line, outf);  <span class="comment">// 输出原始行</span></span><br><span class="line">	</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> (pass_thru) <span class="keyword">continue</span>;  <span class="comment">// 透传模式跳过后续处理</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/* </span></span><br><span class="line"><span class="comment">     * 段类型检测：识别.text段和其他数据段</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">if</span> (line[<span class="number">0</span>] == <span class="string">&#x27;\t&#x27;</span> &amp;&amp; line[<span class="number">1</span>] == <span class="string">&#x27;.&#x27;</span>) &#123;<span class="comment">//行首是制表符，且后面一位是&#x27;.&#x27;,既各种段</span></span><br><span class="line"></span><br><span class="line">      <span class="comment">/* OpenBSD跳转表特殊处理 */</span></span><br><span class="line">       <span class="keyword">if</span> (!clang_mode &amp;&amp;              <span class="comment">// 非clang模式</span></span><br><span class="line">          instr_ok &amp;&amp;                 <span class="comment">// 当前在代码段</span></span><br><span class="line">          !<span class="built_in">strncmp</span>(line + <span class="number">2</span>, <span class="string">&quot;p2align &quot;</span>, <span class="number">8</span>) &amp;&amp;  <span class="comment">// 对齐指令</span></span><br><span class="line">          <span class="built_in">isdigit</span>(line[<span class="number">10</span>]) &amp;&amp;        <span class="comment">// 后跟数字</span></span><br><span class="line">          line[<span class="number">11</span>] == <span class="string">&#x27;\n&#x27;</span>) &#123;         <span class="comment">// 行结束</span></span><br><span class="line">        skip_next_label = <span class="number">1</span>;          <span class="comment">// 标记跳过下一个标签</span></span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="comment">/* 检测.text段开始 */</span></span><br><span class="line">      <span class="keyword">if</span> (!<span class="built_in">strncmp</span>(line + <span class="number">2</span>, <span class="string">&quot;text\n&quot;</span>, <span class="number">5</span>) ||</span><br><span class="line">          !<span class="built_in">strncmp</span>(line + <span class="number">2</span>, <span class="string">&quot;section\t.text&quot;</span>, <span class="number">13</span>) ||</span><br><span class="line">          !<span class="built_in">strncmp</span>(line + <span class="number">2</span>, <span class="string">&quot;section\t__TEXT,__text&quot;</span>, <span class="number">21</span>) ||</span><br><span class="line">          !<span class="built_in">strncmp</span>(line + <span class="number">2</span>, <span class="string">&quot;section __TEXT,__text&quot;</span>, <span class="number">21</span>)) &#123;</span><br><span class="line">        instr_ok = <span class="number">1</span>;  <span class="comment">// 标记进入可插桩区域</span></span><br><span class="line">        <span class="keyword">continue</span>; </span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="comment">/* 检测非.text段（数据段/bss段） */</span></span><br><span class="line">      <span class="keyword">if</span> (!<span class="built_in">strncmp</span>(line + <span class="number">2</span>, <span class="string">&quot;section\t&quot;</span>, <span class="number">8</span>) ||</span><br><span class="line">          !<span class="built_in">strncmp</span>(line + <span class="number">2</span>, <span class="string">&quot;section &quot;</span>, <span class="number">8</span>) ||</span><br><span class="line">          !<span class="built_in">strncmp</span>(line + <span class="number">2</span>, <span class="string">&quot;bss\n&quot;</span>, <span class="number">4</span>) ||</span><br><span class="line">          !<span class="built_in">strncmp</span>(line + <span class="number">2</span>, <span class="string">&quot;data\n&quot;</span>, <span class="number">5</span>)) &#123;</span><br><span class="line">        instr_ok = <span class="number">0</span>;  <span class="comment">// 标记离开可插桩区域</span></span><br><span class="line">        <span class="keyword">continue</span>;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 检测处理器指令集切换（.code32/.code64） */</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">strstr</span>(line, <span class="string">&quot;.code&quot;</span>)) &#123;</span><br><span class="line">      <span class="keyword">if</span> (<span class="built_in">strstr</span>(line, <span class="string">&quot;.code32&quot;</span>)) skip_csect = use_64bit;   <span class="comment">// 64位模式跳过32位代码</span></span><br><span class="line">      <span class="keyword">if</span> (<span class="built_in">strstr</span>(line, <span class="string">&quot;.code64&quot;</span>)) skip_csect = !use_64bit;  <span class="comment">// 32位模式跳过64位代码</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 检测汇编语法切换（AT&amp;T/Intel） */</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">strstr</span>(line, <span class="string">&quot;.intel_syntax&quot;</span>)) skip_intel = <span class="number">1</span>;  <span class="comment">// 跳过Intel语法块</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">strstr</span>(line, <span class="string">&quot;.att_syntax&quot;</span>)) skip_intel = <span class="number">0</span>;    <span class="comment">// 返回AT&amp;T语法</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 检测内联汇编块（#APP/#NO_APP） */</span></span><br><span class="line">    <span class="keyword">if</span> (line[<span class="number">0</span>] == <span class="string">&#x27;#&#x27;</span> || line[<span class="number">1</span>] == <span class="string">&#x27;#&#x27;</span>) &#123;</span><br><span class="line">      <span class="keyword">if</span> (<span class="built_in">strstr</span>(line, <span class="string">&quot;#APP&quot;</span>)) skip_app = <span class="number">1</span>;      <span class="comment">// 进入内联汇编块</span></span><br><span class="line">      <span class="keyword">if</span> (<span class="built_in">strstr</span>(line, <span class="string">&quot;#NO_APP&quot;</span>)) skip_app = <span class="number">0</span>;   <span class="comment">// 离开内联汇编块</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* </span></span><br><span class="line"><span class="comment">     * 插桩点检测：跳过以下情况：</span></span><br><span class="line"><span class="comment">     * 1. Intel语法块 2. 内联汇编块 3. 非.text段 4. 注释行</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">if</span> (skip_intel || skip_app || skip_csect || !instr_ok ||</span><br><span class="line">        line[<span class="number">0</span>] == <span class="string">&#x27;#&#x27;</span> || line[<span class="number">0</span>] == <span class="string">&#x27; &#x27;</span>) <span class="keyword">continue</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 条件分支指令检测（如jnz/jbe等） */</span></span><br><span class="line">    <span class="keyword">if</span> (line[<span class="number">0</span>] == <span class="string">&#x27;\t&#x27;</span>) &#123;</span><br><span class="line">      <span class="comment">/* 检测条件跳转（非jmp指令） */</span></span><br><span class="line">      <span class="keyword">if</span> (line[<span class="number">1</span>] == <span class="string">&#x27;j&#x27;</span> &amp;&amp; line[<span class="number">2</span>] != <span class="string">&#x27;m&#x27;</span> &amp;&amp; R(<span class="number">100</span>) &lt; inst_ratio) &#123;</span><br><span class="line">        <span class="comment">/* 插入桩代码 */</span></span><br><span class="line">        <span class="built_in">fprintf</span>(outf, use_64bit ? trampoline_fmt_64 : trampoline_fmt_32,</span><br><span class="line">                R(MAP_SIZE));</span><br><span class="line">        ins_lines++;  <span class="comment">// 增加插桩计数</span></span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">continue</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 标签处理（函数入口/分支标签） */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> __APPLE__</span></span><br><span class="line">    <span class="comment">/* macOS标签格式：L&lt;label&gt;: */</span></span><br><span class="line">    <span class="keyword">if</span> ((colon_pos = <span class="built_in">strstr</span>(line, <span class="string">&quot;:&quot;</span>))) &#123;</span><br><span class="line">      <span class="keyword">if</span> (line[<span class="number">0</span>] == <span class="string">&#x27;L&#x27;</span> &amp;&amp; <span class="built_in">isdigit</span>(*(colon_pos - <span class="number">1</span>))) &#123;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">else</span></span></span><br><span class="line">    <span class="comment">/* 标准标签格式：.L&lt;label&gt;: */</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">strstr</span>(line, <span class="string">&quot;:&quot;</span>)) &#123;</span><br><span class="line">      <span class="keyword">if</span> (line[<span class="number">0</span>] == <span class="string">&#x27;.&#x27;</span>) &#123;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span> <span class="comment">/* __APPLE__ */</span></span></span><br><span class="line">        <span class="comment">/* 分支目标标签处理（如.L0:/LBB0_0:） */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> __APPLE__</span></span><br><span class="line">        <span class="comment">/* macOS分支标签：L&lt;num&gt; 或 LBB&lt;num&gt; */</span></span><br><span class="line">        <span class="keyword">if</span> ((<span class="built_in">isdigit</span>(line[<span class="number">1</span>]) || (clang_mode &amp;&amp; !<span class="built_in">strncmp</span>(line, <span class="string">&quot;LBB&quot;</span>, <span class="number">3</span>)))</span><br><span class="line">            &amp;&amp; R(<span class="number">100</span>) &lt; inst_ratio) &#123;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">else</span></span></span><br><span class="line">        <span class="comment">/* 标准分支标签：.L&lt;num&gt; 或 .LBB&lt;num&gt; */</span></span><br><span class="line">        <span class="keyword">if</span> ((<span class="built_in">isdigit</span>(line[<span class="number">2</span>]) || (clang_mode &amp;&amp; !<span class="built_in">strncmp</span>(line + <span class="number">1</span>, <span class="string">&quot;LBB&quot;</span>, <span class="number">3</span>)))</span><br><span class="line">            &amp;&amp; R(<span class="number">100</span>) &lt; inst_ratio) &#123;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span> <span class="comment">/* __APPLE__ */</span></span></span><br><span class="line">          <span class="comment">/* 设置延迟插桩标志（避免破坏异常处理） */</span></span><br><span class="line">          <span class="keyword">if</span> (!skip_next_label) instrument_next = <span class="number">1</span>; </span><br><span class="line">          <span class="keyword">else</span> skip_next_label = <span class="number">0</span>;  <span class="comment">// 重置OpenBSD跳转表标志</span></span><br><span class="line">        &#125;</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">/* 函数入口标签（始终插桩） */</span></span><br><span class="line">        instrument_next = <span class="number">1</span>;  <span class="comment">// 标记下一个标签需要插桩</span></span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;  <span class="comment">// 结束文件遍历</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">/* 插入主插桩逻辑（覆盖率跟踪等） */</span></span><br><span class="line">  <span class="keyword">if</span> (ins_lines)</span><br><span class="line">    <span class="built_in">fputs</span>(use_64bit ? main_payload_64 : main_payload_32, outf);</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* 清理资源：关闭文件 */</span></span><br><span class="line">  <span class="keyword">if</span> (input_file) fclose(inf);</span><br><span class="line">  fclose(outf);</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* 输出插桩统计信息 */</span></span><br><span class="line">  <span class="keyword">if</span> (!be_quiet) &#123;</span><br><span class="line">    <span class="keyword">if</span> (!ins_lines) WARNF(<span class="string">&quot;No instrumentation targets found%s.&quot;</span>,</span><br><span class="line">                          pass_thru ? <span class="string">&quot; (pass-thru mode)&quot;</span> : <span class="string">&quot;&quot;</span>);</span><br><span class="line">    <span class="keyword">else</span> OKF(<span class="string">&quot;Instrumented %u locations (%s-bit, %s mode, ratio %u%%).&quot;</span>,</span><br><span class="line">             ins_lines, use_64bit ? <span class="string">&quot;64&quot;</span> : <span class="string">&quot;32&quot;</span>,</span><br><span class="line">             getenv(<span class="string">&quot;AFL_HARDEN&quot;</span>) ? <span class="string">&quot;hardened&quot;</span> : </span><br><span class="line">             (sanitizer ? <span class="string">&quot;ASAN/MSAN&quot;</span> : <span class="string">&quot;non-hardened&quot;</span>),</span><br><span class="line">             inst_ratio);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span>** argv)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  s32 pid;               <span class="comment">// 子进程ID</span></span><br><span class="line">  u32 rand_seed;         <span class="comment">// 随机数种子</span></span><br><span class="line">  <span class="keyword">int</span> status;            <span class="comment">// 子进程退出状态</span></span><br><span class="line">  u8* inst_ratio_str = getenv(<span class="string">&quot;AFL_INST_RATIO&quot;</span>);  <span class="comment">// 获取环境变量中的插桩比例</span></span><br><span class="line"></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">timeval</span> <span class="title">tv</span>;</span>     <span class="comment">// 时间结构（用于生成随机种子）</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">timezone</span> <span class="title">tz</span>;</span></span><br><span class="line"></span><br><span class="line">  clang_mode = !!getenv(CLANG_ENV_VAR);  <span class="comment">// 检测是否在Clang模式下运行</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">/* 初始化输出设置 */</span></span><br><span class="line">  <span class="keyword">if</span> (isatty(<span class="number">2</span>) &amp;&amp; !getenv(<span class="string">&quot;AFL_QUIET&quot;</span>)) &#123;  <span class="comment">// 如果标准错误是终端且未设置静默模式</span></span><br><span class="line">    SAYF(cCYA <span class="string">&quot;afl-as &quot;</span> cBRI VERSION cRST <span class="string">&quot; by &lt;lcamtuf@google.com&gt;\n&quot;</span>);  <span class="comment">// 显示版本信息</span></span><br><span class="line">  &#125; <span class="keyword">else</span> be_quiet = <span class="number">1</span>;  <span class="comment">// 否则设置为静默模式</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">/* 参数检查：必须至少有一个参数（输入文件） */</span></span><br><span class="line">  <span class="keyword">if</span> (argc &lt; <span class="number">2</span>) &#123;</span><br><span class="line">    <span class="comment">// 显示使用说明（用户直接运行时）</span></span><br><span class="line">    SAYF(<span class="string">&quot;\n&quot;</span></span><br><span class="line">         <span class="string">&quot;This is a helper application for afl-fuzz. It is a wrapper around GNU &#x27;as&#x27;,\n&quot;</span></span><br><span class="line">         <span class="string">&quot;executed by the toolchain whenever using afl-gcc or afl-clang. You probably\n&quot;</span></span><br><span class="line">         <span class="string">&quot;don&#x27;t want to run this program directly.\n\n&quot;</span></span><br><span class="line">         <span class="string">&quot;Rarely, when dealing with extremely complex projects, it may be advisable to\n&quot;</span></span><br><span class="line">         <span class="string">&quot;set AFL_INST_RATIO to a value less than 100 in order to reduce the odds of\n&quot;</span></span><br><span class="line">         <span class="string">&quot;instrumenting every discovered branch.\n\n&quot;</span>);</span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* 生成随机数种子 */</span></span><br><span class="line">  gettimeofday(&amp;tv, &amp;tz);  <span class="comment">// 获取当前时间</span></span><br><span class="line">  rand_seed = tv.tv_sec ^ tv.tv_usec ^ getpid();  <span class="comment">// 混合时间戳和进程ID</span></span><br><span class="line">  srandom(rand_seed);      <span class="comment">// 初始化随机数生成器</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">/* 处理编译参数 */</span></span><br><span class="line">  edit_params(argc, argv);  <span class="comment">// 修改as的参数并设置输入/输出文件路径</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">/* 处理插桩比例设置 */</span></span><br><span class="line">  <span class="keyword">if</span> (inst_ratio_str) &#123;  <span class="comment">// 如果设置了AFL_INST_RATIO环境变量</span></span><br><span class="line">    <span class="comment">// 解析并验证插桩比例（0-100）</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">sscanf</span>(inst_ratio_str, <span class="string">&quot;%u&quot;</span>, &amp;inst_ratio) != <span class="number">1</span> || inst_ratio &gt; <span class="number">100</span>) </span><br><span class="line">      FATAL(<span class="string">&quot;Bad value of AFL_INST_RATIO (must be between 0 and 100)&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* 安全检查：防止无限递归调用 */</span></span><br><span class="line">  <span class="keyword">if</span> (getenv(AS_LOOP_ENV_VAR))  <span class="comment">// 如果检测到循环调用标志</span></span><br><span class="line">    FATAL(<span class="string">&quot;Endless loop when calling &#x27;as&#x27; (remove &#x27;.&#x27; from your PATH)&quot;</span>);</span><br><span class="line">  setenv(AS_LOOP_ENV_VAR, <span class="string">&quot;1&quot;</span>, <span class="number">1</span>);  <span class="comment">// 设置标志防止递归</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">/* 处理ASAN/MSAN模式 */</span></span><br><span class="line">  <span class="keyword">if</span> (getenv(<span class="string">&quot;AFL_USE_ASAN&quot;</span>) || getenv(<span class="string">&quot;AFL_USE_MSAN&quot;</span>)) &#123;</span><br><span class="line">    sanitizer = <span class="number">1</span>;         <span class="comment">// 标记为sanitizer模式</span></span><br><span class="line">    inst_ratio /= <span class="number">3</span>;       <span class="comment">// 降低插桩密度（减少冲突）</span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* 核心插桩逻辑 */</span></span><br><span class="line">  <span class="keyword">if</span> (!just_version) add_instrumentation();  <span class="comment">// 如果不是仅显示版本，执行插桩</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">/* 创建子进程调用真正的汇编器 */</span></span><br><span class="line">  <span class="keyword">if</span> (!(pid = fork())) &#123;  <span class="comment">// 子进程分支</span></span><br><span class="line">    <span class="comment">// 执行GNU as汇编器（使用修改后的参数）</span></span><br><span class="line">    execvp(as_params[<span class="number">0</span>], (<span class="keyword">char</span>**)as_params);</span><br><span class="line">    FATAL(<span class="string">&quot;Oops, failed to execute &#x27;%s&#x27; - check your PATH&quot;</span>, as_params[<span class="number">0</span>]);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* 父进程处理 */</span></span><br><span class="line">  <span class="keyword">if</span> (pid &lt; <span class="number">0</span>) PFATAL(<span class="string">&quot;fork() failed&quot;</span>);  <span class="comment">// 检查fork是否成功</span></span><br><span class="line">  <span class="keyword">if</span> (waitpid(pid, &amp;status, <span class="number">0</span>) &lt;= <span class="number">0</span>) PFATAL(<span class="string">&quot;waitpid() failed&quot;</span>);  <span class="comment">// 等待子进程结束</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">/* 清理临时文件 */</span></span><br><span class="line">  <span class="keyword">if</span> (!getenv(<span class="string">&quot;AFL_KEEP_ASSEMBLY&quot;</span>)) unlink(modified_file);  <span class="comment">// 除非要求保留，否则删除临时文件</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">/* 退出并传递汇编器的退出状态 */</span></span><br><span class="line">  <span class="built_in">exit</span>(WEXITSTATUS(status));  <span class="comment">// 确保返回码与as一致</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里我们先梳理一下代码里几个不能完全写在注释里的点</p>
<h3 id="trampoline-fmt-32与trampoline-fmt-64"><a href="#trampoline-fmt-32与trampoline-fmt-64" class="headerlink" title="trampoline_fmt_32与trampoline_fmt_64"></a>trampoline_fmt_32与trampoline_fmt_64</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">const</span> u8* trampoline_fmt_32 =</span><br><span class="line"></span><br><span class="line">  <span class="string">&quot;\n&quot;</span></span><br><span class="line">  <span class="string">&quot;/* --- AFL TRAMPOLINE (32-BIT) --- */\n&quot;</span></span><br><span class="line">  <span class="string">&quot;\n&quot;</span></span><br><span class="line">  <span class="string">&quot;.align 4\n&quot;</span></span><br><span class="line">  <span class="string">&quot;\n&quot;</span></span><br><span class="line">  <span class="string">&quot;leal -16(%%esp), %%esp\n&quot;</span></span><br><span class="line">  <span class="string">&quot;movl %%edi,  0(%%esp)\n&quot;</span></span><br><span class="line">  <span class="string">&quot;movl %%edx,  4(%%esp)\n&quot;</span></span><br><span class="line">  <span class="string">&quot;movl %%ecx,  8(%%esp)\n&quot;</span></span><br><span class="line">  <span class="string">&quot;movl %%eax, 12(%%esp)\n&quot;</span></span><br><span class="line">  <span class="string">&quot;movl $0x%08x, %%ecx\n&quot;</span></span><br><span class="line">  <span class="string">&quot;call __afl_maybe_log\n&quot;</span></span><br><span class="line">  <span class="string">&quot;movl 12(%%esp), %%eax\n&quot;</span></span><br><span class="line">  <span class="string">&quot;movl  8(%%esp), %%ecx\n&quot;</span></span><br><span class="line">  <span class="string">&quot;movl  4(%%esp), %%edx\n&quot;</span></span><br><span class="line">  <span class="string">&quot;movl  0(%%esp), %%edi\n&quot;</span></span><br><span class="line">  <span class="string">&quot;leal 16(%%esp), %%esp\n&quot;</span></span><br><span class="line">  <span class="string">&quot;\n&quot;</span></span><br><span class="line">  <span class="string">&quot;/* --- END --- */\n&quot;</span></span><br><span class="line">  <span class="string">&quot;\n&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">const</span> u8* trampoline_fmt_64 =</span><br><span class="line"></span><br><span class="line">  <span class="string">&quot;\n&quot;</span></span><br><span class="line">  <span class="string">&quot;/* --- AFL TRAMPOLINE (64-BIT) --- */\n&quot;</span></span><br><span class="line">  <span class="string">&quot;\n&quot;</span></span><br><span class="line">  <span class="string">&quot;.align 4\n&quot;</span></span><br><span class="line">  <span class="string">&quot;\n&quot;</span></span><br><span class="line">  <span class="string">&quot;leaq -(128+24)(%%rsp), %%rsp\n&quot;</span></span><br><span class="line">  <span class="string">&quot;movq %%rdx,  0(%%rsp)\n&quot;</span></span><br><span class="line">  <span class="string">&quot;movq %%rcx,  8(%%rsp)\n&quot;</span></span><br><span class="line">  <span class="string">&quot;movq %%rax, 16(%%rsp)\n&quot;</span></span><br><span class="line">  <span class="string">&quot;movq $0x%08x, %%rcx\n&quot;</span></span><br><span class="line">  <span class="string">&quot;call __afl_maybe_log\n&quot;</span></span><br><span class="line">  <span class="string">&quot;movq 16(%%rsp), %%rax\n&quot;</span></span><br><span class="line">  <span class="string">&quot;movq  8(%%rsp), %%rcx\n&quot;</span></span><br><span class="line">  <span class="string">&quot;movq  0(%%rsp), %%rdx\n&quot;</span></span><br><span class="line">  <span class="string">&quot;leaq (128+24)(%%rsp), %%rsp\n&quot;</span></span><br><span class="line">  <span class="string">&quot;\n&quot;</span></span><br><span class="line">  <span class="string">&quot;/* --- END --- */\n&quot;</span></span><br><span class="line">  <span class="string">&quot;\n&quot;</span>;</span><br></pre></td></tr></table></figure>

<p>从上面的代码中我们可以知道trampoline_fmt_32和trampoline_fmt_64是被加入到由编译器生成的.s文件中</p>
<h3 id="OpenBSD"><a href="#OpenBSD" class="headerlink" title="OpenBSD"></a>OpenBSD</h3><p>OpenBSD跳转表是OpenBSD系统中使用gcc或者clang编译得到的，遇到OpenBSD跳转表后的跳过逻辑我举个例子看看</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">	.text</span><br><span class="line">	.globl	check_value</span><br><span class="line">check_value:</span><br><span class="line">	pushq	%rbp</span><br><span class="line">	.p2align 4,,10   # ← AFL 检测点 (设置 skip_next_label=1)</span><br><span class="line">	.p2align 3</span><br><span class="line">.L4:                # ← 跳转表标签 (被跳过)</span><br><span class="line">	.long	.L3-.L4</span><br><span class="line">.L3:                # ← 正常标签 (会插桩)</span><br><span class="line">	movl	$10, %eax</span><br></pre></td></tr></table></figure>

<p>会跳过遇到OpenBSD后的第一个标签，也就是上面的.L4</p>
<h3 id="add-instrumentation的逻辑"><a href="#add-instrumentation的逻辑" class="headerlink" title="add_instrumentation的逻辑"></a>add_instrumentation的逻辑</h3><p>add_instrumentation是afl-as的核心代码，这里介绍一下其核心逻辑</p>
<h4 id="一、整体处理流程"><a href="#一、整体处理流程" class="headerlink" title="一、整体处理流程"></a><strong>一、整体处理流程</strong></h4><ol>
<li><strong>逐行扫描</strong>：<br>按顺序读取汇编文件每一行，同时生成插桩后的新文件。</li>
<li><strong>双阶段处理</strong>：<ul>
<li><strong>延迟插桩</strong>：标记关键位置，在后续实际指令前插入</li>
<li><strong>立即插桩</strong>：遇到特定指令时直接插入</li>
</ul>
</li>
<li><strong>状态机驱动</strong>：<br>通过多个状态标志动态控制插桩行为：<ul>
<li><code>instr_ok</code>：是否在可插桩的代码段（.text）</li>
<li><code>skip_*</code>：跳过特殊区域（Intel语法/内联汇编等）</li>
<li><code>instrument_next</code>：延迟插桩标记</li>
</ul>
</li>
</ol>
<h4 id="二、关键插桩位置"><a href="#二、关键插桩位置" class="headerlink" title="二、关键插桩位置"></a><strong>二、关键插桩位置</strong></h4><ol>
<li><strong>函数入口点</strong></li>
</ol>
<ul>
<li><strong>识别特征</strong>：<br>非局部标签（如 <code>main:</code>，无前导<code>.</code>或<code>L</code>）</li>
<li><strong>插桩方式</strong>：<br>在函数标签后的<strong>第一条指令前</strong>插入跟踪代码</li>
<li><strong>目的</strong>：<br>记录函数调用事件</li>
</ul>
<ol start="2">
<li><strong>条件分支</strong></li>
</ol>
<ul>
<li><strong>识别特征</strong>：<br>条件跳转指令（<code>j</code>开头非<code>jmp</code>，如 <code>jnz</code>, <code>je</code>）</li>
<li><strong>插桩方式</strong>：<br><strong>紧跟指令后</strong>立即插入</li>
<li><strong>目的</strong>：<br>捕获分支未执行路径（not-taken path）</li>
</ul>
<ol start="3">
<li><strong>分支目标</strong></li>
</ol>
<ul>
<li><strong>识别特征</strong>：<br>编译器生成的局部标签（<code>.L0:</code>, <code>.LBB0_0:</code>）</li>
<li><strong>插桩方式</strong>：<br>在标签后的<strong>第一条指令前</strong>插入</li>
<li><strong>目的</strong>：<br>记录分支目标执行情况</li>
</ul>
<h4 id="三、跳过机制"><a href="#三、跳过机制" class="headerlink" title="三、跳过机制"></a><strong>三、跳过机制</strong></h4><ol>
<li><strong>代码段过滤</strong></li>
</ol>
<ul>
<li><strong>只插桩</strong>：<br><code>.text</code> 代码段（通过 <code>.section</code> 指令识别）</li>
<li><strong>跳过</strong>：<br><code>.data</code>/<code>.bss</code> 数据段及其他非代码段</li>
</ul>
<ol start="2">
<li><strong>语法块跳过</strong></li>
</ol>
<ul>
<li><strong>Intel语法块</strong>：<br>检测 <code>.intel_syntax</code> 指令，跳过整个语法块</li>
<li><strong>内联汇编块</strong>：<br>跳过 <code>#APP</code> 和 <code>#NO_APP</code> 之间的代码</li>
</ul>
<ol start="3">
<li><strong>平台特殊处理</strong></li>
</ol>
<ul>
<li><strong>OpenBSD跳转表</strong>：<ol>
<li>检测 <code>.p2align</code> 指令序列（特征标记）</li>
<li>跳过后续第一个标签的插桩</li>
<li>避免破坏跳转表偏移计算</li>
</ol>
</li>
<li><strong>macOS标签差异</strong>：<br>处理无前导点<code>.</code>的标签格式（如 <code>L0:</code> vs <code>.L0:</code>）</li>
</ul>
<p>这里再用图总结一下add_instrumentation的逻辑</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">graph LR</span><br><span class="line">    A[开始扫描] --&gt; B&#123;行类型判断&#125;</span><br><span class="line">    B --&gt;|普通指令| C[保持原样输出]</span><br><span class="line">    B --&gt;|段指令| D[更新段状态]</span><br><span class="line">    B --&gt;|标签| E&#123;标签类型&#125;</span><br><span class="line">    E --&gt;|函数入口| F[标记延迟插桩]</span><br><span class="line">    E --&gt;|分支目标| G[按规则标记]</span><br><span class="line">    E --&gt;|特殊标签| H[跳过处理]</span><br><span class="line">    B --&gt;|条件跳转| I[立即插桩]</span><br><span class="line">    B --&gt;|对齐指令| J[检测跳转表]</span><br><span class="line">    J --&gt; K[设置标签跳过]</span><br><span class="line">    F --&gt; L[后续指令前插桩]</span><br><span class="line">    G --&gt; L</span><br><span class="line">    I --&gt; M[直接输出桩代码]</span><br><span class="line">    L --&gt; N[输出桩代码]</span><br><span class="line">    C --&gt; O[写输出文件]</span><br><span class="line">    N --&gt; O</span><br><span class="line">    O --&gt; P&#123;文件结束？&#125;</span><br><span class="line">    P --&gt;|否| A</span><br><span class="line">    P --&gt;|是| Q[注入主桩代码]</span><br><span class="line">    Q --&gt; R[输出统计]</span><br></pre></td></tr></table></figure>

<h2 id="afl-fast-clang"><a href="#afl-fast-clang" class="headerlink" title="afl-fast-clang"></a>afl-fast-clang</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">  Copyright 2015 Google LLC All rights reserved.</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">  Licensed under the Apache License, Version 2.0 (the &quot;License&quot;);</span></span><br><span class="line"><span class="comment">  you may not use this file except in compliance with the License.</span></span><br><span class="line"><span class="comment">  You may obtain a copy of the License at:</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    http://www.apache.org/licenses/LICENSE-2.0</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">  Unless required by applicable law or agreed to in writing, software</span></span><br><span class="line"><span class="comment">  distributed under the License is distributed on an &quot;AS IS&quot; BASIS,</span></span><br><span class="line"><span class="comment">  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.</span></span><br><span class="line"><span class="comment">  See the License for the specific language governing permissions and</span></span><br><span class="line"><span class="comment">  limitations under the License.</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">   american fuzzy lop - LLVM-mode wrapper for clang</span></span><br><span class="line"><span class="comment">   ------------------------------------------------</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">   Written by Laszlo Szekeres &lt;lszekeres@google.com&gt; and</span></span><br><span class="line"><span class="comment">              Michal Zalewski &lt;lcamtuf@google.com&gt;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">   LLVM integration design comes from Laszlo Szekeres.</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">   This program is a drop-in replacement for clang, similar in most respects</span></span><br><span class="line"><span class="comment">   to ../afl-gcc. It tries to figure out compilation mode, adds a bunch</span></span><br><span class="line"><span class="comment">   of flags, and then calls the real compiler.</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> AFL_MAIN</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;../config.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;../types.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;../debug.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;../alloc-inl.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> u8*  obj_path;               <span class="comment">/* Path to runtime libraries         */</span></span><br><span class="line"><span class="keyword">static</span> u8** cc_params;              <span class="comment">/* Parameters passed to the real CC  */</span></span><br><span class="line"><span class="keyword">static</span> u32  cc_par_cnt = <span class="number">1</span>;         <span class="comment">/* Param count, including argv0      */</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/* Try to find the runtime libraries. If that fails, abort. */</span></span><br><span class="line"><span class="comment">/* 查找 AFL 运行时对象文件 afl-llvm-rt.o 的路径 */</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">find_obj</span><span class="params">(u8* argv0)</span> </span>&#123;</span><br><span class="line">  </span><br><span class="line">  u8 *afl_path = <span class="built_in">getenv</span>(<span class="string">&quot;AFL_PATH&quot;</span>);<span class="comment">// 尝试从环境变量 AFL_PATH 获取路径</span></span><br><span class="line">  u8 *slash, *tmp;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (afl_path) &#123;</span><br><span class="line">    <span class="comment">// 拼接完整路径: AFL_PATH + &quot;/afl-llvm-rt.o&quot;</span></span><br><span class="line">    tmp = <span class="built_in">alloc_printf</span>(<span class="string">&quot;%s/afl-llvm-rt.o&quot;</span>, afl_path);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!<span class="built_in">access</span>(tmp, R_OK)) &#123;</span><br><span class="line">      obj_path = afl_path;<span class="comment">// 验证成功，保存路径</span></span><br><span class="line">      <span class="built_in">ck_free</span>(tmp);<span class="comment">// 释放临时字符串</span></span><br><span class="line">      <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">ck_free</span>(tmp);<span class="comment">// 文件不可读，释放临时字符串</span></span><br><span class="line"></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 尝试从 argv0 (当前可执行文件路径) 获取目录</span></span><br><span class="line">  slash = <span class="built_in">strrchr</span>(argv0, <span class="string">&#x27;/&#x27;</span>);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (slash) &#123;</span><br><span class="line"></span><br><span class="line">    u8 *dir;</span><br><span class="line"></span><br><span class="line">    *slash = <span class="number">0</span>;<span class="comment">// 临时截断字符串获取目录</span></span><br><span class="line">    dir = <span class="built_in">ck_strdup</span>(argv0);<span class="comment">// 复制目录字符串</span></span><br><span class="line">    *slash = <span class="string">&#x27;/&#x27;</span>;<span class="comment">// 恢复原始路径</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 拼接路径: 当前目录 + &quot;/afl-llvm-rt.o&quot;</span></span><br><span class="line">    tmp = <span class="built_in">alloc_printf</span>(<span class="string">&quot;%s/afl-llvm-rt.o&quot;</span>, dir);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!<span class="built_in">access</span>(tmp, R_OK)) &#123;</span><br><span class="line">      obj_path = dir;           <span class="comment">// 验证成功，保存路径</span></span><br><span class="line">      <span class="built_in">ck_free</span>(tmp);         <span class="comment">// 释放临时字符串</span></span><br><span class="line">      <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 清理资源</span></span><br><span class="line">    <span class="built_in">ck_free</span>(tmp);</span><br><span class="line">    <span class="built_in">ck_free</span>(dir);</span><br><span class="line"></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (!<span class="built_in">access</span>(AFL_PATH <span class="string">&quot;/afl-llvm-rt.o&quot;</span>, R_OK)) &#123;</span><br><span class="line">    obj_path = AFL_PATH;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 所有尝试均失败，报错退出</span></span><br><span class="line">  <span class="built_in">FATAL</span>(<span class="string">&quot;Unable to find &#x27;afl-llvm-rt.o&#x27; or &#x27;afl-llvm-pass.so&#x27;. Please set AFL_PATH&quot;</span>);</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/* Copy argv to cc_params, making the necessary edits. */</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">edit_params</span><span class="params">(u32 argc, <span class="keyword">char</span>** argv)</span> </span>&#123;</span><br><span class="line">  <span class="comment">// 标志变量初始化</span></span><br><span class="line">  u8 fortify_set = <span class="number">0</span>, asan_set = <span class="number">0</span>, x_set = <span class="number">0</span>, bit_mode = <span class="number">0</span>;</span><br><span class="line">  u8 *name;</span><br><span class="line">  <span class="comment">// 分配参数数组 (原始参数 + 128个额外参数空间)</span></span><br><span class="line">  cc_params = <span class="built_in">ck_alloc</span>((argc + <span class="number">128</span>) * <span class="built_in"><span class="keyword">sizeof</span></span>(u8*));</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 从argv[0]提取程序名 (不含路径)</span></span><br><span class="line">  name = <span class="built_in">strrchr</span>(argv[<span class="number">0</span>], <span class="string">&#x27;/&#x27;</span>);</span><br><span class="line">  <span class="keyword">if</span> (!name) name = argv[<span class="number">0</span>]; <span class="keyword">else</span> name++;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (!<span class="built_in">strcmp</span>(name, <span class="string">&quot;afl-clang-fast++&quot;</span>)) &#123;</span><br><span class="line">    <span class="comment">// C++: 优先使用AFL_CXX环境变量，否则默认clang++</span></span><br><span class="line">    u8* alt_cxx = <span class="built_in">getenv</span>(<span class="string">&quot;AFL_CXX&quot;</span>);</span><br><span class="line">    cc_params[<span class="number">0</span>] = alt_cxx ? alt_cxx : (u8*)<span class="string">&quot;clang++&quot;</span>;</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="comment">// C: 优先使用AFL_CC环境变量，否则默认clang</span></span><br><span class="line">    u8* alt_cc = <span class="built_in">getenv</span>(<span class="string">&quot;AFL_CC&quot;</span>);</span><br><span class="line">    cc_params[<span class="number">0</span>] = alt_cc ? alt_cc : (u8*)<span class="string">&quot;clang&quot;</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* There are two ways to compile afl-clang-fast. In the traditional mode, we</span></span><br><span class="line"><span class="comment">     use afl-llvm-pass.so to inject instrumentation. In the experimental</span></span><br><span class="line"><span class="comment">     &#x27;trace-pc-guard&#x27; mode, we use native LLVM instrumentation callbacks</span></span><br><span class="line"><span class="comment">     instead. The latter is a very recent addition - see:</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">     http://clang.llvm.org/docs/SanitizerCoverage.html#tracing-pcs-with-guards */</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 根据编译配置选择插桩模式</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> USE_TRACE_PC</span></span><br><span class="line">  cc_params[cc_par_cnt++] = <span class="string">&quot;-fsanitize-coverage=trace-pc-guard&quot;</span>;</span><br><span class="line"><span class="comment">//#ifndef __ANDROID__</span></span><br><span class="line"><span class="comment">//  cc_params[cc_par_cnt++] = &quot;-mllvm&quot;;</span></span><br><span class="line"><span class="comment">//  cc_params[cc_par_cnt++] = &quot;-sanitizer-coverage-block-threshold=0&quot;;</span></span><br><span class="line"><span class="comment">//#endif</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">else</span></span></span><br><span class="line">  <span class="comment">// 传统LLVM pass模式</span></span><br><span class="line">  cc_params[cc_par_cnt++] = <span class="string">&quot;-Xclang&quot;</span>; <span class="comment">// 向clang前端传递参数</span></span><br><span class="line">  cc_params[cc_par_cnt++] = <span class="string">&quot;-load&quot;</span>; <span class="comment">// 加载LLVM插件</span></span><br><span class="line">  cc_params[cc_par_cnt++] = <span class="string">&quot;-Xclang&quot;</span>;</span><br><span class="line">  cc_params[cc_par_cnt++] = <span class="built_in">alloc_printf</span>(<span class="string">&quot;%s/afl-llvm-pass.so&quot;</span>, obj_path);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span> <span class="comment">/* ^USE_TRACE_PC */</span></span></span><br><span class="line"></span><br><span class="line">  cc_params[cc_par_cnt++] = <span class="string">&quot;-Qunused-arguments&quot;</span>;<span class="comment">// 忽略未使用的命令行参数 (避免clang警告)</span></span><br><span class="line"></span><br><span class="line">   <span class="comment">// 遍历原始参数 (跳过程序名)</span></span><br><span class="line">  <span class="keyword">while</span> (--argc) &#123;</span><br><span class="line">    u8* cur = *(++argv);</span><br><span class="line">    <span class="comment">// 检测架构/位宽设置</span></span><br><span class="line">    <span class="keyword">if</span> (!<span class="built_in">strcmp</span>(cur, <span class="string">&quot;-m32&quot;</span>)) bit_mode = <span class="number">32</span>;</span><br><span class="line">    <span class="keyword">if</span> (!<span class="built_in">strcmp</span>(cur, <span class="string">&quot;armv7a-linux-androideabi&quot;</span>)) bit_mode = <span class="number">32</span>;</span><br><span class="line">    <span class="keyword">if</span> (!<span class="built_in">strcmp</span>(cur, <span class="string">&quot;-m64&quot;</span>)) bit_mode = <span class="number">64</span>;</span><br><span class="line">    <span class="comment">// 检测语言指定标记 (-x)</span></span><br><span class="line">    <span class="keyword">if</span> (!<span class="built_in">strcmp</span>(cur, <span class="string">&quot;-x&quot;</span>)) x_set = <span class="number">1</span>;</span><br><span class="line">    <span class="comment">// 检测ASAN/MSAN是否已启用</span></span><br><span class="line">    <span class="keyword">if</span> (!<span class="built_in">strcmp</span>(cur, <span class="string">&quot;-fsanitize=address&quot;</span>) ||</span><br><span class="line">        !<span class="built_in">strcmp</span>(cur, <span class="string">&quot;-fsanitize=memory&quot;</span>)) asan_set = <span class="number">1</span>;</span><br><span class="line">    <span class="comment">// 检测FORTIFY_SOURCE是否设置</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">strstr</span>(cur, <span class="string">&quot;FORTIFY_SOURCE&quot;</span>)) fortify_set = <span class="number">1</span>;</span><br><span class="line">    <span class="comment">// 忽略可能导致链接问题的参数</span></span><br><span class="line">    <span class="keyword">if</span> (!<span class="built_in">strcmp</span>(cur, <span class="string">&quot;-Wl,-z,defs&quot;</span>) ||</span><br><span class="line">        !<span class="built_in">strcmp</span>(cur, <span class="string">&quot;-Wl,--no-undefined&quot;</span>)) <span class="keyword">continue</span>;</span><br><span class="line">    <span class="comment">// 保留其他参数</span></span><br><span class="line">    cc_params[cc_par_cnt++] = cur;</span><br><span class="line"></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// AFL_HARDEN 加固模式</span></span><br><span class="line">  <span class="keyword">if</span> (<span class="built_in">getenv</span>(<span class="string">&quot;AFL_HARDEN&quot;</span>)) &#123;</span><br><span class="line">    <span class="comment">// 启用全栈保护</span></span><br><span class="line">    cc_params[cc_par_cnt++] = <span class="string">&quot;-fstack-protector-all&quot;</span>;</span><br><span class="line">    <span class="comment">// 若未设置则添加 FORTIFY_SOURCE</span></span><br><span class="line">    <span class="keyword">if</span> (!fortify_set)</span><br><span class="line">      cc_params[cc_par_cnt++] = <span class="string">&quot;-D_FORTIFY_SOURCE=2&quot;</span>;</span><br><span class="line"></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (!asan_set) &#123;</span><br><span class="line">    <span class="comment">// ASAN (Address Sanitizer)</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">getenv</span>(<span class="string">&quot;AFL_USE_ASAN&quot;</span>)) &#123;</span><br><span class="line">      <span class="comment">// 冲突检测</span></span><br><span class="line">      <span class="keyword">if</span> (<span class="built_in">getenv</span>(<span class="string">&quot;AFL_USE_MSAN&quot;</span>))</span><br><span class="line">        <span class="built_in">FATAL</span>(<span class="string">&quot;ASAN and MSAN are mutually exclusive&quot;</span>);</span><br><span class="line"></span><br><span class="line">      <span class="keyword">if</span> (<span class="built_in">getenv</span>(<span class="string">&quot;AFL_HARDEN&quot;</span>))</span><br><span class="line">        <span class="built_in">FATAL</span>(<span class="string">&quot;ASAN and AFL_HARDEN are mutually exclusive&quot;</span>);</span><br><span class="line">       <span class="comment">// 设置ASAN参数</span></span><br><span class="line">      cc_params[cc_par_cnt++] = <span class="string">&quot;-U_FORTIFY_SOURCE&quot;</span>;</span><br><span class="line">      cc_params[cc_par_cnt++] = <span class="string">&quot;-fsanitize=address&quot;</span>;</span><br><span class="line"></span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="built_in">getenv</span>(<span class="string">&quot;AFL_USE_MSAN&quot;</span>)) &#123;<span class="comment">// MSAN (Memory Sanitizer)</span></span><br><span class="line">      <span class="comment">// 冲突检测</span></span><br><span class="line">      <span class="keyword">if</span> (<span class="built_in">getenv</span>(<span class="string">&quot;AFL_USE_ASAN&quot;</span>))</span><br><span class="line">        <span class="built_in">FATAL</span>(<span class="string">&quot;ASAN and MSAN are mutually exclusive&quot;</span>);</span><br><span class="line"></span><br><span class="line">      <span class="keyword">if</span> (<span class="built_in">getenv</span>(<span class="string">&quot;AFL_HARDEN&quot;</span>))</span><br><span class="line">        <span class="built_in">FATAL</span>(<span class="string">&quot;MSAN and AFL_HARDEN are mutually exclusive&quot;</span>);</span><br><span class="line">      <span class="comment">// 设置MSAN参数</span></span><br><span class="line">      cc_params[cc_par_cnt++] = <span class="string">&quot;-U_FORTIFY_SOURCE&quot;</span>;</span><br><span class="line">      cc_params[cc_par_cnt++] = <span class="string">&quot;-fsanitize=memory&quot;</span>;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">  &#125;</span><br><span class="line"><span class="comment">// trace-pc 模式特定检查</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> USE_TRACE_PC</span></span><br><span class="line">   <span class="comment">// 该模式下不支持插桩比例设置</span></span><br><span class="line">  <span class="keyword">if</span> (<span class="built_in">getenv</span>(<span class="string">&quot;AFL_INST_RATIO&quot;</span>))</span><br><span class="line">    <span class="built_in">FATAL</span>(<span class="string">&quot;AFL_INST_RATIO not available at compile time with &#x27;trace-pc&#x27;.&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span> <span class="comment">/* USE_TRACE_PC */</span></span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (!<span class="built_in">getenv</span>(<span class="string">&quot;AFL_DONT_OPTIMIZE&quot;</span>)) &#123;</span><br><span class="line">    <span class="comment">// 默认优化设置 (除非 AFL_DONT_OPTIMIZE 被设置)</span></span><br><span class="line">    cc_params[cc_par_cnt++] = <span class="string">&quot;-g&quot;</span>;</span><br><span class="line">    cc_params[cc_par_cnt++] = <span class="string">&quot;-O3&quot;</span>;</span><br><span class="line">    cc_params[cc_par_cnt++] = <span class="string">&quot;-funroll-loops&quot;</span>;</span><br><span class="line"></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (<span class="built_in">getenv</span>(<span class="string">&quot;AFL_NO_BUILTIN&quot;</span>)) &#123;</span><br><span class="line">    <span class="comment">// 禁用特定内置函数 (AFL_NO_BUILTIN)</span></span><br><span class="line">    cc_params[cc_par_cnt++] = <span class="string">&quot;-fno-builtin-strcmp&quot;</span>;</span><br><span class="line">    cc_params[cc_par_cnt++] = <span class="string">&quot;-fno-builtin-strncmp&quot;</span>;</span><br><span class="line">    cc_params[cc_par_cnt++] = <span class="string">&quot;-fno-builtin-strcasecmp&quot;</span>;</span><br><span class="line">    cc_params[cc_par_cnt++] = <span class="string">&quot;-fno-builtin-strncasecmp&quot;</span>;</span><br><span class="line">    cc_params[cc_par_cnt++] = <span class="string">&quot;-fno-builtin-memcmp&quot;</span>;</span><br><span class="line"></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// AFL 必要的预定义宏</span></span><br><span class="line">  cc_params[cc_par_cnt++] = <span class="string">&quot;-D__AFL_HAVE_MANUAL_CONTROL=1&quot;</span>;</span><br><span class="line">  cc_params[cc_par_cnt++] = <span class="string">&quot;-D__AFL_COMPILER=1&quot;</span>;</span><br><span class="line">  cc_params[cc_par_cnt++] = <span class="string">&quot;-DFUZZING_BUILD_MODE_UNSAFE_FOR_PRODUCTION=1&quot;</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* When the user tries to use persistent or deferred forkserver modes by</span></span><br><span class="line"><span class="comment">     appending a single line to the program, we want to reliably inject a</span></span><br><span class="line"><span class="comment">     signature into the binary (to be picked up by afl-fuzz) and we want</span></span><br><span class="line"><span class="comment">     to call a function from the runtime .o file. This is unnecessarily</span></span><br><span class="line"><span class="comment">     painful for three reasons:</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">     1) We need to convince the compiler not to optimize out the signature.</span></span><br><span class="line"><span class="comment">        This is done with __attribute__((used)).</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">     2) We need to convince the linker, when called with -Wl,--gc-sections,</span></span><br><span class="line"><span class="comment">        not to do the same. This is done by forcing an assignment to a</span></span><br><span class="line"><span class="comment">        &#x27;volatile&#x27; pointer.</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">     3) We need to declare __afl_persistent_loop() in the global namespace,</span></span><br><span class="line"><span class="comment">        but doing this within a method in a class is hard - :: and extern &quot;C&quot;</span></span><br><span class="line"><span class="comment">        are forbidden and __attribute__((alias(...))) doesn&#x27;t work. Hence the</span></span><br><span class="line"><span class="comment">        __asm__ aliasing trick.</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line"><span class="comment">/* 持久模式循环宏 (__AFL_LOOP) 实现技巧：</span></span><br><span class="line"><span class="comment">     1. 使用 __attribute__((used)) 防止优化移除</span></span><br><span class="line"><span class="comment">     2. 使用 volatile 指针防止链接器GC</span></span><br><span class="line"><span class="comment">     3. 使用 __asm__ 别名解决命名空间问题 */</span></span><br><span class="line">  cc_params[cc_par_cnt++] = <span class="string">&quot;-D__AFL_LOOP(_A)=&quot;</span></span><br><span class="line">    <span class="string">&quot;(&#123; static volatile char *_B __attribute__((used)); &quot;</span><span class="comment">// volatile防优化</span></span><br><span class="line">    <span class="string">&quot; _B = (char*)\&quot;&quot;</span> PERSIST_SIG <span class="string">&quot;\&quot;; &quot;</span><span class="comment">// 持久模式签名</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> __APPLE__</span></span><br><span class="line">    <span class="string">&quot;__attribute__((visibility(\&quot;default\&quot;))) &quot;</span><span class="comment">// macOS可见性</span></span><br><span class="line">    <span class="string">&quot;int _L(unsigned int) __asm__(\&quot;___afl_persistent_loop\&quot;); &quot;</span><span class="comment">// 函数别名</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">else</span></span></span><br><span class="line">    <span class="string">&quot;__attribute__((visibility(\&quot;default\&quot;))) &quot;</span><span class="comment">// 标准可见性</span></span><br><span class="line">    <span class="string">&quot;int _L(unsigned int) __asm__(\&quot;__afl_persistent_loop\&quot;); &quot;</span><span class="comment">// 函数别名</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span> <span class="comment">/* ^__APPLE__ */</span></span></span><br><span class="line">    <span class="string">&quot;_L(_A); &#125;)&quot;</span>;<span class="comment">// 调用持久循环函数</span></span><br><span class="line"> <span class="comment">/* 延迟初始化宏 (__AFL_INIT) 实现 */</span></span><br><span class="line">  cc_params[cc_par_cnt++] = <span class="string">&quot;-D__AFL_INIT()=&quot;</span></span><br><span class="line">    <span class="string">&quot;do &#123; static volatile char *_A __attribute__((used)); &quot;</span><span class="comment">// volatile防优化</span></span><br><span class="line">    <span class="string">&quot; _A = (char*)\&quot;&quot;</span> DEFER_SIG <span class="string">&quot;\&quot;; &quot;</span><span class="comment">// 延迟初始化签名</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> __APPLE__</span></span><br><span class="line">    <span class="string">&quot;__attribute__((visibility(\&quot;default\&quot;))) &quot;</span></span><br><span class="line">    <span class="string">&quot;void _I(void) __asm__(\&quot;___afl_manual_init\&quot;); &quot;</span><span class="comment">// macOS别名</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">else</span></span></span><br><span class="line">    <span class="string">&quot;__attribute__((visibility(\&quot;default\&quot;))) &quot;</span></span><br><span class="line">    <span class="string">&quot;void _I(void) __asm__(\&quot;__afl_manual_init\&quot;); &quot;</span><span class="comment">// 标准别名</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span> <span class="comment">/* ^__APPLE__ */</span></span></span><br><span class="line">    <span class="string">&quot;_I(); &#125; while (0)&quot;</span>;<span class="comment">// 调用初始化函数</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (x_set) &#123;</span><br><span class="line">    cc_params[cc_par_cnt++] = <span class="string">&quot;-x&quot;</span>; <span class="comment">// 如果存在 -x 参数，添加&quot;none&quot;重置语言类型</span></span><br><span class="line">    cc_params[cc_par_cnt++] = <span class="string">&quot;none&quot;</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> __ANDROID__</span></span><br><span class="line">  <span class="built_in"><span class="keyword">switch</span></span> (bit_mode) &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">case</span> <span class="number">0</span>:</span><br><span class="line">      cc_params[cc_par_cnt++] = <span class="built_in">alloc_printf</span>(<span class="string">&quot;%s/afl-llvm-rt.o&quot;</span>, obj_path);</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">case</span> <span class="number">32</span>:</span><br><span class="line">      cc_params[cc_par_cnt++] = <span class="built_in">alloc_printf</span>(<span class="string">&quot;%s/afl-llvm-rt-32.o&quot;</span>, obj_path);</span><br><span class="line"></span><br><span class="line">      <span class="keyword">if</span> (<span class="built_in">access</span>(cc_params[cc_par_cnt - <span class="number">1</span>], R_OK))</span><br><span class="line">        <span class="built_in">FATAL</span>(<span class="string">&quot;-m32 is not supported by your compiler&quot;</span>);</span><br><span class="line"></span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">case</span> <span class="number">64</span>:</span><br><span class="line">      cc_params[cc_par_cnt++] = <span class="built_in">alloc_printf</span>(<span class="string">&quot;%s/afl-llvm-rt-64.o&quot;</span>, obj_path);</span><br><span class="line"></span><br><span class="line">      <span class="keyword">if</span> (<span class="built_in">access</span>(cc_params[cc_par_cnt - <span class="number">1</span>], R_OK))</span><br><span class="line">        <span class="built_in">FATAL</span>(<span class="string">&quot;-m64 is not supported by your compiler&quot;</span>);</span><br><span class="line"></span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">  &#125;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"></span><br><span class="line">  cc_params[cc_par_cnt] = <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/* Main entry point */</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span>** argv)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (<span class="built_in">isatty</span>(<span class="number">2</span>) &amp;&amp; !<span class="built_in">getenv</span>(<span class="string">&quot;AFL_QUIET&quot;</span>)) &#123;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> USE_TRACE_PC</span></span><br><span class="line">    <span class="built_in">SAYF</span>(cCYA <span class="string">&quot;afl-clang-fast [tpcg] &quot;</span> cBRI VERSION  cRST <span class="string">&quot; by &lt;lszekeres@google.com&gt;\n&quot;</span>);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">else</span></span></span><br><span class="line">    <span class="built_in">SAYF</span>(cCYA <span class="string">&quot;afl-clang-fast &quot;</span> cBRI VERSION  cRST <span class="string">&quot; by &lt;lszekeres@google.com&gt;\n&quot;</span>);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span> <span class="comment">/* ^USE_TRACE_PC */</span></span></span><br><span class="line"></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (argc &lt; <span class="number">2</span>) &#123;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">SAYF</span>(<span class="string">&quot;\n&quot;</span></span><br><span class="line">         <span class="string">&quot;This is a helper application for afl-fuzz. It serves as a drop-in replacement\n&quot;</span></span><br><span class="line">         <span class="string">&quot;for clang, letting you recompile third-party code with the required runtime\n&quot;</span></span><br><span class="line">         <span class="string">&quot;instrumentation. A common use pattern would be one of the following:\n\n&quot;</span></span><br><span class="line"></span><br><span class="line">         <span class="string">&quot;  CC=%s/afl-clang-fast ./configure\n&quot;</span></span><br><span class="line">         <span class="string">&quot;  CXX=%s/afl-clang-fast++ ./configure\n\n&quot;</span></span><br><span class="line"></span><br><span class="line">         <span class="string">&quot;In contrast to the traditional afl-clang tool, this version is implemented as\n&quot;</span></span><br><span class="line">         <span class="string">&quot;an LLVM pass and tends to offer improved performance with slow programs.\n\n&quot;</span></span><br><span class="line"></span><br><span class="line">         <span class="string">&quot;You can specify custom next-stage toolchain via AFL_CC and AFL_CXX. Setting\n&quot;</span></span><br><span class="line">         <span class="string">&quot;AFL_HARDEN enables hardening optimizations in the compiled code.\n\n&quot;</span>,</span><br><span class="line">         BIN_PATH, BIN_PATH);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> __ANDROID__</span></span><br><span class="line">  <span class="built_in">find_obj</span>(argv[<span class="number">0</span>]);<span class="comment">//查找 AFL 运行时对象文件 afl-llvm-rt.o 的路径</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"></span><br><span class="line">  <span class="built_in">edit_params</span>(argc, argv);<span class="comment">//编辑并构建最终的编译器参数列表</span></span><br><span class="line"></span><br><span class="line">  <span class="built_in">execvp</span>(cc_params[<span class="number">0</span>], (<span class="keyword">char</span>**)cc_params);</span><br><span class="line"></span><br><span class="line">  <span class="built_in">FATAL</span>(<span class="string">&quot;Oops, failed to execute &#x27;%s&#x27; - check your PATH&quot;</span>, cc_params[<span class="number">0</span>]);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="afl-llvm-pass"><a href="#afl-llvm-pass" class="headerlink" title="afl-llvm-pass"></a>afl-llvm-pass</h2><h3 id="GlobalVariable"><a href="#GlobalVariable" class="headerlink" title="GlobalVariable"></a>GlobalVariable</h3><p><em>GlobalVariable</em> 类是 LLVM 中间表示（IR）中表示全局变量的核心类</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="built_in">GlobalVariable</span>(Type *Ty,</span><br><span class="line">               <span class="keyword">bool</span> isConstant,</span><br><span class="line">               LinkageTypes Linkage,</span><br><span class="line">               Constant *Initializer = <span class="literal">nullptr</span>,</span><br><span class="line">               <span class="keyword">const</span> Twine &amp;Name = <span class="string">&quot;&quot;</span>,</span><br><span class="line">               ThreadLocalMode = NotThreadLocal,</span><br><span class="line">               <span class="keyword">unsigned</span> AddressSpace = <span class="number">0</span>,</span><br><span class="line">               <span class="keyword">bool</span> isExternallyInitialized = <span class="literal">false</span>)</span><br></pre></td></tr></table></figure>

<p>构造函数参数如上</p>
<ul>
<li><code>Type *Ty</code>: <strong>必需。</strong> 全局变量的类型。注意，全局变量在 LLVM IR 中始终是指针类型。<code>Ty</code> 指定的是该指针所指向的数据的类型（例如，<code>i32*</code> 表示指向 32 位整数的指针，此时 <code>Ty</code> 应为 <code>IntegerType::get(Context, 32)</code>，<code>Type::getInt32PtrTy(Context)</code> 会返回 <code>i32*</code>)。</li>
<li><code>bool isConstant</code>: <strong>必需。</strong> 如果为 <code>true</code>，表示该全局变量在程序执行期间是常量（不可修改）。如果为 <code>false</code>，表示变量是可写的。</li>
<li><code>LinkageTypes Linkage</code>: <strong>必需。</strong> 指定链接类型，控制该全局变量在链接时的可见性和行为。常见值如 <code>ExternalLinkage</code>（外部可见）、<code>InternalLinkage</code>（仅本模块可见）、<code>PrivateLinkage</code>（类似内部，但更严格的局部性）、<code>WeakAnyLinkage</code>/<code>WeakODRLinkage</code>（弱链接）、<code>LinkOnceAnyLinkage</code>/<code>LinkOnceODRLinkage</code>（链接时去重）等。</li>
<li><code>Constant *Initializer = nullptr</code>: 可选的初始值。必须是 <code>Constant</code> 或其子类（如 <code>ConstantInt</code>, <code>ConstantFP</code>, <code>ConstantArray</code>, <code>ConstantStruct</code>, <code>GlobalValue</code> 等）。类型必须与 <code>Ty</code> 所指向的类型兼容（例如，如果 <code>Ty</code> 是 <code>i32*</code>，那么 <code>Initializer</code> 必须是 <code>ConstantInt</code> 或其子类，表示一个 <code>i32</code> 类型的常量）。如果为 <code>nullptr</code>，则表示该全局变量没有初始化器（通常用于声明而非定义）。</li>
<li><code>const Twine &amp;Name = &quot;&quot;</code>: 可选的全局变量名称（例如 <code>@gvar</code>）。<code>Twine</code> 是 LLVM 中高效处理字符串拼接和传递的类。</li>
<li><code>ThreadLocalMode = NotThreadLocal</code>: 指定线程本地存储模式。默认为 <code>NotThreadLocal</code>（普通全局变量）。其他选项如 <code>GeneralDynamicTLSModel</code>, <code>LocalDynamicTLSModel</code>, <code>InitialExecTLSModel</code>, <code>LocalExecTLSModel</code>，用于实现线程局部变量。</li>
<li><code>unsigned AddressSpace = 0</code>: 指定该全局变量所在的地址空间。默认为 0（通用地址空间）。某些目标架构（如 GPU）支持不同的地址空间（如全局内存、常量内存、共享内存、局部内存）。</li>
<li><code>bool isExternallyInitialized = false</code>: 如果为 <code>true</code>，表示该全局变量虽然在当前模块中定义，但其初始值是由外部实体（例如另一个模块或运行时环境）设置的。这通常与特殊链接类型或运行时模型相关。</li>
</ul>
<p><strong>功能：</strong> 创建一个 <code>GlobalVariable</code> 对象，并<strong>自动将其插入到指定模块 <code>M</code> 的全局变量列表的末尾</strong><br>再来看看afl-llvm-pass中的两个GlobalVariable对象：</p>
<h4 id="AFLMapPtr-共享内存区域指针"><a href="#AFLMapPtr-共享内存区域指针" class="headerlink" title="AFLMapPtr - 共享内存区域指针"></a>AFLMapPtr - 共享内存区域指针</h4><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">GlobalVariable *AFLMapPtr =</span><br><span class="line">      <span class="keyword">new</span> <span class="built_in">GlobalVariable</span>(M, PointerType::<span class="built_in">get</span>(Int8Ty, <span class="number">0</span>), <span class="literal">false</span>,</span><br><span class="line">                         GlobalValue::ExternalLinkage, <span class="number">0</span>, <span class="string">&quot;__afl_area_ptr&quot;</span>);</span><br></pre></td></tr></table></figure>

<ol>
<li><p><strong>变量类型</strong>：<code>PointerType::get(Int8Ty, 0)</code></p>
<ul>
<li>指向 <code>i8</code>（8位整数/字节）的指针</li>
<li>地址空间为 0（默认通用地址空间）</li>
<li>相当于 C 语言中的 <code>unsigned char*</code></li>
</ul>
</li>
<li><p><strong>变量属性</strong>：</p>
<ul>
<li><p><code>false</code>：非常量（可修改）</p>
</li>
<li><p>```<br>GlobalValue::ExternalLinkage</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">     ：外部链接</span><br><span class="line"></span><br><span class="line">     - 需要在链接时解析的实际符号</span><br><span class="line"></span><br><span class="line">   - `0`：初始化为 `nullptr`（无初始值）</span><br><span class="line"></span><br><span class="line">   - `&quot;__afl_area_ptr&quot;`：全局符号名称</span><br><span class="line"></span><br><span class="line">3. **实际作用**：</span><br><span class="line"></span><br><span class="line">   - 这是 AFL 插桩的核心变量，指向共享内存区域</span><br><span class="line">   - AFL 运行时会在程序启动前将此指针初始化为实际共享内存地址</span><br><span class="line">   - 插桩代码通过此指针访问和更新覆盖率位图(bitmap)</span><br><span class="line">   - 当程序执行到被插桩的基本块时，代码会更新此指针指向的共享内存</span><br><span class="line"></span><br><span class="line">#### AFLPrevLoc - 前一个位置标识符</span><br><span class="line"></span><br><span class="line">```cpp</span><br><span class="line">GlobalVariable *AFLPrevLoc = new GlobalVariable(</span><br><span class="line">      M, Int32Ty, false, GlobalValue::ExternalLinkage, 0, &quot;__afl_prev_loc&quot;,</span><br><span class="line">      0, GlobalVariable::GeneralDynamicTLSModel, 0, false);</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
</ol>
<p><strong>功能分析：</strong></p>
<ol>
<li><p><strong>变量类型</strong>：<code>Int32Ty</code> - 32位整数</p>
</li>
<li><p><strong>关键属性</strong>：</p>
<ul>
<li><p><code>false</code>：非常量（可修改）</p>
</li>
<li><p><code>GlobalValue::ExternalLinkage</code>：外部链接</p>
</li>
<li><p><code>0</code>：初始化为 <code>nullptr</code>（实际由运行时初始化）</p>
</li>
<li><p><code>&quot;__afl_prev_loc&quot;</code>：全局符号名称</p>
</li>
<li><p>```<br>GlobalVariable::GeneralDynamicTLSModel</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">     ：线程本地存储模式</span><br><span class="line"></span><br><span class="line">     - **最重要的特性**：每个线程有自己的副本</span><br><span class="line"></span><br><span class="line">3. **实际作用**：</span><br><span class="line"></span><br><span class="line">   - 存储&quot;前一个基本块&quot;的随机标识符</span><br><span class="line">   - AFL 使用此变量实现路径跟踪：`当前基本块ID ^ (前一个基本块ID &gt;&gt; 1)`</span><br><span class="line">   - 线程本地存储(TLS)确保：</span><br><span class="line">     - 每个线程有自己的执行路径记录</span><br><span class="line">     - 多线程程序也能正确跟踪覆盖率</span><br><span class="line">     - 避免线程间竞争条件</span><br><span class="line">   - GeneralDynamicTLSModel 是最通用的 TLS 模型，适用于动态链接库</span><br><span class="line"></span><br><span class="line">```cpp</span><br><span class="line">#define AFL_LLVM_PASS</span><br><span class="line"></span><br><span class="line">#include &quot;../config.h&quot;</span><br><span class="line">#include &quot;../debug.h&quot;</span><br><span class="line"></span><br><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line">#include &lt;stdlib.h&gt;</span><br><span class="line">#include &lt;unistd.h&gt;</span><br><span class="line"></span><br><span class="line">#include &quot;llvm/ADT/Statistic.h&quot;</span><br><span class="line">#include &quot;llvm/IR/IRBuilder.h&quot;</span><br><span class="line">#include &quot;llvm/IR/LegacyPassManager.h&quot;</span><br><span class="line">#include &quot;llvm/IR/Module.h&quot;</span><br><span class="line">#include &quot;llvm/Support/Debug.h&quot;</span><br><span class="line">#include &quot;llvm/Transforms/IPO/PassManagerBuilder.h&quot;</span><br><span class="line"></span><br><span class="line">using namespace llvm;</span><br><span class="line"></span><br><span class="line">namespace &#123;</span><br><span class="line"></span><br><span class="line">  class AFLCoverage : public ModulePass &#123;</span><br><span class="line"></span><br><span class="line">    public:</span><br><span class="line"></span><br><span class="line">      static char ID;</span><br><span class="line">      AFLCoverage() : ModulePass(ID) &#123; &#125;</span><br><span class="line"></span><br><span class="line">      bool runOnModule(Module &amp;M) override;</span><br><span class="line"></span><br><span class="line">      // StringRef getPassName() const override &#123;</span><br><span class="line">      //  return &quot;American Fuzzy Lop Instrumentation&quot;;</span><br><span class="line">      // &#125;</span><br><span class="line"></span><br><span class="line">  &#125;;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">char AFLCoverage::ID = 0;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">bool AFLCoverage::runOnModule(Module &amp;M) &#123;</span><br><span class="line">  // 获取当前模块的 LLVM 上下文</span><br><span class="line">  LLVMContext &amp;C = M.getContext();</span><br><span class="line">   // 定义常用的整数类型</span><br><span class="line">  IntegerType *Int8Ty  = IntegerType::getInt8Ty(C);// 8位整数类型</span><br><span class="line">  IntegerType *Int32Ty = IntegerType::getInt32Ty(C);// 32位整数类型</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">  /* Show a banner */</span><br><span class="line"></span><br><span class="line">  char be_quiet = 0;// 静默模式标志</span><br><span class="line"></span><br><span class="line">  // 如果标准错误是终端且未设置 AFL_QUIET，则显示横幅</span><br><span class="line">  if (isatty(2) &amp;&amp; !getenv(&quot;AFL_QUIET&quot;)) &#123;</span><br><span class="line">    // 打印彩色横幅</span><br><span class="line">    SAYF(cCYA &quot;afl-llvm-pass &quot; cBRI VERSION cRST &quot; by &lt;lszekeres@google.com&gt;\n&quot;);</span><br><span class="line"></span><br><span class="line">  &#125; else be_quiet = 1;// 启用静默模式</span><br><span class="line"></span><br><span class="line">  /* Decide instrumentation ratio */</span><br><span class="line"></span><br><span class="line">  char* inst_ratio_str = getenv(&quot;AFL_INST_RATIO&quot;);// 获取环境变量</span><br><span class="line">  unsigned int inst_ratio = 100;// 默认100%插桩</span><br><span class="line"></span><br><span class="line">  if (inst_ratio_str) &#123;</span><br><span class="line">    // 解析环境变量值 (1-100)</span><br><span class="line">    if (sscanf(inst_ratio_str, &quot;%u&quot;, &amp;inst_ratio) != 1 || !inst_ratio ||</span><br><span class="line">        inst_ratio &gt; 100)</span><br><span class="line">      FATAL(&quot;Bad value of AFL_INST_RATIO (must be between 1 and 100)&quot;);</span><br><span class="line"></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  /* Get globals for the SHM region and the previous location. Note that</span><br><span class="line">     __afl_prev_loc is thread-local. */</span><br><span class="line">  /* 获取 SHM 共享内存区域和上一次位置的全局变量 */</span><br><span class="line">  // __afl_area_ptr: 指向共享内存的指针</span><br><span class="line">  GlobalVariable *AFLMapPtr =</span><br><span class="line">      new GlobalVariable(M, PointerType::get(Int8Ty, 0), false,</span><br><span class="line">                         GlobalValue::ExternalLinkage, 0, &quot;__afl_area_ptr&quot;);</span><br><span class="line">  // __afl_prev_loc: 线程局部存储的上一个位置（跨函数保持）</span><br><span class="line">  GlobalVariable *AFLPrevLoc = new GlobalVariable(</span><br><span class="line">      M, Int32Ty, false, GlobalValue::ExternalLinkage, 0, &quot;__afl_prev_loc&quot;,</span><br><span class="line">      0, GlobalVariable::GeneralDynamicTLSModel, 0, false);</span><br><span class="line"></span><br><span class="line">  /* Instrument all the things! */</span><br><span class="line">  /* 开始插桩所有基本块 */</span><br><span class="line">  int inst_blocks = 0;</span><br><span class="line"></span><br><span class="line">  for (auto &amp;F : M)</span><br><span class="line">    for (auto &amp;BB : F) &#123;</span><br><span class="line">      // 获取基本块中第一个插入点,寻找一个安全的插入点插入</span><br><span class="line">      BasicBlock::iterator IP = BB.getFirstInsertionPt();</span><br><span class="line">      // 创建IR构建器</span><br><span class="line">      IRBuilder&lt;&gt; IRB(&amp;(*IP));</span><br><span class="line">      // 根据插桩比例随机跳过</span><br><span class="line">      if (AFL_R(100) &gt;= inst_ratio) continue;</span><br><span class="line"></span><br><span class="line">      /* Make up cur_loc */</span><br><span class="line">       /* 生成随机位置ID */</span><br><span class="line">      unsigned int cur_loc = AFL_R(MAP_SIZE); // 生成MAP_SIZE范围内的随机ID</span><br><span class="line"></span><br><span class="line">      ConstantInt *CurLoc = ConstantInt::get(Int32Ty, cur_loc);// 创建常量整数</span><br><span class="line"></span><br><span class="line">      /* Load prev_loc */</span><br><span class="line">      /* 加载上一个位置ID（__afl_prev_loc） */</span><br><span class="line">      LoadInst *PrevLoc = IRB.CreateLoad(AFLPrevLoc);// 生成load指令，加载之前的全局变量__afl_prev_loc</span><br><span class="line">      PrevLoc-&gt;setMetadata(M.getMDKindID(&quot;nosanitize&quot;), MDNode::get(C, None));//禁用Sanitizer检查（避免误报数据竞争）%0 = load i32, i32* @__afl_prev_loc, !nosanitize !0</span><br><span class="line">      Value *PrevLocCasted = IRB.CreateZExt(PrevLoc, IRB.getInt32Ty());//将值零扩展为32位%1 = zext iN %0 to i32</span><br><span class="line"></span><br><span class="line">      /* Load SHM pointer */</span><br><span class="line"></span><br><span class="line">      LoadInst *MapPtr = IRB.CreateLoad(AFLMapPtr); //生成load指令，加载之前的全局变量，%0 = load i32, i32* @__afl_area_ptr</span><br><span class="line">      MapPtr-&gt;setMetadata(M.getMDKindID(&quot;nosanitize&quot;), MDNode::get(C, None));//%0 = load i32, i32* @__afl_area_ptr, !nosanitize !0</span><br><span class="line">      Value *MapPtrIdx =</span><br><span class="line">          IRB.CreateGEP(MapPtr, IRB.CreateXor(PrevLocCasted, CurLoc));//将值零扩展为32位%1 = zext iN %0 to i32</span><br><span class="line"></span><br><span class="line">      /* Update bitmap */</span><br><span class="line"></span><br><span class="line">      LoadInst *Counter = IRB.CreateLoad(MapPtrIdx);//加载当前计数器值，%counter_val = load i8, i8* %map_ptr_idx, !nosanitize !0</span><br><span class="line">      Counter-&gt;setMetadata(M.getMDKindID(&quot;nosanitize&quot;), MDNode::get(C, None));//禁用Sanitizer检查</span><br><span class="line">      Value *Incr = IRB.CreateAdd(Counter, ConstantInt::get(Int8Ty, 1));//计数器加1，%new_val = add i8 %counter_val, 1</span><br><span class="line">      IRB.CreateStore(Incr, MapPtrIdx)</span><br><span class="line">          -&gt;setMetadata(M.getMDKindID(&quot;nosanitize&quot;), MDNode::get(C, None));//存储更新后的值，store i8 %new_val, i8* %map_ptr_idx, !nosanitize !0</span><br><span class="line"></span><br><span class="line">      /* Set prev_loc to cur_loc &gt;&gt; 1 */</span><br><span class="line"></span><br><span class="line">      StoreInst *Store =</span><br><span class="line">          IRB.CreateStore(ConstantInt::get(Int32Ty, cur_loc &gt;&gt; 1), AFLPrevLoc);//store i32 %cur_loc_shifted, i32* @__afl_prev_loc</span><br><span class="line">      Store-&gt;setMetadata(M.getMDKindID(&quot;nosanitize&quot;), MDNode::get(C, None));//禁用Sanitizer检查</span><br><span class="line"></span><br><span class="line">      inst_blocks++;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">  /* Say something nice. */</span><br><span class="line"></span><br><span class="line">  if (!be_quiet) &#123;</span><br><span class="line"></span><br><span class="line">    if (!inst_blocks) WARNF(&quot;No instrumentation targets found.&quot;);</span><br><span class="line">    else OKF(&quot;Instrumented %u locations (%s mode, ratio %u%%).&quot;,</span><br><span class="line">             inst_blocks, getenv(&quot;AFL_HARDEN&quot;) ? &quot;hardened&quot; :</span><br><span class="line">             ((getenv(&quot;AFL_USE_ASAN&quot;) || getenv(&quot;AFL_USE_MSAN&quot;)) ?</span><br><span class="line">              &quot;ASAN/MSAN&quot; : &quot;non-hardened&quot;), inst_ratio);</span><br><span class="line"></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  return true;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">static void registerAFLPass(const PassManagerBuilder &amp;,</span><br><span class="line">                            legacy::PassManagerBase &amp;PM) &#123;</span><br><span class="line"></span><br><span class="line">  PM.add(new AFLCoverage());</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">static RegisterStandardPasses RegisterAFLPass(</span><br><span class="line">    PassManagerBuilder::EP_ModuleOptimizerEarly, registerAFLPass);</span><br><span class="line"></span><br><span class="line">static RegisterStandardPasses RegisterAFLPass0(</span><br><span class="line">    PassManagerBuilder::EP_EnabledOnOptLevel0, registerAFLPass);</span><br><span class="line"></span><br></pre></td></tr></table></figure></li>
</ul>
</li>
</ol>
<h2 id="afl-llvm-rt"><a href="#afl-llvm-rt" class="headerlink" title="afl-llvm-rt"></a>afl-llvm-rt</h2><p>该文件中定义了多个AFL LLVM_Mode的函数</p>
<h3 id="afl-manual-init"><a href="#afl-manual-init" class="headerlink" title="__afl_manual_init"></a>__afl_manual_init</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">u8  __afl_area_initial[MAP_SIZE];           <span class="comment">// 初始共享内存区域（默认64KB）</span></span><br><span class="line">u8* __afl_area_ptr = __afl_area_initial;    <span class="comment">// 当前使用的共享内存指针，由afl-llvm-pass来加入到目标程序</span></span><br><span class="line"><span class="keyword">void</span> __afl_manual_init(<span class="keyword">void</span>) &#123;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">static</span> u8 init_done;<span class="comment">// 初始化状态标志</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (!init_done) &#123;</span><br><span class="line"></span><br><span class="line">    __afl_map_shm();<span class="comment">// 建立共享内存映射</span></span><br><span class="line">    __afl_start_forkserver();<span class="comment">// </span></span><br><span class="line">    init_done = <span class="number">1</span>; <span class="comment">// 标记已初始化</span></span><br><span class="line"></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="afl-map-shm"><a href="#afl-map-shm" class="headerlink" title="__afl_map_shm"></a>__afl_map_shm</h4><p>该函数就是从环境变量中读取SHM_ENV_VAR来获取共享内存，如果存在的话就赋值给**__afl_area_ptr**，</p>
<p>如果没有就指向**__afl_area_initial**数组</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">void</span> __afl_map_shm(<span class="keyword">void</span>) &#123;</span><br><span class="line"></span><br><span class="line">  u8 *id_str = <span class="built_in">getenv</span>(SHM_ENV_VAR);<span class="comment">// 获取环境变量中的共享内存ID</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">/* If we&#x27;re running under AFL, attach to the appropriate region, replacing the</span></span><br><span class="line"><span class="comment">     early-stage __afl_area_initial region that is needed to allow some really</span></span><br><span class="line"><span class="comment">     hacky .init code to work correctly in projects such as OpenSSL. */</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (id_str) &#123;</span><br><span class="line"></span><br><span class="line">    u32 shm_id = <span class="built_in">atoi</span>(id_str);<span class="comment">// 获取环境变量中的共享内存ID</span></span><br><span class="line"></span><br><span class="line">    __afl_area_ptr = <span class="built_in">shmat</span>(shm_id, <span class="literal">NULL</span>, <span class="number">0</span>);<span class="comment">// 转换字符串为整数ID</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Whooooops. */</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (__afl_area_ptr == (<span class="keyword">void</span> *)<span class="number">-1</span>) _exit(<span class="number">1</span>);<span class="comment">// 错误处理</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Write something into the bitmap so that even with low AFL_INST_RATIO,</span></span><br><span class="line"><span class="comment">       our parent doesn&#x27;t give up on us. */</span></span><br><span class="line"></span><br><span class="line">    __afl_area_ptr[<span class="number">0</span>] = <span class="number">1</span>;<span class="comment">// 初始化第一个字节，防止父进程误判</span></span><br><span class="line"></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="afl-start-forkserver"><a href="#afl-start-forkserver" class="headerlink" title="__afl_start_forkserver"></a>__afl_start_forkserver</h4><p><code>__afl_start_forkserver</code> 是 AFL（American Fuzzy Lop）模糊测试工具的核心组件之一，它实现了高效的 fork 服务器机制。这个函数的主要作用是创建一个长期运行的服务器进程，负责管理目标程序的执行，从而避免重复的进程创建开销。</p>
<ol>
<li>初始化与握手</li>
</ol>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">static</span> u8 tmp[<span class="number">4</span>];</span><br><span class="line"><span class="keyword">if</span> (<span class="built_in">write</span>(FORKSRV_FD + <span class="number">1</span>, tmp, <span class="number">4</span>) != <span class="number">4</span>) <span class="keyword">return</span>;</span><br></pre></td></tr></table></figure>

<ul>
<li>通过状态管道（<code>FORKSRV_FD + 1</code>）向 AFL 父进程发送 4 字节任意数据</li>
<li>这是 fork 服务器的启动信号，告知 AFL “我已准备就绪”</li>
<li>如果写失败，说明不需要 fork 服务器，直接返回执行目标程</li>
</ul>
<ol start="2">
<li>主循环 - 处理测试用例</li>
</ol>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">while</span> (<span class="number">1</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">read</span>(FORKSRV_FD, &amp;was_killed, <span class="number">4</span>) != <span class="number">4</span>) _exit(<span class="number">1</span>);</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>阻塞读取控制管道（<code>FORKSRV_FD</code>），等待 AFL 发送测试用例</li>
<li><code>was_killed</code> 表示上一个子进程是否被 AFL 终止（超时等情况）</li>
</ul>
<ol start="3">
<li><p>子进程管理</p>
<table>
<thead>
<tr>
<th><code>child_stopped</code> 值</th>
<th>子进程状态</th>
<th>可能场景</th>
<th>下一步动作</th>
</tr>
</thead>
<tbody><tr>
<td><strong>0</strong></td>
<td>没有暂停的子进程</td>
<td>1. 无子进程 2. 子进程正在运行</td>
<td>创建新进程 (<code>fork()</code>)</td>
</tr>
<tr>
<td><strong>1</strong></td>
<td>有子进程处于暂停状态 (SIGSTOP)</td>
<td>持久化模式等待唤醒</td>
<td>恢复进程 (<code>SIGCONT</code>)</td>
</tr>
</tbody></table>
<ol>
<li><p>处理持久化模式的竞态条件</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (child_stopped &amp;&amp; was_killed) &#123;</span><br><span class="line">    child_stopped = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">waitpid</span>(child_pid, &amp;status, <span class="number">0</span>) &lt; <span class="number">0</span>) _exit(<span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>当子进程处于暂停状态但 AFL 已发出终止信号时</li>
<li>确保彻底结束前一个子进程，避免僵尸进程</li>
</ul>
</li>
<li><p>创建新进程（非持久化模式）</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (!child_stopped) &#123;</span><br><span class="line">    child_pid = fork();</span><br><span class="line">    <span class="keyword">if</span> (child_pid &lt; <span class="number">0</span>) _exit(<span class="number">1</span>);  <span class="comment">// fork 失败</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!child_pid) &#123;  <span class="comment">// 子进程分支</span></span><br><span class="line">        <span class="built_in">close</span>(FORKSRV_FD);</span><br><span class="line">        <span class="built_in">close</span>(FORKSRV_FD + <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">return</span>;  <span class="comment">// 跳出函数，执行目标程序</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>创建新进程执行测试用例</li>
<li>子进程关闭通信管道后返回，继续执行被测试程序</li>
<li>父进程（fork 服务器）继续运行</li>
</ul>
</li>
<li><p>恢复持久化进程</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="built_in">kill</span>(child_pid, SIGCONT);</span><br><span class="line">    child_stopped = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>对于持久化模式，不创建新进程</li>
<li>向暂停的子进程发送 SIGCONT 唤醒它</li>
<li>重用同一个进程执行新测试用例</li>
</ul>
</li>
<li><p>与 AFL 通信</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 发送子进程 PID</span></span><br><span class="line"><span class="keyword">if</span> (<span class="built_in">write</span>(FORKSRV_FD + <span class="number">1</span>, &amp;child_pid, <span class="number">4</span>) != <span class="number">4</span>) _exit(<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 等待子进程结束</span></span><br><span class="line"><span class="keyword">if</span> (<span class="built_in">waitpid</span>(child_pid, &amp;status, is_persistent ? WUNTRACED : <span class="number">0</span>) &lt; <span class="number">0</span>)</span><br><span class="line">    _exit(<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 处理持久化模式的暂停状态</span></span><br><span class="line"><span class="keyword">if</span> (<span class="built_in">WIFSTOPPED</span>(status)) child_stopped = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 发送子进程状态</span></span><br><span class="line"><span class="keyword">if</span> (<span class="built_in">write</span>(FORKSRV_FD + <span class="number">1</span>, &amp;status, <span class="number">4</span>) != <span class="number">4</span>) _exit(<span class="number">1</span>);</span><br></pre></td></tr></table></figure>

<ol>
<li>将子进程 PID 发送给 AFL</li>
<li>等待子进程结束（或暂停）</li>
<li>检测持久化模式的暂停状态（SIGSTOP）</li>
<li>将子进程状态返回给 AFL</li>
</ol>
</li>
</ol>
<h5 id="通信管道说明"><a href="#通信管道说明" class="headerlink" title="通信管道说明"></a>通信管道说明</h5><table>
<thead>
<tr>
<th>文件描述符</th>
<th>方向</th>
<th>用途</th>
</tr>
</thead>
<tbody><tr>
<td>FORKSRV_FD</td>
<td>输入</td>
<td>接收 AFL 的测试用例和控制命令</td>
</tr>
<tr>
<td>FORKSRV_FD+1</td>
<td>输出</td>
<td>向 AFL 发送状态和结果信息</td>
</tr>
</tbody></table>
<h5 id="持久化-vs-非持久化模式"><a href="#持久化-vs-非持久化模式" class="headerlink" title="持久化 vs 非持久化模式"></a>持久化 vs 非持久化模式</h5><h6 id="非持久化模式（默认）"><a href="#非持久化模式（默认）" class="headerlink" title="非持久化模式（默认）"></a>非持久化模式（默认）</h6><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">sequenceDiagram</span><br><span class="line">    participant A as AFL</span><br><span class="line">    participant F as Fork 服务器</span><br><span class="line">    participant C as 子进程</span><br><span class="line">    </span><br><span class="line">    A-&gt;&gt;F: 发送测试用例</span><br><span class="line">    F-&gt;&gt;C: fork()</span><br><span class="line">    C-&gt;&gt;F: 执行测试</span><br><span class="line">    F-&gt;&gt;A: 返回PID和状态</span><br><span class="line">    C--&gt;&gt;F: 进程结束</span><br><span class="line">    F-&gt;&gt;A: 通知结束状态</span><br></pre></td></tr></table></figure>

<h6 id="持久化模式"><a href="#持久化模式" class="headerlink" title="持久化模式"></a>持久化模式</h6><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">sequenceDiagram</span><br><span class="line">    participant A as AFL</span><br><span class="line">    participant F as Fork 服务器</span><br><span class="line">    participant C as 持久化进程</span><br><span class="line">    </span><br><span class="line">    A-&gt;&gt;F: 发送测试用例1</span><br><span class="line">    F-&gt;&gt;C: SIGCONT</span><br><span class="line">    C-&gt;&gt;F: 执行测试1</span><br><span class="line">    C-&gt;&gt;F: SIGSTOP（暂停）</span><br><span class="line">    F-&gt;&gt;A: 返回状态</span><br><span class="line">    </span><br><span class="line">    A-&gt;&gt;F: 发送测试用例2</span><br><span class="line">    F-&gt;&gt;C: SIGCONT</span><br><span class="line">    C-&gt;&gt;F: 执行测试2</span><br><span class="line">    C-&gt;&gt;F: SIGSTOP（暂停）</span><br><span class="line">    F-&gt;&gt;A: 返回状态</span><br></pre></td></tr></table></figure></li>
</ol>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">void</span> __afl_start_forkserver(<span class="keyword">void</span>) &#123;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">static</span> u8 tmp[<span class="number">4</span>];<span class="comment">// 临时缓冲区</span></span><br><span class="line">  s32 child_pid;<span class="comment">// 子进程PID</span></span><br><span class="line"></span><br><span class="line">  u8  child_stopped = <span class="number">0</span>;<span class="comment">// 子进程停止状态标志,若为1表示有子进程可以唤醒</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">/* Phone home and tell the parent that we&#x27;re OK. If parent isn&#x27;t there,</span></span><br><span class="line"><span class="comment">     assume we&#x27;re not running in forkserver mode and just execute program. */</span></span><br><span class="line">    <span class="comment">// 通过状态管道通知父进程准备就绪</span></span><br><span class="line">  <span class="keyword">if</span> (<span class="built_in">write</span>(FORKSRV_FD + <span class="number">1</span>, tmp, <span class="number">4</span>) != <span class="number">4</span>) <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 主循环处理测试用例</span></span><br><span class="line">  <span class="keyword">while</span> (<span class="number">1</span>) &#123;</span><br><span class="line"></span><br><span class="line">    u32 was_killed;</span><br><span class="line">    <span class="keyword">int</span> status;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Wait for parent by reading from the pipe. Abort if read fails. */</span></span><br><span class="line">    <span class="comment">// 等待父进程发送测试用例</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">read</span>(FORKSRV_FD, &amp;was_killed, <span class="number">4</span>) != <span class="number">4</span>) _exit(<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* If we stopped the child in persistent mode, but there was a race</span></span><br><span class="line"><span class="comment">       condition and afl-fuzz already issued SIGKILL, write off the old</span></span><br><span class="line"><span class="comment">       process. */</span></span><br><span class="line">    <span class="comment">// 处理持久化模式下的竞态条件</span></span><br><span class="line">    <span class="keyword">if</span> (child_stopped &amp;&amp; was_killed) &#123;</span><br><span class="line">      child_stopped = <span class="number">0</span>;</span><br><span class="line">      <span class="keyword">if</span> (<span class="built_in">waitpid</span>(child_pid, &amp;status, <span class="number">0</span>) &lt; <span class="number">0</span>) _exit(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!child_stopped) &#123;</span><br><span class="line"></span><br><span class="line">      <span class="comment">/* Once woken up, create a clone of our process. */</span></span><br><span class="line">      <span class="comment">// 创建子进程进行模糊测试</span></span><br><span class="line">      child_pid = fork();</span><br><span class="line">      <span class="keyword">if</span> (child_pid &lt; <span class="number">0</span>) _exit(<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">      <span class="comment">/* In child process: close fds, resume execution. */</span></span><br><span class="line">      <span class="comment">// 子进程分支</span></span><br><span class="line">      <span class="keyword">if</span> (!child_pid) &#123;</span><br><span class="line"></span><br><span class="line">        <span class="built_in">close</span>(FORKSRV_FD);<span class="comment">// 关闭不必要的文件描述符</span></span><br><span class="line">        <span class="built_in">close</span>(FORKSRV_FD + <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">return</span>;               <span class="comment">// 返回目标程序继续执行</span></span><br><span class="line">  </span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line"></span><br><span class="line">      <span class="comment">/* Special handling for persistent mode: if the child is alive but</span></span><br><span class="line"><span class="comment">         currently stopped, simply restart it with SIGCONT. */</span></span><br><span class="line">      <span class="comment">// 恢复被暂停的持久化进程</span></span><br><span class="line">      <span class="built_in">kill</span>(child_pid, SIGCONT);</span><br><span class="line">      child_stopped = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* In parent process: write PID to pipe, then wait for child. */</span></span><br><span class="line">    <span class="comment">// 向父进程发送子进程PID</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">write</span>(FORKSRV_FD + <span class="number">1</span>, &amp;child_pid, <span class="number">4</span>) != <span class="number">4</span>) _exit(<span class="number">1</span>);</span><br><span class="line">     <span class="comment">// 等待子进程完成</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">waitpid</span>(child_pid, &amp;status, is_persistent ? WUNTRACED : <span class="number">0</span>) &lt; <span class="number">0</span>)</span><br><span class="line">      _exit(<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* In persistent mode, the child stops itself with SIGSTOP to indicate</span></span><br><span class="line"><span class="comment">       a successful run. In this case, we want to wake it up without forking</span></span><br><span class="line"><span class="comment">       again. */</span></span><br><span class="line">    <span class="comment">// 处理持久化模式的暂停状态</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">WIFSTOPPED</span>(status)) child_stopped = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Relay wait status to pipe, then loop back. */</span></span><br><span class="line">    <span class="comment">// 向父进程发送子进程状态</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">write</span>(FORKSRV_FD + <span class="number">1</span>, &amp;status, <span class="number">4</span>) != <span class="number">4</span>) _exit(<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="afl-persistent-loop"><a href="#afl-persistent-loop" class="headerlink" title="__afl_persistent_loop"></a>__afl_persistent_loop</h3><ol>
<li>初次代码调用</li>
</ol>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">static</span> u8 first_pass = <span class="number">1</span>;  <span class="comment">// 静态变量，保持跨调用状态</span></span><br><span class="line"><span class="keyword">static</span> u32 cycle_cnt;      <span class="comment">// 循环计数器</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (first_pass) &#123;</span><br><span class="line">    <span class="keyword">if</span> (is_persistent) &#123;</span><br><span class="line">        <span class="comment">// 重置覆盖率记录</span></span><br><span class="line">        <span class="built_in">memset</span>(__afl_area_ptr, <span class="number">0</span>, MAP_SIZE);  <span class="comment">// 清零整个共享内存区域</span></span><br><span class="line">        __afl_area_ptr[<span class="number">0</span>] = <span class="number">1</span>;  <span class="comment">// 设置&quot;存活标志&quot;，防止父进程误判</span></span><br><span class="line">        __afl_prev_loc = <span class="number">0</span>;     <span class="comment">// 重置基本块追踪状态</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    cycle_cnt = max_cnt;  <span class="comment">// 设置最大迭代次数</span></span><br><span class="line">    first_pass = <span class="number">0</span>;       <span class="comment">// 标记初始化完成</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span>;             <span class="comment">// 指示进入循环体</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol start="2">
<li>持久化循环主体</li>
</ol>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (is_persistent) &#123;</span><br><span class="line">    <span class="keyword">if</span> (--cycle_cnt) &#123;  <span class="comment">// 递减计数器并检查是否继续</span></span><br><span class="line">        <span class="built_in">raise</span>(SIGSTOP);  <span class="comment">// ★ 核心：暂停进程等待新输入</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 状态重置</span></span><br><span class="line">        __afl_area_ptr[<span class="number">0</span>] = <span class="number">1</span>;   <span class="comment">// 设置存活标志</span></span><br><span class="line">        __afl_prev_loc = <span class="number">0</span>;      <span class="comment">// 重置基本块追踪</span></span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;  <span class="comment">// 继续循环</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol start="3">
<li>退出循环处理</li>
</ol>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line">    __afl_area_ptr = __afl_area_initial;  <span class="comment">// 切换回虚拟内存区域</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;  <span class="comment">// 终止循环</span></span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">sequenceDiagram</span><br><span class="line">    participant C as 目标程序</span><br><span class="line">    participant F as Fork服务器</span><br><span class="line">    participant A as AFL模糊器</span><br><span class="line">    </span><br><span class="line">    Note over C: 首次调用</span><br><span class="line">    C-&gt;&gt;C: 初始化覆盖率</span><br><span class="line">    C-&gt;&gt;F: 返回1 (继续循环)</span><br><span class="line">    </span><br><span class="line">    Note over C: 迭代1</span><br><span class="line">    C-&gt;&gt;A: 执行测试用例1</span><br><span class="line">    C-&gt;&gt;F: raise(SIGSTOP)</span><br><span class="line">    F-&gt;&gt;A: 报告暂停</span><br><span class="line">    A-&gt;&gt;F: 发送测试用例2</span><br><span class="line">    F-&gt;&gt;C: SIGCONT</span><br><span class="line">    C-&gt;&gt;C: 重置状态</span><br><span class="line">    </span><br><span class="line">    Note over C: 迭代2</span><br><span class="line">    C-&gt;&gt;A: 执行测试用例2</span><br><span class="line">    C-&gt;&gt;F: raise(SIGSTOP)</span><br><span class="line">    F-&gt;&gt;A: 报告暂停</span><br><span class="line">    A-&gt;&gt;F: 发送测试用例3</span><br><span class="line">    F-&gt;&gt;C: SIGCONT</span><br><span class="line">    C-&gt;&gt;C: 重置状态</span><br><span class="line">    </span><br><span class="line">    Note over C: 迭代3</span><br><span class="line">    C-&gt;&gt;A: 执行测试用例3</span><br><span class="line">    C-&gt;&gt;F: raise(SIGSTOP)</span><br><span class="line">    F-&gt;&gt;A: 报告暂停</span><br><span class="line">    </span><br><span class="line">    Note over C: 循环结束</span><br><span class="line">    A-&gt;&gt;F: 发送退出信号</span><br><span class="line">    F-&gt;&gt;C: SIGCONT</span><br><span class="line">    C-&gt;&gt;C: 切换内存区域</span><br><span class="line">    C-&gt;&gt;F: 返回0 (退出循环)</span><br></pre></td></tr></table></figure>



<h4 id="目标程序中的集成"><a href="#目标程序中的集成" class="headerlink" title="目标程序中的集成"></a>目标程序中的集成</h4><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// AFL持久化循环</span></span><br><span class="line"><span class="keyword">while</span> (__AFL_LOOP(<span class="number">1000</span>)) &#123;</span><br><span class="line">    <span class="comment">/* 用户负责重置程序状态 */</span></span><br><span class="line">    <span class="built_in">reset_global_variables</span>();</span><br><span class="line">    <span class="built_in">close_open_files</span>();</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/* 读取输入 */</span></span><br><span class="line">    <span class="keyword">size_t</span> len = <span class="built_in">read</span>(<span class="number">0</span>, buf, BUF_SIZE);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/* 测试核心逻辑 */</span></span><br><span class="line">    <span class="built_in">test_function</span>(buf, len);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 后续代码不会记录覆盖率 */</span></span><br><span class="line"><span class="built_in">cleanup_resources</span>();</span><br></pre></td></tr></table></figure>



<h3 id="SanitizerCoverage-回调函数"><a href="#SanitizerCoverage-回调函数" class="headerlink" title="SanitizerCoverage 回调函数"></a>SanitizerCoverage 回调函数</h3><h4 id="sanitizer-cov-trace-pc-guard：覆盖率追踪回调"><a href="#sanitizer-cov-trace-pc-guard：覆盖率追踪回调" class="headerlink" title="__sanitizer_cov_trace_pc_guard：覆盖率追踪回调"></a>__sanitizer_cov_trace_pc_guard：覆盖率追踪回调</h4><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">void</span> __sanitizer_cov_trace_pc_guard(<span class="keyword">uint32_t</span>* guard) &#123;</span><br><span class="line">  __afl_area_ptr[*guard]++;<span class="comment">// 增加对应位置的计数器</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="sanitizer-cov-trace-pc-guard-init：插桩点初始化"><a href="#sanitizer-cov-trace-pc-guard-init：插桩点初始化" class="headerlink" title="__sanitizer_cov_trace_pc_guard_init：插桩点初始化"></a>__sanitizer_cov_trace_pc_guard_init：插桩点初始化</h4><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">void</span> __sanitizer_cov_trace_pc_guard_init(<span class="keyword">uint32_t</span>* start, <span class="keyword">uint32_t</span>* stop) &#123;</span><br><span class="line"></span><br><span class="line">  u32 inst_ratio = <span class="number">100</span>;<span class="comment">// 默认插桩比例</span></span><br><span class="line">  u8* x;</span><br><span class="line">  <span class="comment">// 跳过已初始化或空范围</span></span><br><span class="line">  <span class="keyword">if</span> (start == stop || *start) <span class="keyword">return</span>;</span><br><span class="line">  <span class="comment">// 获取环境变量中的插桩比例</span></span><br><span class="line">  x = <span class="built_in">getenv</span>(<span class="string">&quot;AFL_INST_RATIO&quot;</span>);</span><br><span class="line">  <span class="keyword">if</span> (x) inst_ratio = <span class="built_in">atoi</span>(x);</span><br><span class="line">  <span class="comment">// 验证比例有效性</span></span><br><span class="line">  <span class="keyword">if</span> (!inst_ratio || inst_ratio &gt; <span class="number">100</span>) &#123;</span><br><span class="line">    <span class="built_in">fprintf</span>(stderr, <span class="string">&quot;[-] ERROR: Invalid AFL_INST_RATIO (must be 1-100).\n&quot;</span>);</span><br><span class="line">    <span class="built_in">abort</span>();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* Make sure that the first element in the range is always set - we use that</span></span><br><span class="line"><span class="comment">     to avoid duplicate calls (which can happen as an artifact of the underlying</span></span><br><span class="line"><span class="comment">     implementation in LLVM). */</span></span><br><span class="line">  <span class="comment">// 初始化第一个元素（防重复调用）</span></span><br><span class="line">  *(start++) = <span class="built_in">R</span>(MAP_SIZE - <span class="number">1</span>) + <span class="number">1</span>;</span><br><span class="line">  <span class="comment">// 遍历初始化所有guard</span></span><br><span class="line">  <span class="keyword">while</span> (start &lt; stop) &#123;</span><br><span class="line">    <span class="comment">// 按比例随机决定是否插桩</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">R</span>(<span class="number">100</span>) &lt; inst_ratio) *start = <span class="built_in">R</span>(MAP_SIZE - <span class="number">1</span>) + <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">else</span> *start = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    start++;</span><br><span class="line"></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">sequenceDiagram</span><br><span class="line">    participant C as 编译器(LLVM)</span><br><span class="line">    participant P as 目标程序</span><br><span class="line">    participant A as AFL运行时</span><br><span class="line">    </span><br><span class="line">    C-&gt;&gt;P: 编译时插入回调函数</span><br><span class="line">    P--&gt;&gt;A: 程序启动</span><br><span class="line">    A-&gt;&gt;P: 调用 __sanitizer_cov_trace_pc_guard_init</span><br><span class="line">    P-&gt;&gt;A: 初始化插桩点</span><br><span class="line">    loop 程序执行</span><br><span class="line">        P-&gt;&gt;A: 基本块执行时调用 __sanitizer_cov_trace_pc_guard</span><br><span class="line">        A-&gt;&gt;A: 更新共享内存计数器</span><br><span class="line">    end</span><br><span class="line">    A--&gt;&gt;AFL: 分析覆盖率数据</span><br></pre></td></tr></table></figure>

</div></article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta">Author: </span><span class="post-copyright-info"><a href="mailto:undefined">Kr0emer</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta">Link: </span><span class="post-copyright-info"><a href="http://kr0emer.com/2025/07/14/AFL代码详读（上）/">http://kr0emer.com/2025/07/14/AFL代码详读（上）/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta">Copyright Notice: </span><span class="post-copyright-info">All articles in this blog are licensed under <a target="_blank" rel="noopener" href="https://creativecommons.org/licenses/by-nc-sa/4.0/">CC BY-NC-SA 4.0</a> unless stating additionally.</span></div></div><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/fuzz/">fuzz</a></div><div class="social-share pull-right"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/social-share.js@1.0.16/dist/css/share.min.css"><script src="https://cdn.jsdelivr.net/npm/social-share.js@1.0.16/dist/js/social-share.min.js"></script><nav id="pagination"><div class="next-post pull-right"><a href="/2025/07/01/CSCD70%202023s%20Assignment%201%20Introduction%20to%20LLVM%20%E8%AE%B0%E5%BD%95/"><span>CSCD70 2023s Assignment1 Introduction to LLVM 记录</span><i class="fa fa-chevron-right"></i></a></div></nav><div id="gitalk-container"></div><script>var gitalk = new Gitalk({
  clientID: '699be94dd9838f660bbd',
  clientSecret: '68baa1120b9638dd3038c08ccb5d72c0da979cdc',
  repo: 'gitment-comments',
  owner: 'Kr0emer',
  admin: 'Kr0emer',
  id: md5(decodeURI(location.pathname)),
  language: 'zh-CN'
})
gitalk.render('gitalk-container')</script></div></div><footer class="footer-bg" style="background-image: url(https://kr0emer-blog-1306550410.cos.ap-nanjing.myqcloud.com/img/72177032_p0.png)"><div class="layout" id="footer"><div class="copyright">&copy;2021 - 2025 By Kr0emer</div><div class="framework-info"><span>Driven - </span><a target="_blank" rel="noopener" href="http://hexo.io"><span>Hexo</span></a><span class="footer-separator">|</span><span>Theme - </span><a target="_blank" rel="noopener" href="https://github.com/Molunerfinn/hexo-theme-melody"><span>Melody</span></a></div><div class="footer_custom_text">hitokoto</div><div class="busuanzi"><script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><span id="busuanzi_container_page_pv"><i class="fa fa-file"></i><span id="busuanzi_value_page_pv"></span><span></span></span></div></div></footer><i class="fa fa-arrow-up" id="go-up" aria-hidden="true"></i><script src="https://cdn.jsdelivr.net/npm/animejs@latest/anime.min.js"></script><script src="https://cdn.jsdelivr.net/npm/jquery@latest/dist/jquery.min.js"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.js"></script><script src="https://cdn.jsdelivr.net/npm/velocity-animate@latest/velocity.min.js"></script><script src="https://cdn.jsdelivr.net/npm/velocity-ui-pack@latest/velocity.ui.min.js"></script><script src="/js/utils.js?version=1.9.0"></script><script src="/js/fancybox.js?version=1.9.0"></script><script src="/js/sidebar.js?version=1.9.0"></script><script src="/js/copy.js?version=1.9.0"></script><script src="/js/fireworks.js?version=1.9.0"></script><script src="/js/transition.js?version=1.9.0"></script><script src="/js/scroll.js?version=1.9.0"></script><script src="/js/head.js?version=1.9.0"></script><script src="/js/search/local-search.js"></script><script>if(/Android|webOS|iPhone|iPod|iPad|BlackBerry/i.test(navigator.userAgent)) {
  $('#nav').addClass('is-mobile')
  $('footer').addClass('is-mobile')
  $('#top-container').addClass('is-mobile')
}</script><div class="search-dialog" id="local-search"><div class="search-dialog__title" id="local-search-title">Local search</div><div id="local-input-panel"><div id="local-search-input"><div class="local-search-box"><input class="local-search-box--input" placeholder="Search for Posts"></div></div></div><hr><div id="local-search-results"><div id="local-hits"></div><div id="local-stats"><div class="local-search-stats__hr" id="hr"><span>Powered by</span> <a target="_blank" rel="noopener" href="https://github.com/wzpan/hexo-generator-search" style="color:#49B1F5;">hexo-generator-search</a></div></div></div><span class="search-close-button"><i class="fa fa-times"></i></span></div><div class="search-mask"></div></body></html>